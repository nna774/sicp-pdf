\chapter{レジスタマシンによる演算}
\label{Chapter 5}

\vspace{0.2em}

\begin{quote}
私の目的は天の機械は神からの授かり物や生き物ではなく、時計仕掛のような物であることを
示すことです。
(そして時計が魂を持つと信ずる人はその理由をその仕事に対するメーカーの栄光に帰するでしょう。)
それはほとんど全ての多様な運動が最も単純な物質の力により引き起こされるとする限りにおいて、
時計の全ての動作が1つの錘により引き起こされるのと全く同じように。

---Johannes Kepler (Herwart von Hohenburgへの手紙, 1605)
\end{quote}

\vspace{1.0em}

\noindent
私達はこの本をプロセスを学ぶことと、プロセスをLispで書かれた手続を用いて説明することにより
始めました。これらの手続の意味を説明するために、いくつかの評価モデルを用いました。
\link{Chapter 1}の置換モデル、\link{Chapter 3}の環境モデル、\link{Chapter 4}のメタ循環評価機です。
私達のメタ循環評価機の調査は特にLispのような言語がどのように解釈されるのかについての
謎の大部分を氷解させました。しかしメタ循環評価機ですらも重要な疑問を未知の状態に残します。
Lispシステム中の制御の仕組みは明らかにしないためです。例えば、この評価機は
部分式の評価がこの式の値を用いる式にどのようにその値を返すのかについて説明しません。
またこの評価機は、ある再帰関数が反復プロセス(つまり、定量的な記憶域で評価されるもの)を生成するのに
対し、一方で他の再帰関数が再帰プロセスを生成することもまた説明しません。
これらの疑問は未解決のままです。なぜならメタ循環評価機はそれ自身がLispプログラムであり、
それ故に根底に存在するLispシステムの制御構造を引き継ぐためです。より完全なLisp評価機の
制御構造の説明を与えるためには、Lispそれ自身よりもよりプリミティブなレベルについて
取り組まねばなりません。

この章ではプロセスを旧来の計算機の個々の操作を用いて説明します。そのような計算機、つまり
\newterm{register machine}(\jnewterm{レジスタマシン})は\newterm{registers}(\jnewterm{レジスタ})と呼ばれる
固定長の記憶要素の集合の中身を操作する\newterm{instructions}(\jnewterm{命令})を順に実行します。
典型的なレジスタマシンの命令はプリミティブな操作をいくつかのレジスタの中身に対して
適用し、その結果を他のレジスタに割り当てます。レジスタマシンにより実行される
プロセスの私達の説明は伝統的な計算機向けの``機械語''にとても良く似ているでしょう。
しかし、何らかの特定の計算機の機械語に注力する代わりに、私達はいくつかのLisp手続を
調査し、各手続を実行するための特定のレジスタマシンを設計します。従って私達はこの目的に
機械語のコンピュータプログラマではなく、ハードウェアアーキテクトの視点から取り組みます。
レジスタマシンの設計において、私達は再帰のような重要なプログラミング構造を実装するための
仕組みを開発します。またレジスタマシンの設計を記述するための言語も与えます。
\link{Section 5.2}ではこれらの記述を用いて設計したマシンをシミュレートするLispプログラムを
実装します。

私達のレジスタマシンのプリミティブな命令の多くはとても簡単です。例えばある命令は2つの
レジスタから取得した数値を足し、結果を生成して3つ目のレジスタに格納します。
そのような命令は簡単に記述されたハードウェアにより実行されることができます。
しかし、リスト構造を取り扱うためにはメモリ操作命令\code{car}, \code{cdr}, \code{cons}もまた
使用します。これは複雑なストレージ(記憶領域)獲得の仕組みを必要とします。
\link{Section 5.3}でより初歩的な命令を用いてのそれらの実装について学びます。

\link{Section 5.4}ではレジスタマシンによる簡単な手続の形式化についての経験を貯めた後に、
\link{Section 4.1}のメタ循環評価機により説明されたアルゴリズムを実行するマシンを設計します。
これがSchemeがどのように解釈されるのかについての私達の理解のギャップを、評価機の
制御の仕組みに対する明確なモデルを与えることにより、埋めることでしょう。
\link{Section 5.5}ではSchemeプログラムを評価機のレジスタマシンのレジスタと命令を用いて直接実行可能な
一連の命令に変換する簡単なコンパイラについて学びます。



\section{レジスタマシンの設計}
\label{Section 5.1}

レジスタマシンを設計するためには、その\newterm{data paths}(\jnewterm{データパス})(レジスタと命令)と
これらの命令を順序付ける\newterm{controller}(\jnewterm{コントローラ})を設計する必要があります。
簡単なレジスタマシンの設計を説明するために、2つの整数の最大公約数(\acronym{GCD})を求めるために使用した
ユークリッドのアルゴリズムを検討しましょう。\link{Section 1.2.5}で学んだように、ユークリッドの
アルゴリズムは反復プロセスにて以下の手続にて指定されるように実行されることができます。

\begin{scheme}
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
\end{scheme}

\noindent
このアルゴリズムを実行する機械は2つの数値、\( a \)と\( b \)を追跡しなければいけません。
そうすることでこれらの数値がそれらの名前と共に2つのレジスタに格納されることが推測できます。
必要とされる基本的な命令はレジスタ\code{b}の値が0であるかどうかを確認し、レジスタ\code{a}の中身を
レジスタ\code{b}の中身で割った余りを求めます。剰余の命令は複雑な処理ですが、当座は剰余を求める
プリミティブな手法が存在すると仮定します。\acronym{GCD}アルゴリズムの各サイクルにおいて、
レジスタ\code{a}の中身はレジスタ\code{b}の中身で置き換えられ、レジスタ\code{b}の中身は\code{a}の古い中身を
\code{b}の古い中身で割った場合の余りで置き換えられなければなりません。
もしこれらの置換が同時に行われれば便利でしょう。しかし私達のレジスタマシンのモデルでは
ただ1つのレジスタのみが各ステップで新しい値を割り当てられることができます。
置換を達成するためには、私達の機械は3つ目の``temporary''(一時的な)レジスタを使用します。
これを\code{t}と呼びます。(最初に剰余は\code{t}に置かれます。次に\code{b}の中身が\code{a}に置かれます。
最後に\code{t}に格納されている剰余が\code{b}に置かれます。)

この機械のレジスタと命令を\link{Figure 5.1}に示されるデータパス図を用いて説明することができます。
この図では、レジスタ(\code{a}, \code{b}, \code{t})は長方形で表現されます。値をレジスタに割り当てる方向は
\code{X}が頭の後ろにあり、データの元からレジスタを指す矢印により示されます。\code{X}は押された時に
元の値が指定されたレジスタに``flow''する(流れる)ボタンだと考えることができます。
各ボタンの横にあるラベルはそのボタンを参照するのに使われる名前です。この名前は
自由で、かつ記憶を助ける値を持つことを選択することができます。(例えば、\code{a<\-/b}は
ボタンを押すとレジスタ\code{b}の中身を\code{a}に割り当てることを意味します)。
レジスタに対するデータ元は別のレジスタであることも可能で(\code{a<\-/b}の代入のように)、また
(\code{t<\-/r}の代入のように)命令の結果や、定数(変更できない組込の値、データパス図では
定数を持つ三角形で表現される)にもなり得ます。

\begin{figure}[tb]
\phantomsection\label{Figure 5.1}
\centering
\begin{comment}
\heading{Figure 5.1:} Data paths for a \acronym{GCD} machine.

\begin{example}
                              ___
+-----+          +-----+     /   \
|  a  |<--(X)----|  b  +--->|  =  |
+--+--+   a<-b   +-+---+     \___/
   |               |  ^        ^
   +------+   +----+  |        |
          |   |      (X) b<-t  |
       .--+---+--.    |       / \
        \  rem  /     |      / O \
         \_____/      |     +-----+
            |         |
           (X) t<-r   |
            |         |
            V         |
         +-----+      |
         |  t  +------+
         +-----+
\end{example}
\end{comment}
\includegraphics[width=58mm]{fig/chap5/Fig5.1a.pdf}
\par\bigskip
\noindent
\heading{Figure 5.1:} \acronym{GCD}マシンのデータパス
\end{figure}

\noindent
定数とレジスタの中身から値を求める命令はデータパス図では命令に対する名前を持つ
台形により表現されます。例えば\link{Figure 5.1}で\code{rem}と印された箱はそれに
取り付けられたレジスタ\code{a}と\code{b}の中身の剰余を求める命令を表します。
ボタンの無い矢印は入力レジスタと定数から箱へと指し、別の矢印は命令の出力値からレジスタへと
接続しています。テストはそのテストを表す名前を持つ円で表現されます。例えば、
私達の\acronym{GCD}マシンはレジスタ\code{b}の中身がゼロであるかをテストする命令を持ちます。
テストはまたその入力レジスタと定数からの矢印を持ちます。しかし出力の矢印を持ちません。
その値はデータパスでなくコントローラにより使用されます。全体としては、データパス図は
機械にとって必要とされるレジスタと命令と、それらがどのように接続されるべきかを示しています。
もし私達が矢印を配線に、\code{X}ボタンをスイッチだと見れば、データパス図は電子部品から
構築することができる機械の配線図にとても似ています。

データパスに対し実際に\acronym{GCD}を求めるためには、複数のボタンが正しい順序で
押される必要があります。私達はこの順序を\link{Figure 5.2}で図示されるコントローラ図を
用いて説明します。コントローラ図の要素はデータパスのコンポーネントがどのように
操作されるべきかであるかを示します。コントローラ図の長方形の箱は押されるべきデータパスの
ボタンを判別します。そして矢印はあるステップから次への順を示します。図の中のひし形は
選択を表現します。ひし形内で確認されたデータパスのテストの値に依存し、2つの順路矢印の1つに
従います。私達はコントローラを物質的なアナロジーを用いて解釈することができます。この図を
ビー玉が転がっている迷路だと考えるのです。ビー玉が箱に転がり込んだ時に、箱により名付けら
れたデータパスボタンを押します。ビー玉が(\code{b} = 0のテストのような)決断点に転がり込んだ
時には、示されたテストの結果により決定された道に乗りその点を去ります。
これらをもとに、データパスとコントローラは完全に\acronym{GCD}を求めるための機械を説明します。
私達はコントローラ(転がるビー玉)を\code{start}と印された地点から、レジスタ\code{a}と\code{b}に
数値を置いてから開始します。コントローラが\code{done}に辿り着いた時、\acronym{GCD}の値は
レジスタ\code{a}の中に見つかります。

\begin{figure}[tb]
\phantomsection\label{Figure 5.2}
\centering
\begin{comment}
\heading{Figure 5.2:} Controller for a \acronym{GCD} machine.

\begin{example}
     start
       |
       V
      / \ yes
+--->< = >-----> done
|     \ /
|      | no
|      V
|  +------+
|  | t<-r |
|  +---+--+
|      |
|      V
|  +------+
|  | a<-b |
|  +---+--+
|      |
|      V
|  +------+
+--+ b<-t |
   +------+
\end{example}
\end{comment}
\includegraphics[width=41mm]{fig/chap5/Fig5.2.pdf}
\par\bigskip
\noindent
\heading{Figure 5.2:} \acronym{GCD}マシンのコントローラ
\end{figure}


\begin{quote}
\heading{\phantomsection\label{Exercise 5.1}Exercise 5.1:}
以下の手続で指定される反復アルゴリズムを用いて階乗を求めるレジスタマシンを設計せよ。
このマシンに対するデータパスとコントローラの図を描け。

\begin{scheme}
(define (factorial n)
  (define (iter product counter)
    (if (> counter n)
        product
        (iter (* counter product)
              (+ counter 1))))
  (iter 1 1))
\end{scheme}
\end{quote}



\subsection{レジスタマシンを記述するための言語}
\label{Section 5.1.1}


データパスとコントローラの図は\acronym{GCD}の様な簡単な機械を表現するには適切です。
しかしそれらはLispインタプリタのような大きな機械を記述するには扱いにくい物です。
複雑な機械を扱うことを可能にするために、私達はテキスト形式でデータパスとコントローラの図
により与えられる全ての情報を表現する言語を作成することにします。まずは直接図を写し取る
表記法から始めます。

機械のデータパスをレジスタと命令を記述することにより定義します。レジスタを記述するために、
それに名前を与え、それに対する代入をコントロールするボタンを指定します。
これらのボタン全てに名前を与え、ボタンのコントロールの下にレジスタに入れられる
データの代入元を指定します。(代入元はレジスタ、定数、または命令です)。命令を
記述するために、それに名前を与え、その入力(レジスタ、または定数)を指定します。

機械のコントローラを\newterm{instructions}(\jnewterm{命令})の列として、その列の
\newterm{entry points}(\jnewterm{エントリポイント}、入口)を特定する\newterm{labels}(\jnewterm{ラベル})と共に
定義します。

\begin{itemize}

\item
レジスタに値を割り当てるために押すデータパスボタンの名前。(これはコントローラ図の
箱に対応する)

\item
\code{test}(テスト)命令、特定のテストを実行する。

\item
直前のテストの結果に基づくコントローララベルにより示された地点への条件分岐(\code{branch}命令)。
(テストと分岐は共にコントローラ図のひし形に対応する)。もしテストが偽であれば、
コントローラは命令列の次の命令へと続ける。そうでなければ、コントローラはラベルの
次の命令から続ける。

\item
無条件分岐(\code{goto}命令)は実行を続ける地点にコントローララベルを名付ける

\end{itemize}

\noindent
機械はコントローラの命令列の初めから開始し、列の終わりに辿り付いた時に実行を停止する。
ただし分岐が制御の流れを変更した場合、命令はそれが並べられた順に向かい実行される。

\begin{quote}
\heading{\phantomsection\label{Figure 5.3}Figure 5.3:} \( \downarrow \) A specification of the \acronym{GCD}
machine.

\begin{scheme}
(data-paths
 (registers
  ((name a)
   (buttons ((name a<-b) (source (register b)))))
  ((name b)
   (buttons ((name b<-t) (source (register t)))))
  ((name t)
   (buttons ((name t<-r) (source (operation rem))))))
 (operations
  ((name rem) (inputs (register a) (register b)))
  ((name =) (inputs (register b) (constant 0)))))
(controller
 test-b                           ~\textrm{; label}~
   (test =)                       ~\textrm{; test}~
   (branch (label gcd-done))      ~\textrm{; conditional branch}~
   (t<-r)                         ~\textrm{; button push}~
   (a<-b)                         ~\textrm{; button push}~
   (b<-t)                         ~\textrm{; button push}~
   (goto (label test-b))          ~\textrm{; unconditional branch}~
 gcd-done)                        ~\textrm{; label}~
\end{scheme}

\end{quote}

\noindent
\link{Figure 5.3}はこの方法で記述された\acronym{GCD}マシンを示します。この例はこれらの
記述の一般性を暗示しているに過ぎません。\acronym{GCD}マシンはとても単純な場合であるからです。
各レジスタはたった1つのボタンしか持たず、各ボタンとテストはコントローラにより
ただ1度しか利用されていません。

残念なことに、このような記述を読むことは難しいことです。コントローラの命令を理解する
ためには、常にボタンの名前と命令の名前の定義に戻らねばならず、またボタンが何をするのか
理解するためには命令の名前の定義を参照する必要があるでしょう。従って私達はこの表記法を
変形し、データパスとコントローラの記述からの情報を組み合わせることで全てを一緒に
見られるようにします。

記述のこの形式を得るために、自由裁量なボタンと命令の名前をそれらの振舞の定義により
置き換えます。つまり、(コントローラの中で)``ボタン\code{t<\-/r}を押せ''と言い、別に
(データパスの中で)``ボタン\code{t<\-/r}は\code{rem}命令の値をレジスタ\code{t}に代入''と
``\code{rem}命令の入力はレジスタ\code{a}と\code{b}の中身''と言う代わりに、これからは
(コントローラの中で)``レジスタ\code{a}と\code{b}の中身上での\code{rem}命令の値をレジスタ\code{t}に
代入するボタンを押せ''と言うことにします。同様に、(コントローラの中で)``\code{=}テストを
実行せよ''と言い、別に(データパスの中で)``\code{=}テストはレジスタ\code{b}の中身と定数0の上で
動作する''と言う代わりに、これからは``\code{=}テストをレジスタ\code{b}の中と定数0の上で実行せよ''と
言います。データパスの記述は省略し、コントローラの命令列のみを残します。従って、
\acronym{GCD}マシンは以下のように記述されます。

\begin{scheme}
(controller
 test-b
   (test (op =) (reg b) (const 0))
   (branch (label gcd-done))
   (assign t (op rem) (reg a) (reg b))
   (assign a (reg b))
   (assign b (reg t))
   (goto (label test-b))
 gcd-done)
\end{scheme}

\noindent
この記述の形式は\link{Figure 5.3}で説明されたものよりも読み易いでしょう。
しかし同時に欠点も持ちます。

\begin{itemize}

\item
大きな機械に対してはより冗長である。データパス要素の複雑な記述がその要素が
コントローラ命令列内で触れられる度に繰り返されるため。(これは\acronym{GCD}の例では
問題にならない。命令とボタンのそれぞれがただ1度しか使用されないため)。さらに、
データパス記述の繰り返しが実際の機械のデータパス構造を分かりにくくする。
大きな機械にとっていくつのレジスタ、命令、ボタンが存在し、それらがどのように相互接続されて
いるのかは自明では無い。

\item
機械の定義内のコントローラの命令はLisp式の様に見えるため、それらが自由裁量なLisp式
ではないことを簡単に忘れてしまう。それらは正式な機械の命令のみを記述できる。
例えば、命令は直接には定数とレジスタの中身のみに対して操作ができる。他の命令の
結果に対してはできない。

\end{itemize}

\noindent
これらの欠点にも係らず、私達はこのレジスタマシンの言語をこの章を通して使用します。
データパスの要素と接続を理解することよりもコントローラを理解することにより関係
していくためです。しかし、私達はデータパスの設計は実際の機械の設計において、とても
重要であることを肝に命じておかねばなりません。

\begin{quote}
\heading{\phantomsection\label{Exercise 5.2}Exercise 5.2:}
レジスタマシン言語を用いて\link{Exercise 5.1}の反復階乗機械を記述せよ。

\end{quote}

\subsubsection*{アクション}


\acronym{GCD}マシンを変更して、\acronym{GCD}が欲しい数値を入力し、端末に答が表示される
ようにしてみましょう。私達は読み込みや表示ができる機械をどのように作るかについては
議論しません。しかし(私達がSchemeにて\code{read}と\code{display}を使う時に行うように)
それらがプリミティブな命令として既に存在すると仮定します。\footnote{この仮定は
多量の複雑さを言い繕っています。通常、Lispシステムの実装の大きな部分が読み込みと
表示を可能にすることに関してささげられています。}

\begin{figure}[tb]
\phantomsection\label{Figure 5.4}
\centering
\begin{comment}
\heading{Figure 5.4:} A \acronym{GCD} machine that reads inputs and prints results.

\begin{example}
                   .--------.
                    \ read /
                     \____/
                       |
               +-------*------+
               |              |
        a<-rd (X)            (X) b<-rd
               |              |
               V              V           ___
            +-----+        +-----+       /   \
            |  a  |<--(X)--+  b  +----->|  =  |
            +-+-+-+  a<-b  +-+---+       \___/
              | |            |  ^          ^
           +--+ +----+    +--+  |          |
           |         |    |    (X) b<-t   / \
           V         V    V     |        / O \
      .---------.  .---------.  |       /_____\
--(X)->\ print /    \  rem  /   |
   P    \_____/      \_____/    |
                        |       |
                       (X) t<-r |
                        |       |
                        V       |
                     +-----+    |
                     |  t  +----+
                     +-----+
\end{example}

\begin{scheme}
 (controller
  gcd-loop
    (assign a (op read))
    (assign b (op read))
  test-b
    (test (op =) (reg b) (const 0))
    (branch (label gcd-done))
    (assign t (op rem) (reg a) (reg b))
    (assign a (reg b))
    (assign b (reg t))
    (goto (label test-b))
  gcd-done
    (perform (op print) (reg a))
    (goto (label gcd-loop)))
\end{scheme}

\end{comment}
\includegraphics[width=107mm]{fig/chap5/Fig5.4b.pdf}
\par\bigskip
\noindent
\heading{Figure 5.4:} 入力を読み込み結果を表示する\acronym{GCD}マシン
\end{figure}

\noindent
\code{read}は私達が使用してきた、その中でレジスタに格納することができる値を生成する
命令のような物です。しかし\code{read}は入力をどのレジスタからも取得しません。その値は
私達が設計している機械の外側の部品で起こる何かに依存しています。私達は私達の機械の
命令にそのようは振舞を持つことを許します。従って\code{read}の使用を描き、記述することを
他の任意の値を求める命令と全く同様に行います。

一方で、\code{print}は私達が使用してきた命令とは基本的な意味において異なります。これは
レジスタに格納できる出力の値を生成しません。この種の命令は\newterm{action}(\jnewterm{アクション})として
参照することにします。データパス図ではアクションは値を求める命令と同じように、アクションの
名前を含む台形として表現します。矢印は任意の入力(レジスタ、または定数)からアクションの箱へと
指します。またボタンをアクションと関連付けることもします。ボタンを押すとアクションが起こります。
コントローラにアクションボタンを押させるために、\code{perform}(パフォーム、実行)と呼ばれる
新しい種類の命令を用います。従ってレジスタ\code{a}の中身を表示するアクションはコントローラの
命令列の中でその命令により表現されます。

\begin{scheme}
(perform (op print) (reg a))
\end{scheme}

\noindent
\link{Figure 5.4}は新しい\acronym{GCD}マシンのデータパスとコントローラを示しています。
回答を表示した後にマシンをストップさせる代わりに、再開させています。そのため数値の
ペアを読み込み、それらの\acronym{GCD}を計算し、結果を表示することを繰り返します。
この構造は\link{Chapter 4}のインタプリタにて使用したドライバループに似ています。

\subsection{機械設計における抽象化}
\label{Section 5.1.2}

私達はこれから頻繁に、実際には複雑な``プリミティブな''命令を含む機械を定義します。例えば
\link{Section 5.4}と\link{Section 5.5}ではSchemeの環境の操作をプリミティブとして扱います。
そのような抽象化はそれにより機械の部品の詳細を無視することを可能にし、設計の他の
側面に集中することを可能にするため有益です。しかし、私達が数多くの複雑さを敷物の下に
隠してしまった事実は機械設計が非現実的であることを意味しません。
私達は常に複雑な``プリミティブ''をより簡単なプリミティブな命令で置き換えることができます。

\acronym{GCD}マシンについて考えます。マシンはレジスタ\code{a}と\code{b}の中身の剰余を
求める、結果をレジスタ\code{t}に割り当てる命令を持ちます。もし\acronym{GCD}マシンを
プリミティブな剰余命令を使用すること無しに構築したい場合、より単純な命令、例えば
引き算を用いてどのように剰余を求めるのかを指定しなければなりません。実際に、この
方法で剰余を見つけるSchemeの手続を描くことができます。

\begin{scheme}
(define (remainder n d)
  (if (< n d) n (remainder (- n d) d)))
\end{scheme}

従って\acronym{GCD}マシンのデータパス内の剰余命令を引き算命令と比較テストで置き換える
ことができます。\link{Figure 5.5}は緻密化されたマシンのデータパスとコントローラを
示します。\acronym{GCD}コントローラ定義内の以下の命令は、

\begin{scheme}
(assign t (op rem) (reg a) (reg b))
\end{scheme}

\noindent
\link{Figure 5.6}に示されるように、ループを含む一連の命令により置き換えることができます。

\begin{figure}[tp]
\phantomsection\label{Figure 5.5}
\centering
\begin{comment}
\heading{Figure 5.5:} Data paths and controller for the elaborated \acronym{GCD} machine.

\begin{example}
                                    ___
+-----+         +-----+            /   \
|  a  |<--(X)---+  b  +-------*-->|  =  |
+--+--+   a<-b  +-+---+       |    \___/
   |              |  ^        |
  (X) t<-a        |  |        |
   |              | (X) b<-t  |
   V              |  |       _V_
+-----+           |  |      /   \
|  t  +-------*---|--*-----|  <  |
+-----+       |   |         \___/
   ^          V   V
   |        ---------
  (X) t<-d   \  -  /
   |          --+--
   |            |
   +------------+


   start
     |
     V
    / \ yes            +-------+
+->< = >----> done     | t<-d  |<--+
|   \ /                +---+---+   |
|    | no                  |       |
|    |                     V       |
|    |   +------+         / \ no   |
|    +-->| t<-a +------->< < >-----+
|        +------+         \ /
|                          | yes
|      +-------------------+
|      V
|  +-------+
|  | a<-b  |
|  +---+---+
|      |
|      V
|  +-------+
+--+ b<-t  |
   +-------+
\end{example}
\end{comment}
\includegraphics[width=67mm]{fig/chap5/Fig5.5a.pdf}
\begin{quote}
\heading{Figure 5.5:} 精緻な\acronym{GCD}マシンのデータパスとコントローラ
\end{quote}
\end{figure}


\noindent
\heading{\phantomsection\label{Figure 5.6}\mbox{Figure 5.6:}} \( \downarrow \) \link{Figure 5.5}の\acronym{GCD}マシンのコントローラの命令列

\begin{quote}
\begin{scheme}
(controller test-b
              (test (op =) (reg b) (const 0))
              (branch (label gcd-done))
              (assign t (reg a))
            rem-loop
              (test (op <) (reg t) (reg b))
              (branch (label rem-done))
              (assign t (op -) (reg t) (reg b))
              (goto (label rem-loop))
            rem-done
              (assign a (reg b))
              (assign b (reg t))
              (goto (label test-b))
            gcd-done)
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.3}Exercise 5.3:}
平方根を求める機械を\link{Section 1.1.7}で説明されたようにニュートン法を用いて設計せよ。

\begin{scheme}
(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
\end{scheme}


\code{good\-/enough?}と\code{improve}命令はプリミティブとして存在するとして始めよ。
次にこれらを算術演算子を用いてどのように展開するか示せ。\code{sqrt}マシン設計の各版を
データパス図を描き、レジスタマシンのコントローラ定義を記述することで説明せよ。
\end{quote}

\subsection{サブルーチン}
\label{Section 5.1.3}

演算を実行する機械を設計する時、私達は良くコンポーネントを複製するのではなく、
演算の異なる部品により共有されるコンポーネントを準備することを好みます。
2つの\acronym{GCD}演算を含む機械についえ考えてみましょう。1つはレジスタ\code{a}と\code{b}の
中身の\acronym{GCD}を求め、もう1つはレジスタ\code{c}と\code{d}の\acronym{GCD}を求めます。
私達はまずプリミティブな\code{gcd}命令を持つと仮定することから始め、次に2つの\code{gcd}の
インスタンスをよりプリミティブな命令を用いて展開するでしょう。\link{Figure 5.7}は
結果としての機械のデータパスの\acronym{GCD}の部分を、それらが機械の残りの部分にどのように
接続されていかを除いて示しています。この図はまた機械のコントローラシーケンス(命令列)の
対応する部分も示しています。

\begin{figure}[tb]
\phantomsection\label{Figure 5.7}
\centering
\begin{comment}
\heading{Figure 5.7:} Portions of the data paths and controller sequence for a machine with two \acronym{GCD} computations.

\begin{example}
                            ___                                 ___  
+-----+        +-----+     /   \    +-----+        +-----+     /   \ 
|  a  |<-(X)---+  b  |--->|  =  |   |  c  |<-(X)---+  d  |--->|  =  |
+--+--+  a<-b  ++----+     \___/    +--+--+  c<-d  ++----+     \___/ 
   |            |  ^         ^         |            |  ^         ^   
   `----.   .---'  |         |         `----.   .---'  |         |   
        V   V     (X) b<-t   |              V   V     (X) d<-t   |   
       -------     |        / \            -------     |        / \  
       \ rem /     |       /_0_\           \ rem /     |       /_0_\ 
        --+--      |                        --+--      |             
          |        |                          |        |             
         (X) t<-r  |                         (X) s<-r  |             
          |        |                          |        |             
          V        |                          V        |             
       +-----+     |                       +-----+     |             
       |  t  +-----'                       |  s  +-----'             
       +-----+                             +-----+                   
\end{example}

\begin{scheme}
gcd-1
 (test (op =) (reg b) (const 0))
 (branch (label after-gcd-1))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd-1))
after-gcd-1
   ~\( \dots \)~
gcd-2
 (test (op =) (reg d) (const 0))
 (branch (label after-gcd-2))
 (assign s (op rem) (reg c) (reg d))
 (assign c (reg d))
 (assign d (reg s))
 (goto (label gcd-2))
after-gcd-2
\end{scheme}

\end{comment}
\includegraphics[width=105mm]{fig/chap5/Fig5.7b.pdf}
\begin{quote}
\heading{Figure 5.7:} 2つの\acronym{GCD}演算を持つ機械のデータパスとコントローラシーケンスの一部
\end{quote}
\end{figure}

\noindent
この機械は2つの剰余命令の箱と2つの等値テストの箱を持っています。もし複製された
コンポーネントが剰余の箱のように複雑なら、これは機械を構築するのに経済的な方法では
ありません。私達はより大きな機械の演算に影響を与えないように与えられた場合に、
同じコンポーネントを両方の\acronym{GCD}演算に用いることでデータパスコンポーネントの
複製を防ぎます。もしレジスタ\code{a}と\code{b}の値がコントローラが\code{gcd\-/2}に取り掛かって
いる時に必要無いのであれば(またはもしこれらの値が安全のために他のレジスタに移動して
おくことができるのならば)、機械を変更し、レジスタ\code{c}と\code{d}でなく、レジスタ\code{a}と
\code{b}を2つ目の\acronym{GCD}を1つ目と同じに求めるおおができます。もしこれを行うなら、
\link{Figure 5.8}に示されるコントローラシーケンスを得ます。
\newpage

\begin{quote}
\heading{\phantomsection\label{Figure 5.8}Figure 5.8:} \( \downarrow \) 2つの異なる\acronym{GCD}演算に対して同じデータパスコンポーネントを使用する機械のコントローラシーケンスの一部
\begin{scheme}
gcd-1
 (test (op =) (reg b) (const 0))
 (branch (label after-gcd-1))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd-1))
after-gcd-1
  ~\( \dots \)~
gcd-2
 (test (op =) (reg b) (const 0))
 (branch (label after-gcd-2))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd-2))
after-gcd-2
\end{scheme}
\end{quote}

\noindent
私達はデータパスコンポーネントの複製を削除しました。(そうすることでデータパスは
\link{Figure 5.1}の状態に戻りました)。しかしコントローラは今ではそれらのエントリポイントの
ラベルのみが異なる2つの\acronym{GCD}シーケンスを持ちます。これら2つのシーケンスを
1つのシーケンス---\code{gcd} \newterm{subroutine}(\jnewterm{サブルーチン})---への分岐により置き換えた
ほうが良くなるでしょう。サブルーチンの終わりにメインの命令列の正しい場所へと戻ります。
これを次のように達成することができます。\code{gcd}に分岐する前に、(0か1のような)識別するための値を
特別なレジスタ、\code{continue}に置きます。\link{Figure 5.9}は結果としてのコントローラシーケンスの
関連する部分を示しています。これはただ1つの\code{gcd}命令列のコピーを含みます。

\begin{quote}
\heading{\phantomsection\label{Figure 5.9}Figure 5.9:} \( \downarrow \) \link{Figure 5.8}でコントローラシーケンスの重複を防ぐため\code{continue}レジスタを用いる
\begin{scheme}
gcd
 (test (op =) (reg b) (const 0))
 (branch (label gcd-done))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd))
gcd-done
 (test (op =) (reg continue) (const 0))
 (branch (label after-gcd-1))
 (goto (label after-gcd-2))
  ~\( \dots \)~
 ~\textrm{;; \code{gcd}を必要とする場所からその場所へと分岐する前に}~
 ~\textrm{;; レジスタ\code{continue}に0を置く}~
 (assign continue (const 0))
 (goto (label gcd))
after-gcd-1
  ~\( \dots \)~

 ~\textrm{;; \code{gcd}の二度目の使用の前にはレジスタ\code{continue}に1を置く}~
 (assign continue (const 1))
 (goto (label gcd))
after-gcd-2
\end{scheme}
\end{quote}

\noindent
これは小さな問題に対応するのに妥当な取り組み方です。しかしもし数多くの\acronym{GCD}演算が
コントローラシーケンスの中にある場合には困ったことになりそうです。
\acronym{gcd}サブルーチンの後に実行をどこで続けるかを決定するために、データパス内のテストと
コントローラ内に分岐命令が\acronym{gcd}を置く全ての場所に対して必要となるでしょう。
サブルーチンを実装するためのより強力な手法は、\code{continue}レジスタにサブルーチンが終了した時に
実行が続行しなければならない場所のコントローラシーケンス内のエントリポイントのラベルを持たせることです。
この戦略の実装にはレジスタマシンのデータパスとコントローラの間に新しい種類のコネクションが必要です。
ラベルの値をレジスタから取得し指定されたエントリポイントから実行を再開するのに使用できるような方法のため、
レジスタにコントローラシーケンス内のラベルを代入するための方法が必要です。

この能力を反映するために、レジスタマシン言語の\code{assign}命令を拡張し、レジスタに値として
ラベルをコントローラシーケンスから(特別な種類の中身として)代入することを許可する拡張を行います。
また\code{goto}命令にも静的ラベルにより記述されたエントリポイントのみでなく、レジスタの中により
表されたエントリポイントから実行を続行することを許可する拡張を行います。
これらの新しい構造物を用いることで、\code{continue}レジスタ内に格納された
場所に分岐することにより、\code{gcd}サブルーチンを停止することができます。
これは\link{Figure 5.10}に示されたコントローラシーケンスへと導きます。

\begin{quote}
\heading{\phantomsection\label{Figure 5.10}Figure 5.10:} \( \downarrow \) Assigning labels to the
\code{continue} register simplifies and generalizes the strategy shown in
\link{Figure 5.9}.
\begin{scheme}
gcd
 (test (op =) (reg b) (const 0))
 (branch (label gcd-done))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd))
gcd-done
 (goto (reg continue))
   ~\( \dots \)~
 ~\textrm{;; \code{gcd}を呼ぶ前に、\code{continue}に\code{gcd}が戻るべきラベルを代入します}~
 (assign continue (label after-gcd-1))
 (goto (label gcd))
after-gcd-1
   ~\( \dots \)~
 ~\textrm{;; 異なる継続を持つ2つ目の\code{gcd}呼出}~
 (assign continue (label after-gcd-2))
 (goto (label gcd))
after-gcd-2
\end{scheme}
\end{quote}

\noindent
複数のサブルーチンを持つマシンは複数の継続レジスタ(例えば\code{gcd\-/continue}, \code{factorial\-/continue})を
用いるか、または全てのサブルーチンが単一の\code{continue}レジスタを共有することができるでしょう。
共有はより経済的ですが、別のサブルーチン(\code{sub2})を呼び出すサブルーチン(\code{sub1})を持っていないか
注意しなければなりません。\code{sub1}が\code{continue}の中身を何か他のレジスタに、\code{continue}を
\code{sub2}の呼出のために設定する前に保存しなければ、 \code{sub1}は完了した時点で
どこに行けば良いのか知ることができません。次の節で開発される再帰を扱う仕組みは
この入れ子のサブルーチン呼出の問題にもより良い解法を提供します。

\subsection{再帰実装にスタックを使用する}
\label{Section 5.1.4}

ここまでに説明されたアイデアを用いて、そのプロセスの各状態変数に
対応するレジスタを持つレジスタマシンを指定することにより、任意の反復プロセスを
実装することができます。この機械はレジスタの中身を変更しながら、繰り返しコントローラの
ループを、ある停止条件が満たされるまで実行します。コントローラシーケンスの各地点に
おいて、(反復プロセスの状態を表現する)機械の状態はレジスタの状態(状態変数の値)により
完全に決定されます。

しかし、再帰プロセスを実装する場合には追加の仕組みを必要とします。
以下の階乗を求めるための再帰手法について考えましょう。これは\link{Section 1.2.1}で
最初に調査しました。

\begin{scheme}
(define (factorial n)
  (if (= n 1) 1 (* (factorial (- n 1)) n)))
\end{scheme}

\noindent
この手続から見てとれるように、\( n! \)の演算は\( (n - 1)! \)の演算を必要とします。
私達の\acronym{GCD}は以下の手続からモデル化されていますが、

\begin{scheme}
(define (gcd a b)
  (if (= b 0) a (gcd b (remainder a b))))
\end{scheme}

\noindent
同様に別の\acronym{GCD}を求める必要があります。しかし、元の演算から新しい{GCD}演算へと
簡約する{GCD}手続と、部分問題として別の階乗を求める必要がある\code{factorial}の間には
重要な違いがあります。\acronym{GCD}においては新しい\acronym{GCD}演算に対する答は
元の問題の答です。次の\acronym{GCD}を求めるためには、単純に新しい引数を\acronym{GCD}マシンの
入力レジスタに置き、機械のデータパスを同じコントローラシーケンスを実行することにより
再利用します。機械が最後の\acronym{GCD}問題を解くことを完了した時には、演算全体を
完了したことになります。

階乗の場合(または任意の再帰プロセス)においては新しい階乗の部分問題の回答は元の問題の
回答ではありません。\( (n - 1)! \)に対して得られた値は最終回答を得るために\( n \)で
乗算しなければなりません。もし\acronym{GCD}の設計を真似し、階乗の部分問題をレジスタ\code{n}を
デクリメント(1引く)し、階乗マシンに戻るこのより解決したいとしても、その結果に乗算を
行う有効な古い\code{n}の値は既に存在しません。従って部分問題上で働くための2つ目の
階乗マシンが必要です。この2つ目の階乗の演算はそれ自身が階乗の部分問題を持ち、それは
3つ目の階乗マシンを必要とし、以下繰り返されます。各階乗マシンがその中に別の階乗マシンを
持つため、総計の機械は同様な機械の無限の入れ子を含み、従って固定長の有限数な部品から
構築することはできません。

\begin{figure}[tp]
\phantomsection\label{Figure 5.11}
\centering
\begin{comment}
\heading{Figure 5.11:} A recursive factorial machine.

\begin{example}
                             ___
                            /   \
    +----------*-----------|  =  |
    |          |            \___/
   (X)         |              ^
    |          |              |
    V          |          +---+---+   sn    +-------+
+-------+      |          |       +---(X)-->|       |
|  val  |<-(X)-|----------+   n   |         | stack |
+-----+-+      |          |       |<--(X)---+       |
  ^   |        |          +-------+   rn    +-+-----+
  |   |        |            ^                 |   ^
 (X)  |        |            |                 |   |
  |   |   +----|--------*  (X)                |  (X) sc
  |   |   |    |        |   |             rc (X)  |
  |   |   |    *----.   |   |                 |   |
  |   V   V    |    V   V   |                 V   |
  |  -------   |   -------  |              +------+-+
  |  \  *  /   |   \  -  /  |              |continue+--> controller
  |   --+--    |    --+--   |              +--------+
  |     |      |      |     |               ^      ^
  +-----+      |      +-----+               |      |
               |                           (X)    (X)
               |                            |      |
              / \                   after- / \    / \  fact-
             /_1_\                  fact  /___\  /___\ done
\end{example}

\begin{smallscheme}
(controller
   (assign continue (label fact-done))     ~\textrm{; set up final return address}~
 fact-loop
   (test (op =) (reg n) (const 1))
   (branch (label base-case))
   ~\textrm{;; Set up for the recursive call by saving \code{n} and \code{continue}.}~
   ~\textrm{;; Set up \code{continue} so that the computation will continue}~
   ~\textrm{;; at \code{after\-/fact} when the subroutine returns.}~
   (save continue)
   (save n)
   (assign n (op -) (reg n) (const 1))
   (assign continue (label after-fact))
   (goto (label fact-loop))
 after-fact
   (restore n)
   (restore continue)
   (assign val (op *) (reg n) (reg val))   ~\textrm{; \code{val} now contains}~ ~\( n(n-1)! \)~
   (goto (reg continue))                   ~\textrm{; return to caller}~
 base-case
   (assign val (const 1))                  ~\textrm{; base case: }~1! = 1
   (goto (reg continue))                   ~\textrm{; return to caller}~
 fact-done)
\end{smallscheme}

\end{comment}
\includegraphics[width=106mm]{fig/chap5/Fig5.11a.pdf}
\par\bigskip
\noindent
\heading{Figure 5.11:} 再帰階乗マシン
\end{figure}

\noindent
それにもかかわらず、もし機械の各入れ子のインスタンスが同じコンポーネントを使用するように
準備ができれば階乗プロセスをレジスタマシンとして実装できます。具体的に言えば、
\( n! \)を求める機械は\( (n - 1)! \)を求める部分問題、\( (n - 2)! \)の部分問題、以下
繰り返しの仕事に同じコンポーネントを使用せねばなりません。これはもっともらしく見えます。
例え階乗プロセスが同じ機械のコピーの未束縛の数値が演算を実行するのに必要だと指図したとしても、
これらのコピーのただ1つが一度に有効になる必要があるためです。この機械が再帰の部分問題に
遭遇した時に、メインの問題上の仕事を中断し、同じ物理部品を部分問題上の仕事に再利用し、
そして中断した演算を続けることが可能です。

部分問題の中では、レジスタの中身はメインの問題の中の物と異なります。(この場合には
レジスタ\code{n}はデクリメントされます)。中断された演算を続けることを可能にするために、
機械は部分問題が解決した後に必要となる全てのレジスタの中身を保存しなければなりません。
そうすることで、中断した演算を続ける時にこれらの値が再格納されることができます。
階乗の場合には、デクリメントされたレジスタ\code{n}の階乗の演算が完了した時に再格納されるように
\code{n}の古い値を保存します。\footnote{古い\code{n}を保存する必要は無いと主張する人が
いるかもしれません。デクリメントし、部分問題を解決した後に、単純に古い値を回復するために
インクリメントすることができると思われるでしょう。例えこの戦略が階乗に対しては
働いたとしても、それは一般的にはうまく行きません。レジスタの古い値が常に
新しい値から求められるとは限らないためです。}

予測可能な限界が入れ子の再帰呼出の深さには存在しないため、任意の数のレジスタ値を
保存する必要があるでしょう。これらの値は保存された順の逆順に再格納されねばなりません。
入れ子の再帰では突入する最後の部分問題が最初に完了するためです。このことが
\newterm{stack}(\jnewterm{スタック})、つまり``last in, first out''(LIFO, 後入れ先出し)データ構造を
レジスタ値の保存への使用することを指示しています。レジスタマシン言語を拡張し、
2つの種類の命令を追加することでスタックを含めることができます。値はスタックに
\code{save}命令を用いて置かれて、\code{restore}命令を用いてスタックから再格納されます。
スタック上に一連の値が\code{save}された後に、連続した\code{restore}がこれらの値を逆順に
取り出します。\footnote{\link{Section 5.3}において,よりプリミティブな命令を用いてどのように
スタックを実装するかについて学びます。}

スタックの助けを借りることで階乗マシンの各階乗部分問題のために、データパスの
単一のコピーを再利用することができます。同様なデータパスを操作するコントローラシーケンスの
再利用についても同様の設計上の問題が存在します。階乗演算を再実行するためには,
コントローラは単純には最初に反復プロセスのようにループバックすることはできません。
\( (n - 1)! \)を解いた後には機械は依然としてその結果と\( n \)を掛ける必要があるためです。
コントローラは\( n! \)の演算を中断し、部分問題\( (n - 1)! \)を解き、そして\( n! \)の演算を
続けなければなりません。階乗演算のこの見方は\link{Section 5.1.3}で説明されたサブルーチンの仕組みの
使用を推奨しており、これはコントローラにレジスタ\code{continue}を使用させて部分問題を解く
列の一部へと移動し、そしてメイン問題を中止した場所から続行します。このようにして
\code{continue}レジスタに格納されたエントリポイントに帰る階乗のサブルーチンを作ることができます。
各サブルーチン呼出の周りでは、\code{continue}を\code{n}レジスタに行うのと同じように保存し
再格納します。階乗演算の各``レベル''が同じ\code{continue}レジスタを利用するためです。
つまり、階乗サブルーチンはそれが自分自身を部分問題として呼び出す時に、新しい値を\code{continue}に
設定しなければいけません。しかし部分問題を解くために呼び出した場所に戻るために
古い値が必要となるのです。

\link{Figure 5.11}は再帰\code{factorial}手続を実装する機械のためのデータパスとコントローラを
示しています。この機械はスタックと3つのレジスタ、\code{n}, \code{val}, \code{continue}を持ちます。
データパス図を単純化するために、レジスタ代入ボタンには名前を付けず、スタック命令ボタン
(レジスタを保存する\code{sc}と\code{sn}、レジスタに戻す\code{rc}と\code{rn})のみに付けています。
機械を運用するには、レジスタ\code{n}に階乗を求めたい数を入れ、それから機械を開始します。
機械が\code{fact\-/done}に辿り着いた時に演算は完了し、答はレジスタ\code{val}に見つかります。
コントローラシーケンスでは\code{n}と\code{continue}が各再帰呼出の前に保存され、その呼出から
戻る時に再格納されます。呼出からの復帰は\code{continue}に格納された場所に分岐することにより
達成されます。\code{continue}は機械が開始した時に最後の復帰が\code{fact\-/done}に向かうように
初期化されます。階乗演算の結果を持つ\code{val}レジスタは再帰呼出の前に保存されません。
\code{val}の古い中身はサブルーチンから復帰後には役に立たないためです。部分問題により
生成された新しい値のみが必要とされます。

例え原理上は階乗演算が無限の機械を必要とするとしても、\link{Figure 5.11}の機械は
実際には限りが無いかもしれないスタックを除けば有限です。しかし、スタックのどんな特定の
物理実装も有限のサイズを持ち、このことが機械により扱うことが可能な再帰呼出の深さを
制限します。この階乗の実装は再帰アルゴリズムをスタックで容量が増加された通常のレジスタマシン
として実現するための一般的な戦略を説明します。再帰部分問題に遭遇した時には
その現在の値が部分問題が解決された後に必要とされるレジスタをスタック上に保存します。
次に再帰部分問題を解決し、保存されたレジスタを戻してメイン問題の実行を続行します。
\code{continue}レジスタは常に保存されなければなりません。保存する必要の有るレジスタが
他に存在するかどうかは機械に依存します。全ての再帰演算が部分問題の解決の間に変更される
レジスタの元の値を必要とはしないためです。(\link{Exercise 5.4}参照)。

\subsubsection*{二重再帰}


より複雑な再帰プロセス、\link{Section 1.2.2}で紹介したフィボナッチ数の木再帰演算について調査してみましょう。

\begin{scheme}
(define (fib n)
  (if (< n 2)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))
\end{scheme}

\noindent
階乗と同じ様に、再帰フィボナッチ演算をレジスタマシンとしてレジスタ\code{n}, \code{val}, \code{continue}と用いて
実装することができます。この機械は階乗のものよりも、より複雑です。コントローラシーケンスの中に
二箇所の再帰呼出の実行が必要な箇所が存在するためです。一度目は\( {\rm Fib}(n - 1) \)を求めるために、
二度目は\( {\rm Fib}(n - 2) \)を求めるためです。
これらの各呼出に準備するために、後にその値が必要となるレジスタを保存し、レジスタ\code{n}に
再帰的に求める(\( n - 1 \)または\( n - 2 \))必要のあるフィボナッチ数を設定します。
そして\code{continue}に戻り先のメインシーケンスのエントリポイント(それぞれ\code{afterfib\-/n\-/1}または\code{afterfib\-/n\-/2})を
割り当てます。そうしたら\code{fib\-/loop}へと飛びます。再帰呼出から帰る時には、回答は\code{val}の
中にあります。\link{Figure 5.12}はこの機械のためのコントローラシーケンスを示しています。

\begin{quote}
\heading{\phantomsection\label{Figure 5.12}Figure 5.12:} \( \downarrow \) Controller for a machine to compute
Fibonacci numbers.

\begin{scheme}
(controller
   (assign continue (label fib-done))
 fib-loop
   (test (op <) (reg n) (const 2))
   (branch (label immediate-answer))
   ~\textrm{;; Fib\( (n-1) \)を求める準備}~
   (save continue)
   (assign continue (label afterfib-n-1))
   (save n)                 ~\textrm{; \code{n}の古い値を保存}~
   (assign n (op -) (reg n) (const 1)) ~\textrm{; \code{n}を\code{n\-/1}で上書き}~
   (goto (label fib-loop))  ~\textrm{; 再帰呼出の実行}~
 afterfib-n-1     ~\textrm{; リターン時に, \code{val}がFib\( (n-1) \)を持つ}~
   (restore n)
   (restore continue)
   ~\textrm{;; Fib\( (n - 2) \)を求める準備}~
   (assign n (op -) (reg n) (const 2))
   (save continue)
   (assign continue (label afterfib-n-2))
   (save val)               ~\textrm{; Fib\( (n-1) \)を保存}~
   (goto (label fib-loop))
 afterfib-n-2     ~\textrm{; リターン時に, \code{val}がFib\( (n-2) \)を持つ}~
   (assign n (reg val))     ~\textrm{; \code{n}がここでFib\( (n-2) \)を持つ}~
   (restore val)            ~\textrm{; \code{val}がここでFib\( (n-1) \)を持つ}~
   (restore continue)

   (assign val              ~\textrm{; Fib\( (n-1) \) + Fib\( (n-2) \)}~
           (op +) (reg val) (reg n))
   (goto (reg continue))    ~\textrm{; 呼び出しから戻る, 答は\code{val}の中にある}~
 immediate-answer
   (assign val (reg n))     ~\textrm{; 基底の場合: Fib\( (n) = n \)}~
   (goto (reg continue))
 fib-done)
\end{scheme}

\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.4}Exercise 5.4:}
次の手続のそれぞれを実装するレジスタマシンを指定せよ。各マシンに対して、
コントローラ命令列を書き、データパスを示す図を描け。

\begin{enumerate}[a]

\item
再帰指数計算

\begin{scheme}
(define (expt b n)
  (if (= n 0)
      1
      (* b (expt b (- n 1)))))
\end{scheme}

\item
反復指数計算

\begin{scheme}
(define (expt b n)
  (define (expt-iter counter product)
    (if (= counter 0)
        product
        (expt-iter (- counter 1)
                   (* b product))))
  (expt-iter n 1))
\end{scheme}

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.5}Exercise 5.5:}
階乗とフィボナッチの機械をいくつかの非自明な入力を用いて手動でシミュレートせよ。
(少なくとも1回の再帰呼出を必要とする)。実行中の各重要な地点におけるスタックの中身を示せ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.6}Exercise 5.6:}
Ben Bitdiddleはフィボナッチマシンのコントローラシーケンスが余分な\code{save}と\code{restore}を持ち、
より速いマシンを作るために取り除くことができることに気付いた。これらの命令はどこにあるか?
\end{quote}

\subsection{命令の要約}
\label{Section 5.1.5}

私達のレジスタマシン言語のコントローラ命令は以下の形式の内1つを持ち、各\( \langle \)\( input_i \)\( \rangle \)は
\code{(reg<\var{register\-/name}>)}か\code{(const <\var{constant\-/value}>)}の何れかです。
これらの命令は\link{Section 5.1.1}で導入されました。

\begin{scheme}
(assign ~\( \dark \langle \)~~\var{\dark register-name}~~\( \dark \rangle \)~ (reg ~\( \dark \langle \)~~\var{\dark register-name}~~\( \dark \rangle \)~))
(assign ~\( \dark \langle \)~~\var{\dark register-name}~~\( \dark \rangle \)~ (const ~\( \dark \langle \)~~\var{\dark constant-value}~~\( \dark \rangle \)~))
(assign ~\( \dark \langle \)~~\var{\dark register-name}~~\( \dark \rangle \)~ 
        (op ~\( \dark \langle \)~~\var{\dark operation-name}~~\( \dark \rangle \)~) 
        ~\( \dark \langle \)~~\( \dark input_1 \)~~\( \dark \rangle \)~ ~\( \dots \)~ ~\( \dark \langle \)~~\( \dark input_n \)~~\( \dark \rangle \)~)
(perform (op ~\( \dark \langle \)~~\var{\dark operation-name}~~\( \dark \rangle \)~) ~\( \dark \langle \)~~\( \dark input_1 \)~~\( \dark \rangle \)~ ~\( \dots \)~ ~\( \dark \langle \)~~\( \dark input_n \)~~\( \dark \rangle \)~)
(test (op ~\( \dark \langle \)~~\var{\dark operation-name}~~\( \dark \rangle \)~) ~\( \dark \langle \)~~\( \dark input_1 \)~~\( \dark \rangle \)~ ~\( \dots \)~ ~\( \dark \langle \)~~\( \dark input_n \)~~\( \dark \rangle \)~)
(branch (label ~\( \dark \langle \)~~\var{\dark label-name}~~\( \dark \rangle \)~))
(goto (label ~\( \dark \langle \)~~\var{\dark label-name}~~\( \dark \rangle \)~))
\end{scheme}

\noindent
レジスタを用いてラベルを保存することは\link{Section 5.1.3}で導入されました。

\begin{scheme}
(assign ~\( \dark \langle \)~~\var{\dark register-name}~~\( \dark \rangle \)~ (label ~\( \dark \langle \)~~\var{\dark label-name}~~\( \dark \rangle \)~))
(goto (reg ~\( \dark \langle \)~~\var{\dark register-name}~~\( \dark \rangle \)~))
\end{scheme}

\noindent
スタックを使用する命令は\link{Section 5.1.4}で導入されました。

\begin{scheme}
(save ~\( \dark \langle \)~~\var{\dark register-name}~~\( \dark \rangle \)~)
(restore ~\( \dark \langle \)~~\var{\dark register-name}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
ここまでで見た\( \langle \)\var{constant-value}\( \rangle \)の種類は数値のみです。しかし
後程、文字列、シンボル、それにリストを使用します。
\begin{scheme}
(const "abc") ~\textrm{は文字列}~ "abc",
(const abc) ~\textrm{はシンボル}~ abc,
(const (a b c)) ~\textrm{はリスト}~ (a b c),
(const ()) ~\textrm{は空リスト}~
\end{scheme}

\section{レジスタマシンシミュレータ}
\label{Section 5.2}

レジスタマシンの設計を良く理解するために、私達は設計した機械を期待通りに実行されるか
確認するためにテストをする必要があります。設計のテストを行う1つの方法として
\link{Exercise 5.5}と同様にコントローラの命令を手動でシミュレートする方法があります。
しかしこれは簡単な機械を除いてとんでもなく退屈な方法です。この節ではレジスタマシン言語で
記述された機械のためのシミュレータを構築します。このシミュレータは4つのインターフェイス
手続を持つSchemeのプログラムです。1つ目はレジスタマシンの記述をマシンのモデルを構築する
ために利用します(データ構造の部品がシミュレートされるマシンの部品に対応します)。
残りの3つがモデルを操作することにより機械のシミュレーションを可能にします。

\begin{quote}

\begin{scheme}
(make-machine ~\( \dark \langle \)~~\var{\dark register-names}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark operations}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark controller}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
与えられたレジスタ、命令、コントローラを持つ機械のモデルを構築し、返します。

\begin{scheme}
(set-register-contents! ~\( \dark \langle\kern0.08em \)~~\var{\dark machine-model}~~\( \dark \rangle \)~ 
                        ~\( \dark \langle \)~~\var{\dark register-name}~~\( \dark \rangle \)~ 
                        ~\( \dark \langle \)~~\var{\dark value}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
与えられた機械でシミュレートされるレジスタに値を格納します。

\begin{scheme}
(get-register-contents ~\( \dark \langle\kern0.08em \)~~\var{\dark machine-model}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark register-name}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
与えられた機械のシミュレートされるレジスタの中身を返す。

\begin{scheme}
(start ~\( \dark \langle\kern0.08em \)~~\var{\dark machine-model}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
与えられた機械の実行をシミュレートする。コントローラシーケンスの最初から開始し、
シーケンスの最後に辿り着いた時に停止する。
\end{quote}

\noindent
これらの手続がどのように利用されるかの例として、\link{Section 5.1.1}の\acronym{GCD}マシンの
モデルとなる\code{gcd\-/machine}を以下のように定義します。

\begin{scheme}
(define gcd-machine
  (make-machine
   '(a b t)
   (list (list 'rem remainder) (list '= =))
   '(test-b (test (op =) (reg b) (const 0))
            (branch (label gcd-done))
            (assign t (op rem) (reg a) (reg b))
            (assign a (reg b))
            (assign b (reg t))
            (goto (label test-b))
            gcd-done)))
\end{scheme}

\noindent
\code{make\-/machine}に対する最初の引数はレジスタ名のリストです。次の引数は各命令名と
その命令を実装するScheme手続(つまり、同じ入力値を与えられて同じ出力値を生成します)を
ペアにするテーブル(2要素リストのリスト)です。最後の引数は\link{Section 5.1}にあるように
ラベルと機械の命令(機械語)のリストとしてのコントローラを指定します。


この機械を用いて\acronym{GCD}を求めるために、入力レジスタを設定し、機械を開始し、
シミュレーションが停止した時に結果を検査します。

\begin{scheme}
(set-register-contents! gcd-machine 'a 206)
~\textit{done}~
(set-register-contents! gcd-machine 'b 40)
~\textit{done}~
(start gcd-machine)
~\textit{done}~
(get-register-contents gcd-machine 'a)
~\textit{2}~
\end{scheme}

\noindent
この演算はSchemeで書かれた\code{gcd}手続よりもとても遅く実行します。なぜなら
\code{assign}のような低レベルの機械語をより複雑な命令によりシミュレートするためです。

\begin{quote}
\heading{\phantomsection\label{Exercise 5.7}Exercise 5.7:}
シミュレータを用いて\link{Exercise 5.4}で自分で設計した機械をテストせよ。
\end{quote}



\subsection{マシンモデル}
\label{Section 5.2.1}

\code{make\-/machine}にて生成された機械のモデルは\link{Chapter 3}で開発された
メッセージパッシングの技術を用いた局所状態を持つ手続として表現されています。
このモデルを構築するために、\code{make\-/machine}は手続\code{make\-/new\-/machine}を呼び
全てのレジスタマシンに対して共通なマシンモデルの部品を構築することから始めます。
\code{make\-/new\-/machine}により構築されるこの基本的な機械のモデルは本質的には
いくつかのレジスタとスタックと、コントローラ命令を1つずつ処理する実行の
仕組みを一緒にしたコンテナです。

\code{make\-/machine}は次にこの基本的なモデルを(それに対してメッセージを送ることで)
拡張し、レジスタ、命令、定義される特定の機械のコントローラを含めます。
最初に新しい機械の中に与えられた各レジスタ名に対するレジスタを獲得し、指定された
命令をその機械にインストール(導入)します。次に\newterm{assembler}(\jnewterm{アセンブラ})(下記の
\link{Section 5.2.2}で説明されます)を用いてコントローラリストを新しい機械に対する命令に変換し、
これらを機械の命令列としてインストールします。\code{make\-/machine}はその値として変更された
機械のモデルを返します。

\begin{scheme}
(define (make-machine register-names ops controller-text)
  (let ((machine (make-new-machine)))
    (for-each
     (lambda (register-name)
       ((machine 'allocate-register) register-name))
     register-names)
    ((machine 'install-operations) ops)
    ((machine 'install-instruction-sequence)
     (assemble controller-text machine))
    machine))
\end{scheme}

\subsubsection*{レジスタ}

レジスタは\link{Chapter 3}の様に局所状態を持つ手続として表現されます。手続\code{make\-/register}は
アクセスと変更が可能な値を持つレジスタを作成します。

\begin{scheme}
(define (make-register name)
  (let ((contents '*unassigned*))
    (define (dispatch message)
      (cond ((eq? message 'get) contents)
            ((eq? message 'set)
             (lambda (value) (set! contents value)))
            (else
             (error "Unknown request: REGISTER" message))))
    dispatch))
\end{scheme}

\noindent
以下の手続はレジスタにアクセスするために使用されます。

\begin{scheme}
(define (get-contents register) (register 'get))
(define (set-contents! register value)
  ((register 'set) value))
\end{scheme}

\subsubsection*{スタック}


スタックもまた局所状態を持つ手続として表現されます。手続\code{make\-/stack}は
局所状態がスタック上のアイテム(項目)のリストから成るスタックを作成します。
スタックはスタック上にアイテムを\code{push}とスタックから最上位の
アイテムを取り去りそれを返す\code{pop}、スタックを空に初期化する\code{initialize}の
リクエストを受け付けます。

\begin{scheme}
(define (make-stack)
  (let ((s '()))
    (define (push x) (set! s (cons x s)))
    (define (pop)
      (if (null? s)
          (error "Empty stack: POP")
          (let ((top (car s)))
            (set! s (cdr s))
            top)))
    (define (initialize)
      (set! s '())
      'done)
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize) (initialize))
            (else (error "Unknown request: STACK"
                         message))))
    dispatch))
\end{scheme}

\noindent
以下の手続はスタックへのアクセスに使用されます。

\begin{scheme}
(define (pop stack) (stack 'pop))
(define (push stack value) ((stack 'push) value))
\end{scheme}

\subsubsection*{基本的な機械}

\link{Figure 5.13}に示す\code{make\-/new\-/machine}手続は局所状態がスタック、初期値が空の
命令列、初期値がスタックを初期化する命令を持つ命令のリスト、初期値として2つのレジスタ
\code{flag}(フラグ)と\code{pc}(``program counter''、プログラムカウンタ)を持つ
\newterm{register table}(\jnewterm{レジスタテーブル})から成り立ちます。内部手続\code{lookup\-/register}は
テーブル内のレジスタを探します。

\code{flag}レジスタはシミュレートされる機械にて分岐をコントロールするために使用されます。
\code{test}命令は\code{flag}の中身にテストの結果(真、または、偽)を設定します。\code{branch}命令は
分岐するかしないかを\code{flag}の中身を調査して決定します。

\code{pc}レジスタは機械が実行する命令の順序付けを決定します。この順序付けは内部手続\code{execute}により
実装されています。シミュレーションモデルでは各機械命令は
\newterm{instruction execution procedure}(\jnewterm{命令実行手続})と呼ばれる引数無しの
手続を含むデータ構造であり、この手続を呼ぶことにより命令の実行をシミュレートします。
シミュレーションが実行されるにつれ、\code{pc}は次に実行される命令から始まる命令列の地点を
指します。\code{execute}はその命令を得て、それを命令実行手続を呼ぶことにより実行し、
このサイクルを実行する命令が無くなるまで(すなわち、\code{pc}が命令列の最後を
指すまで)繰り返します。

\newpage
\noindent
\heading{\phantomsection\label{Figure 5.13}Figure 5.13:}
\( \downarrow \) 基本の機械モデルを実装する\code{make\-/new\-/machine}手続

\begin{scheme}
(define (make-new-machine)
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stack (make-stack))
        (the-instruction-sequence '()))
    (let ((the-ops
           (list (list 'initialize-stack
                       (lambda () (stack 'initialize)))))
          (register-table
           (list (list 'pc pc) (list 'flag flag))))
      (define (allocate-register name)
        (if (assoc name register-table)
            (error "Multiply defined register: " name)
            (set! register-table
                  (cons (list name (make-register name))
                        register-table)))
        'register-allocated)
      (define (lookup-register name)
        (let ((val (assoc name register-table)))
          (if val
              (cadr val)
              (error "Unknown register:" name))))
      (define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts)
              'done
              (begin
                ((instruction-execution-proc (car insts)))
                (execute)))))
      (define (dispatch message)
        (cond ((eq? message 'start)
               (set-contents! pc the-instruction-sequence)
               (execute))
              ((eq? message 'install-instruction-sequence)
               (lambda (seq)
                 (set! the-instruction-sequence seq)))
              ((eq? message 'allocate-register) 
               allocate-register)
              ((eq? message 'get-register)
               lookup-register)
              ((eq? message 'install-operations)
               (lambda (ops)
                 (set! the-ops (append the-ops ops))))
              ((eq? message 'stack) stack)
              ((eq? message 'operations) the-ops)
              (else (error "Unknown request: MACHINE"
                           message))))
      dispatch)))
\end{scheme}

\noindent
工程の一部として、各命令の実行手続は\code{pc}を変更し次に実行される命令を指すようにします。
\code{branch}と\code{goto}命令は\code{pc}を変更し新しい行き先を指すようにします。
全ての他の命令は単純に\code{pc}を進めて列の次の命令を指すようにします。
各\code{execute}の呼出が\code{execute}を再び呼び出すことに中止して下さい。
これはしかし無限ループにはなりません。命令実行手続の実行は\code{pc}の中身を
変更するためです。

\code{make\-/new\-/machine}は\code{dispatch}手続を返します。これは内部の状態にアクセスする
メッセージパッシングを実装します。機械の開始は\code{pc}に命令列の最初を設定し、
\code{execute}を呼ぶことにより達成されることに注意して下さい。

利便性のために、機械の\code{start}命令の代替となる手続のインターフェイスを提供します。
同様に、レジスタの中身の設定、試験の手続も\link{Section 5.2}の最初にて指示されたように
提供します。

\begin{scheme}
(define (start machine) (machine 'start))
(define (get-register-contents machine register-name)
  (get-contents (get-register machine register-name)))
(define (set-register-contents! machine register-name value)
  (set-contents! (get-register machine register-name)
                 value)
  'done)
\end{scheme}

\noindent
これらの手続(と\link{Section 5.2.2}と\link{Section 5.2.3}の多くの手続)は以下を用いて与えられた機械と
レジスタ名のレジスタを探します。

\begin{scheme}
(define (get-register machine reg-name)
  ((machine 'get-register) reg-name))
\end{scheme}

\subsection{アセンブラ}
\label{Section 5.2.2}

アセンブラはコントローラの機械のための式の列を対応する機械の命令のリストへと変形します。
各命令はその実行手続を持ちます。概して、アセンブラは\link{Chapter 4}で学習した評価機に
とても似ています。入力言語が存在し(この場合にはレジスタマシン言語)、言語の式の各型に
対して適切なアクションを実行しなければなりません。

各命令のための実行手続を生成する技術は\link{Section 4.1.7}で実行時に実行から分析を分離する
ことで高速化するために用いたのものと同じです。\link{Chapter 4}で学んだように、
Schemeの式の多くの実用的な分析は変数の実際の値を知らなくとも実行することができました。
ここでも同様に、レジスタマシン言語の式の多くの実用的な分析が実際の機械のレジスタの
値を知ることなしに実行することができます。例えばレジスタへの参照をレジスタオブジェクトへの
ポインタにより置き換えたり、ラベルをラベルが指定する命令列内の地点へのポインタで
置き換えることができます。

アセンブラが命令実行手続を生成する前に、全てのテーブルが何を参照するのか知っておく
必要がります。そのためコントローラテキストを走査し命令からラベルを分離することから
始めます。アセンブラがテキストを走査するにつれ、命令のリストと各ラベルをそのリスト内部を指すポインタと
関連付けるテーブルの両方を構築します。そうしたらアセンブラは命令リストを各命令に
対する実行手続を挿入することで増補します。

\code{assemble}手続はアセンブラに対する主な入口です。コントローラテキストとマシンモデルを引数として
取り、モデルに格納するべき命令列を返します。\code{assemble}は\code{extract\-/labels}を呼び初期命令リストと
与えられたコントローラテキストからラベルテーブルを構築します。\code{extract\-/labels}の2つ目の引数は
これらの結果を処理するために呼ばれるべきものです。この手続は\code{update\-/insts!}を用いて命令実行
手続を再生し、それらを命令リストの中に挿入し、変更されたリストを返します。

\begin{scheme}
(define (assemble controller-text machine)
  (extract-labels
   controller-text
   (lambda (insts labels)
     (update-insts! insts labels machine)
     insts)))
\end{scheme}

\noindent
\code{extract\-/labels}は引数としてリスト\code{text}(コントローラ命令式の列)と
\code{receive}手続を取ります。\code{receive}は2つの値と共に呼び出されます。
(1) 命令データ構造のリスト\code{insts}はそれぞれが\code{text}からの命令を含みます。
(2) テーブル\code{labels}は\code{text}からの各ラベルとそのラベルが指定するリスト\code{insts}内の
位置とを関連付けします。

\begin{scheme}
(define (extract-labels text receive)
  (if (null? text)
      (receive '() '())
      (extract-labels
       (cdr text)
       (lambda (insts labels)
         (let ((next-inst (car text)))
           (if (symbol? next-inst)
               (receive insts
                        (cons (make-label-entry next-inst
                                                insts)
                              labels))
               (receive (cons (make-instruction next-inst)
                              insts)
                        labels)))))))
\end{scheme}

\noindent
\code{extract\-/labels}は連続して\code{text}の要素を走査し、\code{insts}と\code{labels}を集積する
ことで働きます。もし要素がシンボル(従ってラベル)なら適切なエントリが\code{labels}テーブルに
追加されます。そうでなければその要素は\code{insts}リスト上に集積されます。\footnote{
\code{receive}手続をここで使用するのは\code{extract\-/labels}を得て、効率的に2つの値、\code{labels}と
\code{insts}をそれを保持する複合データ構造を明示的に作ること無しに返すための方法です。
代替となる、明示的に値のペアを返す実装は以下の通りです。

\begin{smallscheme}
(define (extract-labels text)
  (if (null? text)
      (cons '() '())
      (let ((result (extract-labels (cdr text))))
        (let ((insts (car result)) (labels (cdr result)))
          (let ((next-inst (car text)))
            (if (symbol? next-inst)
                (cons insts
                      (cons (make-label-entry next-inst insts) 
                            labels))
                (cons (cons (make-instruction next-inst) insts)
                      labels)))))))
\end{smallscheme}

\noindent
これは\code{assemble}により以下のように呼び出されます。

\begin{smallscheme}
(define (assemble controller-text machine)
  (let ((result (extract-labels controller-text)))
    (let ((insts (car result)) (labels (cdr result)))
      (update-insts! insts labels machine)
      insts)))
\end{smallscheme}

\noindent
\code{receive}の使用は複数の値を返す洗練された手法の実演、または単純にプログラミング上のトリックを
見せ付けるための言い訳として考えることができます。\code{receive}のような次に実行されるべき手続引数は
``継続''と呼ばれます。\link{Section 4.3.3}で私達が継続を\code{amb}評価機のバックトラック制御構造の実装に
用いたのを思い出して下さい。
}


\code{update\-/insts!}は命令リストを変更します。これは初期値としては命令のテキストのみを
含みますが、対応する実行手続を含むようになります。

\begin{scheme}
(define (update-insts! insts labels machine)
  (let ((pc (get-register machine 'pc))
        (flag (get-register machine 'flag))
        (stack (machine 'stack))
        (ops (machine 'operations)))
    (for-each
     (lambda (inst)
       (set-instruction-execution-proc!
        inst
        (make-execution-procedure
         (instruction-text inst)
         labels machine pc flag stack ops)))
     insts)))
\end{scheme}

\noindent
マシン語データ構造は単純に命令テキストと対応する実行手続のペアを作ります。
実行手続は\code{extract\-/labels}が命令を構築した時にはまだ存在せず、
後に\code{update\-/insts!}により挿入されます。

\begin{scheme}
(define (make-instruction text) (cons text '()))
(define (instruction-text inst) (car inst))
(define (instruction-execution-proc inst) (cdr inst))
(define (set-instruction-execution-proc! inst proc)
  (set-cdr! inst proc))
\end{scheme}

\noindent
命令テキストはシミュレータでは使用されません。しかし、デバッグのために
手元に置いておくと便利です。(\link{Exercise 5.16}参照)


ラベルテーブルの要素はペアです。

\begin{scheme}
(define (make-label-entry label-name insts)
  (cons label-name insts))
\end{scheme}

\noindent
テーブル内の要素は以下により検索されます。

\begin{scheme}
(define (lookup-label labels label-name)
  (let ((val (assoc label-name labels)))
    (if val
        (cdr val)
        (error "Undefined label: ASSEMBLE"
               label-name))))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.8}Exercise 5.8:}
以下のレジスタマシンのコードは曖昧である。ラベル\code{here}が複数回、定義されているためである。

\begin{scheme}
start
  (goto (label here))
here
  (assign a (const 3))
  (goto (label there))
here
  (assign a (const 4))
  (goto (label there))
there
\end{scheme}


シミュレータが書かれているままの状態で、レジスタ\code{a}の中身はコントローラが
\code{there}に辿り着いた時に何になるか? 手続\code{extract\-/labels}を変更し、同じラベル名が
2つの異なる地点を指し示すのに使用された場合にエラーを発するようにせよ。
\end{quote}

\subsection{各命令に対する実行手続の生成}
\label{Section 5.2.3}

アセンブラは命令の実行手続を生成するために\code{make\-/execution\-/procedure}を呼びます。
\link{Section 4.1.7}の評価機の\code{analyze}手続と同様に、これは適切な実行手続を生成するために
命令の型に従い呼出を行います。

\begin{scheme}
(define (make-execution-procedure 
         inst labels machine pc flag stack ops)
  (cond ((eq? (car inst) 'assign)
         (make-assign inst machine labels ops pc))
        ((eq? (car inst) 'test)
         (make-test inst machine labels ops flag pc))
        ((eq? (car inst) 'branch)
         (make-branch inst machine labels flag pc))
        ((eq? (car inst) 'goto)
         (make-goto inst machine labels pc))
        ((eq? (car inst) 'save)
         (make-save inst machine stack pc))
        ((eq? (car inst) 'restore)
         (make-restore inst machine stack pc))
        ((eq? (car inst) 'perform)
         (make-perform inst machine labels ops pc))
        (else
         (error "Unknown instruction type: ASSEMBLE"
                inst))))
\end{scheme}

\noindent
レジスタマシンの言語の命令の各型に対し、適切な実行手続を構築する生成器が存在します。
これらの手続の詳細がレジスタマシン言語の構文と個別の命令の意味の両方を決定します。
データ抽象化を用いることで全体的な実行の仕組みからレジスタマシンの式の詳細な構文を
分離しています。これは\link{Section 4.1.2}で評価機に対して行ったのと同様で、構文手続を用いて
命令の部分を抽出し、分類することによります。

\subsubsection*{\code{assign}命令}


\code{make\-/assign}手続は\code{assign}命令を扱います。

\begin{scheme}
(define (make-assign inst machine labels operations pc)
  (let ((target
         (get-register machine (assign-reg-name inst)))
        (value-exp (assign-value-exp inst)))
    (let ((value-proc
           (if (operation-exp? value-exp)
               (make-operation-exp
                value-exp machine labels operations)
               (make-primitive-exp
                (car value-exp) machine labels))))
      (lambda ()   ~\textrm{; \code{assign}に対する実行手続}~
        (set-contents! target (value-proc))
        (advance-pc pc)))))
\end{scheme}

\noindent
\code{make\-/assign}はターゲットとなるレジスタ名(命令の2つ目の要素)と値の式(命令を
構成するリストの残りの部分)を\code{assign}命令からセレクタを用いて抽出します。

\begin{scheme}
(define (assign-reg-name assign-instruction)
  (cadr assign-instruction))
(define (assign-value-exp assign-instruction)
  (cddr assign-instruction))
\end{scheme}

\noindent
レジスタ名が\code{get\-/register}を用いて検索され目的のレジスタオブジェクトを生成します。
値の式はもし値が命令の結果であるのなら\code{make\-/operation\-/exp}に渡され、そうでなければ
\code{make\-/primitive\-/exp}に渡されます。これらの手続(以下に示されます)は値の式を構文解析し
その値に対する実行手続を生成します。これは引数無しの手続で\code{value\-/proc}と呼ばれ、
シミュレーションの間にレジスタに代入される実際の値を生成するために評価されます。
レジスタ名の検索と値の式の構文解析の仕事はただ一度、アセンブリ時(アセンブラ実行時)に実行されることに注意して下さい。
その命令がシミュレートされる度に毎回ではありません。この仕事量の削減こそが私達が
実行手続を使用する理由です。そしてこれが直接\link{Section 4.1.7}の評価機において、実行から
プログラム分析を分離することにより仕事量の削減を得たことに対応します。

\code{make\-/assign}により返される結果は\code{assign}命令のための実行手続です。
この手続が(マシンモデルの\code{execute}手続により)呼ばれた時に、\code{value\-/proc}手続を
実行することにより得られた結果を目的のレジスタの中身に設定します。その次に\code{pc}を
以下の手続を実行することにより次の命令へと進めます。

\begin{scheme}
(define (advance-pc pc)
  (set-contents! pc (cdr (get-contents pc))))
\end{scheme}

\noindent
\code{advance\-/pc}は\code{branch}と\code{goto}を除く全ての命令に対する通常の終わりです。

\subsubsection*{\code{Test}, \code{branch}, \code{goto}命令}

\code{make\-/test}は\code{test}命令を同様な方法で扱います。これはテストされる条件を指定する
式を抽出し、それに対する実行手続を生成します。シミュレーション時に、条件のための
手続が呼ばれ、その結果が\code{flag}レジスタに割り当てられ、\code{pc}が進められます。

\begin{scheme}

(define (make-test inst machine labels operations flag pc)
  (let ((condition (test-condition inst)))
    (if (operation-exp? condition)
        (let ((condition-proc
               (make-operation-exp
                condition machine labels operations)))
          (lambda ()
            (set-contents! flag (condition-proc))
            (advance-pc pc)))
        (error "Bad TEST instruction: ASSEMBLE" inst))))
(define (test-condition test-instruction)
  (cdr test-instruction))
\end{scheme}

\noindent
\code{branch}命令のための実行手続は\code{flag}レジスタの中身をチェックし、\code{pc}の中身に
分岐の目的地を設定するか(分岐が選択された場合)、または単に\code{pc}を進めます
(分岐が選択されなかった場合)。\code{branch}命令内で指定された目的値はラベルでなければ
ならず、\code{make\-/branch}手続がこのことを強制することに注意して下さい。またラベルは
アセンブリ時に検索され、\code{branch}命令がシミュレートされる時に毎回検索される
訳ではないことにも注意して下さい。

\begin{scheme}
(define (make-branch inst machine labels flag pc)
  (let ((dest (branch-dest inst)))
    (if (label-exp? dest)
        (let ((insts
               (lookup-label
                labels 
                (label-exp-label dest))))
          (lambda ()
            (if (get-contents flag)
                (set-contents! pc insts)
                (advance-pc pc))))
        (error "Bad BRANCH instruction: ASSEMBLE" inst))))
(define (branch-dest branch-instruction)
  (cadr branch-instruction))
\end{scheme}

\noindent
\code{goto}命令は\code{branch}に似ていますが、目的地がラベルか、またはレジスタにより指定される
ことが異なります。また条件分岐ではありません。\code{pc}は常に新しい目的地に設定されます。

\begin{scheme}
(define (make-goto inst machine labels pc)
  (let ((dest (goto-dest inst)))
    (cond ((label-exp? dest)
           (let ((insts (lookup-label
                         labels
                         (label-exp-label dest))))
             (lambda () (set-contents! pc insts))))
          ((register-exp? dest)
           (let ((reg (get-register
                       machine
                       (register-exp-reg dest))))
             (lambda ()
               (set-contents! pc (get-contents reg)))))
          (else (error "Bad GOTO instruction: ASSEMBLE"
                       inst)))))
(define (goto-dest goto-instruction)
  (cadr goto-instruction))
\end{scheme}

\subsubsection*{他の命令}

スタック命令の\code{save}と\code{restore}は単純にスタックを指定したレジスタと共に
用いて、\code{pc}を進めます。

\begin{scheme}
(define (make-save inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (push stack (get-contents reg))
      (advance-pc pc))))
(define (make-restore inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (set-contents! reg (pop stack))
      (advance-pc pc))))
(define (stack-inst-reg-name stack-instruction)
  (cadr stack-instruction))
\end{scheme}

\noindent
\code{make\-/perform}で扱われる最後の命令型は実行されるべきアクションのための実行手続を
生成します。シミュレーション時にこのアクション手続が実行され\code{pc}は進められます。

\begin{scheme}
(define (make-perform inst machine labels operations pc)
  (let ((action (perform-action inst)))
    (if (operation-exp? action)
        (let ((action-proc
               (make-operation-exp
                action machine labels operations)))
          (lambda () (action-proc) (advance-pc pc)))
        (error "Bad PERFORM instruction: ASSEMBLE" inst))))
(define (perform-action inst) (cdr inst))
\end{scheme}

\subsubsection*{部分式の実行手続}

\code{reg}, \code{label}, または\code{const}式の値はレジスタへの代入(\code{make\-/assign})のため、
または演算命令の入力(下記の\code{make\-/operation\-/exp})のために必要になるかもしれません。
以下の手続はこれらの式のための値をシミュレーションの間に生成するための実行手続を
生成します。

\begin{scheme}
(define (make-primitive-exp exp machine labels)
  (cond ((constant-exp? exp)
         (let ((c (constant-exp-value exp)))
           (lambda () c)))
        ((label-exp? exp)
         (let ((insts (lookup-label
                       labels
                       (label-exp-label exp))))
           (lambda () insts)))
        ((register-exp? exp)
         (let ((r (get-register machine
                                (register-exp-reg exp))))
           (lambda () (get-contents r))))
        (else
         (error "Unknown expression type: ASSEMBLE" exp))))
\end{scheme}

\noindent
\code{reg}, \code{label}, \code{const}式の構文は以下により決定されます。

\begin{scheme}
(define (register-exp? exp) (tagged-list? exp 'reg))
(define (register-exp-reg exp) (cadr exp))
(define (constant-exp? exp) (tagged-list? exp 'const))
(define (constant-exp-value exp) (cadr exp))
(define (label-exp? exp) (tagged-list? exp 'label))
(define (label-exp-label exp) (cadr exp))
\end{scheme}

\noindent
\code{assign}, \code{perform}, \code{test}命令は(\code{op}式により指定される)機械の演算命令の
(\code{reg}と\code{const}式により指定される)いくつかのオペランドへの適用を含むかも
しれません。以下の手続は``演算命令式''---命令からの演算命令とオペランドの式を
含むリスト---に対する実行手続を生成します。

\begin{scheme}
(define (make-operation-exp exp machine labels operations)
  (let ((op (lookup-prim (operation-exp-op exp)
                         operations))
        (aprocs
         (map (lambda (e)
                (make-primitive-exp e machine labels))
              (operation-exp-operands exp))))
    (lambda ()
      (apply op (map (lambda (p) (p)) aprocs)))))
\end{scheme}

\noindent
演算命令式の構文は以下により決定されます。

\begin{scheme}
(define (operation-exp? exp)
  (and (pair? exp) (tagged-list? (car exp) 'op)))
(define (operation-exp-op operation-exp)
  (cadr (car operation-exp)))
(define (operation-exp-operands operation-exp)
  (cdr operation-exp))
\end{scheme}

\noindent
演算命令式の処理が\link{Section 4.1.7}の評価機において各オペランドに対して実行手続を生成したことにおいて
\code{analyze\-/application}手続による手続の適用の処理にとても似ていることに注意して下さい。
シミュレーション時に、オペランド手続を呼び、結果となる値に対して演算をシミュレートする
Scheme手続を適用します。シミュレーション手続は演算命令の名前を機械の演算命令テーブルから
検索することで見つかります。

\begin{scheme}
(define (lookup-prim symbol operations)
  (let ((val (assoc symbol operations)))
    (if val
        (cadr val)
        (error "Unknown operation: ASSEMBLE"
               symbol))))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.9}Exercise 5.9:}
上記の機械の演算命令の取扱はそれらにラベル、定数、レジスタの中身上での演算を可能にする。
式を処理する手続を変更し、演算命令がレジスタと定数のみに対して使用できるような条件を
強制するようにせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.10}Exercise 5.10:}
レジスタマシンの命令に新しい構文を設計し、シミュレータを変更してその新しい構文を使用せよ。
シミュレータの内、この節の構文手続以外を変更せずにあなたの新しい構文を実装することができるだろうか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.11}Exercise 5.11:}
\link{Section 5.1.4}で\code{save}と\code{restore}を導入した時、以下の順の様に最後に保存した物ではない
レジスタに戻した場合に何が起こるのかは指定しなかった。

\begin{scheme}
(save y)  (save x)  (restore y)
\end{scheme}


\code{restore}の意味に対してはいくつかの妥当な可能性が存在する。

\begin{enumerate}[a]

\item
\code{(restore y)}はスタック上に最後に保存された値を、どのレジスタからその値が来たのか
関係無しに\code{y}に入れる。これが私達のシミュレータの振舞である。この振舞の利点の
活用法を示すため、\link{Section 5.1.4}のフィボナッチマシンから1つ命令を削減して見せよ。(\link{Figure 5.12})

\item
\code{(restore y)}はスタック上に最後に保存された値を\code{y}に入れる。しかしその
値が\code{y}から保存された場合のみである。そうでなければエラーを発する。
シミュレータを変更してこのように振る舞うようにせよ。\code{save}を変更して
スタック上に値と共にレジスタ名を保存しなければならない。

\item
\code{(restore y)}は\code{y}の後に他のどのレジスタが保存され、取り出されていなくても
最後に\code{y}から保存した値を\code{y}に入れる。シミュレータをこのように振る舞うように変更せよ。
分離されたスタックを各レジスタに関連付けする必要がある。また\code{initialize\-/stack}命令に
全てのレジスタのスタックを初期化させなければならない。

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.12}Exercise 5.12:}
シミュレータは与えられたコントローラと共に機械を実装するために必要とされるデータパスを
決定することを手助けするために利用することが可能である。アセンブラを拡張し以下の情報を
マシンモデルに格納せよ。

\begin{itemize}

\item
全ての命令のリストを重複を削除し、命令の型でソートする(\code{assign}, \code{goto}等)

\item
エントリポイントを持つのに使用されたレジスタの(重複の無い)リスト。(これらは
\code{goto}命令で参照されたレジスタである)

\item
\code{save}または\code{restore}されたレジスタの(重複の無い)リスト

\item
各レジスタに対し、代入元の(重複の無い)リスト。(例えば\link{Figure 5.11}の階乗マシンの
レジスタ\code{val}の入力元は\code{(const 1)}と\code{((op *) (reg n) (reg val))}).

\end{itemize}


メッセージパッシングの機械へのインターフェイスを拡張し、この新しい情報へのアクセスを提供せよ。
あなたの分析器をテストするために\link{Figure 5.12}のフィボナッチマシンを定義し、
構築されたリストを試験せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.13}Exercise 5.13:}
シミュレータを変更することで、\code{make\-/machine}に対する引数としてレジスタのリストを
要求するのではなく、コントローラシーケンスを使用して機械がどんなレジスタを持つのか
決定するようにせよ。\code{make\-/machine}の中でレジスタを事前に獲得しておく代わりに、
命令のアセンブリ時の間に初めて現れた時に1つづつレジスタを獲得するようにせよ。
\end{quote}

\subsection{機械のパフォーマンスの監視}
\label{Section 5.2.4}

シミュレーションは提案された機械設計の正しさを確認するためだけではなく、
機械のパフォーマンスを計るためにも便利です。例えば、私達のシミュレータに演算中に
使用されるスタック命令の数を計る``メーター''を導入することができます。これを行うためには、
シミュレーションを行うスタックを変更しスタック上にレジスタが保存された回数とスタックが
到達した最大の深さを追跡するにし、スタックのインターフェイスにメッセージを追加し
以下のように統計を表示するようにします。また\code{make\-/new\-/machine}内の\code{the\-/ops}を以下の様に
初期化することで、基本的なマシンモデルにスタックの統計を表示する命令を追加します。

\begin{scheme}
(list (list 'initialize-stack
            (lambda () (stack 'initialize)))
      (list 'print-stack-statistics
            (lambda () (stack 'print-statistics))))
\end{scheme}

\noindent
以下が新しい版の\code{make\-/stack}です。

\begin{scheme}
(define (make-stack)
  (let ((s '())
        (number-pushes 0)
        (max-depth 0)
        (current-depth 0))
    (define (push x)
      (set! s (cons x s))
      (set! number-pushes (+ 1 number-pushes))
      (set! current-depth (+ 1 current-depth))
      (set! max-depth (max current-depth max-depth)))
    (define (pop)
      (if (null? s)
          (error "Empty stack: POP")
          (let ((top (car s)))
            (set! s (cdr s))
            (set! current-depth (- current-depth 1))
            top)))
    (define (initialize)
      (set! s '())
      (set! number-pushes 0)
      (set! max-depth 0)
      (set! current-depth 0)
      'done)
    (define (print-statistics)
      (newline)
      (display (list 'total-pushes  '= number-pushes
                     'maximum-depth '= max-depth)))
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize) (initialize))
            ((eq? message 'print-statistics)
             (print-statistics))
            (else
             (error "Unknown request: STACK" message))))
    dispatch))
\end{scheme}

\noindent
\link{Exercise 5.15}から\link{Exercise 5.19}はレジスタマシンシミュレータに追加できる
他の便利な監視とデバッグの機能を説明します。

\begin{quote}
\heading{\phantomsection\label{Exercise 5.14}Exercise 5.14:}
\link{Figure 5.11}で示された階乗マシンを用いて様々な小さな値\( n \)に対する\( n! \)の
演算に必要とされるpushの数とスタックの最大深さを計れ。データから任意\( n > 1 \)に
対する\( n! \)を求めるのに使用されたpush命令の総数とスタックの最大深度に対する
\( n \)を用いた方程式を決定せよ。それぞれが\( n \)の線形関数であり、従って2つの
定数により決定されることに注意せよ。統計が表示されるために、階乗マシンをスタックを初期化する
命令と統計を表示する命令を拡張しなければならない。また機械を変更することで\( n \)に対する
値を繰り返し読み込み、階乗を求め、結果を表示できるようにしたいと思うかもしれないだろう(我々が
\link{Figure 5.4})で丁度\acronym{GCD}マシンに対して行ったように)。そうすることで繰り返し
\code{get\-/register\-/contents},\code{set\-/register\-/contents!}, \code{start}を起動する必要が無くなる。

\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.15}Exercise 5.15:}
レジスタマシンのシミュレータに\newterm{instruction counting}(\jnewterm{命令数カウンタ})を
追加せよ。これはマシンモデルに対して実行された命令数を追跡させる。マシンモデルの
インターフェイスを拡張し、命令カウンタの値を表示する物とカウンタをゼロにリセットする
新しいメッセージを受け入れるようにせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.16}Exercise 5.16:}
シミュレータを拡張し\newterm{instruction tracing}(\jnewterm{命令トレーサ})を追加せよ。
これは各命令が実行される前に、シミュレータが命令のテキストを表示する。
マシンモデルに対しトレーサをon/offする\code{trace\-/on}と\code{trace\-/off}メッセージを受け入れるようにせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.17}Exercise 5.17:}
\link{Exercise 5.16}の命令トレーサを拡張し命令を表示する前にシミュレータが
コントローラシーケンス内でその命令の直前のラベル表示するにせよ。
命令数カウンタ(\link{Exercise 5.15})に干渉しない方法で行うように注意すること。
シミュレータに必要なラベル情報を維持するようにすることが必要だろう。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.18}Exercise 5.18:}
\link{Section 5.2.1}の\code{make\-/register}手続を変更し、レジスタをトレース可能にせよ。
レジスタがトレースのon、offを行うメッセージを受け入れなければならない。
レジスタがトレースされている時、そのレジスタに対する代入はレジスタの名前、
レジスタの古い値、代入される新しい値が表示されること。マシンモデルへの
インターフェイスを拡張し指定された機械のレジスタに対するトレーサのon、offを
可能にせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.19}Exercise 5.19:}
Alyssa P. Hackerはシミュレータ内に\newterm{breakpoint}(\jnewterm{ブレイクポイント})の機能を
欲しいと思った。それにより彼女の機械設計を手助けするためである。あなたが彼女のために
この機能を導入するために雇用された。彼女はコントローラシーケンス内でシミュレータが
停止する場所を指定し、機械の状態を調査することができるようにして欲しかった。
あなたは以下の手続を実装しようとしている。

\begin{scheme}
(set-breakpoint ~\( \dark \langle\kern0.08em \)~~\var{\dark machine}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark label}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark n}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
これは与えられたラベルの後ろの\( n \)番目の命令の直前にブレイクポイントを設定する。
例えば、

\begin{scheme}
(set-breakpoint gcd-machine 'test-b 4)
\end{scheme}

\noindent
上の式はブレイクポイントを\code{gcd\-/machine}のレジスタ\code{a}への代入の直前にブレイクポイントを
導入する。シミュレータがブレイクポイントに到達する時、ラベルとブレークポイントのオフセットを
表示し、命令の実行を停止しなければなりません。するとAlyssaは\code{get\-/register\-/contents}と
\code{set\-/register\-/contents!}を用いてシミュレートされている機械の状態を操作することが可能になる。
次に彼女は以下を入力することで実行を続行できなければならない。

\begin{scheme}
(proceed-machine ~\( \dark \langle\kern0.08em \)~~\var{\dark machine}~~\( \dark \rangle \)~)
\end{scheme}


また特定のブレイクポイントを以下を用いて削除できなければならない。

\begin{scheme}
(cancel-breakpoint ~\( \dark \langle\kern0.08em \)~~\var{\dark machine}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark label}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark n}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
または全てのブレイクポイントを削除するためには以下を用いる。

\begin{scheme}
(cancel-all-breakpoints ~\( \dark \langle\kern0.08em \)~~\var{\dark machine}~~\( \dark \rangle \)~)
\end{scheme}
\end{quote}

\section{記憶域の割当とガベージコレクション}
\label{Section 5.3}

\link{Section 5.4}ではレジスタマシンとしてのScheme評価機をどのように実装するかを示します。
議論を簡易化するために、私達のレジスタマシンは\newterm{list-structured memory}(\jnewterm{リスト構造メモリ})を
供えていると仮定します。この機械ではリスト構造のデータを操作する命令はプリミティブです。
そのようなメモリが存在するという仮定はSchemeインタプリタの制御の仕組みに集中する場合には
有用な抽象化です。しかしこれは現在のコンピュータの実際のプリミティブなデータ操作の
現実の光景を反映してはいません。Lispシステムがどのように動作するかのより完全な理解を得るためには、
リスト構造がどのように旧来のコンピュータのメモリに互換性のある方法で表現されるかについて
調査しなければなりません。

リスト構造の実装には2つの考慮点が存在します。1つは純粋に表現上の問題です。
Lispのペアによる``箱とポインタ''構造をストレージと典型的なコンピュータのメモリの
アドレス指定能力を用いてどのように表現するか。2つ目の問題は演算が進行するにつれての
メモリ管理に関係します。Lispシステムの動作は決定的に、継続して新しいデータオブジェクトを
作る能力に依存しています。これらは逐次実行されるLisp手続により明示的に作成されるオブジェクトと
同様に、インタプリタ自身により作成される環境や引数リストのような構造も含みます。
持続的な新しいデータオブジェクトの作成は無限の容量でかつ、高速にアドレス指定できるメモリを
持つコンピュータ上では問題を起こさないでしょうが、コンピュータのメモリは有限な量しか
ありません(残念なことに)。Lispシステムは従って無限のメモリという空想をサポートする
\newterm{automatic storage allocation}(\jnewterm{自動記憶域割当})の設備を提供します。
データオブジェクトが既に必要でなくなった時に、それに割り当てられたメモリは自動的に
リサイクルされ新しく構築されるデータオブジェクトに利用されます。そのような自動的な
記憶域割当を提供する多様な技術が存在します。この節で私達が議論する手法は
\newterm{garbage collection}(\jnewterm{ガベージコレクション}、ゴミ拾い)と呼ばれます。



\subsection{ベクタとしてのメモリ}
\label{Section 5.3.1}

伝統的なコンピュータのメモリは小さな部屋の配列だと考えることができます。
各部屋は情報の一片を入れることができます。各部屋は\newterm{address}(\jnewterm{アドレス})または
\newterm{location}(\jnewterm{位置})と呼ばれる個有の名前を持ちます。典型的なメモリシステムは
2つのプリミティブな命令を提供します。1つは指定された位置に格納されたデータを取り出し、
もう1つは指定された位置に新しいデータを割り当てます。メモリアドレスはある部屋の集合に
シーケンシャル(順)なアクセスをサポートするためにインクリメントすることができます。
より一般的には、多くの重要なデータの操作はメモリアドレスをデータして扱うことを要求します。
このデータはメモリ上の位置に格納でき、機械のレジスタ上で操作できなければいけません。
リスト構造の表現はそのような\newterm{address arithmetic}(\jnewterm{アドレス演算})の一つの応用です。

コンピュータメモリをモデル化するためには、\newterm{vector}(\jnewterm{ベクタ})と呼ばれる新しい
種類のデータ構造を用います。抽象的には、ベクタは複合データオブジェクトであり、その
個別の要素が整数の索引を用いて、索引から独立した時間量でアクセスすることができます。\footnote{メモリを
項目のリストとして表現することはできます。しかし、アクセス時間はその場合、索引から独立しません。
リストの\( n \)番目の要素へのアクセスが\( n - 1 \)回の\code{cdr}命令を必要とするためです。}
メモリ操作を説明するために、ベクタを扱うための2つのプリミティブなScheme手続を使用します。

\begin{itemize}

\item
\code{(vector\-/ref <\var{vector}> <\var{n}>)}はベクタの\( n \)番目の要素を返す。

\item
\code{(vector\-/set! <\var{vector}> <\var{n}> <\var{value}>)}はベクタの\( n \)番目の要素に
指定された値を設定する。

\end{itemize}

\noindent
例えば、\code{v}がベクタであるならば、\code{(vector\-/ref v 5)}はベクタ\code{v}の5番目の項目を
取得し、\code{(vector\-/set! v 5 7)}はベクタ\code{v}の5番目の項目の値を7に変更します。\footnote{完全にするには、
ベクタを構築する\code{make\-/vector}命令を指定するべきです。しかし、現在のアプリケーションではベクタを
コンピュータメモリの固定区域をモデル化するためにのみ使用します。}コンピュータメモリに対して、
このアクセスはアドレス演算を用いて、メモリ内のベクタの開始位置を指定する
\newterm{base address}(\jnewterm{ベース(基底)アドレス})とベクタの特定の項目のオフセットを指定する
\newterm{index}(\jnewterm{インデックス}、索引)を組み合わせることで実装することができます。

\subsubsection*{Lispデータの表現}

ベクタを用いてリスト構造メモリに対する基本的なペア構造を実装することができます。
コンピュータメモリが2つのベクタに分割されている所を想像してみましょう。
\code{the\-/cars}と\code{the\-/cdrs}です。私達は次のようにリスト構造を表現します。
ペアに対するポイントは2つのベクタへの索引です。ペアの\code{car}は\code{the\-/cars}に
指定した索引を用いた項目です。そしてペアの\code{cdr}は指定された索引を用いた\code{the\-/cdrs}の
項目です。またペア以外のオブジェクト(例えば数値やシンボル)に対する表現とデータの種類をお互いに見分ける
ための手法も必要になります。これを達成する方法は多数存在しますが、しかしそれらは
全て\newterm{typed pointers}(\jnewterm{型付きポインタ})の使用へと帰します。これはつまり、
``ポインタ''の概念を拡張しデータの型の情報を含めることです。\footnote{これは正確に
\link{Chapter 2}で紹介したジェネリック(総称)な命令を扱うための``タグ付きデータ''と同じ考えです。
ここではしかし、データの型はリストの使用を通して構築されるのでなく、プリミティブな機械レベルにて
含まれます。}データの型はシステムにペアのポインタ(``ペア''データ型とメモリベクタを
指す索引から成り立つ)を他の種類のデータへのポインタ(何らかの他のデータ型とその型を
表現するために利用された何かにより成り立つ)を見分けることを可能にします。
2つのデータオブジェクトはそれらのポインタが全く同じである場合に同じ(\code{eq?})だと
判断されます。\footnote{型情報はLispシステムが実装される機械の詳細に依存して多様な
方法でエンコード(encode、符号化)されるでしょう。Lispプログラムの実行効率はこの選択
がどれだけ明確に行われたかに強く依存します。しかし良い選択のための一般的な設計ルールを
形式化することは難しいことです。型付きポインタを実装する最も簡単な方法は固定長の
ビット集合を各ポインタの中でデータ型をエンコードする\newterm{type field}(\jnewterm{型フィールド})とする様に
割り当てしておくことです。そのような表現を設計するにおいて解決すべき重要な問題は
次を含みます。いくつの型ビットが必要とされるか? ベクタの索引の長さはどれだけ必要か?
どれだけ効率良くプリミティブな機械語命令がポインタの型フィールドの操作に使用できるか?
型フィールドを効率良く扱うための特別なハードウェアを含む機械は\newterm{tagged
architectures}(\jnewterm{タグアーキテクチャ})を持つと言われます。}\link{Figure 5.14}はこの手法を
用いてリスト\code{((1 2) 3 4)}を表現する場合を図示しています。その箱とポインタ図もまた
示されています。私達は文字接頭辞をデータ型情報を示すために使用しています。従って、
ペアに対する索引5を伴なうポインタは\code{p5}と示されます。空リストはポインタ\code{e0}で示されます。
そして数値4へのポインタは\code{n4}として示されます。箱とポインタ図において各ペアの左隅に
ペアの\code{car}と\code{cdr}がどこに格納されるかを指定するベクタの索引を表示しました。

数値へのポインタ、例えば\code{n4}は数値データを示す型と実際の数値4の表現から成り立つでしょう。\footnote{この
数値の表現上の決断はポインタの等価性をテストする\code{eq?}が数値の等値性の試験に使用できるか
どうかを決定します。もしポインタが数値それ自身を含む場合、等しい数値は同じポインタを持ちます。
しかしもしポインタが数値が格納される位置の索引を持つ場合、私達が同じ数を複数の位置に
格納しないことに注意しない場合に限り等しい数値が同じポインタになることが保証されます。}
単一のポインタのために獲得された固定長のメモリの中で表現されるには大き過ぎる数値を扱うためには、
独特な\newterm{bignum}(\jnewterm{ビッグナンバー})データ型を使うことができるでしょう。このためのポインタは
格納される数値の部分が格納されるリストを指定します。\footnote{これは丁度数値を数字の列として
書くのに似ています。ただし各``桁''が0から単一のポインタに格納できる最大の数の間になることが
異なります。}

\begin{figure}[tb]
\phantomsection\label{Figure 5.14}
\centering
\begin{comment}
\heading{Figure 5.14:} Box-and-pointer and memory-vector representations of the list \code{((1 2) 3 4)}.

\begin{example}
               +---+---+               +---+---+    +---+---+
((1 2) 3 4) -->| * | *-+-------------->| * | *-+--->| * | / |
               +-|-+---+               +-|-+---+    +-|-+---+
              1  |                    2  |         4  |
                 V                       V            V
               +---+---+    +---+---+  +---+        +---+
               | * | *-+--->| * | / |  | 3 |        | 4 |
               +-|-+---+    +-|-+---+  +---+        +---+
              5  |         7  |
                 V            V
               +---+        +---+
               | 1 |        | 2 |
               +---+        +---+

   Index   0    1    2    3    4    5    6    7    8    ...
         +----+----+----+----+----+----+----+----+----+----
the-cars |    | p5 | n3 |    | n4 | n1 |    | n2 |    | ...
         +----+----+----+----+----+----+----+----+----+----
the-cdrs |    | p2 | p4 |    | e0 | p7 |    | e0 |    | ...
         +----+----+----+----+----+----+----+----+----+----
\end{example}
\end{comment}
\includegraphics[width=91mm]{fig/chap5/Fig5.14a.pdf}
\begin{quote}
\heading{Figure 5.14:} リスト\code{((1 2) 3 4)}の``箱とポインタ''とメモリベクタの表現
\end{quote}
\end{figure}

\noindent
シンボルはその表示内容を形成する文字の列を指定する型付きポインタとして表現されることが
できるでしょう。この列はLispのreaderにより、最初に入力の中の文字列に出くわした時に
構築されます。2つのシンボルのインスタンスが\code{eq?}により``同じ''シンボルであると
認識されて欲しいことと、\code{eq?}にポインタの等価性のための簡単なテストになって欲しいこと
から、もしreaderが同じ文字列を2回見た場合、(同じ文字列に対する)同じポインタを両方の
出現に対して表現するために利用することを保証しなければなりません。これを達成するためには、
readerは伝統的に\newterm{obarray}(\jnewterm{オブジェクト配列})と呼ばれる出会った全てのシンボルの
表を管理します。readerが文字列に遭遇しシンボルを構築しようとする時、obarrayをチェックし
同じ文字列を以前に見ていないか確認します。もし初見であれば、文字列を用いて新しいシンボル
(新しい文字列に対する型付きポインタ)を構築し、このポインタをobarrayに挿入します。
もしreaderが既にその文字列を見ていれば、obarrayに格納されているシンボルのポインタを返します。
この文字列を一意なポインタで置き換える処理はシンボルの\newterm{interning}(\jnewterm{抑留})と呼ばれます。

\subsubsection*{プリミティブなリスト命令の実装}

上記の表現の構想を与えられた時に、レジスタマシンの各``プリミティブ''なリスト命令を
複数のプリミティブなベクタ命令で置き換えることができます。2つのレジスタ\code{the\-/cars}と
\code{the\-/cdrs}を用いてメモリベクタを特定し、\code{vector\-/ref}と\code{vector\-/set!}がプリミティブな
命令として有効であると仮定します。またポインタ上の演算命令(例えばポインタをインクリメントする、
ペアのポインタを用いてベクタを索引付けする、または2つの数値を足す)は型付きポインタの
索引部分しか利用しません。

\noindent
例えば、次の命令をサポートするレジスタマシンをその下の条件の下で作成することができます。

\begin{scheme}
(assign ~\( \dark \langle \)~~\( \dark reg_1 \)~~\( \dark \rangle \)~ (op car) (reg ~\( \dark \langle \)~~\( \dark reg_2 \)~~\( \dark \rangle \)~))
(assign ~\( \dark \langle \)~~\( \dark reg_1 \)~~\( \dark \rangle \)~ (op cdr) (reg ~\( \dark \langle \)~~\( \dark reg_2 \)~~\( \dark \rangle \)~))
\end{scheme}

\noindent
上の命令のそれぞれに対しこれらが実装されているとします。

\begin{scheme}
(assign ~\( \dark \langle \)~~\( \dark reg_1 \)~~\( \dark \rangle \)~ (op vector-ref) (reg the-cars) (reg ~\( \dark \langle \)~~\( \dark reg_2 \)~~\( \dark \rangle \)~))
(assign ~\( \dark \langle \)~~\( \dark reg_1 \)~~\( \dark \rangle \)~ (op vector-ref) (reg the-cdrs) (reg ~\( \dark \langle \)~~\( \dark reg_2 \)~~\( \dark \rangle \)~))
\end{scheme}

\noindent
以下の命令は、

\begin{scheme}
(perform (op set-car!) (reg ~\( \dark \langle \)~~\( \dark reg_1 \)~~\( \dark \rangle \)~) (reg ~\( \dark \langle \)~~\( \dark reg_2 \)~~\( \dark \rangle \)~))
(perform (op set-cdr!) (reg ~\( \dark \langle \)~~\( \dark reg_1 \)~~\( \dark \rangle \)~) (reg ~\( \dark \langle \)~~\( \dark reg_2 \)~~\( \dark \rangle \)~))
\end{scheme}

\noindent
次のように実装されます。

\begin{scheme}
(perform
 (op vector-set!) (reg the-cars) (reg ~\( \dark \langle \)~~\( \dark reg_1 \)~~\( \dark \rangle \)~) (reg ~\( \dark \langle \)~~\( \dark reg_2 \)~~\( \dark \rangle \)~))
(perform
 (op vector-set!) (reg the-cdrs) (reg ~\( \dark \langle \)~~\( \dark reg_1 \)~~\( \dark \rangle \)~) (reg ~\( \dark \langle \)~~\( \dark reg_2 \)~~\( \dark \rangle \)~))
\end{scheme}

\noindent
\code{cons}は未使用の索引を割り当て、\code{cons}の引数を\code{the\-/cars}と\code{the\-/cdrs}の中で
索引付けられたベクタの位置に格納します。私達は特別なレジスタ、\code{free}が存在し、
常に次に使用可能な索引を持つペアポインタを保つと仮定します。そしてそのポインタの
索引部分をインクリメントすることで次の空き位置を探すことができます。\footnote{空きの
記憶域を探す他の方法も存在します。例えば、全ての未使用のペアをリンクして
\newterm{free list}(\jnewterm{空きリスト})にすることもできたでしょう。私達の空き位置は連続的
(従ってポインタをインクリメントすることでアクセス可能であるため)です。なぜなら
私達が圧縮GCを用いているためです。また\link{Section 5.3.2}も参照して下さい。}例えば、以下の命令は

\begin{scheme}
(assign ~\( \dark \langle \)~~\( \dark reg_1 \)~~\( \dark \rangle \)~ (op cons) (reg ~\( \dark \langle \)~~\( \dark reg_2 \)~~\( \dark \rangle \)~) (reg ~\( \dark \langle \)~~\( \dark reg_3 \)~~\( \dark \rangle \)~))
\end{scheme}

\noindent
次の一連のベクタ命令として実装されます。\footnote{これは本質的に\link{Section 3.3.1}で説明した\code{set\-/car!}と
\code{set\-/cdr!}を用いた\code{cons}の実装です。その実装内で使用された命令\code{get\-/new\-/pair}は
ここでは\code{free}ポインタにより実現されています。}

\begin{scheme}
(perform
 (op vector-set!) (reg the-cars) (reg free) (reg ~\( \dark \langle \)~~\( \dark reg_2 \)~~\( \dark \rangle \)~))
(perform
 (op vector-set!) (reg the-cdrs) (reg free) (reg ~\( \dark \langle \)~~\( \dark reg_3 \)~~\( \dark \rangle \)~))
(assign ~\( \dark \langle \)~~\( \dark reg_1 \)~~\( \dark \rangle \)~ (reg free))
(assign free (op +) (reg free) (const 1))
\end{scheme}

\noindent
以下の\code{eq?}命令は

\begin{scheme}
(op eq?) (reg ~\( \dark \langle \)~~\( \dark reg_1 \)~~\( \dark \rangle \)~) (reg ~\( \dark \langle \)~~\( \dark reg_2 \)~~\( \dark \rangle \)~)
\end{scheme}

\noindent
単純にレジスタ内の全ての項目の等価性をテストします。そして
\code{pair?}, \code{null?}, \code{symbol?}, \code{number?}等のような述語は型フィールドのみを
確認する必要があります。

\subsubsection*{スタックの実装}

私達のレジスタマシンはスタックを用いますが、ここでは特に特別なことを行う必要がありません。
スタックはリストを用いてモデル化することができるためです。スタックは保存した値のリストと
することができ、特別なレジスタ\code{the\-/stack}により指し示されます。従って\code{
(save <\var{reg}>)}は以下のように実装することができます。

\begin{scheme}
(assign the-stack (op cons) (reg ~\( \dark \langle \)~~\var{\dark reg}~~\( \dark \rangle \)~) (reg the-stack))
\end{scheme}

\noindent
同様に、\code{(restore <\var{reg}>)}は次のように実装することができます。

\begin{scheme}
(assign ~\( \dark \langle \)~~\var{\dark reg}~~\( \dark \rangle \)~ (op car) (reg the-stack))
(assign the-stack (op cdr) (reg the-stack))
\end{scheme}

\noindent
そして\code{(perform (op initialize\-/stack))}は以下のように実装することができます。

\begin{scheme}
(assign the-stack (const ()))
\end{scheme}

\noindent
これらの命令は上で与えられたベクタ命令を用いてさらに伸展されます。しかし、伝統的な計算機
アーキテクチャにおいてはスタックを別のベクタとして割り当てることは通常は好都合です。
そうすれば、スタックにpushやpopを行うことはベクタに対する索引をインクリメント、
デクリメントすることにより達成することができます。

\begin{quote}
\heading{\phantomsection\label{Exercise 5.20}Exercise 5.20:}
以下の式から生成されるリスト構造の表現と(\link{Figure 5.14}にあるような)メモリ-ベクタ表現の
箱とポインタ図を描け。

\begin{scheme}
(define x (cons 1 2))
(define y (list x x))
\end{scheme}

\noindent
ただし、\code{free}ポインタの初期値は\code{p1}とする。\code{free}の最終的な値は何か?
どんなポインタが\code{x}と\code{y}の値を表現するか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.21}Exercise 5.21:}
以下の手続のためのレジスタマシンを実装せよ。リスト構造のメモリ命令は機械のプリミティブと
して使用可能だと仮定せよ。

\begin{enumerate}[a]

\item
再帰\code{count\-/leaves}:

\begin{scheme}
(define (count-leaves tree)
  (cond ((null? tree) 0)
        ((not (pair? tree)) 1)
        (else (+ (count-leaves (car tree))
                 (count-leaves (cdr tree))))))
\end{scheme}

\item
明示的なカウンタを用いた再帰\code{count\-/leaves}

\begin{scheme}
(define (count-leaves tree)
  (define (count-iter tree n)
    (cond ((null? tree) n)
          ((not (pair? tree)) (+ n 1))
          (else
           (count-iter (cdr tree)
                       (count-iter (car tree) 
                                   n)))))
  (count-iter tree 0))
\end{scheme}
\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.22}Exercise 5.22:}
\link{Section 3.3.1}の\link{Exercise 3.12}は2つのリストを接続し1つの新しいリストを形成する\code{append}手続と、
2つのリストを一緒に繋ぎ合わせる\code{append!}手続を紹介した。これらの手続それぞれを実装するレジスタ
マシンを設計せよ。リスト構造のメモリ命令はプリミティブな命令として使用可能と前提せよ。
\end{quote}

\subsection{無限のメモリの幻想を維持する}
\label{Section 5.3.2}

\link{Section 5.3.1}で概観した表現手法はリスト構造の実装上の問題を解決しましたが、無限の容量の
メモリを持っている場合という条件付きでした。実際のコンピュータではいつかは新しいペア
を構築するための空き容量を使い切ってしまいます。\footnote{これはいつかは正しくはなく
なるかもしれません。なぜならメモリが十分に大きくなればコンピュータの生存時間の間には
空きメモリを使い切ることは不可能になるかもしれないからです。例えば一年は
\( 3\cdot10^{\hbox{13}} \)マイクロ秒ですから、もし1マイクロ秒に1回\code{cons}を行うので
あれば、30年間はメモリを使い切ることのないコンピュータを構築するのには
約\( 10^{\hbox{15}} \)セルのメモリを必要とします。それだけのメモリは今日の標準では話にならない程大きく
見えますが、しかし物理的に不可能ではありません。一方で、プロセッサはより速くなりつつあり
未来のコンピュータは数多くのプロセッサを並列に単一のメモリ上で作動するかもしれません。
従って私達の前提よりもよい早くメモリを使い切ることが可能かもしれません。}しかし、
典型的な演算により生成されるペアの多くは中間結果を保つためだけに使用されます。これらの
結果がアクセスされた後には、それらのペアはもう必要ありません。それらは\newterm{garbage}(\jnewterm{ゴミ})です。
例えば、以下の演算は

\begin{scheme}
(accumulate + 0 (filter odd? (enumerate-interval 0 n)))
\end{scheme}

\noindent
2つのリストを構築します。enumaration(列挙)と列挙をフィルタリングした結果です。
accumulation(集積)が完了した時に、これらのリストはもう必要ありません。そして
割り当てられたメモリは返還要求できます。もし全てのゴミを定期的に回収する準備を
行えるのであれば、そしてもしこれが新しいペアを構築するのと大体同じ比率でメモリを
リサイクルすることになれば、無限の容量のメモリが存在するという錯覚を維持することが
できます。

ペアをリサイクルするためには、どの割り当てられたペアが必要でないか(それらの中身が
その後将来の演算に影響しないという意味で)決定する方法を持たねばなりません。
これを達成するために調査する手法は\newterm{garbage collection}(\jnewterm{ガベージコレクション}、GC)として
知られています。ガベージコレクションはLispの逐次実行における任意の時点で、将来の
演算に影響を与えることができるオブジェクトは現状で機械のレジスタ内に存在する
ポインタにより辿り着くことができるオブジェクトのみであるという観察結果に基いています。\footnote{ここでは
スタックは\link{Section 5.3.1}で説明されたリストとして表現されていると仮定しています。そのため
スタック上の項目はスタックレジスタ内のポインタを通してアクセスすることができます。}
そのようにアクセスできないどのメモリセルもリサイクルして良いでしょう。

ガベージコレクションを実行する方法は数多く存在します。ここで調査する手法は
\newterm{stop-and-copy}と呼ばれます。基本的な考えはメモリを2つに割ります。
``ワーキングメモリ''と``空きメモリ''です。\code{cons}がペアを構築する時、ワーキングメモリに
割り当てます。ワーキングメモリに空きが無い時、ワーキングメモリ内の使い道のある全てのペアを探し出し、
これらをフリーメモリ内の連続した位置にコピーすることでガベージコレクションを実行します。
(使い道のあるペアは機械のレジスタから始めて、全ての\code{car}と\code{cdr}のポインタを
追跡することにより探し出します)。ゴミはコピーしないため、推定上、新しいペアを
割り当てるための利用できる追加の空きメモリが存在するはずです。加えて、ワーキング
メモリ内の全てが必要ありません。その中の使い道のあるペアはコピーされています。
従ってワーキングメモリと空きメモリの役割を交換すれば、処理を続けることができます。
新しいペアは新しいワーキングメモリ(空きメモリだった物)の中に割り当てられます。
これがいっぱいになったなら、使い道のあるペアを新しい空きメモリ(ワーキングメモリだったもの)の
中にコピーできます。\footnote{
この考えはMinsky(ミンスキー)により発明され、\acronym{MIT}研究所の
電子工学ラボのPDP-1に対するLispの実装の一部として実装されました。
\link{Fenichel and Yochelson (1969)}によりMultics時分割システムのLisp実装で使用するために、
さらに開発が進められました。後に、\link{Baker (1978)}はこの手法の``リアルタイム''版を開発しました。
これはガベージコレクションの間に演算を停止する必要がありません。Bakerの考えは
Hewitt, Lieberman, Moonにより拡張され(\link{Lieberman and Hewitt 1983}参照)、
ある構造はvolatile(揮発性)であり、別の構造はより永続的であるといった事実を
活用する様になりました。

一般に利用される代替的なガベージコレクションの技術は\newterm{mark-sweep}(\jnewterm{マーク アンド スイープ})の
手法です。これは回帰のレジスタからアクセス可能な全ての構造の追跡と辿り着く各ペアへのマーキングから
成り立ちます。次に全てのメモリを走査し、マークの無い全てのメモリはゴミとして``掃き出し''、
再使用可能とされます。マーク アンド スイープの十分な議論は\link{Allen 1978}の中に見つけられます。

Minsky-Fenichel-Yochelsonアルゴリズムは巨大なメモリシステムに対する使用における
支配的なアルゴリズムです。メモリの使い道のある部分のみを調査するためです。
これはスイープの段階で全てのメモリを確認しなければならないmark-and-sweepとは対照的です。
stop-and-copyの2つ目の強みは\newterm{compacting}(\jnewterm{圧縮})ガベージコレクタであることです。
つまり、ガベージコレクションの段階の終わりには使い道のあるデータは連続したメモリ位置に
移動され、全てのゴミペアは圧縮の仮定で外に出されます。このことが仮想メモリを使用する
機械におけるパフォーマンス上の考慮において非常に重要と成り得ます。仮想メモリを使用する
機械は広範囲に分離されたメモリアドレスへのアクセスに余計なページング処理が必要となるかも
しれません。
}

\subsubsection*{stop-and-copyガベージコレクタの実装}

今から私達はレジスタマシン言語を用いてstop-and-copyアルゴリズムをより詳細に
記述します。私達は\code{root}と呼ばれるレジスタが存在し、ある構造体へのポインタを
保持し、そのポインタから最終的には全てのアクセス可能なデータを指し示すことが
できるという前提を行います。これはガベージコレクションを行う直前に全てのレジスタの
中身を事前に割り当てられたリストに格納し、\code{root}により指し示させることで
準備が行えます。\footnote{このレジスタのリストは記憶域割当システムのレジスタ---\code{root},
\code{the\-/cars}, \code{the\-/cdrs}, それにこの節で紹介される他のレジスタは含みません。}
私達はまた現在のワーキングメモリに加えて、使い道のあるデータをコピーできる空きメモリが
存在すると前提します。現在のワーキングメモリはベースアドレスが\code{the\-/cars}と\code{the\-/cdrs}と
呼ばれるレジスタに格納されるベクタから成り立ち、そして空きメモリは同様に
\code{new\-/cars}と\code{new\-/cdrs}と呼ばれるレジスタに格納されます。

ガベージコレクションは現在のワーキングメモリ内の空きセルが枯渇した時に引き起こされます。
それはつまり、\code{cons}命令が\code{free}ポインタをメモリベクタの終端を越えてインクリメント
しようとした時です。ガベージコレクションの処理が完了した時、\code{root}ポインタは
新しいメモリの中を指し示し、\code{root}からアクセス可能な全てのオブジェクトは新しいメモリに
移動されています。そして\code{free}ポインタは新しいメモリ内の新しいペアを割り当てられる
次の位置を示します。加えて、ワーキングメモリと新しいメモリの役割が交換されます。
新しいペアは\code{free}により指し示される位置から始まる新しいメモリ内に構築され、
(以前の)ワーキングメモリは次のガベージコレクションに対する新しいメモリとして
使用可能となります。\link{Figure 5.15}はガベージコレクション直前、直後のメモリの
割り振りを示します。

\begin{figure}[tp]
\phantomsection\label{Figure 5.15}
\centering
\begin{comment}
\begin{quote}
\heading{Figure 5.15:} Reconfiguration of memory by the garbage-collection process.

\begin{example}
             Just before garbage collection

         +------------------------------------+
the-cars |                                    | working
         | mixture of useful data and garbage | memory
the-cdrs |                                    |
         +------------------------------------+
                                            ^
                                            | free

         +------------------------------------+
new-cars |                                    | free   
         |            free memory             | memory
new-cdrs |                                    |
         +------------------------------------+

             Just after garbage collection

         +------------------------------------+
new-cars |                                    | new  
         |          discarded memory          | free  
new-cdrs |                                    | memory
         +------------------------------------+

         +------------------+-----------------+
the-cars |                  |                 | new
         |   useful data    |    free area    | working
the-cdrs |                  |                 | memory
         +------------------+-----------------+
                              ^
                              | free
\end{example}
\end{quote}
\end{comment}
\includegraphics[width=91mm]{fig/chap5/Fig5.15a.pdf}
\begin{quote}
\heading{Figure 5.15:} ガベージコレクションプロセスによるメモリの再構成
\end{quote}
\end{figure}

\noindent
ガベージコレクション処理の状態は2つのポインタを管理することによりコントロールされています。
\code{free}と\code{scan}です。これらは新しいメモリの開始位置を指し示すように初期化されます。
アルゴリズムは\code{root}により指し示されるペアの新しいメモリの開始位置への再配置から開始されます。
ペアはコピーされ、\code{root}ポインタは新しい位置を指すように調整されます。そして
\code{free}ポインタがインクリメントされます。併せて、ペアの古い位置はその中身が移動された
ことを示すマークが付けられます。このマーキングは次のように行われます。\code{car}の位置には
これが既に移動されたオブジェクトであることを示す特別なタグを置きます。(そのような
オブジェクトは伝統的に\newterm{broken heart}(失恋)と呼ばれます。)\footnote{\emph{broken heart}と
いう用語はDavid Cresseyにより作られました。彼は1970年代初期の間に\acronym{MIT}で開発された
Lispの方言、MDLのためにガベージコレクタを書きました。}\code{cdr}の位置には
\newterm{forwarding address}(\jnewterm{転送先})を置きます。これはオブジェクトの移動先の位置を指し示します。

\code{root}の再配置の後に、ガベージコレクタは基本となるサイクルに入ります。
アルゴリズムの各ステップにおいて、\code{scan}ポインタ(初期値として再配置後の\code{root}を指す)は、
新しいメモリに移動されたがその\code{car}と\code{cdr}のポインタが依然として古いメモリ内の
オブジェクトを参照しているペアを指します。これらのオブジェクトはそれぞれが再配置され、
\code{scan}ポインタはインクリメントされます。オブジェクト(例えば走査しているペアの\code{car}ポインタにより
指されたオブジェクト)を再配置するためにはそのオブジェクトが既に移動されていないかを
(そのオブジェクトの\code{car}の位置内にbroken-heartタグが存在するこにより示されていないか)確認します。
もしオブジェクトがまだ移動されていなければ、それを\code{free}により示される位置にコピーし、
\code{free}を更新し、オブジェクトの古い位置にbroken-heartを設定し、そのオブジェクトへの
ポインタを(この礼では、走査しているペアの\code{car}ポインタを)更新し、新しい位置を指すようにします。
もしオブジェクトが既に移動されている場合には、(broken heartの\code{cdr}の位置に見つかる)その移動先は
走査中のペアのポインタに置き換えられます。最終的には、\code{scan}
ポインタが\code{free}ポインタを追い越す時点まで、全てのアクセス可能なオブジェクトは移動され、
精査されます。そして処理は停止します。

stop-and-copyアルゴリズムをレジスタマシンの命令列として記述することができます。
オブジェクトの再配置の基本的なステップは\code{relocate\-/old\-/result\-/in\-/new}と呼ばれるサブルーチンにて
達成されます。このサブルーチンはその引数として再配置するオブジェクトのポインタを\code{old}という名の
レジスタから取得します。これは指定されたオブジェクトを再配置し、(処理の間に\code{free}をインクリメントし)、
再配置されたオブジェクトを指すポインタを\code{new}と呼ばれるレジスタに入れます。
そして\code{relocate\-/continue}レジスタに格納されたエントリポイントへ分岐することで帰ります。
ガベージコレクションを始めるために、このサブルーチンを起動して、\code{free}と\code{scan}を初期化した後に
\code{root}ポインタを再配置します。\code{root}の再配置が完了した時に、\code{new}ポインタを新しい\code{root}と
して導入し、ガベージコレクタのメインループに入ります。

\begin{scheme}
begin-garbage-collection
  (assign free (const 0))
  (assign scan (const 0))
  (assign old (reg root))
  (assign relocate-continue (label reassign-root))
  (goto (label relocate-old-result-in-new))
reassign-root
  (assign root (reg new))
  (goto (label gc-loop))
\end{scheme}

\noindent
ガベージコレクタのメインループでは走査すべきオブジェクトが残っているのか決定しなければ
なりません。これを\code{scan}ポインタが\code{free}ポインタと一致するかどうかを試験することで
行います。もしポインタが等しければ、全てのアクセス可能なオブジェクトの再配置は完了し、
\code{gc\-/flip}へと分岐します。ここは後片付けを行い、割り込みが行われた演算を継続します。
もしまだ走査すべきペアが残っているのであれば、再配置(relocate)のサブルーチンを呼び出し
次のペアの\code{car}を(\code{old}内の\code{car}ポインタを配置することで)再配置します。
\code{relocate\-/continue}レジスタの設定によりサブルーチンは\code{car}ポインタを更新するために
帰ります。

\begin{scheme}
gc-loop
  (test (op =) (reg scan) (reg free))
  (branch (label gc-flip))
  (assign old (op vector-ref) (reg new-cars) (reg scan))
  (assign relocate-continue (label update-car))
  (goto (label relocate-old-result-in-new))
\end{scheme}

\noindent
\code{update\-/car}にて、精査しているペアの\code{car}ポインタを変更します。次にペアの
\code{cdr}を再配置するために向かいます。再配置が完了すると\code{update\-/cdr}に帰ってきます。
再配置と\code{cdr}の更新の後に、そのペアの精査を完了しメインループを継続します。

\begin{scheme}
update-car
  (perform (op vector-set!)
           (reg new-cars)
           (reg scan)
           (reg new))
  (assign old (op vector-ref) (reg new-cdrs) (reg scan))
  (assign relocate-continue (label update-cdr))
  (goto (label relocate-old-result-in-new))

update-cdr
  (perform (op vector-set!)
           (reg new-cdrs)
           (reg scan)
           (reg new))
  (assign scan (op +) (reg scan) (const 1))
  (goto (label gc-loop))
\end{scheme}

\noindent
サブルーチン\code{relocate\-/old\-/result\-/in\-/new}はオブジェクトを次のように再配置します。
もし(\code{old}により指し示される)再配置すべきオブジェクトがペアでないなら、そのオブジェクトへの
同じポインタを変更無しで(\code{new}の中で)返します。(例えば、\code{car}が数値の4であるペアを精査して
いるとします。もし\link{Section 5.3.1}にて説明されているように\code{n4}で\code{car}を表現するのなら、
``再配置された''\code{car}のポインタも依然として\code{n4}であって欲しいと願うはずです)。
そうでなければ、再配置を実行しなければなりません。もしペアの再配置すべき\code{car}の位置に
broken-heartタグを持つのならば、そのペアは実際には既に移動されています。従って
(broken-heartの\code{cdr}の位置から)移動先を取得し、これを\code{new}に入れて返します。
もし\code{old}内のポインタがまだ移動されていないペアを指す場合、そのペアを(\code{free}が指し示す)
新しいメモリの最初の空きセルに移動させ、broken-heartタグと移動先を元の位置に格納することで
broken-heartを設定します。\code{relocate\-/old\-/result\-/in\-/new}はレジスタ\code{oldcr}を用いて
\code{old}により指し示されるオブジェクトの\code{car}または\code{cdr}を保持します。\footnote{ガベージ
コレクタは低レベルの述語\code{pointer\-/to\-/pair?}をリスト構造\code{pair?}命令の代わりに使用します。
実際のシステムでは様々な物がガベージコレクションの目的のためにペアとして扱われるためです。
例えば、\acronym{IEEE}標準に準拠するSchemeシステムでは手続オブジェクトは特別な種類の``ペア''
として実装されても良くこれは述語\code{pair?}は満たしません。シミュレーションの目的には、
\code{pointer\-/to\-/pair?}は\code{pair?}として実装できます。}

\begin{scheme}
relocate-old-result-in-new
  (test (op pointer-to-pair?) (reg old))
  (branch (label pair))
  (assign new (reg old))
  (goto (reg relocate-continue))
pair
  (assign oldcr (op vector-ref) (reg the-cars) (reg old))
  (test (op broken-heart?) (reg oldcr))
  (branch (label already-moved))
  (assign new (reg free)) ~\textrm{; ペアの新しい位置}~
  ~\textrm{;; \code{free}ポインタを更新する}~
  (assign free (op +) (reg free) (const 1))
  ~\textrm{;; \code{car}と\code{cdr}を新しいメモリにコピーする.}~
  (perform (op vector-set!)
           (reg new-cars) (reg new) (reg oldcr))
  (assign oldcr (op vector-ref) (reg the-cdrs) (reg old))
  (perform (op vector-set!)
           (reg new-cdrs) (reg new) (reg oldcr))
  ~\textrm{;; ブロークンハートの構築}~
  (perform (op vector-set!)
           (reg the-cars) (reg old) (const broken-heart))
  (perform
   (op vector-set!) (reg the-cdrs) (reg old) (reg new))
  (goto (reg relocate-continue))
already-moved
  (assign new (op vector-ref) (reg the-cdrs) (reg old))
  (goto (reg relocate-continue))
\end{scheme}

\noindent
ガベージコレクション処理の最後に、メモリの新旧の役割をポインタを交換することにより
交代します。\code{the\-/cars}と\code{new\-/cars}、そして\code{the\-/cdrs}を\code{new\-/cdrs}を交換します。
これで次回メモリが枯渇した時にもう一度ガベージコレクションを行う準備ができます。

\begin{scheme}
gc-flip
  (assign temp (reg the-cdrs))
  (assign the-cdrs (reg new-cdrs))
  (assign new-cdrs (reg temp))
  (assign temp (reg the-cars))
  (assign the-cars (reg new-cars))
  (assign new-cars (reg temp))
\end{scheme}

\section{明示的制御評価機}
\label{Section 5.4}
\link{Section 5.1}では簡単なSchemeプログラムをどのようにレジスタマシンの記述に変形するかについて学びました。
ここではこの変形をより複雑なプログラム上で実行します。\link{Section 4.1.1}--\link{Section 4.1.4}のメタ循環評価機です。
メタ循環評価機はSchemeインタプリタの振舞が手続\code{eval}と\code{apply}と用いてどのように説明できるかを示しました。
この節で開発する\newterm{explicit-control evaluator}(\jnewterm{明示的制御評価機})は評価過程にて使用される
潜在的な手続呼出と引数受け渡しの仕組みがレジスタとスタックの命令を用いてどのように説明できるかを
示します。付け加えて、明示的制御評価機はSchemeインタプリタの実装としての役割を果たすことができ、
従来の計算機の生来の機械語ととてもそっくりな言語で書かれています。この評価機は\link{Section 5.2}のレジスタ
マシンシミュレータにより実行することができます。あるいは、Scheme評価機の機械語実装を構築するための
開始点として使用することができます。またはSchemeの式を評価するための特殊用途の機械にすら使用できるでしょう。
\link{Figure 5.16}はそのようなハードウェア実装を示しています。Schemeの評価機として働くシリコンチップです。
このチップの設計者はこの節の中で説明される評価機に似たレジスタマシンに対するデータパスとコントローラの
仕様から開始しました。そしてIC(integrated-circuit、統合回路)を構築するための設計自動化プログラムを
使用しました。\footnote{このチップとその設計手法についてのより多くの情報については\link{Batali et al. 1982}を
参照して下さい。}

\begin{figure}[tb]
\phantomsection\label{Figure 5.16}
\centering
\begin{comment}
\heading{Figure 5.16:} A silicon-chip implementation of an evaluator for Scheme.

[A photograph of chip layout]

\end{comment}
\includegraphics[width=91mm]{fig/chap5/chip.jpg}
\begin{quote}
\heading{Figure 5.16:} Scheme評価機のシリコンチップ実装
\end{quote}
\end{figure}

\subsubsection*{レジスタと命令}

明示的制御評価機の設計では、私達のレジスタマシンで使用される命令を指定しなければなりません。
私達は\code{quoted?}や\code{make\-/procedure}のような手続を用いることで抽象構文を用いたメタ循環評価機を
説明しました。レジスタマシンの実装においてはこれらの手続を初歩的なリスト構造メモリの命令列に
展開することができました。そしてこれらの命令を私達のレジスタマシン上に実装しました。
しかし、これは私達の評価機の基本的な構造をその詳細によりわかりにくくしながら、とても長くして
しまいます。その表現を明快にするために、レジスタマシンのプリミティブな命令として
\link{Section 4.1.2}で与えられた構文手続と環境を表現するための手続、それに\link{Section 4.1.3}と\link{Section 4.1.4}で与えられた
実行時データを含めることにします。低レベルのマシン語でプログラミングできる、またはハードウェア
にて実装できる評価機の完全な仕様化を行うために、\link{Section 5.3}で説明したリスト構造の実装を用いて
これらの命令をより基本的な命令により置き換えることができるでしょう。

私達のScheme評価機レジスタマシンはスタックと7つのレジスタを含みます。
\code{exp}, \code{env}, \code{val}, \code{continue}, \code{proc}, \code{argl}, \code{unev}です。
\code{exp}は評価される式の保持に仕様され、\code{env}は評価がその中で実行される環境を
持ちます。評価の終わりには、\code{val}が指定された環境における式の評価により
得られた値を保持します。\code{continue}レジスタは\link{Section 5.1.4}で説明されたように
再帰の実装に用いられます。(評価機はそれ自身を再帰的に呼び出す必要があります。
式の評価はその部分式の評価を必要とするためです)。レジスタ\code{proc}, \code{argl}, \code{unev}は
組み合わせの評価に用いられます。

私達はデータパス図を評価機のレジスタと命令がどのように接続されているかを示すために
提供はしません。また機械の命令の完全なリストの提供も行ないません。これらは評価機の
コントローラに暗黙的に存在し、コントローラの詳細が与えられます。



\subsection{明示制御評価機の核}
\label{Section 5.4.1}

評価機の中心的な要素は\code{eval\-/dispatch}で始まる命令列です。これは\link{Section 4.1.1}で説明された
メタ循環評価機の\code{eval}手続に対応します。コントローラが\code{eval\-/dispatch}から開始する時、
\code{exp}により指定された式を、\code{env}により指定された環境にて評価します。
評価が完了した時には、コントローラは\code{continue}に格納されたエントリポイントに飛びます。
その時、\code{val}レジスタが式の値を保持しています。メタ循環の\code{eval}と同様に、
\code{eval\-/dispatch}の構造は評価される式の構文型上の事例分析です。\footnote{私達のコントローラに
おいては、ディスパッチ(dispatch、割り振り)は\code{test}と\code{branch}の命令列として書かれています。
代替法として、データ適従スタイルで書くこともできるでしょう(そして実際のシステムは恐らくそうされて
いるでしょう)。連続したテストの実行の必要を防ぎ、新しい式の型の定義を用意にするためです。
Lispを実行するように設計された機械は恐らく\code{dispatch\-/on\-/type}命令を含むことでしょう。
これはそのようなデータに従った割り振りを効率的に実行します。}

\begin{scheme}
eval-dispatch
  (test (op self-evaluating?) (reg exp))
  (branch (label ev-self-eval))
  (test (op variable?) (reg exp))
  (branch (label ev-variable))
  (test (op quoted?) (reg exp))
  (branch (label ev-quoted))
  (test (op assignment?) (reg exp))
  (branch (label ev-assignment))
  (test (op definition?) (reg exp))
  (branch (label ev-definition))
  (test (op if?) (reg exp))
  (branch (label ev-if))
  (test (op lambda?) (reg exp))
  (branch (label ev-lambda))
  (test (op begin?) (reg exp))
  (branch (label ev-begin))
  (test (op application?) (reg exp))
  (branch (label ev-application))
  (goto (label unknown-expression-type))
\end{scheme}

\subsubsection*{単純な式の評価}

数値と文字列(これらは自己評価です)、変数、クォーテーション、そして\code{lambda}式は
評価するべき部分式がありません。これらのために、評価機は単純に正しい値を\code{val}レジスタに
配置し、\code{continue}により指定されたエントリポイントから実行を継続します。
単純な式の評価は以下のコントローラのコードにより実行されます。

\begin{scheme}
ev-self-eval
  (assign val (reg exp))
  (goto (reg continue))
ev-variable
  (assign 
    val (op lookup-variable-value) (reg exp) (reg env))
  (goto (reg continue))
ev-quoted
  (assign val (op text-of-quotation) (reg exp))
  (goto (reg continue))
ev-lambda
  (assign unev (op lambda-parameters) (reg exp))
  (assign exp (op lambda-body) (reg exp))
  (assign val (op make-procedure)
              (reg unev) (reg exp) (reg env))
  (goto (reg continue))
\end{scheme}

\noindent
\code{ev\-/lambda}がどのように\code{unev}と\code{exp}レジスタを用いてラムダ式のパラメタと
ボディを保持し、\code{env}の中の環境と共に\code{make\-/procedure}命令に引き渡されるのか観察して下さい。

\subsubsection*{手続適用の評価}

手続の適用はオペレータとオペランドを含む組み合わせにより指定します。
オペレータはその値が手続となる部分式であり、オペランドはその値が引数となる部分式で、
その引数に対して手続が適用されねばなりません。メタ循環の\code{eval}は適用をそれ自身を
再帰的に呼び出すことで扱い、組み合わせの各要素を評価し、そして結果を\code{apply}に渡します。
これが実際の手続適用を実行します。明示的制御評価機も同じことを行います。
これらの再帰呼出は\code{goto}命令と共に、スタックを使用して再帰呼出から戻った時に
再格納されるようにレジスタを保存することで実装されます。各呼出の前にどのレジスタが
保存されなければならないのかの確認に注意をしなければなりません。(なぜならこれらの値が
後で必要になるからです)。\footnote{これは重要ですが、アルゴリズムをLispの様な手続型の言語から
レジスタマシンの言語へ翻訳する場合において微妙な点です。必要な物だけを保存することの
代替法として、各再帰呼出の前に全てのレジスタ(\code{val}を除く)を保存することもできます。
これは\newterm{framed-stack}(\jnewterm{スタックフレーム})の統制と呼ばれます。これはうまく行きますが
しかし必要以上のレジスタを保存します。このことはスタック命令が高価であるというシステム内の
懸念点に成り得ます。後に使用される必要のないレジスタの保存はまた使用価値の無いデータを
手放さないことにも成り得ます。これはそうでなければガベージコレクションされ、再使用される
ために領域が解法されたはずです。}

適用の評価はオペレータを評価し手続を生成することから開始します。手続は後に評価された
オペランドに適用されます。オペレータを評価するためには、それを\code{exp}レジスタに
移動させ、\code{eval\-/dispatch}へ飛びます。\code{env}レジスタ内の環境は既にその中でオペレータを
評価するために適切な物になっていますが、それでも\code{env}を保存します。オペランドの評価にも
必要なためです。またオペランドを\code{unev}の中に展開し、スタック上にこれを保存します。
\code{continue}に対し\code{eval\-/dispatch}がオペレータの評価が完了した後に\code{ev\-/appl\-/did\-/operator}にて
resume(再開)できるように設定します。しかし、最初に\code{continue}の古い値は保存します。
これがコントローラに対し適用後にどこから続行するのかを告げるためです。

\begin{scheme}
ev-application
  (save continue)
  (save env)
  (assign unev (op operands) (reg exp))
  (save unev)
  (assign exp (op operator) (reg exp))
  (assign continue (label ev-appl-did-operator))
  (goto (label eval-dispatch))
\end{scheme}

\noindent
オペレータ部分式の評価からの帰還すると、組み合わせのオペランドの評価と、
結果としての引数を\code{argl}に保持されるリストの中への蓄積へと進みます。
最初に未評価のオペランドと環境を戻します。\code{argl}を空リストに初期化します。
そして\code{proc}レジスタにオペレータの評価により生成された手続を割り当てます。
もしオペランドが無ければ、直接\code{apply\-/dispatch}へと進みます。そうでなければ、
\code{proc}をスタックに保存し引数評価ループを開始します。\footnote{
\link{Section 4.1.3}の評価機データ構造の手続に以下の2つの手続を引数リストの操作のために追加します。

\begin{smallscheme}
(define (empty-arglist) '())
(define (adjoin-arg arg arglist) (append arglist (list arg)))
\end{smallscheme}


また追加の構文手続を使用して組み合わせの最後のオペランドであるかのテストを行います。

\begin{smallscheme}
(define (last-operand? ops) (null? (cdr ops)))
\end{smallscheme}
}

\begin{scheme}
ev-appl-did-operator
  (restore unev)                       ~\textrm{; the operands}~
  (restore env)
  (assign argl (op empty-arglist))
  (assign proc (reg val))              ~\textrm{; the operator}~
  (test (op no-operands?) (reg unev))
  (branch (label apply-dispatch))
  (save proc)
\end{scheme}

\noindent
引数評価ループの各サイクルは\code{unev}の中のリストからオペランドを評価し、その結果を\code{argl}の
中に蓄積します。オペランドを評価するために、それを\code{exp}レジスタの中に入れ、
実行が引数蓄積段階から再開できるよう\code{continueを}設定した後に\code{eval\-/dispatch}に飛びます。
しかし、最初に私達はそれまでに(\code{argl}に保持されている)蓄積された引数、環境(\code{env}に維持)、
評価されていない残りのオペランド(\code{unev}が保持)を保存します。最後のオペランドの評価は
特別な場合として扱われ\code{ev\-/appl\-/last\-/arg}により取り扱われます。

\begin{scheme}
ev-appl-operand-loop
  (save argl)
  (assign exp (op first-operand) (reg unev))
  (test (op last-operand?) (reg unev))
  (branch (label ev-appl-last-arg))
  (save env)
  (save unev)
  (assign continue (label ev-appl-accumulate-arg))
  (goto (label eval-dispatch))
\end{scheme}

\noindent
オペランドが評価された時に、その値は\code{argl}にて保持されるリストの中に蓄積されます。
そのオペランドはその後\code{unev}中の未評価オペランドのリストから消され、引数評価が
続行されます。

\begin{scheme}
ev-appl-accumulate-arg
  (restore unev)
  (restore env)
  (restore argl)
  (assign argl (op adjoin-arg) (reg val) (reg argl))
  (assign unev (op rest-operands) (reg unev))
  (goto (label ev-appl-operand-loop))
\end{scheme}

\noindent
最後の引数の評価は異なる扱いを受けます。環境や未評価のオペランドのリストを
\code{eval\-/dispatch}に飛ぶ前に保存する必要がありません。最後のオペランドが評価された後に
それらは必要が無いためです。従って評価から特別なエントリポイント\code{ev\-/appl\-/accum\-/last\-/arg}に
帰ります。これは引数リストを戻し、新しい引数を蓄積し、保存された手続を戻し、適用
を実行するために飛びます。\footnote{最後のオペランドの処理の特別な最適化は
\newterm{evlis tail recursion}(\jnewterm{エブリス末尾再帰})として知られています(\link{Wand 1980}参照)。
最初のオペランドも特別な場合とすれば、私達は引数評価ループをいくらかより効率的良くできたでしょう。
これは\code{argl}の初期化を最初のオペランドの評価の後まで延期することができ、この場合に\code{argl}を
保存することを防げたでしょう。\link{Section 5.5}のコンパイラはこの最適化を実行します。
(\link{Section 5.5.3}の\code{construct\-/arglist}手続と比較して下さい。)}

\begin{scheme}
ev-appl-last-arg
  (assign continue (label ev-appl-accum-last-arg))
  (goto (label eval-dispatch))
ev-appl-accum-last-arg
  (restore argl)
  (assign argl (op adjoin-arg) (reg val) (reg argl))
  (restore proc)
  (goto (label apply-dispatch))
\end{scheme}

\noindent
引数評価ループの詳細はインタプリタが組み合わせのオペランドを評価する順を決定します。(例えば、
左から右や右から左---\link{Exercise 3.8}参照)。この順はメタ循環評価機では決定されません。
メタ循環評価機はその制御構造をその基礎を成し実装を行うSchemeから継承します。\footnote{メタ循環評価機の
オペランドの評価順は\link{Section 4.1.1}の手続\code{list\-/of\-/values}内の\code{cons}への引数の評価順により決定されます
(\link{Exercise 4.1}参照)。}(\code{ev\-/appl\-/operand\-/loop}内で一連のオペランドを\code{unev}から抽出するために使用された)
\code{first\-/operand}セレクタは\code{car}として実装され、\code{rest\-/operands}は\code{cdr}として実装され、
明示的制御評価機は組み合わせのオペランドを左から右への順で評価します。

\subsubsection*{手続適用}

エントリポイント\code{apply\-/dispatch}はメタ循環評価機の\code{apply}手続に対応します。
\code{apply\-/dispatch}に到達する時に、\code{proc}レジスタは適用するための手続を持ち、
\code{argl}は適用するべき評価された引数のリストを持ちます。
(元々は\code{eval\-/dispatch}に渡され、\code{ev\-/application}で保存された)\code{continue}の保存された値は
手続適用の結果と共に帰る場所を伝えますが、スタック上に存在します。適用が完了した時に、
コントローラは保存された\code{continue}により指示されたエントリポイントへ、\code{val}内の
適用の結果と共に移動します。メタ循環の\code{apply}と同様に、考慮すべき2つの場合が存在します。
適用すべき手続はプリミティブであるか、または複合手続であるかです。

\begin{scheme}
apply-dispatch
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-apply))
  (test (op compound-procedure?) (reg proc))
  (branch (label compound-apply))
  (goto (label unknown-procedure-type))
\end{scheme}

\noindent
各プリミティブは引数を\code{argl}から取得し、その結果を\code{val}内に置くように実装されていると
想定されます。機械がどのようにプリミティブを扱うかを指定するためには、それぞれのプリミティブを
実装するための一連のコントローラ命令を提供しなければならず、\code{proc}の中身により判別された
プリミティブのための命令への割り振りを行うように\code{primitive\-/apply}を準備しなければなりません。
私達はプリミティブの詳細ではなく、評価処理の構造に興味があるため、それらの代わりに
単に\code{apply\-/primitive\-/procedure}を使用します。これは\code{proc}内の手続を\code{argl}内の引数に対して
適用します。\link{Section 5.2}のシミュレータを用いて評価機のシミュレーションを行う目的のために、
私達は手続\code{apply\-/primitive\-/procedure}を使用します。これは根底にあるSchemeシステムを
適用を実行するために呼び出します。私達が\link{Section 4.1.4}のメタ循環評価機で行ったのと全く同じです。
プリミティブの適用の値を計算した後に、\code{continue}を戻して指定されたエントリポイントに飛びます。

\begin{scheme}
primitive-apply
  (assign val (op apply-primitive-procedure)
              (reg proc)
              (reg argl))
  (restore continue)
  (goto (reg continue))
\end{scheme}

\noindent
複合手続を適用するためには、メタ循環評価機と全く同様に進行します。
手続のパラメタを引数に束縛するフレームを構築し、このフレームを用いて手続により
運ばれた環境を拡張し、この拡張環境の中で手続のボディを形成する式の列を評価します。
\link{Section 5.4.2}で説明される\code{ev\-/sequence}は列の評価を取り扱います。

\begin{scheme}
compound-apply
  (assign unev (op procedure-parameters) (reg proc))
  (assign env (op procedure-environment) (reg proc))
  (assign env (op extend-environment)
              (reg unev) (reg argl) (reg env))
  (assign unev (op procedure-body) (reg proc))
  (goto (label ev-sequence))
\end{scheme}

\noindent
\code{compound\-/apply}は\code{env}レジスタが新しい値を割り当てられるインタプリタ内で唯一の場所です。
メタ循環評価機と同様に、新しい環境は手続により運ばれた環境から引数リストと対応する束縛される
変数のリストと共に構築されます。

\subsection{列の評価と末尾再帰}
\label{Section 5.4.2}

明示的制御評価機の\code{ev\-/sequence}の部分はメタ循環評価機の\code{eval\-/sequence}手続と同等です。
手続のボディ内の式、または明示的な\code{begin}式内の列を取り扱います。

明示的な\code{begin}式は\code{unev}内に評価されるべき式の列を配置し、\code{continue}をスタック上に保存し、
\code{ev\-/sequence}に飛ぶことで評価されます。

\begin{scheme}
ev-begin
  (assign unev (op begin-actions) (reg exp))
  (save continue)
  (goto (label ev-sequence))
\end{scheme}

\noindent
手続のボディ内の暗黙的な列は\code{compound\-/apply}から\code{ev\-/sequence}へと飛ぶことで
扱われます。この時点で\code{continue}は既に\code{ev\-/application}で保存され、スタック上に存在します。

\code{ev\-/sequence}と\code{ev\-/sequence\-/continue}のエントリポイントはループを形成し、
連続して列内の各式を評価します。未評価の式のリストは\code{unev}に保持されています。
各式の評価の前に、列内にさらなる評価すべき式が存在しないかどうか確認します。
もしそうであれば、(\code{unev}に保持された)未評価の式の残りと、(\code{env}に保持された)
式の残りが評価される環境を保存し、その式を評価するために\code{eval\-/dispatch}を呼びます。
2つの保存されたレジスタはこの評価からの帰還時に\code{ev\-/sequence\-/continue}にて戻されます。

列内の最後の式は\code{ev\-/sequence\-/last\-/exp}にて異なる取扱を行います。
この後には評価すべき式は無いため、\code{unev}と\code{env}を\code{eval\-/dispatch}に行く前に
保存する必要はありません。列全体の値は最後の式の値であるため、最後の式の評価の後に
スタック上に現時点で保存されている(\code{ev\-/application}または\code{ev\-/begin}にて保存された)
エントリポイントから続行すること以外に必要なことはありません。
\code{continue}を設定して\code{eval\-/dispatch}からここに帰るように準備し、次にスタックから
\code{continue}の値を戻してそのエントリポイントから続行するのではなく、\code{eval\-/dispatch}へ
行く前にスタックから\code{continue}を戻します。そうすることで\code{eval\-/dispatch}は
式を評価した後にそのエントリポイントから続行します。

\begin{scheme}
ev-sequence
  (assign exp (op first-exp) (reg unev))
  (test (op last-exp?) (reg unev))
  (branch (label ev-sequence-last-exp))
  (save unev)
  (save env)
  (assign continue (label ev-sequence-continue))
  (goto (label eval-dispatch))
ev-sequence-continue
  (restore env)
  (restore unev)
  (assign unev (op rest-exps) (reg unev))
  (goto (label ev-sequence))
ev-sequence-last-exp
  (restore continue)
  (goto (label eval-dispatch))
\end{scheme}

\subsubsection*{末尾再帰}


\link{Chapter 1}にて以下のような手続により記述されるプロセスは、

\begin{scheme}
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))
\end{scheme}

\noindent
反復プロセスだと述べました。例えこの手続が構文的に(それ自身の単語の定義において)再帰であっても、
論理的には評価機にとって、1つの\code{sqrt\-/iter}の呼出から次の呼出への横断において情報を保存する
必要がありません。\footnote{\link{Section 5.1}にてそのようなプロセスをどのようにスタックを持たない
レジスタマシンにて実装するのかを学びました。プロセスの状態は固定長のレジスタ集合に格納されます。}
\code{sqrt\-/iter}のような手続を、手続がそれ自身を呼び出すことを続けるに従い記憶域を増加させる
必要無しに実行することが可能な評価機は、\newterm{tail-recursive}(\jnewterm{末尾再帰})評価機と呼ばれます。
\link{Chapter 4}のメタ循環評価機の実装は評価機が末尾再帰であるかどうかを指定しませんでした。
その評価機が状態を保存するための仕組みをその基礎に横たわるSchemeから継承していたためです。
しかし明示的制御評価機と用いる場合、私達は評価の過程を追跡し、いつ手続呼出が正味の情報集積を
スタック上に引き起すのかを確認することができます。

私達の評価機は末尾再帰です。なぜなら列の最後の式を評価するために、スタック上に
何の情報も保存すること無く\code{eval\-/dispatch}へと直接飛びます。従って、
列の最後の式---例えもしそれが手続呼出であっても(\code{sqrt\-/iter}のように、手続のボディの最後の
式が\code{if}式であっても、\code{sqrt\-/iter}への呼出へと簡約されます)---の評価がスタック上に
何の情報の蓄積も起こしません。\footnote{この\code{ev\-/sequence}における末尾再帰の実装は
多くのコンパイラで使用されている良く知られた最適化の技術の一種です。手続呼出で
終了する手続のコンパイルでは、呼出を呼び出された手続のエントリポイントへのジャンプで
置き換えることができます。この節で行ったように、この戦略をインタプリタの中に構築することは
言語の至る所に均一に最適化を提供します。}

もしこの場合に情報を保存する必要が無いという事実を活用することを考えなかった場合、
列内の全ての式を同じように取り扱うように\code{eval\-/sequence}を実装していたことでしょう。
レジスタの保存、式の評価、レジスタを戻すために帰る、これらを全ての式が評価されるまで
繰り返したことでしょう。\footnote{We can
define \code{no\-/more\-/exps?} as follows:

\code{no\-/more\-/exps?}を以下のように定義することができます。

\begin{smallscheme}
(define (no-more-exps? seq) (null? seq))
\end{smallscheme}
}

\begin{scheme}
ev-sequence
  (test (op no-more-exps?) (reg unev))
  (branch (label ev-sequence-end))
  (assign exp (op first-exp) (reg unev))
  (save unev)
  (save env)
  (assign continue (label ev-sequence-continue))
  (goto (label eval-dispatch))
ev-sequence-continue
  (restore env)
  (restore unev)
  (assign unev (op rest-exps) (reg unev))
  (goto (label ev-sequence))
ev-sequence-end
  (restore continue)
  (goto (reg continue))
\end{scheme}

\noindent
恐らくこれは列の評価のための以前のコードに対する軽微な変更のように見えるでしょう。
唯一の違いは保存と再格納のサイクルを他と同様に列の最後の式でも通すことです。
インタプリタは依然としてどの式に対しても同じ値を与えます。しかし、この変更は
末尾再帰の実装に対しては致命的です。なぜなら、これで私達は列の最後の式の評価の後にも
(使用価値の無い)レジスタの保存を戻すために帰らねばなりません。
これらの余分な保存は入れ子の手続の呼出の間で蓄積されます。その結果として、\code{sqrt\-/iter}の
ようなプロセスは一定容量を必要とするのでなく、繰り返しの回数に比例する記憶域を必要と
します。この違いは重大事に成り得ます。例えば、末尾再帰を用いれば、無限ループは
手続呼出の仕組みだけを用いて表現できます。

\begin{scheme}
(define (count n)
  (newline) (display n) (count (+ n 1)))
\end{scheme}

\noindent
末尾再帰が無ければ、そのような手続はいつかはスタック領域を使いつくします。
そして真に反復を表現することは手続呼出以外の何らかの制御の仕組みを必要とします。

\subsection{条件文、代入、定義}
\label{Section 5.4.3}

メタ循環評価機と同様に、特殊形式は選択的に式の部分部分を評価することで取り扱われます。
\code{if}式に対しては、述語を評価して、その値を元に、結果部(consequent)と代替部(alternative)の
どちらを評価するか決定します。

述語を評価する前に、\code{if}式自身を保存します。そうすることで後に結果部か代替部を抽出することが
できます。また後に結果部か代替部を評価するため必要となるので環境を保存します。
そして後に\code{if}の値を待っている式の評価に戻るために必要なため\code{continue}も保存します。

\begin{scheme}
ev-if
  (save exp)                    ~\textrm{; 後のため式を保存する}~
  (save env)
  (save continue)
  (assign continue (label ev-if-decide))
  (assign exp (op if-predicate) (reg exp))
  (goto (label eval-dispatch))  ~\textrm{; 述語を評価する}~
\end{scheme}

\noindent
述語の評価から戻る時、真か偽であるかをテストし、結果に依り\code{eval\-/dispatch}に飛ぶ前に
\code{exp}に結果部か代替部を配置します。\code{env}と\code{continue}をここで戻すことが
\code{eval\-/dispatch}に正しい環境を持たせ、正しい場所から継続し\code{if}式の値を受けとるように
設定していることに注意して下さい。

\begin{scheme}
ev-if-decide
  (restore continue)
  (restore env)
  (restore exp)
  (test (op true?) (reg val))
  (branch (label ev-if-consequent))
ev-if-alternative
  (assign exp (op if-alternative) (reg exp))
  (goto (label eval-dispatch))
ev-if-consequent
  (assign exp (op if-consequent) (reg exp))
  (goto (label eval-dispatch))
\end{scheme}

\subsubsection*{代入と定義}

代入と定義は\code{ev\-/assignment}により扱われます。ここには\code{eval\-/dispatch}から代入式が\code{exp}の
中にある状態で到達します。\code{ev\-/assignment}の最初のコードは式の部分の値を評価し、次に
新しい値を環境に導入します。\code{Set\-/variable\-/value!}が機械語命令として必要可能であると
前提します。

\begin{scheme}
ev-assignment
  (assign unev (op assignment-variable) (reg exp))
  (save unev)                   ~\textrm{; 後のため変数を保存}~
  (assign exp (op assignment-value) (reg exp))
  (save env)
  (save continue)
  (assign continue (label ev-assignment-1))
  (goto (label eval-dispatch))  ~\textrm{; 代入値を評価する}~
ev-assignment-1
  (restore continue)
  (restore env)
  (restore unev)
  (perform
   (op set-variable-value!) (reg unev) (reg val) (reg env))
  (assign val (const ok))
  (goto (reg continue))
\end{scheme}

\noindent
定義も同様に扱われます。

\begin{scheme}
ev-definition
  (assign unev (op definition-variable) (reg exp))
  (save unev)                   ~\textrm{; 変数を後のため保存}~
  (assign exp (op definition-value) (reg exp))
  (save env)
  (save continue)
  (assign continue (label ev-definition-1))
  (goto (label eval-dispatch))  ~\textrm{; 定義値を評価する}~
ev-definition-1
  (restore continue)
  (restore env)
  (restore unev)
  (perform
   (op define-variable!) (reg unev) (reg val) (reg env))
  (assign val (const ok))
  (goto (reg continue))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.23}Exercise 5.23:}
評価機を拡張し、\code{cond}, \code{let}, 等の派生式を取り扱うようにせよ(\link{Section 4.1.2})。
\code{cond\-/>if}の様な構文変換器が機械語命令として使用可能と前提して``インチキ''しても良い。\footnote{これは
本当はインチキではありません。実際のゼロからの実装においても、Schemeを解釈する明示的制御評価機を用いて
\code{cond\-/>if}のようなソースレベル変換を実行前の構文フェーズにて実行するでしょう。}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.24}Exercise 5.24:}
\code{cond}を新しい基本的な特殊形式として\code{if}に簡約すること無しに実装せよ。
連続する\code{cond}節の述語を真になるものを見つけるまでテストするループを構築する必要がある。
次に\code{ev\-/sequence}を使用してその節のアクションを評価する。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.25}Exercise 5.25:}
評価機を変更し、\link{Section 4.2}の遅延評価機を基にした正規順評価を使用するようにせよ。
\end{quote}

\subsection{評価機を実行する}
\label{Section 5.4.4}

明示的制御評価機の実装と共に、私達は\link{Chapter 1}から始まった開発の終わりにやってきました。
ここまで私達は引き続きより的確な評価過程のモデルを探求してきました。比較的、略式な
置換モデルから開始し、次にこれを\link{Chapter 3}で環境モデルに拡張しました。これは
状態と変更を扱うことを可能にしました。\link{Chapter 4}のメタ循環評価機ではScheme自身を
式の評価の間に構築される、より明確な環境構造のための言語として使用しました。
ここでは、レジスタマシンを用いてメモリ管理、引数渡し、制御のための評価機の仕組みについて
つぶさに見てきました。それぞれの新しいレベルの説明にて、直前の、明確さで劣る評価処理の
見ることはできない曖昧さに関して問題を提起し、解決する必要がありました。
明示的制御評価機の振舞を理解するために、そのシミュレーションを行い、パフォーマンスを
監視することができます。

私達の評価機にドライバループを導入します。これは\link{Section 4.1.4}の\code{driver\-/loop}手続の
役割を果たします。この評価機は繰り返しプロンプトを表示し、式を読み込み、\code{eval\-/dispatch}へ
飛ぶことで式を評価し、結果を表示します。以下の命令は明示的制御評価機のコントローラシーケンスの
開始を形づくります。\footnote{
ここでは\code{read}と多様な表示命令がプリミティブな機械語命令として
使用可能であると前提します。このことは私達のシミュレーションには便利ですが、実際には完全に
非現実的です。これらは本当はかなり複雑な命令です。実際には、それらは単一の文字を端末との間で
双方向に転送するような低レベルの入出力命令を用いて実装されるでしょう。


\code{get\-/global\-/environment}命令をサポートするためには以下を定義します。

\begin{smallscheme}
(define the-global-environment (setup-environment))
(define (get-global-environment) the-global-environment)
\end{smallscheme}
}

\begin{scheme}
read-eval-print-loop
  (perform (op initialize-stack))
  (perform
   (op prompt-for-input) (const ";;EC-Eval input:"))
  (assign exp (op read))
  (assign env (op get-global-environment))
  (assign continue (label print-result))
  (goto (label eval-dispatch))
print-result
  (perform (op announce-output) (const ";;EC-Eval value:"))
  (perform (op user-print) (reg val))
  (goto (label read-eval-print-loop))
\end{scheme}

\noindent
手続の中で(\code{apply\-/dispatch}で指摘される``未知の手続型エラー''の様な)エラーに遭遇した時、
エラーメッセージを表示し、ドライバループへと戻ります。\footnote{インタプリタに取り扱って
欲しいと願うかもしれない他のエラーも存在します。しかしこれらはあまり単純ではありません。
\link{Exercise 5.30}を参照して下さい。}

\begin{scheme}
unknown-expression-type
  (assign val (const unknown-expression-type-error))
  (goto (label signal-error))
unknown-procedure-type
  (restore continue)    ~\textrm{; clean up stack (from \code{apply\-/dispatch})}~
  (assign val (const unknown-procedure-type-error))
  (goto (label signal-error))
signal-error
  (perform (op user-print) (reg val))
  (goto (label read-eval-print-loop))
\end{scheme}

\noindent
シミュレーションの目的のために、ドライバループを通る度にスタックを初期化します。
(未定義変数の様な)エラーが評価を割り込みした後には空でない可能性があるためです。\footnote{スタックの
初期化をエラーの後にのみ行うことも可能でしょう。しかしドライバループの中で行うことは
評価機のパフォーマンスを監視するために便利です。この先で説明されます。}

\link{Section 5.4.1}から\link{Section 5.4.4}の間のコードの断片を組合せれば、\link{Section 5.2}のレジスタマシン
シミュレータを用いて実行することができる評価機の機械モデルを作ることができます。

\begin{scheme}
(define eceval
  (make-machine
   '(exp env val proc argl continue unev)
   eceval-operations
   '(read-eval-print-loop
     ~\( \dark \langle \)~~\emph{entire machine controller as given above}~~\( \dark \rangle \)~ )))
\end{scheme}

\noindent
評価機によりプリミティブとして使用される命令をシミュレートするためのScheme手続を定義しなければなりません。
これらは\link{Section 4.1}でメタ循環評価機のために使用したものと同じ手続と、\link{Section 5.4}の至る所の脚注にて
定義されたいくつかの追加の物があります。

\begin{scheme}
(define eceval-operations
  (list (list 'self-evaluating? self-evaluating)
        ~\( \dark \langle \)~~\emph{complete list of operations for eceval machine}~~\( \dark \rangle \)~))
\end{scheme}

\noindent
最後に、グローバル環境を初期化し、評価機を実行します。

\begin{scheme}
(define the-global-environment (setup-environment))
(start eceval)
~\textit{;;; EC-Eval input:}~
(define (append x y)
  (if (null? x) y (cons (car x) (append (cdr x) y))))
~\textit{;;; EC-Eval value:}~
~\textit{ok}~
~\textit{;;; EC-Eval input:}~
(append '(a b c) '(d e f))
~\textit{;;; EC-Eval value:}~
~\textit{(a b c d e f)}~
\end{scheme}

\noindent
もちろん、この方法の式の評価はSchemeに直接入力した場合よりもずっと長くかかります。
複数レベルのシミュレーションが関与するためです。式は明示的制御評価器の機械により評価されます。
これはSchemeプログラムによりシミュレートされ、Schemeプログラム自身はSchemeインタプリタにより
評価されています。

\subsubsection*{評価機のパフォーマンスの監視}

シミュレーションは評価器の実装を案内するのに強力なツールです。
シミュレーションはレジスタマシンの設計の多様性を探求することだけでなく、シミュレートされた
評価器のパフォーマンスを観察することも簡単にします。例えば、パフォーマンスにおける
1つの重要な要因はどれだけ効率良く評価機がスタックを使用するかがあります。
スタック利用上の統計を集めるシミュレータの版を用いて評価機のレジスタマシンを設計することと、
評価機の\code{print\-/result}エントリポイントに統計を表示する命令を追加することでにより、
様々な式を評価するのに必要とされるスタック命令の数を観察することができます(\link{Section 5.2.4})。

\begin{scheme}
print-result
  (perform (op print-stack-statistics))   ~\textrm{; 追加された命令}~
  (perform
   (op announce-output) (const ";;; EC-Eval value:"))
  ~\( \dots \)~ ~\textrm{; 以前と同じ}~
\end{scheme}

\noindent
評価機との応答はこれで以下のように見えます。

\begin{scheme}
~\textit{;;; EC-Eval input:}~
(define (factorial n)
  (if (= n 1) 1 (* (factorial (- n 1)) n)))
~\textit{(total-pushes = 3 maximum-depth = 3)}~
~\textit{;;; EC-Eval value:}~
~\textit{ok}~
~\textit{;;; EC-Eval input:}~
(factorial 5)
~\textit{(total-pushes = 144 maximum-depth = 28)}~
~\textit{;;; EC-Eval value:}~
~\textit{120}~
\end{scheme}

\noindent
評価機のドライバループが全ての応答の開始にスタックを再度初期化することに注意して下さい。
それにより表示された統計は直前の式の評価のために使用されたスタック命令のみを参照します。

\begin{quote}
\heading{\phantomsection\label{Exercise 5.26}Exercise 5.26:}
監視付きのスタックを用いて評価機(\link{Section 5.4.2})の末尾再帰の特性を調査せよ。
評価機を開始し、\link{Section 1.2.1}の反復\code{factorial}手続を定義せよ。

\begin{scheme}
(define (factorial n)
  (define (iter product counter)
    (if (> counter n)
        product
        (iter (* counter product) (+ counter 1))))
  (iter 1 1))
\end{scheme}


手続をいくつかの\( n \)の小さな値で実行せよ。これらの値に対する\( n! \)を求めるのに必要な
最大スタック深度とpushの数を記録せよ。

\begin{enumerate}[a]

\item
\( n! \)を評価するために必要な最大深度が\( n \)から独立していることを発見するだろう。
この深さは何か?

\item
あなたのデータから任意の\( n \ge 1 \)に対して\( n! \)を評価するのに使用されるpush命令の
総数を求める\( n \)の方程式を求めよ。使用される命令数は\( n \)の線形関数であり、従って
2つの定数から決定されることに注意せよ。

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.27}Exercise 5.27:}
\link{Exercise 5.26}との比較として、以下の階乗を再帰的に求める手続の振舞を調査せよ。

\begin{scheme}
(define (factorial n)
  (if (= n 1)
      1
      (* (factorial (- n 1)) n)))
\end{scheme}

この手続を監視付きのスタックを用いて実行し、任意の\( n \ge 1 \)に対して\( n! \)を
評価するために使用される、スタックの最大深度とプッシュの総数を\( n \)の関数として求めよ。
(再び、これらの関数は線形になる)。あなたの経験を以下の表に適切な\( n \)の式を埋めることで
まとめよ。

\begin{comment}

\begin{example}
               Maximum depth       Number of pushes

Recursive
factorial

Iterative
factorial
\end{example}

\end{comment}
\begin{displaymath}
\vbox{
\offinterlineskip
\halign{
\strut 	\hfil \quad #\quad \hfil & \vrule 
	\hfil \quad #\quad \hfil & \vrule
	\hfil \quad #\quad \hfil \cr

				& 最大深度 & pushの総数 \cr
	\noalign{\hrule}
	再帰      		&  		&  \cr
	階乗      		&  		&  \cr
	\noalign{\hrule}
	反復      		&  		&  \cr
	階乗      		&  		&  \cr
}
}
\end{displaymath}
最大深度は演算の実行において評価機により使用された記憶域の量の尺度である。
pushの総数は必要な時間に良く関連している。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.28}Exercise 5.28:}
\link{Section 5.4.2}にて説明されているように\code{eval\-/sequence}を変えることで評価機の定義を変更し、
評価機がもはや末尾再帰ではないようにせよ。\link{Exercise 5.26}と\link{Exercise 5.27}の
実験を再実行し、\code{factorial}手続の両版が今では必要とされる記憶域がそれらの入力に対し
線形に増加することを実演せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.29}Exercise 5.29:}
木再帰フィボナッチ数の演算におけるスタック命令を監視せよ。

\begin{scheme}
(define (fib n)
  (if (< n 2)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))
\end{scheme}

\begin{enumerate}[a]

\item
\( n \ge 2 \)に対して\( {\rm Fib}(n) \)を求まる場合に必要なスタックの最大深度に
対する\( n \)の方程式を与えよ。ヒント：\link{Section 1.2.2}において私達は
この処理により使用される記憶域は\( n \)に対し線形に増加することを議論した。

\item
\( n \ge 2 \)に対して\( {\rm Fib}(n) \)を求めるのに使用されたpushの総数に対する
方程式を与えよ。(費やされた時間に良く関連する)pushの総数は\( n \)の指数関数的に
増加することを見付けなければならない。ヒント：\( S(n) \)を\( {\rm Fib}(n) \)を
求めるのに使用されたpushの総数とせよ。\( S(n - 1) \), \( S(n - 2) \), それにある
固定の``オーバヘッド''として\( n \)から独立した定数\( k \)を用いて\( S(n) \)を
表現する方程式が存在することを主張することができるはずだ。方程式を与えて、\( k \)が
何であるかを述べよ。次に\( S(n) \)が\( a\cdot{\rm Fib}(n + 1) + b \)として表現できる
ことを示し、\( a \)と\( b \)の値を与えよ。

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.30}Exercise 5.30:}
私達の評価機は現在は2つの種類のエラー---未知の型の式と未知の型の手続---のみを発し
キャッチする。他のエラーは評価機のREPLから抜けてしまう。評価機をレジスタマシン
シミュレータを用いて実行した時に、これらのエラーはその下に横たわるSchemeシステムに
よりキャッチされるこれはユーザプログラムがエラーを発生させた時にコンピュータが
強制終了するのと同様である。\footnote{残念ながら、C言語のような従来のコンパイラベース
言語システムにおいてはこれが普通の状況です。\acronym{UNIX}(tm)ではシステムは
``コア(core)をダンプ(dump)''し、\acronym{DOS}/Windows(tm)ではcatatonic(硬まる、フリーズ)します。
Macintosh(tm)は---もしラッキーな場合は---爆発する爆弾の絵を表示しコンピュータをリブートするよう提案します。}
本物のエラーシステムを働かせることは大きなプロジェクトである。しかし、ここで
何が関与しているのかを理解する努力には大きな価値がある。

\begin{enumerate}[a]

\item
未定義の変数にアクセスを試すような評価プロセスで発生するエラーはlookup命令を
変更し識別可能な状態コードを返すように変更することで捕まえることができるだろう。
状態コードは全てのユーザ変数が取り得ない値でなければならない。評価機はこの状態コードに対し
テストを行い、\code{signal\-/error}に飛ぶために必要なことを行う。評価機の中でそのような
変更が必要な全ての箇所を見つけ修正せよ。これはとても大変な作業だ。

\item
ゼロで割ることやシンボルから\code{car}を抽出するような試行により、プリミティブな
手続の適用上で発せられるエラーの取り扱いの問題はずっと酷い物だ。
専門的に記述された高品質なシステムにおいては、プリミティブの適用全てはプリミティブの
一部として安全性が確認されている。例えば全ての\code{car}の呼出は最初に引数がペアであるかを
確認する。もし引数がペアでなければ、適用は区別可能な状態コードを評価機に返す。すると
評価機は失敗を報告する。私達はこれを私達のレジスタマシンシミュレータに全てのプリミティブ
手続の適用性チェックを行い適切な識別可能な状態コードを失敗時に返すようにすることで
手筈を整えることができるだろう。すると評価機の\code{primitive\-/apply}コードが状態コードを
チェックし必要なら\code{signal\-/error}へ飛ぶことができる。この構造を構築し、働くようにせよ。
これは巨大なプロジェクトである。

\end{enumerate}
\end{quote}

\section{コンパイル}
\label{Section 5.5}

\link{Section 5.4}の明示的制御評価機はコントローラがSchemeプログラムを解釈するレジスタマシンです。
この節ではSchemeプログラムをコントローラがSchemeインタプリタではないレジスタマシン上にて
どのように実行するのかについて学びます。

明示的制御評価機械は普遍的です。Schemeで記述できるどんな演算プロセスも実行できます。
評価機のコントローラは望んだ演算を実行するためのデータパスの使用を調整します。
従って、評価機のデータパスは普遍的です。適切なコントローラを与えられた場合に、
私達が望む任意の演算を実行するのに十分です。\footnote{これは理論的な発言です。
この評価機のデータパスが一般的なコンピュータのために特に便利な、または効率的な
データパスの集合であると主張している訳ではありません。例えば、これらは高いパフォーマンスの
浮動小数点演算や、激しくビットベクタを操作する演算の実装にはあまり向いていません。}

商業上の汎用なコンピュータはレジスタと効率的で便利なデータパスの普遍的な集合を
構成する命令の周りに構築されるレジスタマシンです。汎用目的の機械は私達がここまで
使用しているようなレジスタマシン言語のためのインタプリタです。この言語は
機械の\newterm{native language}(\jnewterm{ネイティブ言語})、または単純に\newterm{machine language}(\jnewterm{機械語})と
呼ばれます。機械語で記述されたプログラムはその機械のデータパスを用いた命令列です。
例えば、明示的制御評価機の命令列は専門のインタプリタマシンのためのコントローラではなく、
汎用目的のコンピュータのための機械語プログラムだと考えることができます。

2つの共通な戦略が高水準の言語とレジスタマシンの言語の間のギャップを橋渡しします。
明示的制御評価機は逐次翻訳(interpretation)上の戦略を説明します。機械のネイティブ言語で
書かれたインタプリタは、評価を実行する機械のネイティブ言語とは異なっても良い
ある言語(\newterm{source language}(\jnewterm{ソース言語}))で書かれたプログラムを実行するように
機械を構成します。ソース言語のプリミティブ手続は与えられた機械のネイティブ言語により
記述されたサブルーチンのライブラリとして実装されます。
(\newterm{source program}(\jnewterm{ソースプログラム})と呼ばれる)逐次翻訳するプログラムは
データ構造として表現されます。インタプリタはこのデータ構造を横断し、ソースプログラムを
分析します。それを行うにつれ、ソースプログラムの意図された振舞を適切なプリミティブの
サブルーチンをライブラリから呼ぶことによりシミュレートします。

この節では、\newterm{compilation}(\jnewterm{コンパイル})という代替的な戦略を探求します。
与えられたソース言語と機械に対するコンパイラはソースプログラムを機械のネイティブ言語で書かれた
(\newterm{object program}(\jnewterm{オブジェクトプログラム})と呼ばれる)等価なプログラムに
翻訳します。この節で実装するコンパイラはSchemeで書かれたプログラムを明示的制御評価機の
データパスを用いて実行される命令列へと翻訳します。\footnote{実際には、コンパイルされた
コードを実行する機械はインタプリタマシンよりもより単純に成り得ます。\code{exp}と
\code{unev}のレジスタを使用しないためです。これらを使用するインタプリタは未評価の式の
部分を保持します。しかしコンパイラを用いる場合には、これらの式はレジスタマシンが実行する
コンパイルされたコードの中に組込まれます。同じ理由により、式の構文を扱う機械語命令を
必要としません。しかしコンパイルされたコードは明示的制御評価機械では存在しなかった
いくつかの追加の(コンパイルされた手続オブジェクトを表現するための)機械語命令を使用します。}

逐次翻訳と比べた時、コンパイルはプログラム実行の効率性において大きな向上を与えられます。
このことは下記にてコンパイラの概観において説明して行きます。一方で、インタプリタは
より強力な環境を対話式のプログラム開発とデバッグのために提供します。実行する
ソースプログラムが実行時にも試験し、変更するために使用可能なためです。
それに加えて、プリミティブのライブラリ全体が存在し、新しいプログラムがデバッグの間に
構築し、追加することができることも挙げられます。

コンパイルと逐次翻訳の相補的な利点の視点において、最新のプログラム開発環境は
入り交じった戦略を追求しています。Lispインタプリタは一般的に逐次翻訳された手続と
コンパイルされた手続がお互いを呼びだせるように構築されています。
これはプログラマがデバッグすることを想定されているこれらのプログラムの部品を
コンパイルすることを可能にします。従ってコンパイルの効率上の利点を得ながら、
プログラムのそれらの部品に対して対話式開発とデバッグの流動的な、実行の解釈的な
モードを維持することもできます。\link{Section 5.5.7}において、コンパイラを実装した後には
インタプリタとどのように接続して統合的なインタプリタ・コンパイラ開発システムを
生成するかを示します。

\subsubsection*{コンパイラの概要}

私達のコンパイラは私達のインタプリタに両者のその構造と実行する機能において
とても良く似ています。従って、コンパイラにより式の解析のために使用される仕組みは
インタプリタにて使用されたものと同様になります。さらに、コンパイルされたコードと
逐次翻訳されたコードの接続を簡単にするために、インタプリタと同じ
レジスタ使用法の仕様に従うコードを生成する様にコンパイラを設計します。
環境は\code{env}レジスタに保持され、引数リストは\code{argl}に蓄積され、適用される
手続は\code{proc}に入り、手続はそれらの回答を\code{val}に入れて戻り、手続が戻らなければ
いけない位置は\code{continue}に維持されます。一般的に、コンパイラはソースプログラムを
インタプリタが同じソースプログラムを評価する場合に行うのと本質的に同じレジスタ命令
を実行するオブジェクトプログラムに翻訳します。

この説明ではとても基本的なコンパイラを実装するための戦略を提案します。式をインタプリタと
同じ方法で横断します。インタプリタが式の評価で実行するだろうレジスタ命令に遭遇したら、
その命令を実行はしませんがその代わりに列に蓄積します。結果としての命令列は
オブジェクトコードになります。逐次翻訳に対するコンパイルの効率上の利点を注意して下さい。
インタプリタが式、例えば\code{(f 84 96)}を評価する度に、式の分類(手続の適用であるかを見出す)と
オペランドリストの終端の検査(2つのオペランドが残っているかを見出す)を行います。
コンパイラを用いる場合、式は命令列がコンパイル時に生成された時に一度しか解析されません。
コンパイラにより生成されたオブジェクトコードはオペレータと2つのオペランドを評価する命令しか
含んでおらず、引数リストを組み立て、(\code{proc}内の)手続を(\code{argl}内の)その引数に適用します。

これは\link{Section 4.1.7}の解析評価機で実装したものと同じ種類の最適化です。しかし、コンパイルされた
コード中で効率を良くするためのさらなる機会が存在します。インタプリタが実行するにしたがって、
インタプリタは言語の任意の式に必ず当てはまる過程を追います。対照的に、与えられたコンパイル済みコードの断片は
ある特定の式を実行することを意味します。これは例えばスタックを用いてレジスタを保存する場合等に
大きな違いを生みます。インタプリタが式を評価する時には、任意の偶発性に対して準備をしなければ
なりません。部分式を評価する前に、インタプリタは後で必要となる全てのレジスタを保存します。
部分式が無原則な評価を要求するかもしれないためです。一方、コンパイラは処理対象の特定の式の構造を利用して
不必要なスタック命令を回避するコードを生成することができます。

その一例として、組み合わせ\code{(f 84 96)}について考えてみます。インタプリタが組み合わせの
オペレータを評価する前に、値が後で必要になるオペランドと環境を持つレジスタを保存することで
この評価のための準備を行います。次にインタプリタはオペレータを評価してその結果を\code{val}に
取得し、保存したレジスタを戻し、最後に結果を\code{val}から\code{proc}に移します。しかし、
私達が評価しているこの式では、オペレータがシンボルの\code{f}であり、その評価は機械語の
\code{lookup\-/variable\-/value}にて達成され、これはどのレジスタの値も変化させません。
この節で実装するコンパイラはこの事実を活用し、オペレータをこの命令を使用して評価するコードを
生成します。

\begin{scheme}
(assign proc (op lookup-variable-value)
             (const f)
             (reg env))
\end{scheme}

\noindent
このコードは不必要な保存と復元を回避するだけでなく、lookupの値を直接\code{proc}に割り当てます。
一方でインタプリタは結果を\code{val}の中に取得し、その後に\code{proc}へと移します。

コンパイラはまた環境へのアクセスを最適化することができます。コードを解析した後に、
コンパイラは多くの場合において、どのフレームの中に特定の変数が位置するかを知り、
\code{lookup\-/variable\-/value}による検索を実行するのではなしに、直接アクセスすることができます。
そのような変数のアクセスをどのように実装するかについての議論は\link{Section 5.5.6}にて行います。



\subsection{コンパイラの構造}
\label{Section 5.5.1}

\link{Section 4.1.7}において、私達は元のメタ循環インタプリタを変更して分析を実行から分離しました。
各式を分析して環境を引数として取り必要とされる命令を実行する実行手続を生成しました。
私達のコンパイラでは、本質的には同じ分析を行います。しかし、実行手続を生成する代わりに、
私達のレジスタマシンにより実行される命令列を生成します。

手続\code{compile}はコンパイラ内でのトップレベルの割り振りです。これは\link{Section 4.1.1}の
\code{eval}手続、\link{Section 4.1.7}の\code{analyze}手続、そして\link{Section 5.4.1}の明示的制御評価機の
エントリポイント\code{eval\-/dispatch}に対応します。コンパイラはインタプリタと同様に、
\link{Section 4.1.2}における式の構文手続を用います。\footnote{しかし、私達のコンパイラが
Schemeプログラムであり、式を操作するためにそれが用いる構文手続がメタ循環評価機により
仕様される実際のScheme手続であることに注意して下さい。一方で、明示的制御評価機では
等価な構文命令がレジスタマシンに対する命令として使用可能であると前提しました。
(もちろん、Schemeでレジスタマシンをシミュレートした時には、実際のSchemeの手続を
使用しました。)}\code{compile}はコンパイルされる式の構文の型の事例分析を実行します。
各式の型に対し、特別な\newterm{code generator}(\jnewterm{コード生成器})を割り振ります。

\begin{scheme}
(define (compile exp target linkage)
  (cond ((self-evaluating? exp)
         (compile-self-evaluating exp target linkage))
        ((quoted? exp) (compile-quoted exp target linkage))
        ((variable? exp)
         (compile-variable exp target linkage))
        ((assignment? exp)
         (compile-assignment exp target linkage))
        ((definition? exp)
         (compile-definition exp target linkage))
        ((if? exp) (compile-if exp target linkage))
        ((lambda? exp) (compile-lambda exp target linkage))
        ((begin? exp)
         (compile-sequence
          (begin-actions exp) target linkage))
        ((cond? exp) 
         (compile (cond->if exp) target linkage))
        ((application? exp)
         (compile-application exp target linkage))
        (else
         (error "Unknown expression type: COMPILE" exp))))
\end{scheme}

\subsubsection*{ターゲットとリンク記述子}

\code{compile}とそれが呼ぶコード生成器はコンパイル対象の式に加えて2つの引数を取ります。
コンパイルされたコードがその中で式の値を返すレジスタを指定する\newterm{target}(\jnewterm{ターゲット})と
実行が完了した時に、式のコンパイルの結果としてのコードがどのように続けるべきかを
説明する\newterm{linkage descriptor}(\jnewterm{リンク記述子})です。リンク記述子はコードが
以下の3つの内1つを行うよう要求することができます。

\begin{itemize}

\item
列の次の命令を続ける(これはリンク記述子\code{next}により指定されます)

\item
コンパイルしている手続から戻る(これはリンク記述子\code{return}により指定されます)

\item
名前付きエントリポイントへ飛ぶ(これはリンク記述子として指定したラベルを用いて指定します)

\end{itemize}

\noindent
例えば、式\code{5}(これは自己評価型)をターゲットをレジスタ\code{val}、リンク記述子を\code{next}で
コンパイルする時、以下の命令を生成しなければなりません。

\begin{scheme}
(assign val (const 5))
\end{scheme}

\noindent
同じ式をリンク記述子\code{return}でコンパイルする時には以下の命令を生成しなければなりません。

\begin{scheme}
(assign val (const 5))
(goto (reg continue))
\end{scheme}

\noindent
最初の場合には、実行は列内の次の命令と共に続行します。2つ目の場合には、手続呼出から
戻ります。両者の場合において、式の値はターゲットレジスタ\code{val}に配置されます。

\subsubsection*{命令列とスタックの使用法}

各コード生成器は式のために生成したオブジェクトコードを含む\newterm{instruction sequence}(\jnewterm{命令列})を
返します。複合式に対するコード生成は部分式のためのより単純なコード生成器からの出力を組み合わせる
ことにより達成されます。これは複合式の評価が部分式を評価することにより達成されるのと同じです。

命令列を組み合わせる最も単純な手法は\code{append\-/instruction\-/sequences}という手続です。
これは引数として順に実行されるべき任意の数の命令列を取り、それらを接続し、組み合わされた列を返します。
つまり、もし\( \langle \)\( seq_1 \)\( \rangle \)と\( \langle \)\( seq_2 \)\( \rangle \)が
命令列であるならば、以下の評価は、

\begin{scheme}
(append-instruction-sequences ~\( \dark \langle \)~~\( \dark seq_1 \)~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark seq_2 \)~~\( \dark \rangle \)~)
\end{scheme}

\noindent
次の列を生成します。

\begin{scheme}
~\( \dark \langle \)~~\( \dark seq_1 \)~~\( \dark \rangle \)~
~\( \dark \langle \)~~\( \dark seq_2 \)~~\( \dark \rangle \)~
\end{scheme}

\noindent
レジスタが保存される必要がある度に、コンパイラのコード生成器は\code{preserving}を使用します。
これは命令列を組み立てるための、より芸が細かい手法です。\code{preserving}は3つの引数を
取ります。レジスタの集合と2つの命令列です。これは列をレジスタ集合内の各レジスタの中身が、
2つ目の列の実行に必要ならば、最初の列の実行の間は維持(preserve)されるような方法で接続します。
言い換えれば、もし最初の命令列がレジスタを変更し、2つ目の列が実際にそのレジスタの元の中身を
必要とするならば、\code{preserving}は列を接続する前に最初の列をそのレジスタの\code{save}と\code{restore}で
包みます。そうでなければ、\code{preserving}は単純に接続した命令列を返します。
従って、例えば
\code{(preserving (list}\( \;\;\langle{reg_1}\rangle\;\;\langle{reg_2}\rangle \)\code{)}\( \;\;\langle{seg_1}\rangle\;\;\langle{seg_2}\rangle \)\code{)}
は、
\( \langle \)\( seq_1 \)\( \rangle \)と\( \langle \)\( seq_2 \)\( \rangle \)がどのように
\( \langle \)\( reg_1 \)\( \rangle \)と\( \langle \)\( reg_2 \)\( \rangle \)を使用するかに依存して
以下の4つの命令列の内1つを生成します。

\begin{comment}

\begin{smallexample}
<seq_1> | (save <reg_1>)    | (save <reg_2>)    | (save <reg_2>)
<seq_2> | <seq_1>           | <seq_1>           | (save <reg_1>)
        | (restore <reg_1>) | (restore <reg_2>) | <seq_1>
        | <seq_2>           | <seq_2>           | (restore <reg_1>)
        |                   |                   | (restore <reg_2>)
        |                   |                   | <seq_2>
\end{smallexample}

\end{comment}
\begin{displaymath}
\vbox{
\offinterlineskip
\halign{
\strut 	\kern0.8em # \kern0.4em \hfil & \vrule 
	\kern0.8em # \kern0.4em \hfil & \vrule
	\kern0.8em # \kern0.4em \hfil & \vrule
	\kern0.8em # \kern0.4em \hfil \cr

$\langle{seq_1}\rangle$ 			& \hbox{\tt (save} $\langle{reg_1}\rangle${\tt)} & 
\hbox{\tt (save} $\langle{reg_2}\rangle${\tt)} 	& \hbox{\tt (save} $\langle{reg_2}\rangle${\tt)} \cr

$\langle{seq_2}\rangle$ 			& $\langle{seq_1}\rangle$	& 
$\langle{seq_1}\rangle$ 			& \hbox{\tt (save} $\langle{reg_1}\rangle${\tt)} \cr

						& \hbox{\tt (restore} $\langle{reg_1}\rangle${\tt)} & 
\hbox{\tt (restore} $\langle{reg_2}\rangle${\tt)} 	& $\langle{seq_1}\rangle$ \cr

						& $\langle{seq_2}\rangle$ & 
$\langle{seq_2}\rangle$				& \hbox{\tt (restore} $\langle{reg_1}\rangle${\tt)} \cr

						&  &
			      			& \hbox{\tt (restore} $\langle{reg_2}\rangle${\tt)} \cr

						&  &
			      			& $\langle{seq_2}\rangle$ \cr
}
}
\end{displaymath}

\noindent
\code{preserving}を用いて命令列を組み立てることにより、コンパイラは不必要なスタック命令を
回避することが可能になります。これはまた\code{save}と\code{restore}の命令を\code{preserving}手続の
中で生成するか、しないかの詳細を分離し、個別のコード生成器それぞれを書く場合に
浮かび上がる考慮点から隔離します。実際に\code{save}と\code{restore}の命令は明示的には
コード生成器により生成されることはありません。

原理上は、命令列を単純に命令のリストとして表現できるでしょう。
\code{append\-/instruction\-/sequences}はそうすると命令列の組み立てを通常のリストの
\code{append}にて行うことができます。するとしかし、\code{preserving}は複雑な命令に
なります。それが各命令列に対し、レジスタをどのように使用するかの分析を行わな
ければならないためです。また複雑であると同様に\code{preserving}が非効率にもなります。
各命令列の引数をも分析しなければならなくなるためです。例えこれらの列自身が
\code{preserving}の呼出により構築されていて、それらの部品が既に分析されていてもです。
そのような分析の繰り返しを防ぐために、各命令列とそのレジスタ使用に関する情報とを
結び付けます。基本的な命令列を構築する時に、私達はこの情報を明示的に与えます。
そして命令列を接続する手続は列の組み合わせのために、レジスタ使用の情報を
構成部品である列に結び付けられた情報から引き出します。


命令列は3つの情報を持ちます。

\begin{itemize}

\item
命令列内の命令が実行される前に初期化しなければならないレジスタ集合(これらのレジスタは
命令列により\newterm{needed}(必要とされる)と述べられる)

\item
列内の命令によりその値が変更されるレジスタ集合

\item
列内の実際の命令(\newterm{statements}(\jnewterm{命令文})とも呼ばれる)

\end{itemize}

\noindent
命令列をその3つの部品として表現します。命令列のコンストラクタは従って以下のようになります。

\begin{scheme}
(define (make-instruction-sequence
         needs modifies statements)
  (list needs modifies statements))
\end{scheme}

\noindent
喩えば、現在の環境内で変数\code{x}の値を探し、その結果を\code{val}に割り当てて戻る2つの命令の列は
レジスタ\code{env}と\code{continue}が初期化される必要があり、そしてレジスタ\code{val}を変更します。
この列は従って以下のように構築されます。

\begin{scheme}
(make-instruction-sequence 
 '(env continue)
 '(val)
 '((assign val
           (op lookup-variable-value) (const x) (reg env))
   (goto (reg continue))))
\end{scheme}

\noindent
時々、命令文が無い命令列を構築する必要があります。

\begin{scheme}
(define (empty-instruction-sequence)
  (make-instruction-sequence '() '() '()))
\end{scheme}

\noindent
命令列を組み立てる手続は\link{Section 5.5.4}に示します。

\begin{quote}
\heading{\phantomsection\label{Exercise 5.31}Exercise 5.31:}
手続適用を評価する場合において、明示的制御評価機は常にオペレータの評価の周りで
\code{env}レジスタの保存と復元を行う。また各オペランドの評価の評価の周りでも(最後の1つを除いて)
\code{env}の保存と復元を行う。そえいオペランド列の評価の周りでは\code{proc}の保存と
復元を行う。以下の各組み合わせに対し、これらの\code{save}と\code{restore}命令のどれが
余分であり、従ってコンパイラの\code{preserving}の仕組みにより削減できるかを述べよ。

\begin{scheme}
(f 'x 'y)
((f) 'x 'y)
(f (g 'x) y)
(f (g 'x) 'y)
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.32}Exercise 5.32:}
\code{preserving}の仕組みを用いた場合、コンパイラは組み合わせのオペレータの評価の周りで
オペレータがシンボルの場合に\code{env}の保存と復元を削減することができる。
またそのような最適化を評価機の中に構築することもできるだろう。実際に、\link{Section 5.4}の
明示的制御評価機は既に似たような最適化をオペランドの無い組み合わせを特別な場合として
扱うことで実行している。

\begin{enumerate}[a]

\item
明示的制御評価機を拡張しオペレータがシンボルである組み合わせを別のクラスの
式として認識するようにせよ。そしてこの事実をそのような式の評価において活用
するようにせよ。

\item
Alyssa P. Hackerは評価機を拡張し、組込むことができる全てのコンパイラの最適化を
より多くの特別な場合として認識することで、コンパイルの利点全体を
無くすことができると提案した。あなたはこの考えをどう思うか?

\end{enumerate}
\end{quote}

\subsection{式のコンパイル}
\label{Section 5.5.2}


この節と次の節では、\code{compile}手続が割り振るコード生成器を実装します。

\subsubsection*{リンクコードのコンパイル}

一般的に、各コード生成器の出力は手続\code{compile\-/linkage}により生成された、
要求されたリンク記述子を実装した命令で終わります。もしリンク記述子が\code{return}なら、
命令\code{(goto (reg continue))}を生成せねばなりません。これは\code{continue}レジスタを
必要とし、他のレジスタを変更はしません。もしリンク記述子が\code{next}なら、何の追加の
命令も必要ありません。さもなければ、リンク記述子はラベルであり、そのラベルへの
\code{goto}を生成します。この命令はレジスタを必要とせず、変更もしません。\footnote{
この手続は
\newterm{backquote}(\jnewterm{バッククォート}、または\newterm{quasiquote}(\jnewterm{擬似クォート}))と呼ばれるLispの機能を使用します。
これはリストを構築するのに便利です。リストの前にバッククォート記号を置くことは
クォートすることにとても似ていますが、リスト内のカンマで合図された物全てを評価することが
異なります。


例えば、もし\code{linkage}の値がシンボル\code{branch25}の場合、以下の式は

\begin{smallscheme}
`((goto (label ,linkage)))
\end{smallscheme}


次のリストとして評価されます。

\begin{smallscheme}
((goto (label branch25)))
\end{smallscheme}


同様に、もし\code{x}の値がリスト\code{(a b c)}ならば、以下の式は

\begin{smallscheme}
`(1 2 ,(car x))
\end{smallscheme}


次のリストとして評価されます。

\begin{smallscheme}
(1 2 a)
\end{smallscheme}
}

% For example, if the value of \code{linkage} is the symbol\\ \code{branch25},
% then the expression\\ \code{`((goto (label ,linkage)))}\\ evaluates to the
% list\\ \code{((goto (label branch25)))}.\\ Similarly, if the value of \code{x}
% is the list \code{(a b c)}, then\\ \code{`(1 2 ,(car x))}\\ evaluates to the
% list\\ \code{(1 2 a)}.}

\begin{scheme}
(define (compile-linkage linkage)
  (cond ((eq? linkage 'return)
         (make-instruction-sequence '(continue) '()
          '((goto (reg continue)))))
        ((eq? linkage 'next)
         (empty-instruction-sequence))
        (else
         (make-instruction-sequence '() '()
          `((goto (label ,linkage)))))))
\end{scheme}

\noindent
リンクのコードが命令列に対し\code{preserving}により\code{continue}レジスタを維持しながら
追加されます。リンク記述子\code{return}が\code{continue}レジスタを必要とするためです。
もし与えられた命令列が\code{continue}を変更し、リンクのコードがそれを必要とする場合、
\code{continue}は保存と復元が行われます。

\begin{scheme}
(define (end-with-linkage linkage instruction-sequence)
  (preserving '(continue)
   instruction-sequence
   (compile-linkage linkage)))
\end{scheme}

\subsubsection*{単純な式のコンパイル}

自己評価型式、クォート、変数に対するコード生成器は
必要な値をターゲットのレジスタに割り当てリンク記述子により指示されたように進める
命令列を構築します。

\begin{scheme}
(define (compile-self-evaluating exp target linkage)
  (end-with-linkage linkage
   (make-instruction-sequence '() (list target)
    `((assign ,target (const ,exp))))))
(define (compile-quoted exp target linkage)
  (end-with-linkage linkage
   (make-instruction-sequence '() (list target)
    `((assign ,target (const ,(text-of-quotation exp)))))))
(define (compile-variable exp target linkage)
  (end-with-linkage linkage
   (make-instruction-sequence '(env) (list target)
    `((assign ,target
              (op lookup-variable-value)
              (const ,exp)
              (reg env))))))
\end{scheme}

\noindent
これら全ての代入命令はターゲットレジスタを変更します。また変数の検索を行う物は
\code{env}レジスタを必要とします。

代入と定義はインタプリタの物と同様に扱われます。再帰的に変数に割り当てられる値を求める
コードを生成し、それに対して実際に変数の設定、または定義を行う物と式全体の値(シンボル\code{ok})を割り当てる
物の2つの命令列を接続します。再帰的なコンパイルはターゲット\code{val}とリンク記述子\code{next}を持つので
コードはその結果を\code{val}に入れ、その後に接続されたコードを用いて続けられます。接続は
\code{env}を維持(preserving)している間に行われます。環境が変数の設定、または定義のため
必要なためです。また変数の値のためのコードは複雑な式のコンパイルと成り得るため任意の方法で
レジスタを変更する可能性があります。

\begin{scheme}
(define (compile-assignment exp target linkage)
  (let ((var (assignment-variable exp))
        (get-value-code
         (compile (assignment-value exp) 'val 'next)))
    (end-with-linkage linkage
     (preserving '(env)
      get-value-code
      (make-instruction-sequence '(env val) (list target)
       `((perform (op set-variable-value!)
                  (const ,var)
                  (reg val)
                  (reg env))
         (assign ,target (const ok))))))))

(define (compile-definition exp target linkage)
  (let ((var (definition-variable exp))
        (get-value-code
         (compile (definition-value exp) 'val 'next)))
    (end-with-linkage linkage
     (preserving '(env)
      get-value-code
      (make-instruction-sequence '(env val) (list target)
       `((perform (op define-variable!)
                  (const ,var)
                  (reg val)
                  (reg env))
         (assign ,target (const ok))))))))
\end{scheme}

\noindent
接続された2つの命令列は\code{env}と\code{val}を必要とし、ターゲットを変更します。
例え\code{env}をこの列のために維持したとしても、\code{val}は維持しません。
\code{get\-/value\-/code}が明示的にその結果をこの命令列のために\code{val}に配置するように
設計されているためです。(実際には、もし\code{val}を維持した場合、バグを持つことになります。
これにより直前の\code{val}の中身が\code{get\-/value\-/code}の実行直後に復元されるためです。)

\subsubsection*{条件式のコンパイル}

与えられたターゲットとリンク記述子と共にコンパイルされる\code{if}式のためのコードは
以下の形式を持ちます。

\begin{scheme}
~\( \dark \langle \)~~\emph{述語のコンパイル, ターゲット \code{val}, リンク記述子 \code{next}}~~\( \dark \rangle \)~
 (test (op false?) (reg val))
 (branch (label false-branch))
true-branch
 ~\( \dark \langle \)~~\emph{結果部 与えられたターゲット
  与えられたリンク記述子 又は \code{after\-/if}}~~\( \dark \rangle \)~
false-branch
 ~\( \dark \langle \)~~\emph{代替部 与えられたターゲット リンク記述子}~~\( \dark \rangle \)~
after-if
\end{scheme}

\noindent
このコードを生成するために、述語、結果部、代替部をコンパイルし、結果のコードを
述語の結果をテストするコードと新しく生成された真と偽の分岐をマークするラベルと
条件文の最後と共に組み立てます。\footnote{
私達は単にラベル\code{true\-/branch},
\code{false\-/branch}, \code{after\-/if}を上で示されたように使うことはできません。なぜなら
プログラム中に\code{if}文は複数存在する可能性があるためです。\code{make\-/label}は
シンボルを引数として、与えられたシンボルで始まる取り新しいシンボルを返します。
例えば、\code{(make\-/label 'a)}に対する連続した呼出は\code{a1}, \code{a2}, \( \dots \)を返します。
\code{make\-/label}はクエリ言語における一意の変数名の生成と同様に、以下の様に実装する
ことができます。

\begin{smallscheme}
(define label-counter 0)
(define (new-label-number)
  (set! label-counter (+ 1 label-counter))
  label-counter)
(define (make-label name)
  (string->symbol
    (string-append (symbol->string name)
                   (number->string (new-label-number)))))
\end{smallscheme}
}
このコードの準備では、テストが偽である場合、真の分岐へと飛ぶ必要があります。
唯一、微妙に複雑なのは真の分岐がリンク記述子をどのように扱うかについてです。
もし条件文のリンク記述子が\code{return}、またはラベルの場合、真と偽の分岐は両方共
これと同じリンク記述子を用います。もしリンク記述子が\code{next}なら、真の分岐は
偽の分岐を飛び越し条件文の最後へと飛ぶコードで終わります。

\begin{scheme}
(define (compile-if exp target linkage)
  (let ((t-branch (make-label 'true-branch))
        (f-branch (make-label 'false-branch))
        (after-if (make-label 'after-if)))
    (let ((consequent-linkage
           (if (eq? linkage 'next) after-if linkage)))
      (let ((p-code (compile (if-predicate exp) 'val 'next))
            (c-code
             (compile
              (if-consequent exp) target 
                                  consequent-linkage))
            (a-code
             (compile (if-alternative exp) target linkage)))
        (preserving '(env continue)
         p-code
         (append-instruction-sequences
          (make-instruction-sequence '(val) '()
           `((test (op false?) (reg val))
             (branch (label ,f-branch))))
          (parallel-instruction-sequences
           (append-instruction-sequences t-branch c-code)
           (append-instruction-sequences f-branch a-code))
          after-if))))))
\end{scheme}

\noindent
\code{env}は述語コードの間維持されます。真と偽の分岐で必要になるかもしれないためです。
そして\code{continue}もそれら分岐内でリンクのためのコードにて使用されるかもしれないため維持されます。
真と偽の分岐のためのコード(順には実行されません)は\link{Section 5.5.4}で説明される
専用の結合器、\code{parallel\-/instruction\-/sequences}を使用して接続されます。

\code{cond}は派生式であることに注意してください。そのためコンパイラが取り扱いのために
必要なこと全ては(\link{Section 4.1.2}の)\code{cond\-/>if}変換器を適用して、結果の\code{if}式を
コンパイルするだけです。

\subsubsection*{列のコンパイル}

列のコンパイル(手続のボディ、または明示的な\code{begin}式)はそれらの評価を並列化します。
列の各式は次の条件でコンパイルされます。最後の式は列に対して指示されたリンク記述子を
用いて。他の式はリンク記述子\code{next}を用いて(列の残りを実行するために)。
個別の式の命令列は接続され単一の命令列を形成します。(列の残りのために必要な)\code{env}と
(列の終わりのリンクコードで必要な可能性のある)\code{continue}は維持されます。

\begin{scheme}
(define (compile-sequence seq target linkage)
  (if (last-exp? seq)
      (compile (first-exp seq) target linkage)
      (preserving '(env continue)
       (compile (first-exp seq) target 'next)
       (compile-sequence (rest-exps seq) target linkage))))
\end{scheme}

\subsubsection*{\code{lambda}式のコンパイル}

\code{lambda}式は手続を構築します。\code{lambda}式のためのオブジェクトコードは
以下の形式に従わねばなりません。

\begin{scheme}
~\( \dark \langle \)~~\emph{手続オブジェクトの構築}~ 
 ~\emph{ターゲットレジスタにそれを割り当てる}~~\( \dark \rangle \)~
~\( \dark \langle \)~~\var{\dark リンク}~~\( \dark \rangle \)~
\end{scheme}

\noindent
\code{lambda}式をコンパイルする時、手続のボディのためのコードも生成します。
例えボディが手続構築時に実行されなくても、オブジェクトコードの中の
\code{lambda}式のコードの直後に挿入しておくことは便利です。
もし\code{lambda}式に対するリンク記述子がラベルか\code{return}ならば、このことに問題はありません。
しかし、もしリンク記述子が\code{next}ならば、手続のボディの後ろに挿入されたラベルへ飛ぶリンク記述子を
使用することによりボディに対するコードを回避する必要があります。従ってオブジェクト
コードは以下の形式になります。

\begin{scheme}
~\( \dark \langle \)~~\emph{手続オブジェクトの構築}~ 
 ~\emph{それをターゲットレジスタに割当}~~\( \dark \rangle \)~
 ~\( \dark \langle \)~~\emph{与えられたリンク記述子に対するコード}~~\( \dark \rangle \)~ ~\emph{または}~ ~\code{(goto (label after\-/lambda))}~
 ~\( \dark \langle \)~~\emph{手続ボディのコンパイル後コード}~~\( \dark \rangle \)~
after-lambda
\end{scheme}

\noindent
\code{compile\-/lambda}は手続のボディのコードが続く手続オブジェクトを構築するためのコードを
生成します。手続オブジェクトは実行時に現在の環境(定義時点での環境)をコンパイルされた
手続ボディのエントリポイント(新しく生成されたラベル)と共に
組み立てることで構築されます。\footnote{\label{Footnote 38}
\link{Section 4.1.3}で説明した
複合手続のための構造と同様に、コンパイル後の手続を表現するためのデータ構造を
実装するための機械語命令を必要とします。

\begin{smallscheme}
(define (make-compiled-procedure entry env)
  (list 'compiled-procedure entry env))
(define (compiled-procedure? proc)
  (tagged-list? proc 'compiled-procedure))
(define (compiled-procedure-entry c-proc) (cadr c-proc))
(define (compiled-procedure-env c-proc) (caddr c-proc))
\end{smallscheme}
}

\begin{scheme}
(define (compile-lambda exp target linkage)
  (let ((proc-entry (make-label 'entry))
        (after-lambda (make-label 'after-lambda)))
    (let ((lambda-linkage
           (if (eq? linkage 'next) after-lambda linkage)))
      (append-instruction-sequences
       (tack-on-instruction-sequence
        (end-with-linkage lambda-linkage
         (make-instruction-sequence '(env) (list target)
          `((assign ,target
                    (op make-compiled-procedure)
                    (label ,proc-entry)
                    (reg env)))))
        (compile-lambda-body exp proc-entry))
       after-lambda))))
\end{scheme}

\noindent
\code{compile\-/lambda}は\code{append\-/instruction\-/sequences}(\link{Section 5.5.4})ではなく、
特別な結合器\code{tack\-/on\-/instruction\-/sequence}を手続のボディと\code{lambda}式のコードを
接続するのに利用します。ボディは組み立てられた列が入力された時に実行される命令列の一部では
ないためです。そうではなく、それはただ、そこに置くことが便利だから、その列の中にあります。

\code{compile\-/lambda\-/body}は手続のボディのためのコードを構築します。
このコードはエントリポイントに対するラベルで開始します。次に来るのは
実行時の環境を手続のボディの評価を評価するために正しい環境へとスイッチする
命令列です。即ち、手続の定義環境であり、これは手続が呼ばれる時に利用される引数に
対する形式パラメタの束縛を含むように拡張されています。
これの後には、式の列のコードが来ます。これが手続のボディを作り上げます。
この列はリンク記述子\code{return}とターゲット\code{val}と共にコンパイルさるため、
手続の結果は\code{val}に入れらた状態で手続から戻ることで終わります。

\begin{scheme}
(define (compile-lambda-body exp proc-entry)
  (let ((formals (lambda-parameters exp)))
    (append-instruction-sequences
     (make-instruction-sequence '(env proc argl) '(env)
      `(,proc-entry
        (assign env
                (op compiled-procedure-env)
                (reg proc))
        (assign env
                (op extend-environment)
                (const ,formals)
                (reg argl)
                (reg env))))
     (compile-sequence (lambda-body exp) 'val 'return))))
\end{scheme}

\subsection{組み合わせのコンパイル}
\label{Section 5.5.3}

コンパイル処理の本質は手続適用のコンパイルです。与えられたターゲットとリンク記述子と
共にコンパイルされた組み合わせのコードは以下の形式を持ちます。

\begin{scheme}
~\( \dark \langle \)~~\emph{演算子のコンパイル, ターゲット \code{proc}, リンク記述子 \code{next}}~~\( \dark \rangle \)~
~\( \dark \langle \)~~\emph{オペランドを評価し、\code{argl}内に引数リストを構築}~~\( \dark \rangle \)~
~\( \dark \langle \)~~\emph{手続呼出のコンパイル}~ 
 ~\emph{与えられたターゲットとリンク記述子と共に}~~\( \dark \rangle \)~
\end{scheme}

\noindent
レジスタ\code{env}, \code{proc}, \code{argl}はオペレータ(演算子)とオペランドの評価の間に
保存と復元を行う必要があるかもしれません。ここだけがこのコンパイラにおいて
\code{val}以外のターゲットが指定される箇所であることに注意して下さい。

必要なコードは\code{compile\-/application}により生成されます。これは再帰的にオペレータを
コンパイルして\code{proc}に適用する手続を配置するコードを生成し、オペランドをコンパイルして
個別の適用の個々のオペランドを評価するコードを生成します。オペランドの命令列は
(\code{construct\-/arglist}により)\code{argl}に引数リストを構築するコードと共に組み合わされます。
そして結果となる引数リストのコードは手続のコードと(\code{compile\-/procedure\-/call}により生成された)
手続呼出を実行するコードと共に組み合わされます。コードの列の接続において、
\code{env}レジスタはオペレータの評価の周りにおいて維持(preserving)されなければなりません。
(オペレータの評価がオペランドの評価で必要とな\code{env}を変更する
可能性があるため)。そして\code{proc}レジスタは引数リストの周りで維持されなければなりません。
(オペランドの評価が実際の手続適用に必要な\code{proc}レジスタを変更するかもしれないため)。
\code{Continue}もまたその間中、維持されなければなりません。手続呼出のリンクコードが
必要とするためです。

\begin{scheme}
(define (compile-application exp target linkage)
  (let ((proc-code (compile (operator exp) 'proc 'next))
        (operand-codes
         (map (lambda 
                (operand) (compile operand 'val 'next))
              (operands exp))))
    (preserving '(env continue)
     proc-code
     (preserving '(proc continue)
      (construct-arglist operand-codes)
      (compile-procedure-call target linkage)))))
\end{scheme}

\noindent
引数リストを構築するためのコードは\code{val}内に評価して、次にその値を\code{argl}に蓄積される
引数リスト上に\code{cons}します。\code{argl}上に順に引数を\code{cons}するため、最後の引数から
開始し、最初のもので終わらなければなりません。そうすることで引数は結果リストの中に
最初から最後の順で現れることになります。この一連の評価のための設定を行うため、\code{argl}を
空に初期化することで命令を無駄にするのではなく、\code{argl}の初期値を構築する最初の
コード列を作成します。従って、引数リスト構築の一般的な形式は以下になります。

\begin{scheme}
~\( \dark \langle \)~~\emph{最後のオペランドのコンパイル, ターゲットは\code{val}}~~\( \dark \rangle \)~
(assign argl (op list) (reg val))
~\( \dark \langle \)~~\emph{次のオペランドのコンパイル, ターゲットは\code{val}}~~\( \dark \rangle \)~
(assign argl (op cons) (reg val) (reg argl))
~\( \dots \)~
~\( \dark \langle \)~~\emph{最初のオペランドのコンパイル, ターゲットは\code{val}}~~\( \dark \rangle \)~
(assign argl (op cons) (reg val) (reg argl))
\end{scheme}

\noindent
\code{argl}は各オペランドの評価の間、最初の1つを除いて維持しなければなりません。
(そうすることで、そこまで蓄積した引数を失わないように)。そして\code{env}は
(続きのオペランド評価での使用のため)各オペランドの評価の周りで、
最後の1つを除いて維持されなければなりません。

この引数コードのコンパイルは少しだけ巧妙です。評価する最初のオペランドの特別な
扱いと、\code{argl}と\code{env}を異なる箇所にて維持する必要性のためです。
\code{construct\-/arglist}手続は引数として個々のオペランドを評価するコードを取ります。
もしオペランドが全く無ければ、単純に以下の命令を発行します。

\begin{scheme}
(assign argl (const ()))
\end{scheme}

\noindent
そうでなければ、\code{construct\-/arglist}は\code{argl}を最後の引数で初期化するコードを
生成し、引数の残りを評価するコードを接続し、それらを相次いで\code{argl}の中に隣接させていきます。
引数を最後から最初へ処理するために、オペランドのコード列のリストを
\code{compile\-/application}により提供された順から逆順(reverse)にする必要があります。

\begin{scheme}
(define (construct-arglist operand-codes)
  (let ((operand-codes (reverse operand-codes)))
    (if (null? operand-codes)
        (make-instruction-sequence '() '(argl)
         '((assign argl (const ()))))
        (let ((code-to-get-last-arg
               (append-instruction-sequences
                (car operand-codes)
                (make-instruction-sequence '(val) '(argl)
                 '((assign argl (op list) (reg val)))))))
          (if (null? (cdr operand-codes))
              code-to-get-last-arg
              (preserving '(env)
               code-to-get-last-arg
               (code-to-get-rest-args
                (cdr operand-codes))))))))

(define (code-to-get-rest-args operand-codes)
  (let ((code-for-next-arg
         (preserving '(argl)
          (car operand-codes)
          (make-instruction-sequence '(val argl) '(argl)
           '((assign argl
              (op cons) (reg val) (reg argl)))))))
    (if (null? (cdr operand-codes))
        code-for-next-arg
        (preserving '(env)
         code-for-next-arg
         (code-to-get-rest-args (cdr operand-codes))))))
\end{scheme}

\subsubsection*{手続の適用}

組み合わせの要素を評価した後に、コンパイルされたコードは\code{proc}内の手続を
\code{argl}内の引数に適用しなければなりません。このコードは本質的に\link{Section 4.1.1}の
メタ循環評価機の\code{apply}手続、または\link{Section 5.4.1}の明示的制御評価機の
\code{apply\-/dispatch}エントリポイントと同じ割り振りを実行します。
適用する手続がプリミティブな手続であるか複合手続であるかを確認します。
プリミティブな手続に対しては、\code{apply\-/primitive\-/procedure}を使用します。
簡潔にこれがどのようにコンパイルされた手続を取り扱うのかについて見ていきます。
手続適用のコードは以下の形式を持ちます。

\begin{scheme}
(test (op primitive-procedure?) (reg proc))
 (branch (label primitive-branch))
compiled-branch
 ~\( \dark \langle \)~~\emph{与えられたターゲットと適切なリンク記述子と共に 
  手続をコンパイルするコード}~~\( \dark \rangle \)~
primitive-branch
 (assign ~\( \dark \langle \)~~\var{\dark target}~~\( \dark \rangle \)~
         (op apply-primitive-procedure)
         (reg proc)
         (reg argl))
 ~\( \dark \langle \)~~\var{\dark リンクコード}~~\( \dark \rangle \)~
after-call
\end{scheme}

\noindent
コンパイルされた分岐はprimitive-branchをスキップしなければならないことに注意して下さい。
従って、もし元の手続呼出のリンク記述子が\code{next}ならば、複合分岐はprimitive-branchの後に
挿入されたラベルへと飛ぶリンクコードを使用しなければなりません。(これは\code{compile\-/if}に
おいて、真の分岐のために使用されたリンクコードと同様です。)

\begin{scheme}
(define (compile-procedure-call target linkage)
  (let ((primitive-branch (make-label 'primitive-branch))
        (compiled-branch (make-label 'compiled-branch))
        (after-call (make-label 'after-call)))

    (let ((compiled-linkage
           (if (eq? linkage 'next) after-call linkage)))
      (append-instruction-sequences
       (make-instruction-sequence '(proc) '()
        `((test (op primitive-procedure?) (reg proc))
          (branch (label ,primitive-branch))))
       (parallel-instruction-sequences
        (append-instruction-sequences
         compiled-branch
         (compile-proc-appl target compiled-linkage))
        (append-instruction-sequences
         primitive-branch
         (end-with-linkage linkage
          (make-instruction-sequence '(proc argl)
                                     (list target)
           `((assign ,target
                     (op apply-primitive-procedure)
                     (reg proc)
                     (reg argl)))))))
       after-call))))
\end{scheme}

\noindent
\code{compile\-/if}の真と偽の分岐のような、プリミティブかつ、複合な分岐は通常の
\code{append\-/instruction\-/sequences}ではなく\code{parallel\-/instruction\-/sequences}を
用いて接続されます。それらは順には実行されないためです。

\subsubsection*{コンパイル済み手続の適用}

手続の適用を取り扱うコードはコンパイラの最も微妙な部分です。例えそれが生成する命令列が
とても短くても変わりません。(\code{compile\-/lambda}により構築されたような)コンパイルされた手続は
手続が開始する場所を指定するラベルであるエントリポイントを持ちます。
このエントリポイントにてコードは\code{val}に結果を求め、命令\code{(goto (reg continue))}を実行すること
により戻ります。従って与えられたターゲットとリンク記述子を伴なう(\code{compile\-/proc\-/appl}により生成される)
コンパイルされた手続の適用はリンク記述子がラベルであれば以下のようになります。

\begin{scheme}
(assign continue (label proc-return))
 (assign val (op compiled-procedure-entry) (reg proc))
 (goto (reg val))
proc-return
 (assign ~\( \dark \langle \)~~\var{\dark target}~~\( \dark \rangle \)~ (reg val))   ~\textrm{; ターゲットが\code{val}でなければ含まれる}~
 (goto (label ~\( \dark \langle \)~~\var{\dark リンク記述子}~~\( \dark \rangle \)~))   ~\textrm{; リンクコード}~
\end{scheme}

\noindent
またはリンク記述子が\code{return}の場合は次のとおりです。

\begin{scheme}
(save continue)
 (assign continue (label proc-return))
 (assign val (op compiled-procedure-entry) (reg proc))
 (goto (reg val))
proc-return
 (assign ~\( \dark \langle \)~~\var{\dark target}~~\( \dark \rangle \)~ (reg val))   ~\textrm{; ターゲットが\code{val}でなければ含まれる}~
 (restore continue)
 (goto (reg continue))         ~\textrm{; リンクコード}~
\end{scheme}

\noindent
このコードは手続が\code{proc\-/return}に戻るように\code{continue}を設定し、手続の
エントリポイントへと飛びます。\code{proc\-/return}のコードは手続の結果を\code{val}から
ターゲットレジスタへと(もし必要なら)転送し、次にリンク記述子により指定された
位置へと飛びます。(リンク記述子は常に\code{return}かラベルです。なぜなら
\code{compile\-/procedure\-/call}が複合手続の分岐のためのリンク記述子\code{next}を
\code{after\-/call}ラベルに置き換えるためです。)

実際には、もしターゲットが\code{val}でなければ、それはまさに私達のコンパイラが
生成するコードです。\footnote{実際に、ターゲットが\code{val}でなく、リンク記述子が
\code{return}である場合にはエラーを発します。私達がリンク記述子\code{return}を要求する
箇所は手続のコンパイル内のみです。そして私達の仕様は、手続はその値を\code{val}にて返す、です。}
しかし、通常はターゲットは\code{val}であり(コンパイラが異なるレジスタを指定する唯一の場合は
オペレータの評価のターゲットを\code{proc}にする時です)、そのため手続の結果は直接
ターゲットレジスタに入れられ、コピーを行う特別な位置へ戻る必要はありません。その代わりに、
手続が直接呼び出し元のリンク記述子により指定される場所へ直接``戻る''ように\code{continue}を
設定します。

\begin{scheme}
~\( \dark \langle \)~~\emph{\code{continue}にリンク記述子を設定}~~\( \dark \rangle \)~
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
\end{scheme}

\noindent
もしリンク記述子がラベルならば、手続がそのラベルに戻るように\code{continue}を設定します。
(つまり、上記の\code{proc\-/return}において手続の終端\code{(goto (reg continue))}が
\code{(goto (label <\var{linkage}>))}と等価になります。)

\begin{scheme}
(assign continue (label ~\( \dark \langle \)~~\var{\dark リンク記述子}~~\( \dark \rangle \)~))
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
\end{scheme}

\noindent
もしリンク記述子が\code{return}なら、\code{continue}を設定する必要は全くありません。
それは既に望まれた位置を持っています。(言い換えれば、手続の終端\code{(goto (reg
continue))}は\code{proc\-/return}の\code{(goto (reg continue))}が飛ぶはずだった場所へ
直接飛びます。)

\begin{scheme}
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
\end{scheme}

\noindent
このリンク記述子\code{return}の実装を用いて、コンパイラは末尾再帰のコードを生成します。
手続のボディの最後ステップとしての手続の呼出は直接移動を行いスタック上にどのような
情報も保存しません。

その代わりに手続呼出の場合をリンク記述子\code{return}とターゲット\code{val}を用いて、
上記で示されたように\code{val}以外のターゲットに対しても取り扱ったと仮定します。
これは末尾再帰を損うでしょう。それでも、私達のシステムは任意の式に対して同じ値を
与えます。しかし、私達が手続を呼ぶ度に、\code{continue}を保存し、呼出の後に
(必要の無い)保存の取消を呼び出すことになります。これらの余分な保存が入れ子の手続
呼出の間に蓄積されます。\footnote{コンパイラに末尾再帰のコードを生成させることは
簡単な考えのように見えるかもしれません。しかし一般的な言語のための多くのコンパイラは
C言語とPascalを含めて、これを行いません。従ってこれらの言語は反復プロセスを手続
呼出のみを用いて表現することができません。これらの言語における末尾再帰の困難さは
それらの実装がスタックを用いて手続の引数とローカル変数と同様にリターンアドレスを
も格納しているためです。この本で説明されているSchemeの実装は引数と変数をガベージ
コレクションされるようにメモリに保存します。変数と引数に対してスタックを使用する
理由は他のやり方によりガベージコレクションの必要の無い言語内で、その必要性を回避するからです。
そして一般的にはより効率的になると信じられています。実際には、最新のLispコンパイラは
末尾再帰を無効化せずにスタックを引数のために使用することができます。(このことの説明に
関しては\link{Hanson 1990}を参照して下さい)。またスタックの割当がそもそもガベージ
コレクションより効率的であるかどうかについての討論もいくつか存在します。しかし、
詳細はコンピュータアーキテクチャの委細に依存しているように見えます。(この問題の
反対の立場からの視点については\link{Appel 1987}と\link{Miller and Rozas 1994}を参照して下さい。)}

code{compile\-/proc\-/appl}は上記の手続適用のコードを生成します。これは呼出のためのターゲットが
\code{val}であるか、そしてリンク記述子が\code{return}であるかについてに依存する4つの場合について
考慮します。命令列が全てのレジスタを変更するために宣言されることについて注意して下さい。
手続のボディの実行が自由な形でレジスタを変更することができるためです。\footnote{
変数\code{all\-/regs}は全てのレジスタの名前のリストに対して束縛されます。

\begin{smallscheme}
(define all-regs '(env proc val argl continue))
\end{smallscheme}
}
またターゲットが\code{val}であり、リンク記述子が\code{return}の場合に対するコードの列は
\code{continue}を必要とすると宣言されていることに注意して下さい。例え\code{continue}が
明示的に2つの命令列の中で使用されていなくとも、私達がコンパイルされた手続を入力した
時に\code{continue}が正しい値を持つことを確実にしなければなりません。

\begin{scheme}
(define (compile-proc-appl target linkage)
  (cond ((and (eq? target 'val) (not (eq? linkage 'return)))
         (make-instruction-sequence '(proc) all-regs
           `((assign continue (label ,linkage))
             (assign val (op compiled-procedure-entry)
                         (reg proc))
             (goto (reg val)))))
        ((and (not (eq? target 'val))
              (not (eq? linkage 'return)))
         (let ((proc-return (make-label 'proc-return)))
           (make-instruction-sequence '(proc) all-regs
            `((assign continue (label ,proc-return))
              (assign val (op compiled-procedure-entry)
                          (reg proc))
              (goto (reg val))
              ,proc-return
              (assign ,target (reg val))
              (goto (label ,linkage))))))
        ((and (eq? target 'val) (eq? linkage 'return))
         (make-instruction-sequence 
          '(proc continue) 
          all-regs
          '((assign val (op compiled-procedure-entry)
                        (reg proc))
            (goto (reg val)))))
        ((and (not (eq? target 'val))
              (eq? linkage 'return))
         (error "return linkage, target not val: COMPILE"
                target))))
\end{scheme}

\subsection{命令列のコンパイル}
\label{Sec. 5.5.4}
\label{Section 5.5.4}

この節では命令列がどのように表現され、組み合わされるのかについての詳細を説明します。
\link{Section 5.5.1}から命令列が必要なレジスタのリスト、変更されるレジスタ、実際の命令のリスト
として表現されたことを思い出して下さい。またラベル(シンボル)を命令列の退化した場合だと
考慮します。これはどのレジスタも必要とせず、また変更しません。故に、命令列により必要とされる、または
変更されるレジスタを決定するために以下のセレクタを用います。

\begin{scheme}
(define (registers-needed s)
  (if (symbol? s) '() (car s)))
(define (registers-modified s)
  (if (symbol? s) '() (cadr s)))
(define (statements s)
  (if (symbol? s) (list s) (caddr s)))
\end{scheme}

\noindent
また与えられた命令列が与えられたレジスタを必要とするか、変更するかを決定するために
以下の述語を用います。

\begin{scheme}
(define (needs-register? seq reg)
  (memq reg (registers-needed seq)))
(define (modifies-register? seq reg)
  (memq reg (registers-modified seq)))
\end{scheme}

\noindent
これらの述語とセレクタを用いて、コンパイラを通して使用される様々な命令列の
結合器(combiner)を実装することができます。

基本的な結合器は\code{append\-/instruction\-/sequences}です。これは引数として順に実行される
任意の数の命令列を取り、命令文(statement)が全ての命令列の命令文を一緒に接続した命令文
である命令列を返します。結果の命令列により必要とされる、または変更されるレジスタの
決定が繊細な点になります。これは命令列のどれかにより変更されるレジスタが変更されます。
またこれは最初の命令列が実行する前に初期化されなければならないレジスタ(最初の命令列で
必要とされるレジスタ)に加えて、それに続く命令列により初期化されない(変更されない)
他の命令列により必要とされるレジスタ全てです。

命令列は\code{append\-/2\-/sequences}により一度に2つが接続されます。これは2つの命令列
\code{seq1}と\code{seq2}を取り、命令文が\code{seq1}の命令文の後に\code{seq2}の命令文が置かれる命令列を
返します。これの変更されたレジスタは\code{seq1}か\code{seq2}のどちらかにより変更された
レジスタです。そして必要とされるレジスタは\code{seq1}により必要とされるレジスタと
\code{seq2}で必要とされ\code{seq1}で変更されないレジスタを加えたものです。
(集合の命令を用いて、必要なレジスタの新しい集合は\code{seq1}により必要とされるレジスタの
集合と、\code{seq2}により必要とされるレジスタと\code{seq1}により変更されたレジスタの
差集合との、和集合です。)

\begin{scheme}
(define (append-instruction-sequences . seqs)
  (define (append-2-sequences seq1 seq2)
    (make-instruction-sequence
     (list-union
      (registers-needed seq1)
      (list-difference (registers-needed seq2)
                       (registers-modified seq1)))
     (list-union (registers-modified seq1)
                 (registers-modified seq2))
     (append (statements seq1) (statements seq2))))
  (define (append-seq-list seqs)
    (if (null? seqs)
        (empty-instruction-sequence)
        (append-2-sequences
         (car seqs)
         (append-seq-list (cdr seqs)))))
  (append-seq-list seqs))
\end{scheme}

\noindent
この手続はリストとして表現された集合を操作するためのいくつかの簡単な命令を使います。
\link{Section 2.3.3}で説明された(順序無し)集合表現と同様です。

\begin{scheme}
(define (list-union s1 s2)
  (cond ((null? s1) s2)
        ((memq (car s1) s2) (list-union (cdr s1) s2))
        (else (cons (car s1) (list-union (cdr s1) s2)))))
(define (list-difference s1 s2)
  (cond ((null? s1) '())
        ((memq (car s1) s2) (list-difference (cdr s1) s2))
        (else (cons (car s1)
                    (list-difference (cdr s1) s2)))))
\end{scheme}

\noindent
\code{preserving}は2つ目の主な命令列結合器ですが、レジスタのリスト\code{regs}と順に実行する2つの命令列
\code{seq1}と\code{seq2}を取ります。これは\code{seq1}の命令文(statements)のその後に
\code{seq2}の命令文が続く命令文を持つ命令列を返します。この命令文には\code{seq1}により
変更されるが\code{seq2}で必要とされる\code{regs}内のレジスタを守るために\code{seq1}の周りに
適切な\code{save}と\code{restore}が追加されます。これを達成するために、\code{preserving}は
最初に必要とされる\code{save}とそれに続く\code{seq1}、それに続く必要とされる\code{restore}を
持つ命令列を作ります。この命令列は\code{seq1}により必要とされるレジスタに加えて
レジスタの保存と復元を必要とします。そして\code{seq1}で変更されたレジスタを保存と
回復が行われるものを除いて変更します。次に、この増補された命令列と\code{seq2}が通常の
方法で接続されます。以下の手続はこの戦略を、維持されるべきレジスタのリストを横断しながら
再帰的に実装します。\footnote{\code{preserving}が\code{append}を3つの引数と共に呼び出すことに
注意して下さい。この本に表われる\code{append}の定義は2つの引数しか受け付けませんが、
Schemeの標準は任意の数の引数を取る\code{append}手続を提供します。}

\begin{scheme}
(define (preserving regs seq1 seq2)
  (if (null? regs)
      (append-instruction-sequences seq1 seq2)
      (let ((first-reg (car regs)))
        (if (and (needs-register? seq2 first-reg)
                 (modifies-register? seq1 first-reg))
            (preserving (cdr regs)
             (make-instruction-sequence
              (list-union (list first-reg)
                          (registers-needed seq1))
              (list-difference (registers-modified seq1)
                               (list first-reg))
              (append `((save ,first-reg))
                      (statements seq1)
                      `((restore ,first-reg))))
             seq2)
            (preserving (cdr regs) seq1 seq2)))))
\end{scheme}

\noindent
別の命令列結合器である\code{tack\-/on\-/instruction\-/sequence}は\code{compile\-/lambda}により
手続のボディを他の命令列に接続するために使用されます。手続のボディは組み合わされた列の
一部として実行されるための``インライン''形式ではないため、それによるレジスタの使用は
それが組込まれる命令列のレジスタ使用に影響を与えません。従って手続ボディの必要な、また
変更されるレジスタの集合は別の命令列に接続する時に無視されます。

\begin{scheme}
(define (tack-on-instruction-sequence seq body-seq)
  (make-instruction-sequence
   (registers-needed seq)
   (registers-modified seq)
   (append (statements seq)
           (statements body-seq))))
\end{scheme}

\noindent
\code{compile\-/if}と\code{compile\-/procedure\-/call}は\code{parallel\-/instruction\-/sequences}と
呼ばれる特別な結合器を使用してテストに続く二者択一の分岐を接続します。2つの分岐は
絶対に順には実行されません。どんなテストの評価に対しても、一方か、別の一方に入ります。
このため、2つ目の分岐により必要とされるレジスタは
例えもしこれらが1つ目の分岐により変更されようとも依然として結合後の命令列でも必要とします。

\begin{scheme}
(define (parallel-instruction-sequences seq1 seq2)
  (make-instruction-sequence
   (list-union (registers-needed seq1)
               (registers-needed seq2))
   (list-union (registers-modified seq1)
               (registers-modified seq2))
   (append (statements seq1)
           (statements seq2))))
\end{scheme}

\subsection{コンパイルされたコードの例}
\label{Section 5.5.5}

これでコンパイラの全ての要素について学び終えました。
ここまでのものがどのように御互いに組合せられるのかを見るためにコンパイル済みのコードの例を
試してみましょう。再帰\code{factorial}手続の定義を\code{compile}を呼ぶことでコンパイルしてみます。

\begin{scheme}
(compile
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n)))
 'val
 'next)
\end{scheme}

\noindent
\code{define}式の値はレジスタ\code{val}に配置されなければならないと指定しました。
私達は\code{define}を実行した後にコンパイル済みコードが何を行うのか気にしません。
そのためリンク記述子に対する\code{next}の選択は気まぐれです。

\code{compile}は式が定義であるかを判断します。そのため\code{compile\-/definition}を
呼び出し(ターゲット\code{val}に対し)割り当てられるべき値を求めるコードをコンパイルします。
続いて定義を導入するコード、さらに\code{define}の値(シンボル\code{ok})をターゲットレジスタに
入れるコード、最後にリンクコードが続きます。\code{env}は値の演算の周りで維持されます。
定義の導入のために必要とされるためです。今回のリンク記述子は\code{next}ですから、
リンクコードは存在しません。従ってコンパイルされたコードの骨格は以下のようになります。

\begin{scheme}
~\( \dark \langle \)~~\emph{値を求めるコードで変更されるなら\code{env}を保存}~~\( \dark \rangle \)~
  ~\( \dark \langle \)~~\emph{定義値、ターゲット\code{val}、
   リンク記述子\code{next}のコンパイル}~~\( \dark \rangle \)~
  ~\( \dark \langle \)~~\emph{上で保存したなら\code{env}の復元}~~\( \dark \rangle \)~
  (perform (op define-variable!)
           (const factorial)
           (reg val)
           (reg env))
  (assign val (const ok))
\end{scheme}

\noindent
変数\code{factorial}に対する値を生成するためにコンパイルされる式は、値が階乗を計算する
手続である\code{lambda}式です。\code{compile}は\code{compile\-/lambda}を呼ぶことによりこれを
扱います。\code{compile\-/lambda}は手続のボディをコンパイルし、それに新しいエントリポイントと
してラベル付けを行い、新しいエントリポイントの手続ボディを実行時環境と組み合わせ、
結果を\code{val}に割り当てるコードを生成します。次に命令列はこの時点で挿入された、
このコンパイルされたコードをスキップします。手続のコードそれ自体は手続定義環境を
形式パラメタ\code{n}を手続の引数に束縛するフレームにより拡張することから始めます。
その次に実際の手続のボディが来ます。変数の値のためのこのコードは\code{env}レジスタを
変更しませんので、上で示された任意の\code{save}と\code{restore}は生成されません。
(\code{entry2}における手続のコードはこの時点では実行されません。そのため、その\code{env}の
使用は無関係です)。従って、コンパイルされたコードの骨組は以下のようになります。

\begin{scheme}
  (assign val
          (op make-compiled-procedure)
          (label entry2)
          (reg env))
  (goto (label after-lambda1))
entry2
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env
          (op extend-environment)
          (const (n))
          (reg argl)
          (reg env))
  ~\( \dark \langle \)~~\emph{手続ボディのコンパイル}~~\( \dark \rangle \)~
after-lambda1
  (perform (op define-variable!)
           (const factorial)
           (reg val)
           (reg env))
  (assign val (const ok))
\end{scheme}

\noindent
手続のボディは常に(\code{compile\-/lambda\-/body}により)、ターゲット\code{val}と
リンク記述子\code{return}を用いる命令列としてコンパイルされます。今回の場合の
命令列は単一の\code{if}式から成り立ちます。

\begin{scheme}
(if (= n 1)
    1
    (* (factorial (- n 1)) n))
\end{scheme}

\noindent
\code{compile\-/if}は最初に述語を演算し(ターゲットは\code{val})、次にその結果を確認して
述語が偽であれば真の分岐を回避します。\code{env}と\code{continue}が述語のコードの周りで
維持されます。それらが\code{if}式の残りの部分で必要となる可能性があるためです。
\code{if}式が手続のボディを構成する命令列内の最後の式であるため(そしてただ1つの式であるため)、
そのターゲットは\code{val}で、リンク記述子は\code{return}になります。そのため真と偽の両方の
分岐がターゲット\code{val}とリンク記述子\code{return}と共にコンパイルされます。
(言い換えれば、どちらかの分岐により値が演算される条件文の値がその手続の値です。)

\begin{scheme}
~\( \dark \langle \)~~\emph{述語により変更され、分岐により必要とされるなら 
 \code{continue}, \code{env}を保存する}~~\( \dark \rangle \)~
  ~\( \dark \langle \)~~\emph{述語, ターゲット\code{val}, リンク記述子\code{next}のコンパイル}~~\( \dark \rangle \)~
  ~\( \dark \langle \)~~\emph{上で保存したなら\code{continue}, \code{env}を復元する}~~\( \dark \rangle \)~
  (test (op false?) (reg val))
  (branch (label false-branch4))
true-branch5
  ~\( \dark \langle \)~~\emph{真の分岐, ターゲット\code{val}, リンク記述子\code{return}のコンパイル}~~\( \dark \rangle \)~
false-branch4
  ~\( \dark \langle \)~~\emph{偽の分岐, ターゲット\code{val}, リンク記述子\code{return}のコンパイル}~~\( \dark \rangle \)~
after-if3
\end{scheme}

\noindent
述語\code{(= n 1)}は手続の呼出です。これはオペレータ(シンボル\code{=})を探し、その値を
\code{proc}内に配置します。次に引数\code{1}と変数\code{n}を\code{argl}に集めます。そして
\code{proc}がプリミティブ、または複合手続を含むかどうかをテストし、それに応じて
プリミティブの分岐か複合の分岐へ飛びます。両方の分岐がラベル\code{after\-/call}にて
再開します。オペレータとオペランドの評価の周りでレジスタを維持する必要性は
どのレジスタも保存することにはなりません。今回の場合はそれらの評価は問題となる
レジスタを変更しないためです。

\begin{scheme}
  (assign proc
          (op lookup-variable-value) (const =) (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val
          (op lookup-variable-value) (const n) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch17))
compiled-branch16
  (assign continue (label after-call15))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch17
  (assign val
          (op apply-primitive-procedure)
          (reg proc)
          (reg argl))
after-call15
\end{scheme}

\noindent
真の分岐は定数1ですが、(ターゲット\code{val}とリンク記述子\code{return}と共に)以下の
ようにコンパイルされます。

\begin{scheme}
(assign val (const 1))
(goto (reg continue))
\end{scheme}

\noindent
偽の分岐のコードは別の手続呼出です。手続はシンボル\code{*}で、その引数は\code{n}と
別の手続呼出の結果(\code{factorial}の呼出)です。これらの呼出の全てが\code{proc}と\code{argl}、
それ自身のプリミティブと複合の分岐の準備を行います。\link{Figure 5.17}は手続
\code{factorial}の定義の完全なコンパイルを示します。述語の周りで可能性のある\code{continue}と\code{env}の
\code{save}と\code{restore}が実際に生成されていることに注意して下さい。これらのレジスタが
述語内の手続呼出にて変更され、また分岐内の手続呼び出しと\code{return}のリンクコードにより
必要とされるためです。

\begin{quote}
\heading{\phantomsection\label{Exercise 5.33}Exercise 5.33:}
上で与えられたものとは微妙に異なる以下の階乗手続の定義について考えよ。

\begin{scheme}
(define (factorial-alt n)
  (if (= n 1)
      1
      (* n (factorial-alt (- n 1)))))
\end{scheme}


この手続をコンパイルし結果のコードを\code{factorial}に対して生成されたコードと比べよ。
見つけた全ての違いについて説明せよ。どちらのプログラムが他方よりもより効率的に
実行するだろうか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.34}Exercise 5.34:}
反復階乗手続をコンパイルせよ

\begin{scheme}
(define (factorial n)
  (define (iter product counter)
    (if (> counter n)
        product
        (iter (* counter product)
              (+ counter 1))))
  (iter 1 1))
\end{scheme}


結果のコードに注釈を付け、一方のプロセスがスタック領域を増進させ、他方が一定の
スタック領域で実行される元となる、\code{factorial}の反復版と再帰版のコードの間の
本質的な違いを示せ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Figure 5.17}Figure 5.17:} \( \downarrow \) \code{factorial}手続定義のコンパイル結果

\begin{smallscheme}
~\textrm{;; 手続を構築し、手続のボディのコードを飛ばす}~
  (assign val
          (op make-compiled-procedure) 
          (label entry2) 
          (reg env))
  (goto (label after-lambda1))
entry2     ~\textrm{; \code{factorial}の呼出はここから入る}~
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env
          (op extend-environment) 
          (const (n)) 
          (reg argl) 
          (reg env))
~\textrm{;; 実際の手続のボディを開始する}~
  (save continue)
  (save env)
~\textrm{;; \code{(= n 1)}を求める}~
  (assign proc 
          (op lookup-variable-value) 
          (const =) 
          (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val 
          (op lookup-variable-value) 
          (const n) 
          (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch17))
compiled-branch16
  (assign continue (label after-call15))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch17
  (assign val 
          (op apply-primitive-procedure) 
          (reg proc) 
          (reg argl))
after-call15   ~\textrm{; ここで\code{val}は\code{(= n 1)}の結果を持つ}~
  (restore env)
  (restore continue)
  (test (op false?) (reg val))
  (branch (label false-branch4))
true-branch5  ~\textrm{; return 1}~
  (assign val (const 1))
  (goto (reg continue))
false-branch4
~\textrm{;; \code{(* (factorial (- n 1)) n)}を求めて返す}~
  (assign proc 
          (op lookup-variable-value) 
          (const *) 
          (reg env))
  (save continue)
  (save proc)   ~\textrm{; \code{*}手続を保存する}~
  (assign val 
          (op lookup-variable-value) 
          (const n) 
          (reg env))
  (assign argl (op list) (reg val))
  (save argl)   ~\textrm{; \code{*}の引数リストの一部を保存}~
~\textrm{;; \code{(factorial (- n 1))}を求める。これは\code{*}のもう一方の引数}~
  (assign proc
          (op lookup-variable-value) 
          (const factorial) 
          (reg env))
  (save proc)  ~\textrm{; \code{factorial}手続を保存}~
~\textrm{;; \code{(- n 1)}を求める。これは\code{factorial}に対する引数}~
  (assign proc 
          (op lookup-variable-value)
          (const -) 
          (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val 
          (op lookup-variable-value) 
          (const n) 
          (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch8))
compiled-branch7
  (assign continue (label after-call6))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch8
  (assign val 
          (op apply-primitive-procedure) 
          (reg proc) 
          (reg argl))
after-call6   ~\textrm{; ここで\code{val}は\code{(- n 1)}の結果を持つ}~
  (assign argl (op list) (reg val))
  (restore proc) ~\textrm{; \code{factorial}に戻す}~
~\textrm{;; \code{factorial}の適用}~
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch11))
compiled-branch10
  (assign continue (label after-call9))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch11
  (assign val 
          (op apply-primitive-procedure) 
          (reg proc) 
          (reg argl))
after-call9      ~\textrm{; ここで\code{val}は\code{(factorial (- n 1))}の結果を持つ}~
  (restore argl) ~\textrm{; \code{*}の引数リストの一部を復元}~
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc) ~\textrm{; \code{*}に戻す}~
  (restore continue)
~\textrm{;; \code{*}を適用しその値を返す}~
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch14))
compiled-branch13
~\textrm{;; ここの複合手続は末尾再帰で呼ばれることに注意すること}~
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch14
  (assign val 
          (op apply-primitive-procedure) 
          (reg proc) 
          (reg argl))
  (goto (reg continue))
after-call12
after-if3
after-lambda1
~\textrm{;; 手続を変数\code{factorial}に割り当てる}~
  (perform (op define-variable!) 
           (const factorial) 
           (reg val) 
           (reg env))
  (assign val (const ok))
\end{smallscheme}

\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.35}Exercise 5.35:}
どの式がコンパイルされると\link{Figure 5.18}に示されるコードを生成するか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Figure 5.18}Figure 5.18:} \( \downarrow \) コンパイラ出力の例。\link{Exercise 5.35}参照

\begin{smallscheme}
(assign val 
        (op make-compiled-procedure) 
        (label entry16) 
        (reg env))
  (goto (label after-lambda15))
entry16
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env
          (op extend-environment) 
          (const (x)) 
          (reg argl) 
          (reg env))
  (assign proc 
          (op lookup-variable-value) 
          (const +) 
          (reg env))
  (save continue)
  (save proc)
  (save env)
  (assign proc 
          (op lookup-variable-value) 
          (const g) 
          (reg env))
  (save proc)
  (assign proc 
          (op lookup-variable-value) 
          (const +) 
          (reg env))
  (assign val (const 2))
  (assign argl (op list) (reg val))
  (assign val 
          (op lookup-variable-value) 
          (const x) 
          (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch19))
compiled-branch18
  (assign continue (label after-call17))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch19
  (assign val 
          (op apply-primitive-procedure) 
          (reg proc) 
          (reg argl))
after-call17
  (assign argl (op list) (reg val))
  (restore proc)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch22))
compiled-branch21
  (assign continue (label after-call20))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch22
  (assign val 
          (op apply-primitive-procedure) 
          (reg proc) 
          (reg argl))
after-call20
  (assign argl (op list) (reg val))
  (restore env)
  (assign val 
          (op lookup-variable-value) 
          (const x) 
          (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc)
  (restore continue)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch25))
compiled-branch24
  (assign val 
          (op compiled-procedure-entry) 
          (reg proc))
  (goto (reg val))
primitive-branch25
  (assign val 
          (op apply-primitive-procedure) 
          (reg proc) 
          (reg argl))
  (goto (reg continue))
after-call23
after-lambda15
  (perform (op define-variable!) 
           (const f) 
           (reg val) 
           (reg env))
  (assign val (const ok))
\end{smallscheme}

\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.36}Exercise 5.36:}
私達のコンパイラが生成する組み合わせのオペランドに対する評価の順はどれか?
左から右であるか、右から左であるか、または何らかの他の順であるか?
コンパイラの中のどこがこの順を決定するか? コンパイラを変更し、それが何らかの
別の評価順を生成するようにせよ。(\link{Section 5.4.1}における明示的制御評価機の評価順の
議論を参考にせよ)。オペランドの評価順を変更することが引数リストを構築するコードの
効率にどのような影響があるか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.37}Exercise 5.37:}
スタック使用の最適化のためのコンパイラの\code{preserving}の仕組みを理解する1つの方法は
この考えを用いなかった場合にどんな余分な命令が生成されるかを見てみることだ。
\code{preserving}を変更し、常に\code{save}と\code{restore}の命令を生成するようにせよ。
いくつかの簡単な式をコンパイルし、生成された不必要なスタック命令を確認せよ。
\code{preserving}の仕組みが失われていないものから生成されたコードと比較せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.38}Exercise 5.38:}
私達のコンパイラは不必要なスタック命令を防ぐことに関して賢いものだ。しかし、
機械により提供されるプリミティブな命令を用いて言語のプリミティブな手続の
呼出をコンパイルすることに関しては全く賢くない。例えば、\code{(+ a 1)}を求める
ためにどれだけのコードがコンパイルされるか考えてみる。このコードは引数リストを
\code{argl}に準備し、(環境内でシンボル\code{+}を探すことにより見つけた)プリミティブな加算手続を
\code{proc}に入れる。そしてこの手続がプリミティブであるか複合であるかをテストする。
コンパイラは常にこのテストを実行するコードと、同様にプリミティブと複合の分岐の
ためのコード(内、一方のみが実行される)が生成される。私達はコントローラのプリミティブを
実装する部品を示さなかった。しかし、これらの命令が機械のデータパス内のプリミティブな
数値演算命令を利用することは仮定した。もしコンパイラがプリミティブを\newterm{open-code}
できたらどれだけ少ないコードが生成されたか考えよ。これはつまり、
もしこれらのプリミティブな機械語命令を直接使用するコードを生成することができれば、である。
式\code{(+ a 1)}は以下と同じくらい単純なものにコンパイルされるだろう。\footnote{私達は
同じシンボル\code{+}をソース言語の手続と機械語命令の両方を示すためにここで使用しました。
一般的に、ソース言語のプリミティブと機械のプリミティブの間に1対1の対応はありません。}

\begin{scheme}
(assign
 val (op lookup-variable-value) (const a) (reg env))
(assign val (op +) (reg val) (const 1))
\end{scheme}

この課題では私達のコンパイラを拡張し、選択されたプリミティブのopen-codeをサポートする。
特別な目的のコードがこれらのプリミティブな手続の呼出に対し、一般的な手続適用のコードの
代わりに生成される。これをサポートするためには、私達の機械に特別な引数レジスタ、
\code{arg1}と\code{arg2}を追加する。機械のプリミティブな数値演算子は入力を\code{arg1}と\code{arg2}から
得る。その結果は\code{val}, \code{arg1}, \code{arg2}のどれかに入れて良い。

コンパイラはソースプログラム内のopen-codeなプリミティブの適用を認識できなければ
ならない。\code{compile}手続に割り振りを追加し、
現在認識可能な予約語(特殊形式)に加えてこれらのプリミティブの名前を認識できるようにする。\footnote{プリミティブを
予約語に入れることは一般的には悪い考えです。そうするとユーザがこれらの名前を異なる
手続に束縛し直すことができなくなるためです。さらに、もし使用中のコンパイラに予約語を
追加すると、これらの名前で手続を定義した既存のプログラムが動作しなくなります。
この問題をどのように回避するかの見解については\link{Exercise 5.44}を参照して下さい。}
特殊形式のそれぞれに対してコンパイラはコード生成器を持つ。この課題ではopen-codeな
プリミティブのためのコード生成器の仲間を構築する。

\begin{enumerate}[a]

\item
open-codeなプリミティブ全ては特殊形式とは異なり、オペランドが評価されることを
必要とする。全てのopen-codeのコード生成器から使用されるコード生成器\code{spread\-/arguments}を書け。
\code{spread\-/arguments}はオペランドのリストを取り、与えられたオペランドを次に続く引数
レジスタをターゲットにコンパイルしなければならない。オペランドがopen-codeなプリミティブへの
呼出を含んでも良いことに注意すること。そのため引数レジスタはオペランド評価の間は
維持されなければならない。

\item
プリミティブな手続\code{=}, \code{*}, \code{-}, \code{+}のそれぞれに対してそのオペレータと
ターゲット、リンク記述子の組み合わせを取り引数をレジスタに入れ、与えられた
ターゲットをターゲットに取り、与えられたリンク記述子と共に命令を実行するコードを
生成するコード生成器を書け。2つのオペランドを扱う式を扱うのみで良い。
これらのコード生成器に対する割り振りを作成せよ。

\item
貴方の新しいコンパイラを階乗の例を用いて試してみよ。結果のコードをopen-code無しで
生成した結果と比較せよ。

\item
\code{+}と\code{*}のコード生成器を拡張し任意の数のオペランドを持つ式を取り扱えるようにせよ。
3つ以上のオペランドを持つ式は、それぞれが2つだけ入力を持つ命令の列にコンパイルしなけれ
ばならない。

\end{enumerate}
\end{quote}

\subsection{レキシカルアドレッシング}
\label{Section 5.5.6}

コンパイラにより実行される最も一般的な最適化の1つは変数検索の最適化です。
ここまで実装した私達のコンパイラは評価機の\code{lookup\-/variable\-/value}命令を用いる
コードを生成します。これは実行時環境を通してフレーム毎に取り組みながら、
変数を現在束縛されている全ての変数と比較することで変数の検索を行う。
この検索はもしフレームが深く入れ子になったり、変数の数が多い場合には高コストに
成り得ます。例えば以下の式を評価した結果の適用において、式\code{(* x y z)}の評価の
間に\code{x}の値を探す問題について考えみましょう。

\begin{scheme}
(let ((x 3) (y 4))
  (lambda (a b c d e)
    (let ((y (* a b x)) (z (+ c d x)))
      (* x y z))))
\end{scheme}

\noindent
\code{let}式は\code{lambda}の組み合わせのための単なる糖衣構文ですので、この式は以下と
等価です。

\begin{scheme}
((lambda (x y)
   (lambda (a b c d e)
     ((lambda (y z) (* x y z))
      (* a b x)
      (+ c d x))))
 3
 4)
\end{scheme}

\noindent
\code{lookup\-/variable\-/value}が\code{x}を検索する度に、シンボル\code{x}は \code{y}、または\code{z}に
\code{eq?}でないことを(最初のフレームで)確認しなければなりません。また
(2つ目のフレームにて)\code{a}, \code{b}, \code{c}, \code{d}, \code{e}についても同様に必要です。
差し当たり、私達のプログラムは\code{define}を使用しないと仮定します。つまり変数は
\code{lambda}の使用にのみ束縛されます。私達の言語はレキシカルスコープであるため、
任意の式のための実行時環境は式が現れるプログラムのレキシカルな(語彙的な)構造を
並列化する構造を持ちます。\footnote{これはもし内部定義を許可するのであれば、
それら全てを走査しない限りは正しくありません。\link{Exercise 5.43}を参照して下さい。}
従って、コンパイラは上の式を分析した時に、手続が適用される度に\code{(* x y z)}内の
変数\code{x}が現在のフレームから2つ外のフレームの最初の変数として見つかることを知ることができます。

私達は新しい種類の変数検索命令、\code{lexical\-/address\-/lookup}を発明することにより、この
事実を利用することができます。この命令は引数として環境と2つの数値から成る
\newterm{lexical address}(\jnewterm{レキシカルアドレス})を取ります。2つの数値は、いくつのフレームを
見送るかを指定する\newterm{frame number}とそのフレーム内でいくつの変数を見送るかを
指定する\newterm{displacement number}です。\code{lexical\-/address\-/lookup}は現在のフレームに
対して相対的なレキシカルアドレスに格納された変数の値を生成します。
もし私達の機械に\code{lexical\-/address\-/lookup}命令を追加したなら、コンパイラに対して
\code{lookup\-/variable\-/value}ではなく、この命令を使用して変数を参照するコードを生成させる
ことができます。同様に、コンパイルされたコードは\code{set\-/variable\-/value!}の代わりに
新しい\code{lexical\-/address\-/set!}命令を使用することができます。

そのようなコードを生成するためには、コンパイラは参照をコンパイルしようとする変数の
レキシカルアドレスを決定できなければなりません。プログラム中の変数のレキシカルアドレスは
それがコードのどこにあるのかに依存します。例えば、以下のプログラムでは式
\( \langle \)\var{e1}\( \kern0.08em\rangle \)のアドレスは(2, 0)です。
つまり、2フレーム後ろでそのフレームの最初の変数です。同じ地点で\code{y}はアドレス(0, 0)であり、
\code{c}はアドレス(1, 2)に存在します。式\( \langle \)\var{e2}\( \kern0.09em\rangle \)においては、
\code{x}は(1, 0)に、\code{y}は(1, 1)に、\code{c}は(0, 2)に存在します。

\begin{scheme}
((lambda (x y)
   (lambda (a b c d e)
     ((lambda (y z) ~\( \dark \langle \)~~\var{\dark e1}~~\( \dark \rangle \)~)
      ~\( \dark \langle \)~~\var{\dark e2}~~\( \dark \rangle \)~
      (+ c d x))))
 3
 4)
\end{scheme}

\noindent
コンパイラにとってレキシカルアドレスを使用する1つの方法は
\newterm{compile-time environment}(\jnewterm{コンパイル時環境})と呼ばれるデータ構造を管理することです。
これは実行時環境内にて特定の変数アクセス命令が実行された時に、どの変数がどのフレーム内の
どの位置に存在することになるのかを追跡します。コンパイル時環境はフレームのリストであり、
各フレームが変数の変数のリストを保持します。(もちろん値が束縛されない変数も存在します。
値はコンパイル時には計算されないためです)。コンパイル時環境は\code{compile}の追加の引数に
なり、各コード生成器に渡されます。\code{lambda}のボディがコンパイルされる時、
\code{compile\-/lambda\-/body}がコンパイル時環境を手続のパラメータを持つフレームにより拡張し、
ボディを構成する命令列がその拡張された環境を用いてコンパイルされます。コンパイルの各
時点にて、\code{compile\-/variable}と\code{compile\-/assignment}は適切なレキシカルアドレスを
生成するためにコンパイル時環境を使用します。

\link{Exercise 5.39}から\link{Exercise 5.43}は
コンパイラにレキシカルな検索を組込むためにこのレキシカルアドレス付けの戦略の草案を
どのようにして完了させるかについて説明します。\link{Exercise 5.44}はコンパイル時環境の
別の使用法を説明します。

\begin{quote}
\heading{\phantomsection\label{Exercise 5.39}Exercise 5.39:}
新しい検索命令を実装する\code{lexical\-/address\-/lookup}手続を書け。2つの引数、レキシカル
アドレスと実行時環境を取ること。そして指定したレキシカルアドレスに格納された
変数の値を返すこと。\code{lexical\-/address\-/lookup}はもし変数の値がシンボル\code{*unassigned*}ならば
エラーを発する。\footnote{これはもし内部定義を削除するためにこの検索手法を実装するので
あれば必要となる、変数検索に対する変更です(\link{Exercise 5.43})。レキシカルアドレスを
うまく動かすためにはこれらの定義を排除する必要があります。}また指定したレキシカル
アドレスの変数の値を変更する操作を実装する手続\code{lexical\-/address\-/set!}を書け。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.40}Exercise 5.40:}
コンパイラを変更し、上で説明されたコンパイル時環境を保存するようにせよ。
つまり、\code{compile}と多様なコード生成器の引数にcompile-time-environmentを
追加し、それを\code{compile\-/lambda\-/body}の中で拡張せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.41}Exercise 5.41:}
引数として変数とコンパイル時環境を取り、その環境に関するその変数のレキシカルアドレスを
返す手続\code{find\-/variable}を書け。例えば、上で示されたプログラムの断片において、
式\( \langle \)\var{e1}\( \kern0.08em\rangle \)をコンパイルしている間の
コンパイル時環境は\code{((y z) (a b c d e) (x y))}である。\code{find\-/variable}は以下を
生成しなければならない。

\begin{scheme}
(find-variable 'c '((y z) (a b c d e) (x y)))
~\textit{(1 2)}~
(find-variable 'x '((y z) (a b c d e) (x y)))
~\textit{(2 0)}~
(find-variable 'w '((y z) (a b c d e) (x y)))
~\textit{not-found}~
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.42}Exercise 5.42:}
\link{Exercise 5.41}の\code{find\-/variable}を使用して、\code{compile\-/variable}と
\code{compile\-/assignment}を書き直し、レキシカルアドレス命令を出力するようにせよ。
\code{find\-/variable}が\code{not\-/found}を返す場合においては(つまり、変数がコンパイル時
環境内には存在しない場合には)、コード生成器に対して以前と同じ環境命令を使用させ
ることで束縛を検索させなければならない。(コンパイル時に変数が見つからない唯一の
場所はグローバル環境である。これは実行時環境の一部であり、コンパイル時環境の
一部ではない。\footnote{レキシカルアドレスはグローバル環境内の変数をアクセスする
ためには利用できません。なぜなら、これらの名前は対話形式的に任意の時点で定義と
再定義が可能なためです。\link{Exercise 5.43}の内部定義走査を用いてコンパイラが
知ることができる定義は、グローバル環境に従うトップレベルのものだけです。
定義のコンパイルは、定義された名前がコンパイル時環境に入れることにはなりません。}
従って、もしあなたが望むなら、それらに対し\code{env}内の全ての実行時環境を探させる代わりに、
環境の命令に、命令\code{(op get\-/global\-/environment)}により獲得できるグローバル環境を
直接探させてもかまわない)。変更したコンパイラをこの節の最初の入れ子の\code{lambda}の
組み合わせのような、いくつかの簡単な事例を用いてテストせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.43}Exercise 5.43:}
\link{Section 4.1.6}においてブロック構造に対する内部定義は``実際の''\code{define}だと
考慮されるべきでないと主張した。そうではなく、手続のボディは通常の
\code{set!}を用いて正しい値に初期化された\code{lambda}の
変数のように、内部変数定義が導入されたかのように解釈されるべきである。
\link{Section 4.1.6}と\link{Exercise 4.16}はどのようにメタ循環インタプリタを変更して
内部定義を走査することで、これを達成するかを示した。コンパイラを変更し、
手続のボディをコンパイルする前にこれと同じ変形を実行するようにせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.44}Exercise 5.44:}
この節ではレキシカルアドレスを生成するためのコンパイル時環境の使用に焦点を合わせた。
しかしコンパイル時環境の他の使用法も存在する。例として、\link{Exercise 5.38}では
コンパイルされたコードの効率をopen-codeなプリミティブ手続により向上させた。
私達の実装はopen-codeな手続を予約語として扱った。もしプログラムがそのような名前を
再束縛するなら、\link{Exercise 5.38}にて説明された仕組みは依然としてプリミティブとして
open-codeし、新しい束縛を無視するだろう。例えば、以下の手続について考えてみる。

\begin{scheme}
(lambda (+ * a b x y)
  (+ (* a x) (* b y)))
\end{scheme}

\noindent
これは\code{x}と\code{y}の一次結合を求める。これを引数\code{+matrix}, \code{*matrix}、それに
4つの行列(matrix)と共に呼ぶこともあるだろう。しかし、open-codeなコンパイラは
依然として\code{(+ (* a x) (* b y))}内の\code{+}と\code{*}をプリミティブな\code{+}と\code{*}として
open-codeしてしまうだろう。open-codeなコンパイラを変更し、プリミティブな手続の
名前を含む式に対して正しいコードをコンパイルするために、コンパイル時環境を参考に
するようにせよ。(このコードはプログラムがこれらの名前に対して\code{define}や\code{set!}を
行わない限り正しく動くようになる。)
\end{quote}

\subsection{コンパイル済みコードと評価機の連結}
\label{Section 5.5.7}

私達はまだコンパイルされたコードを評価機にどのようにロードするか、またはどのように
実行するかについて説明していません。ここでは明示的制御評価機が\link{Section 5.4.4}の時点にて定義された
状態であると仮定します。\link{Footnote 38}で指定された追加の命令も含みます。
Scheme式をコンパイルし、結果としてのオブジェクトコードを評価機にロードし、評価機に
グローバル環境の中で実行させ、結果を表示し、評価機のドライバループへと入る手続
\code{compile\-/and\-/go}を実装します。また評価機を変更し、逐次翻訳された式がコンパイルされた
手続を逐次翻訳されたものと同じように呼ぶことができるようにもします。
するとコンパイルされた手続を機械に入れてそれを呼び出すことができます。

\begin{scheme}
(compile-and-go
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n))))
~\textit{;;; EC-Eval value:}~
~\textit{ok}~
~\textit{;;; EC-Eval input:}~
(factorial 5)
~\textit{;;; EC-Eval value:}~
~\textit{120}~
\end{scheme}

\noindent
評価機にコンパイルされた手続の取り扱いを可能にするには(例えば上記の\code{factorial}の呼出を評価すること)、
\code{apply\-/dispatch}(\link{Section 5.4.1})のコードを変更して、それがコンパイルされた手続を
(複合、またはプリミティブな手続から区別可能なものとして)認識し、制御を直接コンパイルされた
コードのエントリポイントへと移動させる必要があります。\footnote{もちろん、
逐次翻訳された手続と同様にコンパイルされた手続も複合(compound, 非プリミティブ)です。明示的
制御評価機で使用された用語との互換性のために、この節では``複合''を逐次翻訳された
(コンパイルされたの逆を)意味するものとして使用します。}

\begin{scheme}
apply-dispatch
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-apply))
  (test (op compound-procedure?) (reg proc))
  (branch (label compound-apply))
  (test (op compiled-procedure?) (reg proc))
  (branch (label compiled-apply))
  (goto (label unknown-procedure-type))
compiled-apply
  (restore continue)
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
\end{scheme}

\noindent
\code{compiled\-/apply}での\code{continue}の復元に注意して下さい。評価機は\code{apply\-/dispatch}にて
継続がスタックの一番上になるように準備されています。一方で、コンパイルされたコードの
エントリポイントは継続が\code{continue}の中にあることを期待しています。そのため、
\code{continue}はコンパイルされたコードが実行される前に復元されなければなりません。

評価機を開始した時にいくつかのコンパイルされたコードを実行することを可能にするために、
\code{branch}命令を評価機の最初に追加します。これはもし\code{flag}レジスタが設定されて
いれば、機械を新しいエントリポイントへと飛ばします。\footnote{
今や評価機は\code{branch}を
用いて開始するので、私達は常に評価機を開始する前に\code{flag}レジスタを初期化しなければ
なりません。機械を通常のREPLにて開始するためには、以下を用いることができます。

\begin{smallscheme}
(define (start-eceval)
  (set! the-global-environment (setup-environment))
  (set-register-contents! eceval 'flag false)
  (start eceval))
\end{smallscheme}
}

\begin{scheme}
(branch (label external-entry))      ~\textrm{; \code{flag}が立っていれば飛ぶ}~
read-eval-print-loop
  (perform (op initialize-stack))
  ~\( \dots \)~
\end{scheme}

\noindent
\code{external\-/entry}は機械が結果を\code{val}に入れ\code{(goto (reg continue))}で
終わる命令列の位置を持つ\code{val}と共に開始すると仮定します。
このエントリポイントで開始する場合、\code{val}で指定された位置へ飛びます。
しかし、最初に\code{continue}に実行が\code{print\-/result}に戻るように設定します。
\code{print\-/result}は\code{val}内の値を表示し、次に評価機のREPLの最初へと
飛びます。\footnote{
コンパイルされた手続はシステムが表示しようとするかもしれない
オブジェクトであるため、システムの表示命令(\link{Section 4.1.4}の)\code{user\-/print}も
変更し、コンパイルされた手続の構成部品を表示しようとしないようにします。

\begin{smallscheme}
(define (user-print object)
  (cond ((compound-procedure? object)
         (display (list 'compound-procedure
                        (procedure-parameters object)
                        (procedure-body object)
                        '<procedure-env>)))
        ((compiled-procedure? object)
         (display '<compiled-procedure>))
        (else (display object))))
\end{smallscheme}
}

\begin{scheme}
external-entry
  (perform (op initialize-stack))
  (assign env (op get-global-environment))
  (assign continue (label print-result))
  (goto (reg val))
\end{scheme}

\noindent
これで以下手続を用いて手続定義をコンパイルし、コンパイルされたコードを実行し、
手続を試行することができるようREPLを実行することができます。コンパイルされた
コードに\code{continue}内の位置に、\code{val}内の結果を持って戻って欲しいため、
式をターゲット\code{val}とリンク記述子\code{return}を用いてコンパイルします。
コンパイラにより生成されたオブジェクトコードを評価機で実行可能な命令に変形する
ために、レジスタマシンシミュレータ(\link{Section 5.2.2})の手続\code{assemble}を使用します。
次に\code{val}レジスタを命令のリストを指すように初期化し、\code{flag}を評価機が
\code{external\-/entry}へ飛ぶように設定し、評価機を開始します。

\begin{scheme}
(define (compile-and-go expression)
  (let ((instructions
         (assemble
          (statements
           (compile expression 'val 'return))
          eceval)))
    (set! the-global-environment (setup-environment))
    (set-register-contents! eceval 'val instructions)
    (set-register-contents! eceval 'flag true)
    (start eceval)))
\end{scheme}

\noindent
もし\link{Section 5.4.4}の終わりのようにスタック監視を設定したなら、
コンパイルされたコードのスタック使用量を調査できます。

\begin{scheme}
(compile-and-go
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n))))
~\textit{(total-pushes = 0 maximum-depth = 0)}~
~\textit{;;; EC-Eval value:}~
~\textit{ok}~
~\textit{;;; EC-Eval input:}~
(factorial 5)
~\textit{(total-pushes = 31 maximum-depth = 14)}~
~\textit{;;; EC-Eval value:}~
~\textit{120}~
\end{scheme}

\noindent
この例を、\link{Section 5.4.4}の終わりで示された同じ手続の逐次翻訳された版を
用いた\code{(factorial 5)}の評価と比べてみて下さい。
逐次翻訳された版は144回のpushと最大スタック深度28を必要としました。
これは私達のコンパイル戦略に起因する最適化を説明しています。

\subsubsection*{逐次翻訳とコンパイル}

この節のプログラムを用いることで、今では逐次翻訳とコンパイルの代替的な実行戦略
を実験することができます。\footnote{コンパイラを拡張してコンパイルされたコードに
逐次翻訳された手続の呼び出しを許可することでさらにうまく行うことができます。
\link{Exercise 5.47}を参照して下さい。}インタプリタは機械をユーザプログラムのレベルへと
上げます。コンパイラはユーザプログラムを機械語のレベルへと下げます。
私達はScheme言語を(またはどんなプログラミング言語も)機械語の上に構築された体系化の
目的を同じとした仲間だと見做すことができます。インタプリタは対話的なプログラム開発と
デバッグに最適です。プログラムのステップの実行がこれらの抽象化を用いて組織化され、
そのため、プログラマにとってより理解しやすくなります。コンパイルされたコードは
より速く実行することができます。プログラムのステップの実行が機械語を利用して体系化され、
コンパイラは自由に高いレベルの抽象化を近道する最適化を作ることができます。\footnote{
実行
戦略とは独立して、もしユーザプログラムを実行した場合にエラーに遭遇した時にシステムを
殺すことや間違った値を生成するおおを許可するのではなく、エラーが発見され、その旨が
伝えられることを望むのならば、明らかなオーバヘッドを経験することになります。
例えば、配列の境界外参照は実行する前に参照の有効性をチェックすることで発見することが
できます。しかし、チェックのオーバヘッドは配列参照自体の何倍ものコストに成り得ます。
そしてプログラマはそのようなチェックが望ましいかの決定において安全性よりもスピードに
重きを置きます。良いコンパイラはそのようなチェックを行うコードを生成することが
可能であるべきです。また冗長なチェックは回避し、プログラマにコンパイルされたコード内での
エラーチェックの範囲と型を制御できるようにするべきです。

CやC++のような人気のある言語のコンパイラはほとんど何も実行コードの中にエラーチェックの
命令を挿入しません。可能な限り速く実行するためです。結果として、プログラマに対して
明示的にエラーチェックを提供させることに陥ります。残念なことに、人々は良くこのことを
軽視します。例えスピードが制約ではない重要なアプリケーションにおいてもです。
こうのような人々のプログラムは高速、かつ危険な生活へと導きます。例えば、1988年に
インターネットを麻痺させた悪名高い``Worm''(ワーム)は\acronym{UNIX}(tm) OS
(オペレーティングシステム)のfingerデーモンにおける入力バッファがオーバフローしたか
どうかのチェックミスを利用しました。(\link{Spafford 1989}参照)
}

逐次翻訳とコンパイルの代替もまた、新しいコンピュータへ言語を移植するための異なる
戦略へと導きます。新しい機械にLispを実装したいと願っていると仮定します。
1つの戦略は\link{Section 5.4}の明示的制御評価機と共に始めて、その命令を新しい機械の命令へと
翻訳することです。異なる戦略はコンパイラと共に始めてコード生成器を変更し、新しい
機械のコードを生成するようにします。2つ目の戦略はどんなLispプログラムも最初に
元のLispシステム上で動くコンパイラを用いてコンパイルし、実行時ライブラリの
コンパイル済みの版とリンクすることにより、新しい機械の上で実行させることが
可能になります。\footnote{もちろん、逐次翻訳とコンパイルの戦略のどちらを用いても、
新しい機械の記憶域割り当て、入出力(I/O)、そして評価機とコンパイラの議論において
``プリミティブ''として扱った全ての多彩な命令もまた新しい機械のために実装しなければ
なりません。ここで仕事量を最小化するための1つの方法としてはこれらの命令を可能な限り
Lispで書き、次に新しい機械のためにコンパイルすることが上げられます。究極的には、
全てが新しい機械のために手で書かれた(ガベージコレクションや実際の機械の
プリミティブを適用する仕組みの様な)小さなカーネルに縮小されます。}
もっと良いことには、コンパイラそれ自身をコンパイルすることができます。そしてこれを
新しい機械の上で他のLispプログラムをコンパイルするために実行するのです。\footnote{この
戦略は、コンパイルされたコンパイラを用いた、新しい機械上でのプログラムのコンパイルが
元のLispシステム上のプログラムのコンパイルと同一であるかどうかという、コンパイラの
正確性の楽しいテストへと至ります。違いの原因の追跡は楽しいのですが、しばしばイライラも
させます。その結果はとても小さな詳細に非常に敏感なためです。}または、\link{Section 4.1}の
インタプリタの内1つをコンパイルして新しい機械上で実行できるインタプリタを
生成することもできます。

\begin{quote}
\heading{\phantomsection\label{Exercise 5.45}Exercise 5.45:}
コンパイルされたコードにより使用されたスタック命令を同じ演算のための評価機により
使用されたスタック命令と比較することで、コンパイラのスタック使用の最適化の範囲を
速さ(スタック命令の総数の削減)と記憶域(最大スタック深度の削減)の両方において
判断することができる。この最適化されたスタックの使用を、同じ演算のための特別な目的の機械
と比較することでコンパイルの品質の何らかの指標を与えることができる。

\begin{enumerate}[a]

\item
\link{Exercise 5.27}は、評価機が上で与えられた再帰階乗手続を用いて
\( n! \)を求めるのに必要なプッシュの数と最大スタック深度を\( n \)の関数として決定するよう
求めた。\link{Exercise 5.14}は\link{Figure 5.11}で示された特別な目的の階乗マシンに
対しする同じ測定を求めた。ここでは同じ分析をコンパイルした\code{factorial}手続を用いて
実行する。

コンパイルされた版のプッシュの数と逐次翻訳された版のプッシュの数との比率を取得せよ
次に同じ事を最大スタック深度に対しても行なえ。\( n! \)を求めるために使用される命令数と
スタック深度は\( n \)の線形であるために、これらの比率は\( n \)が巨大になるにつれ
定数へと収束するはずである。これらの定数は何か? 同様に、特定目的マシンの使用量と
逐次翻訳の版の使用量との比率も求めよ。

特定目的と逐次翻訳されたコードとの間の比率と、コンパイルされたコードと逐次翻訳された
コードとの間の比率を比較せよ。特定目的マシンがコンパイルされたコードよりもとても良い
ことに気付くはずだ。手作りのコントローラのコードは基本的な汎用目的のコンパイラにより
生成されたものよりとても優れているはずだからである。

\item
パフォーマンスにおいて手作り版により近いコードを生成することを手助けする、
コンパイラに対する改善を提案できるだろうか?

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.46}Exercise 5.46:}
\link{Exercise 5.45}のような分析を木再帰フィボナッチ手続のコンパイルの効果を
判断するために実行せよ。

\begin{scheme}
(define (fib n)
  (if (< n 2)
      n
      (+ (fib (- n 1))
         (fib (- n 2)))))
\end{scheme}

\noindent
\link{Figure 5.12}の特定目的フィボナッチマシンを用いた場合の効果と
比較せよ。(逐次翻訳のパフォーマンスの測定のために、\link{Exercise 5.29}を参照せよ)。
フィボナッチ数では、使用された時間的リソースは\( n \)の線形にはならない。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.47}Exercise 5.47:}
この節では逐次翻訳されたコードがコンパイルされたコードを呼び出すことができるように
するために、明示的制御評価機をどのように変更するかを説明した。コンパイルされた手続が
プリミティブとコンパイルされた手続のみでなく、逐次翻訳された手続も同様に呼び出すこと
ができるようにするために、コンパイラをどのように変更するのか示せ。
これは\code{compile\-/procedure\-/call}を複合(逐次翻訳)の場合を取り扱うように変更する必要がある。
全ての同じ\code{target}と\code{linkage}の組み合わせを\code{compile\-/proc\-/appl}が行うように
取り扱うよう気をつけよ。実際に手続適用を行うためには、コードは評価機の\code{compound\-/apply}
エントリポイントへ飛ぶ必要がある。このラベルはオブジェクトコードの中では直接参照することが
できない。(アセンブラが全てのラベルに対し、それがアセンブルしている、そこで定義される
コードにより参照されることを要求するためである)。従って、\code{compapp}と呼ばれるレジスタを
評価機に追加し、このエントリポイントを持たせて、これを初期化する命令を追加する。

\begin{scheme}
 (assign compapp (label compound-apply))
 (branch (label external-entry)) ~\textrm{;\code{flag}が立っていれば飛ぶ}~
read-eval-print-loop ~\( \dots \)~
\end{scheme}

あなたのコードをテストするために、手続\code{g}を呼ぶ手続\code{f}を定義することから始めよ。
\code{compile\-/and\-/go}を用いて\code{f}の定義をコンパイルし、評価機を開始せよ。ここから
評価機に対し入力を行い\code{g}を定義し\code{f}の呼出を試せ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.48}Exercise 5.48:}
この節で実装された\code{compile\-/and\-/go}インターフェイスは扱いにくい。コンパイラを
(評価機が開始された時に)一度しか呼ぶことができないためだ。
以下のように明示的制御評価機の中から呼び出すことができる\code{compile\-/and\-/run}を
追加することでコンパイラ-インタプリタ間のインターフェイスを増補せよ。

\begin{scheme}
~\textit{;;; EC-Eval input:}~
(compile-and-run
 '(define (factorial n)
    (if (= n 1) 1 (* (factorial (- n 1)) n))))
~\textit{;;; EC-Eval value:}~
~\textit{ok}~
~\textit{;;; EC-Eval input:}~
(factorial 5)
~\textit{;;; EC-Eval value:}~
~\textit{120}~
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.49}Exercise 5.49:}
明示的制御評価機のREPLを用いる代わりとして、read-compile-execute-print loopを
実行するレジスタマシンを設計せよ。言い換えれば、このマシンは式を読み込み、それを
コンパイルし、その結果のコードをアセンブルして実行し、その結果を表示するループを
実行する。これは私達のシミュレートされた構成内で簡単に実行できる。なぜなら、
手続\code{compile}と\code{assemble}を``レジスタマシンの命令''として呼ぶことを
手配できるからだ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.50}Exercise 5.50:}
コンパイラを用いて\link{Section 4.1}のメタ循環評価機をコンパイルし、レジスタマシン
シミュレータと用いてこのプログラムを実行せよ。(一度に複数の定義をコンパイルするために、
\code{begin}の中に定義を詰めることができる)。結果としてのインタプリタの実行は
複数レベルの逐次翻訳のため、とても遅い。しかし、実行の詳細全てを理解することは
教育的な課題である。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.51}Exercise 5.51:}
C言語(またはあなたが選んだ何らかの他の低レベルな言語)によるSchemeの基本的な実装を、
\link{Section 5.4}の明示的制御評価機をC言語に翻訳することで開発せよ。このコードを実行するためには、
適切なメモリ割当ルーチンと他の実行時サポートも提供する必要がある。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 5.52}Exercise 5.52:}
\link{Exercise 5.51}に対する好対照として、コンパイラを変更してSchemeの手続を
C言語の命令列へとコンパイルするようにせよ。\link{Section 4.1}のメタ循環評価機をコンパイルして
C言語で書かれたSchemeインタプリタを生成せよ。
\end{quote}
