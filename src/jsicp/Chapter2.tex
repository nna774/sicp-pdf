\chapter{データを用いた抽象化の構築}
\label{Chapter 2}

\begin{quote}
私達は今、数学上の抽象化の重要なステップに到達しました。
記号がどんな意味を持つのか忘れるのです。
\( \dots \)[数学者]に遊んでいる暇はありません。
これらの記号を用いて実行する演算はいくらでもあります、
これらが何を意味するのか全く考える必要無しに。

---Hermann Weyl, \textit{The Mathematical Way of Thinking}
\end{quote}

\vspace{1.0em}

\noindent
\link{Chapter 1}では演算処理とプログラム設計における手続の役割について集中しました。
私達はプリミティブなデータ(数値)とプリミティブな命令(算術演算)の使い方、
組み合わせ、条件式、パラメタの使用を通して複合手続を形成するための手続の結合方法、
\code{define}を用いた抽象化の方法について学びました。
また手続が処理の局地展開のためのパターンとして見なされ得る
ことを学びました。そして手続内で具体化されたプロセスに対するいくつかの共通パターンの、
簡単なアルゴリズム上の解析を分類し、推論し、実行しました。
また高階手続が、一般的な演算の手段を操作し、その結果を用いて推測することを可能にすることにより、
私達の言語を強化することも学びました。
これはプログラミングの本質の大部分です。

この章では私達はより複雑なデータについて目を向けることにします。
第一章での全ての手続は単純な数値データを操作しましたが、単純なデータは私達が
演算を用いて解決したいと願う多くの問題には不十分です。
プログラムは一般的に複雑な事象をモデル化するために設計され、大抵の場合、
複数の側面を持つ実世界の事象をモデル化するため、いくつかのパーツを持つ演算対象の
オブジェクトを構築せねばなりません。
従って第一章での焦点は手続を組み合わせることで複合手続を形成し抽象化を構築すること
でしたが、この章では任意のプログラミング言語においてもう1つの鍵となる側面に向かい
ます。データオブジェクトを組み合わせ\newterm{compound data}(複合データ)
を形成することによる、プログラミング言語が抽象化の構築に対して与える意味です。


私達はなぜプログラミング言語にてデータを組合せたいのでしょうか?
手続を組み合わせたいのと同じ理由のためです。プログラムを設計可能な概念上のレベル
に持ち上げ、設計の部品化を進め、言語の表現力を拡張したいがためです。
手続を定義する能力が、言語のプリミティブな命令のレベルよりもより高い概念のレベル
において処理を扱うことを可能にしてくれるのと同様に、複合データオブジェクトを構築
できる能力は、言語のプリミティブなデータオブジェクトが与えるよりも
より高い概念レベルのデータを扱うことを可能にします。




分数を用いて数値演算を実行するシステム設計の課題を考えます。
2つの分数を取りそれらの和を実行する命令\code{add\-/rat}を想像します。
単純なデータを用いる場合、分数は2つの整数として考えられます。分子と分母です。
すると各分数が2つの整数(分子と分母)で表現されるプログラムの設計が可能です。
そして\code{add\-/rat}は2つの手続(1つは和の分子を求め、もう1つは分母を求める)にて
実装されるでしょう。しかしこれは不恰好です。それではどの分子がどの分母に
関係するのか明示的に追跡をせねばなりません。多くの分数に対して多くの命令を
実行する目的のシステムにおいては、そのような詳細な記録はプログラムを大幅に
散乱させるのみでなく、それらが私達の心にどんな影響を与えるかについは言うまでも
ありません。もし分子と分母をプログラムが分数を単一の概念上の単位として見做し静的な方法で扱えることができる
ペア---\newterm{compound data object}(\jnewterm{複合データオブジェクト})---
に``貼り合せ''られればずっと良くなることでしょう。



複合データの使用はまたプログラムのモジュラリティ(部品化)を推進します。
もし分数を独自に、直接それ自身をオブジェクトとして扱うことができれば、分数それ自体を
扱うプログラムの一部を、分数が整数のペアとして表現されるだろうという詳細から分離する
ことができます。
データオブジェクトがどのように表現されるかを扱うプログラムの部分を、
データオブジェクトがどのように利用されるかを扱うプログラムの部分から分離する一般的なテクニック
は強力な設計手法であり\newterm{data abstraction}(\jnewterm{データ抽象化})と呼ばれます。
どのようにデータ抽象化がプログラムの設計、保守、変更をより簡単にするかを
これから学びます。



複合データの使用はプログラミング言語の表現力を実際に増加させます。
``一次結合''\( ax + by \)の形式化について考えてみて下さい。
\( a \), \( b \), \( x \), \( y \)を引数として取り、\( ax + by \)の
値を返す手続を書こうと思うかもしれません。これは引数が数値であるならば少しも
難しいとは思えません。私達は既に手続を定義できます。

\begin{scheme}
(define (linear-combination a b x y)
  (+ (* a x) (* b y)))
\end{scheme}

\noindent
しかし数値のみが対象ではないと考えてみましょう。手続の項目として加算と乗算が定義され
ているならば分数、複素数、多項式、その他何でも一次結合を形式化できるというアイデアを
表現したいとします。これを以下の形式の手続として表現できるでしょう。

\begin{scheme}
(define (linear-combination a b x y)
  (add (mul a x) (mul b y)))
\end{scheme}

\noindent
\code{add}と\code{mul}はプリミティブな手続\code{+}と\code{*}ではなく、より複雑なものです。
適切な操作を引数\code{a}, \code{b}, \code{x}, \code{y}として与えたどのような種類のデータに対しても行います。
キーポイントは\code{linear\-/combination}が\code{a}, \code{b}, \code{x}, \code{y}について知らねばならないことは
手続\code{add}とは\code{mul}が適切な操作を行うだろうことのみです。手続\code{linear\-/combination}の視点からは
\code{a}, \code{b}, \code{x}, \code{y}が何であるかは無関係であり、それらがどのようによりプリミティブなデータを
用いて表現されるのかについては尚更無関係です。
この同じ例がなぜプログラミング言語が複合オブジェクトを直接操作する能力を提供することが重要であるのか
を示しています。もしこれが無ければ、\code{linear\-/combination}のような手続に対してその引数を \code{add}と
\code{mul}に向けてそれらの詳細な構造を知らずに渡す方法がありません。\footnote{手続を直接操作する能力は
プログラミング言語の表現力に対して類似の増強を与えます。例えば\link{Section 1.3.1}において\code{sum}手続を紹介
しましたが、これは手続\code{term}を引数として取り、ある指定した区間の\code{term}の値の和を求めました。
\code{sum}を定義するためには\code{term}のような手続を、\code{term}がよりプリミティブな命令にてどのように
表現されているのかに関わらず、それ自身の要素として表現できることが重要でした。実際に、もし``手続''
という概念が無ければ\code{sum}のような命令の定義の可能性について考えつくことすら疑わしいことだったでしょう。
その上、加算の実行を考慮する範囲では\code{term}がどのようによりプリミティブな命令から構築され得るのかの
詳細は無関係なのです。}



私達はこの章を先に触れられた分数の数値演算システムを実装することで始めます。
これが複合データとデータ抽象化の議論の背景を形作ります。
複合手続と同様に、解決すべき主な問題は複雑さを対処するための技術としての抽象化であり
どのようにデータ抽象化が適切な\newterm{abstraction barriers}(\jnewterm{抽象化バリア})を
異なるプログラムの部分の間に構築することを可能にするかについて学びます。



複合データを形成するための鍵はプログラミング言語はある種の``糊''を提供しなければ
ならないことであり、そうすることでデータオブジェクトはより複雑なデータオブジェクト
を形成するために組み合わせることが可能になります。多くの有力な種類の糊が存在します。
実際に、全く特別ではない手続のみの``データ''操作を用いて複合データをどのように形成するかに
ついて発見するでしょう。これは第一章の終りに向かい既に希薄となっていた
``手続''と``データ''の区別をよりボカすことになるでしょう。
また列と木を表現するいくつかの保守的な技術についても探検します。複合データを扱う場合の
鍵となる考えの1つは\newterm{closure}(\jnewterm{クロージャ})の概念です---そのデータオブジェクトを組み合わせ
るのに用いる糊はプリミティブなデータオブジェクトのみではなく、複合データオブジェクトもまた
組み合わせられなければなりません。
もう1つの鍵となる考えは複合データオブジェクトは種々様々な方法でプログラムモジュールを組み立てるための
\newterm{conventional interfaces}(\jnewterm{慣習的インターフェイス})の役を演じることができることです。
これらのアイデアのいくつかについてはクロージャを用いる簡単なグラフィック言語を与えることで
説明します。


次に\newterm{symbolic expressions}(\jnewterm{記号表現})---その基本的な部分は任意の記号であり
数字のみではないデータ---を紹介することで言語の具象的な力を増補します。
オブジェクトの集合を表現するための様々な代替方法について探検します。
与えられた数値関数が多くの異なる演算処理により計算され得るのと同様に、
与えられたデータ構造が多くの方法にてより単純なオブジェクトを用いて表現され得ること、
表現の選択がデータを扱う処理の時間と記憶域の要件に対し重大な影響を与えることについて発見するでしょう。
記号微分、集合の表現、情報符号化のコンテキストにてこれらの考えについて調査します。


次にプログラムの異なる部分において異なって表現され得るデータを用いて処理する問題にとりかかります。 
これが\newterm{generic operations}(\jnewterm{総称命令})の実装の必要性へと導きます。総称命令は
多くの異なるデータの型を扱わなければなりません。総称命令の存在時における部品化の保守は
単純なデータ抽象化のみにより構築可能な場合に比べて、より強力な抽象化バリアを、必要とします。
具体的には\newterm{data-directed programming}(\jnewterm{データ適従プログラミング})を
個別のデータ表現に対し分離した設計と\newterm{additively}(\jnewterm{付加的})に(つまり変更無しに)
組み合わせることを可能にする技術として紹介します。
システム設計に対するこのアプローチを説明するために、
多項式上の記号演算の実行向けパッケージを実装するために私達が学んだことを適用することでこの章を終わります。
その実装の中では多項式の係数は整数、分数、複素数、さらには多項式にもなり得ます。


\section{データ抽象化のイントロダクション}
\label{Section 2.1}



\link{Section 1.1.8}においてより複雑な手続を作成する要素として使われる手続は特定の命令の
集合としてのみでなく、手続の抽象化としても見做されることを伝えました。
その手続がどのように実装されたのかの詳細は抑制可能であり、特定の手続それ自身は
相対的に同じ振舞を持つ任意の他の手続で置き換えられます。
言い換えれば、手続がどのように使われるかをその手続がどのようによりプリミティブな
手続を用いて実装されたかの詳細から分離する抽象化を作成できます。
複合データのための類似の概念は\newterm{data abstraction}(\jnewterm{データ抽象化})と呼ばれます。
データ抽象化はどのように複合データオブジェクトが使用されるかをどれがどのようにより
プリミティブなデータオブジェクトから構築されたのかの詳細から分離することを可能にする
方法論(methodology, メソドロジ)です。



データ抽象化の基本的なアイデアは複合データオブジェクトを使用するためのプログラムを構造化
することで``抽象データ''上で操作を行うことです。それはつまり、私達のプログラムが
手元でタスクを実行するためには厳密には必要と言えないデータに関する想定を一切持たないような
方法でデータを利用しなければいけないということです。同時に、``具体的''なデータ表現はデータ
を利用するプログラムとは独立に定義されます。システムにおけるこれらの2つのパーツの間の
インターフェイスは手続の集合であり、\newterm{selectors}(セレクタ)と\newterm{constructors}(コンストラクタ)
と呼ばれ、抽象データを具体的な表現を用いて実装します。このテクニックを説明するために、
分数を扱う手続の集合をどのように設計するかについてこれから考えます。



\subsection{例: 分数のための数値演算命令}
\label{Section 2.1.1}



分数を用いて数値演算を行いたいとします。足し算、引き算、かけ算、割り算をそれらに
対して行い2つの分数が等しいかテストします。



分子と分母から分数を構築する方法を既に持っていると仮定することから始めましょう。
分数を与えられた時にそれの分子と分母を抽出する(または選択(セレクト)する)方法を持っているとも
仮定します。さらにコンストラクタとセレクタが手続として存在すると仮定します。

\begin{itemize}

\item
\( \hbox{\tt(make-rat}\;\langle{n}\kern0.08em\rangle\;\langle{d}\kern0.06em\rangle\hbox{\tt)} \)は分子が整数\( \langle{n}\kern0.08em\rangle \)であり、かつ分母が整数\( \langle{d}\kern0.06em\rangle \)である分数を返す。

\item
\( \hbox{\tt(numer}\;\;\langle{x}\kern0.08em\rangle\hbox{\tt)} \)は分数\( \langle{x}\kern0.08em\rangle \)の分子を返す。

\item
\( \hbox{\tt(denom}\;\;\langle{x}\kern0.08em\rangle\hbox{\tt)} \)は分数\( \langle{x}\kern0.08em\rangle \)の分母を返す。

\end{itemize}

\noindent
ここで統合のための強力な戦略、\newterm{wishful thinking}(\jnewterm{希望的観測})を用います。
私達はまだ分数がどのように表現されるのか、または手続\code{numer}, \code{denom}, \code{make\-/rat}が
どのように実装されるべきであるのかについて語っていません。そうであっても、
もし私達がこれら3つの手続を持っているのならば、足し算、引き算、かけ算、割り算、等値テスト
を以下の関係性を用いて行うことができるでしょう。

\begin{comment}

\begin{example}
n_1   n_2   n_1 d_2 + n_2 d_1
--- + --- = -----------------
d_1   d_2        d_1 d_2

n_1   n_2   n_1 d_2 - n_2 d_1
--- - --- = -----------------
d_1   d_2        d_1 d_2

n_1   n_2   n_1 n_2
--- * --- = -------
d_1   d_2   d_1 d_2

n_1 / d_1   n_1 d_2
--------- = -------
n_2 / d_2   d_1 n_2

n_1   n_2
--- = ---  if and only if n_1 d_2 = n_2 d_1
d_1   d_2
\end{example}
\end{comment}

\begin{align*}
  {n_1 \over d_1} + {n_2 \over d_2} 	&= {n_1 d_2 + n_2 d_1 \over d_1 d_2}, \\
  {n_1 \over d_1} - {n_2 \over d_2} 	&= {n_1 d_2 - n_2 d_1 \over d_1 d_2}, \\
  {n_1 \over d_1} \cdot {n_2 \over d_2}	&= {n_1 n_2 \over d_1 d_2}, \\
  {n_1 / d_1} \over {n_2 / d_2} 	&= {n_1 d_2 \over d_1 n_2}, \\
  {n_1 \over d_1} 			&= {n_2 \over d_2} \quad 
						{\rm\ if\ and\ only\ if\quad} 
						n_1 d_2 = n_2 d_1.
\end{align*}

\noindent
これらのルールを手続として表現できます。

\begin{scheme}
(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))
(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
            (* (denom x) (numer y))))
(define (equal-rat? x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))

\end{scheme}


これでセレクタとコンストラクタの手続である\code{numer}, \code{denom}, \code{make\-/rat}を用いて
分数の操作を定義できました。必要な物は分子と分母を貼り合せて分数を形成する何らかの
方法です。

\subsubsection*{ペア}



データ抽象化の具体的レベルを実装できるようになるために、私達の言語は\newterm{pair}(\jnewterm{ペア})
と呼ばれる複合構造を提供します。それはプリミティブな手続\code{cons}を用いて構築できます。
この手続は2つの引数を取り、2つの引数を部分として持つ複合データオブジェクトを返します。
ペアを与えられた時、プリミティブな手続\code{car}と\code{cdr}を用いてそれの部分を抽出することが
できます。\footnote{\code{cons}という名前は``construct''によります。\code{car}と\code{cdr}という
名前はIBM 704上でのオリジナルのLisp実装に由来します。このマシンはアドレシングの仕組み
としてメモリロケーションの``アドレス''と``デクリメント''の部分を参照可能でした。
\code{car}は``Contents of Address part of Register''(レジスタのアドレス部分の中身)を表し、
\code{cdr}(``クダー''と読みます)は``Contents of Decrement part of Register.''(レジスタの
デクリメント部分の中身)を表します。}
従って、\code{cons}, \code{car}, \code{cdr}を以下のように使用できます。

\begin{scheme}
(define x (cons 1 2))
(car x)
~\textit{1}~
(cdr x)
~\textit{2}~
\end{scheme}

\noindent
ペアは名前を与えることができ、プリミティブなデータオブジェクトと同様に扱うこと
ができるデータオブジェクトです。さらに\code{cons}はその要素がペアであるペアや、その繰り返しを
作ることも可能です。

\begin{scheme}
(define x (cons 1 2))
(define y (cons 3 4))
(define z (cons x y))
(car (car z))
~\textit{1}~
(car (cdr z))
~\textit{3}~
\end{scheme}

\noindent
\link{Section 2.2}においてペアを組み立てるこの能力が、
全ての種類の複雑なデータ構造を作成するために汎用目的構築ブロックとしてペアが利用可能
であることに対し、どのような意味を持つのかについて学びます。
\code{cons}, \code{car}, \code{cdr}により実装された単一の複合データプリミティブペアが
私達が必要とするただ1つの糊です。ペアから構築されたデータオブジェクトは
\newterm{list-structured}(\jnewterm{リスト構造化})データと呼ばれます。

\subsubsection*{分数を表現する}



ペアは分数システムを仕上げるための自然な方法を提供します。単純に分数を2つの
整数、分子と分母のペアとして表現します。そして\code{make\-/rat}, \code{numer}, \code{denom}は
簡単に次のように実装することが可能です。\footnote{
セレクタとコンストラクタを
定義するもう1つの実装として次が挙げられます。

\begin{smallscheme}
(define make-rat cons)
(define numer car)
(define denom cdr)
\end{smallscheme}



最初の定義は名前\code{make\-/rat}を式\code{cons}の値に関連付けます。それはペアを
構築するプリミティブな手続です。従って\code{make\-/rat}と\code{cons}は同じプリミティブな
コンストラクタになります。



セレクタとコンストラクタをこのように定義するのは効率が良いです。\code{make\-/rat}が
\code{cons}を\emph{calling}(呼び出す)代わりに、\code{make\-/rat}が\code{cons}で\emph{is}(ある)
ためです。そのため\code{make\-/rat}が呼ばれた時に2つでなく、1つの手続が呼ばれるだけに
なります。しかし一方で、これを行うことは手続呼出のトレースや手続呼出に対するブレイクポイント
の設定に対するデバッグ上の手助けを無効にしてしまいます。あなたは\code{make\-/rat}の呼出を
見たくなるのであって、\code{cons}への全ての呼出を見たい訳ではないからです。



この本ではこの定義スタイルを使用しないことにしました。}

\begin{scheme}
(define (make-rat n d) (cons n d))
(define (numer x) (car x))
(define (denom x) (cdr x))
\end{scheme}

\noindent
また演算結果を表示するために、分数を分子、スラッシュ、分母で表示することにします。\footnote{
\code{display}はデータを表示するSchemeのプリミティブです。Schemeのプリミティブである\code{newline}
は表示を新しい行から始めます。これらの手続のどちらも意味のある値は返しません。そのため
下記の\code{print\-/rat}内での使用においては\code{print\-/rat}が表示する物のみを示し、インタプリタが
\code{print\-/rat}の返り値として表示する物は示していません。}

\begin{scheme}
(define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x)))
\end{scheme}

\noindent
これで分数手続を試すことができます。

\begin{scheme}
(define one-half (make-rat 1 2))
(print-rat one-half)
~\textit{1/2}~
(define one-third (make-rat 1 3))
(print-rat (add-rat one-half one-third))
~\textit{5/6}~
(print-rat (mul-rat one-half one-third))
~\textit{1/6}~
(print-rat (add-rat one-third one-third))
~\textit{6/9}~
\end{scheme}

\noindent
最後の例が示すとおり、私達の分数実装は分数を最も小さな項に約分しません。
これを\code{make\-/rat}を変更することで改良できます。もし\link{Section 1.2.5}で扱った
2つの整数の最大公約数を生成する\code{gcd}手続を持っていれば、\code{gcd}を用いて
分子と分母を最小の項に、ペアを構築する前に縮小することができます。

\begin{scheme}
(define (make-rat n d)
  (let ((g (gcd n d)))
    (cons (/ n g) (/ d g))))
\end{scheme}

\noindent
これで次の希望した結果を得ます。

\begin{scheme}
(print-rat (add-rat one-third one-third))
~\textit{2/3}~
\end{scheme}

\noindent
この変更は(\code{add\-/rat}や\code{mul\-/rat}のような)実際の命令を実装する他の手続の変更無しに、
コンストラクタ\code{make\-/rat}を変更することで達成されました。

\begin{quote}
引数を扱えるより良い版の\code{make\-/rat}を定義せよ。
\heading{\phantomsection\label{Exercise 2.1}Exercise 2.1:} 正と負の両方の
\code{make\-/rat}は符号の正常化を行わなければならない。従ってもし分数が正であれば
分子と分母の両方が正であるし、もし分数が負であれば分子のみが負でなければならない。
\end{quote}


\subsection{抽象化バリア}
\label{Section 2.1.2}


さらなる複合データとデータ抽象化の例を続ける前に、分数の例にて持ち上がったいくつかの
問題について考えてみましょう。私達は分数操作をコンストラクタ\code{make\-/rat}とセレクタ\code{numer}と
\code{denom}を用いて定義しました。一般的にデータ抽象化の基となる考えは
データオブジェクトの各型に対し、その型のデータオブジェクトの全ての操作が表される命令を用いて、
命令の基本的な集合を判断し、そのデータを操作する時にそれらの命令のみを用いることです。





私達は\link{Figure 2.1}にて示された分数システムの構造を想像することができます。
水平線は\newterm{abstraction barriers}(\jnewterm{抽象化バリア})を表現し、システムの異なる``レベル''
を分離します。各レベルではバリアはデータ抽象化を利用する(上側の)プログラムをデータ抽象化
を実装する(下側の)プログラムから分離します。
分数を利用するプログラムはもっぱら分数パッケージにより``公用向け''に提供された
手続を用いて分数を操作します。それら手続とは\code{add\-/rat},
\code{sub\-/rat}, \code{mul\-/rat}, \code{div\-/rat}, それに \code{equal\-/rat?}です。
これらは順に、もっぱらコンストラクタとセレクタである\code{make\-/rat}, \code{numer}, \code{denom}を
用いて実装されます。この3つはペアを用いて実装されます。ペアがどのように実装されているかの
詳細はペアが\code{cons}, \code{car}, \code{cdr}の使用により操作できる限りにおいては分数パッケージの
他の物に取っては重要ではありません。実質的に、各レベルにおける手続は抽象化バリアを定義する
インターフェイスであり、異なるレベルを接続します。



この単純な考えは多くの利点を持ちます。1つの利点はプログラムの保守と変更をより簡単に
することです。任意の複雑なデータ構造が、プログラミング言語により提供されるプリミティブな
データ構造を用いて多彩な方法で表現されます。もちろん、表現の選択がその上で操作を行う
プログラムに影響を与えます。従ってもし表現がある程度後に変更された場合、全ての当該
プログラムはそれに応じて変更されなければなりません。この作業は大きなプログラムの
場合においては
表現上の依存が設計によりとても少ないプログラムモジュールに対してのみに制限されていなければ
時間のかかる高コストな物に成り得ます。

\begin{figure}[tb]
\phantomsection\label{Figure 2.1}
\centering
\begin{comment}
\begin{quote}
\heading{Figure 2.1:} Data-abstraction barriers in the rational-number package.

\begin{example}
        +------------------------------------+
--------| Programs that use rational numbers |--------
        +------------------------------------+
          Rational numbers in problem domain
            +---------------------------+
------------|   add-rat  sub-rat  ...   |-------------
            +---------------------------+
   Rational numbers as numerators and denominators
              +------------------------+
--------------| make-rat  numer  denom |--------------
              +------------------------+
              Rational numbers as pairs
                  +----------------+
------------------| cons  car  cdr |------------------
                  +----------------+
            However pairs are implemented
\end{example}
\end{quote}
\end{comment}
\includegraphics[width=91mm]{fig/chap2/Fig2.1c.pdf}
\begin{quote}
\heading{Figure 2.1:} 分数パッケージ内の抽象化バリア
\end{quote}
\end{figure}

\noindent
例として、分数を最小の項へと約分する問題の解法の代替法には、分数を組み立てた時でなく、
分数のパーツにアクセスする度に約分を実行する方法があります。
これは異なるコンストラクタとセレクタ手続に導きます。

\begin{scheme}
(define (make-rat n d) (cons n d))
(define (numer x)
  (let ((g (gcd (car x) (cdr x))))
    (/ (car x) g)))
(define (denom x)
  (let ((g (gcd (car x) (cdr x))))
    (/ (cdr x) g)))
\end{scheme}

\noindent
この実装と依然の実装との間の違いはいつ\code{gcd}を求めるかにあります。
私達の典型的な分数の使用においては、同じ分数の分子と分母に何度もアクセスする場合、
分数が組み立てられる時に\code{gcd}を求めるほうが好ましいです。そうでなければ
\code{gcd}を求めるのはアクセスする時まで待ったほうが良いかもしれません。
どちらの場合でも、一方の表現からもう一方の表現へと変更する場合、手続、\code{add\-/rat}, 
\code{sub\-/rat}, その他は全く変更する必要がありません。



表現上の依存対象を少ないインターフェイス手続に制約することはプログラムの設計と共に
それらの変更をも手助けします。なぜなら代替的な実装を考えるための柔軟性を保つ
ことを可能にするためです。私達の簡単な例で続けるために、私達は分数パッケージ
を設計中で、早期に\code{gcd}を構築時と選択時のどちらで実行するか決められないと
想像して下さい。データ抽象化メソドロジはその決定をシステムの他の部分上の進行の
可能性を失わせずに決定を遅らせる方法を与えます。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.2}Exercise 2.2:} 平面上の線分を
表現する問題について考える。各線分は点のペアにて表現する。始点と
終点である。コンストラクタ\code{make\-/segment}とセレクタ\code{start\-/segment}と\code{end\-/segment}
を定義せよ。それらは点を用いて線分の表現を定義する。さらに点は数値のペアにて表現できる。
\( x \)座標と\( y \)座標である。それに沿ってこの表現を定義するコンストラクタ\code{make\-/point}と
セレクタ\code{x\-/point}を\code{y\-/point}を定めよ。
最後に、セレクタとコンストラクタを用いて引数として線分を取りその中点(その座標が両端点の
座標の平均である点)を返す手続\code{midpoint\-/segment}を定義せよ。
あなたの手続をテストするためには以下の点を表示する方法が必要だろう。

\begin{scheme}
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.3}Exercise 2.3:} 平面上の
三角のための表現を実装せよ。(ヒント：\link{Exercise 2.2}を利用したいだろう。)
コンストラクタとセレクタを利用して、与えられた三角の周辺の長さと面積を求める手続を
作れ。適切な抽象化バリアを用いてどんな表現を用いても同じ周辺長と面積の手続が働くよう、
あなたのシステムを設計できるだろうか?

\end{quote}

\subsection{データにより何が意味されるのか}
\label{Section 2.1.3}




\link{Section 2.1.1}にて分数実装を分数演算\code{add\-/rat}, \code{sub\-/rat}, その他を
3つの定められていない手続、\code{make\-/rat}, \code{numer}, \code{denom}を用いて
実装することから始めました。その時点では命令はデータオブジェクト---分子、分母と
分数を用いて定義されると考えることができました。データオブジェクトの振舞は
後者の3つの手続により指定されました。



しかし\newterm{data}(\jnewterm{データ})とは正確には何を意味するのでしょうか。
``与えられたセレクタとコンストラクタにより実装された物全て''と言うのみでは十分ではありません。
明かに3つの手続の任意の集合全てが分数実装に対する適切な基準としての役割を果せる訳ではありません。
もし分数\code{x}を整数のペア\code{n}と\code{d}から組み立てた場合、\code{x}の\code{numer}と\code{denom}の抽出し
それらを割ることは、\code{n}を\code{d}で割るのと同じ結果になることを保証せねばなりません。
言い替えれば、\code{make\-/rat}, \code{numer}, \code{denom}は任意の整数\code{n}と零でない整数\code{d}に対し
もし\code{x}が\code{(make\-/rat n d)}である時、その場合以下の条件を満たさなければなりません。
\begin{comment}

\begin{example}
(numer x)    n
--------- = ---
(denom x)    d
\end{example}

\end{comment}
\begin{displaymath}
 {\hbox{\tt(numer x)} \over \hbox{\tt(denom x)}} = {{\tt n} \over {\tt d}}\,.  
\end{displaymath}


実際にこれが\code{make\-/rat}, \code{numer}, \code{denom}が分数表現のための適切な基準を形成する
ために満たさなければならないただ1つの条件です。
一般的に、私達はデータをセレクタとコンストラクタのある集合と共に、これらの手続が
有効な表現となるために満たさなければならない制約により定義されると考えることができます。\footnote{
意外にもこの考えは厳格に形式化することがとても難しいのです。そのような形式化を与える試みは
2つあります。1つはC. A. R. \link{Hoare (1972)}により開拓され、\newterm{abstract models}(\jnewterm{抽象モデル})
として知られています。``手続プラス制約''の仕様を上の分数の例内で概説されたように形式化します。
分数表現上の条件は整数に関する事実(等値関係と除算)を用いて規定されています。
一般的に抽象モデルは新しい種類のデータオブジェクトを以前に定義されたデータオブジェクトの型を用いて
定義します。従ってデータオブジェクトに関する成立条件はそれらを以前に定義されたデータオブジェクト
に関する成立条件へと還元していくことでチェックできます。
もう1つの試みは\acronym{MIT}のZillesとIBMのGoguen, Thatcher, Wagner, Wrightにより紹介され
(\link{Thatcher et al. 1978}を参照)、またトロント大学のGuttagにより紹介されました。(\link{Guttag 1977}
を参照)。その試みは``手続''を抽象代数システムの要素と見做し、その振舞は``条件''に相当する公理により
指定されました。そして抽象代数のテクニックを用いてデータオブジェクトに関する成立条件をチェックしました。
両者の手法が\link{Liskov and Zilles (1975)}により論文として調査されています。}



この視点は分数のような``高階データオブジェクト''のみを定義するのではなく、
より低いレベルのオブジェクトの定義も提供することができます。
私達が分数を定義するために使用したペアの概念について考えてみます。
私達はまだペアとは実際には何であるのか述べていません。言語が手続\code{cons}, \code{car}, \code{cdr}を
ペア上の命令として提供するとのみ説明しています。しかしこれら3つの命令について
知らなければいけないことはもし私達が2つのオブジェクトを\code{cons}を用いて貼り合わせた時、
\code{car}と\code{cdr}を用いてそれらのオブジェクトを取得することができることのみです。
つまり、それらの命令は任意のオブジェクト\code{x}と\code{y}に対し、もし\code{z}が\code{(cons x y)}であるなら
\code{(car z)}は\code{x}であり、\code{(cdr z)}は\code{y}であるという制約を満たしています。
実際に、これらの3つの手続は言語にプリミティブとして含まれていることについて既に述べました。
しかし、上記の制約を満たす任意の3つの手続ならペアを実装するための基盤として使用することが
可能です。この点は私達が\code{cons}, \code{car}, \code{cdr}をどんなデータ構造も全く利用せずに、
しかし手続のみを用いて実装できることにより、著しく説明されます。
これがその定義です。

\begin{scheme}
(define (cons x y)
  (define (dispatch m)
    (cond ((= m 0) x)
          ((= m 1) y)
          (else (error "Argument not 0 or 1: CONS" m))))
  dispatch)
(define (car z) (z 0))
(define (cdr z) (z 1))
\end{scheme}

\noindent
この手続の使用はデータが何であるべきかという私達の直感的概念のような物には全く
関係しません。それでもなお、これがペアを表現するのに有効な方法であると示すのに
必要なこと全てはこれらの手続が上で与えられた制約を満たすことです。



注意すべき微細な点は\code{(cons x y)}により返される値は手続---すなわち内部で定義された
手続\code{dispatch}であることです。それが1つの引数を取り\code{x}か\code{y}のどちらかを
引数が0であるか1であるかに従って返します。相応して、\code{(car z)}は\code{z}を0に適用します。
故にもし\code{z}が\code{(cons x y)}により作られた手続であるのなら、\code{z}を0に適用すれば
\code{x}を返します。従って、\code{(car (cons x y))}が希望通りに\code{x}を返すことを示しました。
同様に\code{(cdr (cons x y))}は\code{(cons x y)}の返り値としての手続を1に適用し、
\code{y}を返します。従ってこのペアの手続としての実装は有効な実装であり、もし私達が
\code{cons}, \code{car}, \code{cdr}のみを用いてペアにアクセスする場合、この実装を``本物の''データ構造を
用いる実装と区別することはできません。



ペアの手続による表現を提示することのポイントは私達の言語がこのように働いているという
ことではなく(Schemeや一般的なLispシステムは効率上の理由からペアを直接的に実装します)、
しかしそれがこのように働くことができるということです。手続による表現は曖昧ですが、ペアを
表現するのに完璧に適切な方法です。ペアが満たすべき必要な条件を満たすからです。
この例はまた手続をオブジェクトとして操作する能力が自動的に複合データを表現する能力を
提供することを実演しました。これは今は珍しく見えるかもしれませんが、しかし手続による
データの表現は私達のプログラミングレパートリの中心的役割を演じます。このプログラミング
スタイルは時折\newterm{message passing}(\jnewterm{メッセージパッシング})と呼ばれ、私達はこれを
\link{Chapter 3}にてモデリングとシミュレーションの問題を解決する時に基本的なツールとして
用います。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.4}Exercise 2.4:} ここにペアの
代替的な手続上の表現がある。この表現に対して\code{(car (cons
x y))}が任意のオブジェクト\code{x}と\code{y}に対して\code{x}を返すか確認せよ。

\begin{scheme}
(define (cons x y)
  (lambda (m) (m x y)))
(define (car z)
  (z (lambda (p q) p)))
\end{scheme}



対応する\code{cdr}の定義はどうなるか? (ヒント：これが正しく働くか確認するには
\link{Section 1.1.5}の置換モデルを使用せよ)
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.5}Exercise 2.5:} 負ではない
整数のペアを数値と数値演算命令のみを用いて表現できることを、もし\( a \)と\( b \)の
ペアを積\( 2^a 3^b \)の整数で表現すれば可能であることにより示せ。
対応する手続\code{cons}, \code{car}, \code{cdr}.の定義を与えよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.6}Exercise 2.6:} ペアを
手続として表現することが十分に驚かせるに値するものでない場合、
手続を操作可能なある言語においては0と1を足すことを以下のように実装することで
数値が無くてもやっていける(少なくとも負ではない整数のみを考える場合においては)ことを
考えてみよ。

\begin{scheme}
(define zero (lambda (f) (lambda (x) x)))
(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))
\end{scheme}



この表現はその開発者に因んで\newterm{Church numerals}(\jnewterm{チャーチ数})として知られる。
Alonzo Churchは\( \lambda \)-演算を発明した論理学者である。



\code{one}と\code{two}を直接(\code{zero}と\code{add\-/1}を用いずに)定義せよ。(ヒント：
加算手続の直接的な定義\code{+}を与えよ。(\code{add\-/1}の繰り返し適用は用いない)
\end{quote}


\subsection{延長課題: 区間演算}
\label{Section 2.1.4}



Alyssa P. Hackerは人々が工学上の問題を解くのを手助けするシステムを設計しています。
システムにおいて彼女が提供したい1つの機能は(物理機器の測定されたパラメータのような)不正確な量を
既知の精度にて扱う能力です。演算がそのような近似量にて行われた時、結果が既知の
精度の値になるようにするためです。



電気技術者達がAlyssaのシステムを電気の量を計算するために使用します。彼らは時折2つの
抵抗\( R_1 \), \( R_2 \)の並列に等価な抵抗値\( R_p \)を次の式を用いて計算する
必要があります。
\begin{comment}

\begin{example}
            1
R_p = -------------
      1/R_1 + 1/R_2
\end{example}

\end{comment}
\begin{displaymath}
 R_p = {1 \over 1 / R_1 + 1 / R_2}\,.  
\end{displaymath}


抵抗値は通常抵抗の生産者により保証されるいくらかの許容誤差未満であることが知られています。
例えばもしあなたが``10\%の許容誤差で6.8Ω''とラベリングされた抵抗を買ったとしたら、
確かなのはその抵抗は\( 6.8 - 0.68 = 6.12 \)と\( 6.8 + 0.68 = 7.48 \)Ωの間の抵抗を
持つことのみです。従って、もし6.8Ω 10\%の抵抗と並列に4.7Ω 5\%の抵抗を接続した場合に、
組み合わせの抵抗は約2.58Ω(2つの抵抗が低限である場合)から約2.97Ω(2つの抵抗が上限である場合)
の区間になります。



Alyssaのアイデアは``interval arithmetic''(区間演算)を``区間''(不正確な量の取り得る
値の区間を表現するオブジェクト)を連結する演算命令の集合として実装することです。
2つの区間の加算、減算、乗算、除算の結果はそれ自身が区間であり、結果の範囲を表します。



Alyssaは2つの終端、下限と上限を持つ``区間''と呼ばれる抽象オブジェクトの存在を仮定しました。
彼女はまた区間の終端を与えられた時、データコンストラクタ\code{make\-/interval}を用いて区間の
構築ができると仮定しました。Alyssaは最初に2つの区間を足す手続を書きました。彼女は和の最小値は
2つの下限の和であり、最大値は2つの上限の和になるだろうと推測しました。

\begin{scheme}
(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))
\end{scheme}

\noindent
Alyssaはまた2つの区間の積を限界値の積の最小値と最大値を見つけることで算出し、
そしてそれらを結果区間の限界値として用いました。(\code{min}と\code{max}は任意の数の引数の
最小値と最大値を見つけるプリミティブです)。

\begin{scheme}
(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))
\end{scheme}

\noindent
2つの区間を割るために、Alyssaは一つ目に2つ目の逆数を掛けました。区間の逆数の限界値は
上限の逆数と下限の逆数をその順で用いることに注意して下さい。

\begin{scheme}
(define (div-interval x y)
  (mul-interval 
   x
   (make-interval (/ 1.0 (upper-bound y))
                  (/ 1.0 (lower-bound y)))))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.7}Exercise 2.7:} Alyssaの
プログラムは未完成である。なぜなら彼女は区間の抽象の実装を特定していない。
以下に区間のコンストラクタの定義を置く。

\begin{scheme}
(define (make-interval a b) (cons a b))
\end{scheme}


セレクタ\code{upper\-/bound}と\code{lower\-/bound}を定義し実装を完成させよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.8}Exercise 2.8:} Alyssaの
考えと同様の推論を用いて、2つの区間の差がどのように計算されるかを説明せよ。
対応する減算手続\code{sub\-/interval}を定義せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.9}Exercise 2.9:} 区間の
\newterm{width}(\jnewterm{幅})は上限と下限の差の半値である。幅は区間で指定された数値
の不確かさの基準である。いくつかの数値演算に対しては、2つの区間を結合した結果の幅は
引数区間の幅のみによる関数である。一方で他の演算においては結合の幅は引数の幅の
関数ではない。2つの区間の和、または差の幅は足される、または引かれる区間の幅の
関数であることを示せ。これが乗算と除算においては正しくないことを例をもって示せ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.10}Exercise 2.10:} エキスパートシステム
プログラマのBen BitdiddleはAlyssaの肩越しに覗いて、
区間の長さが0の時に割ったらどうなるのか不明だよとコメントした。
Alyssaのコードを変更し、この条件をチェックしてもしそれが起こればエラーを返すようにせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.11}Exercise 2.11:} 通り過ぎながら
Benはまた曖昧なコメントを残した。``区間の終端の符号をテストすることで
\code{mul\-/interval}を7つに場合分けできる。その1つのみが2つ以上の乗算を必要とする。''
この手続をBenの提案に従い書き直せ。
\end{quote}
\noindent
プログラムをデバッグした後で、Alyssaはユーザ候補の一人に見せた。彼は彼女の
プログラムは間違った問題を解いていると文句を言った。彼が欲しい のは中央値として
表現された数値と追加の許容誤差を扱えるプログラムだ。例えば彼は\( 3.5 \pm 0.15 \)の
ような区間を扱いたく、[3.35, 3.65]ではない。Alyssaは彼女の机に戻りこの問題を代替となる
コンストラクタとセレクタを提供することで直した。

\begin{scheme}
(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))
(define (center i)
  (/ (+ (lower-bound i) (upper-bound i)) 2))
(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))
\end{scheme}
\noindent
不運なことに、Alyssaのユーザの多くはエンジニアです。実際の工学の場では通常、小さな不確かさ
を伴なう計測を伴い、区間の中央値に対する区間の幅の割合として測定されます。
エンジニアは通常パーセンテージにて許容誤差を端末のパラメータ上に、以前に与えた抵抗の
仕様のように指定します。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.12}Exercise 2.12:} コンストラクタ
\code{make\-/center\-/percent}を中央値とパーセンテージ許容誤差を取り
望まれた区間を返すように定義せよ。セレクタ\code{percent}を与えられた区間に対する
パーセンテージ許容誤差を返すように定義することも行うこと。\code{center}セレクタは
上で見たものと同じである。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.13}Exercise 2.13:} 小さな
パーセンテージ許容誤差の前提の下では、2つの区間の積のパーセンテージ許容誤差を
因数の許容誤差を用いて近似するための簡単な式が存在することを示せ。
全ての数値は正であると前提して問題を簡単にしても良い。
\end{quote}

\noindent
大変な仕事を終え、Alyssa P. Hackerは完了したシステムを受け渡しました。何年か後、彼女が全てを忘れた頃に、
彼女は興奮した電話を、怒ったユーザ、Lem E. Tweakitから受けました。どうやらLemは並列接続の抵抗の式が2つの
代数的に等価な方法で書くことができることに気付いたようです。
\begin{comment}

\begin{example}
 R_1 R_2
---------
R_1 + R_2
\end{example}

\end{comment}
\begin{displaymath}
 R_1 R_2 \over R_1 + R_2 
\end{displaymath}
\noindent
と、
\begin{comment}

\begin{example}
      1
-------------
1/R_1 + 1/R_2
\end{example}

\end{comment}
\begin{displaymath}
 {1 \over 1 / R_1 + 1 / R_2}\,. 
\end{displaymath}

彼は以下の2つのプログラムを書きました。それぞれが並列接続の抵抗値を異なる式で計算します。

\begin{scheme}
(define (par1 r1 r2)
  (div-interval (mul-interval r1 r2)
                (add-interval r1 r2)))
\end{scheme}

\begin{scheme}
(define (par2 r1 r2)
  (let ((one (make-interval 1 1)))
    (div-interval 
     one (add-interval (div-interval one r1)
                       (div-interval one r2)))))
\end{scheme}

\vspace{0.3em}

LemはAlyssaのプログラムは2つの方法の演算にて異なる値を返すと抗議しました。
これは深刻な苦情です。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.14}Exercise 2.14:} Lemが正しいことを
確認せよ。様々な数値演算にてシステムの挙動を調べよ。
ある区間\( A \)と\( B \)を作成し、式\( A /\! A \)と\( A / B \)の計算において
それらを用いよ。幅が中央値の小さなパーセンテージである区間を用いることで多くの実態を掴む
ことができるだろう。center-percent形式(\link{Exercise 2.12}参照)の演算の結果を
調査せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.15}Exercise 2.15:} Eva Lu Atorは
もう一人のユーザで、彼女もまた異なるが代数的には等価な式により異なる区間が
算出されることに気付いた。彼女はAlyssaのシステムを用いて区間の計算をする式が、
もし式が不確かな値を表現する変数がどれも繰り返されない形であれば、より厳しい
エラーの限界を算出すると言う。
従って彼女は抵抗の並列に対し、\code{par2}の方が\code{par1}より``より良い''プログラムであると述べた。
彼女は正しいだろうか? それは何故か?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.16}Exercise 2.16:} 一般的に、
なぜ等価な代数式が異なる答に導くのか説明せよ。
この欠点を持たない区間演算パッケージを開発することは可能だろうか。
または不可能だろうか。(警告：この問題はとても難しい)
\end{quote}

%=======================================================================================================

\section{階層データと閉包性}
\label{Section 2.2}



ここまで学んだように、ペアは私達が複合データオブジェクトを構築するのに利用可能な
プリミティブな``糊''を提供します。\link{Figure 2.2}はペア---この場合は\code{(cons 1 2)}
にて形成されたペアを図示する標準的な方法を示しています。
この\newterm{box-and-pointer notation}(\jnewterm{箱と点表記法})と呼ばれる表現において、
各オブジェクトは箱への\newterm{pointer}(\jnewterm{ポインタ})として表わされています。
プリミティブオブジェクトの箱はオブジェクトの表現を持っています。例えば数値の箱は
数字を持っています。ペアの箱は実際には二重の箱で、左部分はペアの\code{car}(へのポインタ)
を持っており、右部分は\code{cdr}を持っています。




私達は既に\code{cons}が数値のみでなくペアもまた組み合わせられることについて学びました。
(\link{Exercise 2.2}と\link{Exercise 2.3}であなたはこの事実を用いたか、または用いざるを得な
かったでしょう)。結果としてペアは全ての種類のデータ構造を構築可能な普遍的な構築ブロックを
提供します。\link{Figure 2.3}は数値1, 2, 3, 4を組み合わせるためにペアを用いる
2つの方法を示しています。

\begin{figure}[tb]
\phantomsection\label{Figure 2.2}
\centering
\begin{comment}
\heading{Figure 2.2:} Box-and-pointer representation of \code{(cons 1 2)}.

\begin{example}
     +---+---+     +---+
---->| * | *-+---->| 2 |
     +-|-+---+     +---+
       |
       V
     +---+
     | 1 |
     +---+
\end{example}
\end{comment}
\includegraphics[width=34mm]{fig/chap2/Fig2.2c.pdf}
\begin{quote}
\heading{Figure 2.2:} \code{(cons 1 2)}の箱とポインタ表現
\end{quote}
\end{figure}

\begin{figure}[tb]
\phantomsection\label{Figure 2.3}
\centering
\begin{comment}
\heading{Figure 2.3:} Two ways to combine 1, 2, 3, and 4 using pairs.

\begin{example}
     +---+---+     +---+---+         +---+---+     +---+
---->| * | *-+---->| * | * |    ---->| * | *-+---->| 4 |
     +-|-+---+     +-|-+-|-+         +-|-+---+     +---+
       |             |   |             |
       V             V   V             V
   +---+---+      +---+ +---+      +---+---+     +---+---+
   | * | * |      | 3 | | 4 |      | * | *-+---->| * | * |
   +-|-+-|-+      +---+ +---+      +-|-+---+     +-|-+-|-+
     |   |                           |             |   |
     V   V                           V             V   V
  +---+ +---+                      +---+        +---+ +---+
  | 1 | | 2 |                      | 1 |        | 2 | | 3 |
  +---+ +---+                      +---+        +---+ +---+

  (cons (cons 1 2)                 (cons (cons 1
        (cons 3 4))                            (cons 2 3))
                                         4)
\end{example}
\end{comment}
\includegraphics[width=96mm]{fig/chap2/Fig2.3c.pdf}
\begin{quote}
\heading{Figure 2.3:} ペアを用いて1,2,3,4を組み合わせる2つの方法
\end{quote}
\end{figure}

\noindent
要素がペアであるペアを作成する能力は表現ツールとしてのリスト構造の重要性の本質です。
私達はこの能力を\code{cons}の\jnewterm{閉包性}(closure property)と呼びます。
一般的に、データオブジェクトを組み合わせる操作は
もしその命令による組み合わせの結果それ自身が同じ命令を用いて組み合わせることが可能ならば
閉包性を満たします。\footnote{
ここでの``closure''(閉包)という用語の使用は抽象代数から来ており、
もし操作の集合の要素への適用により生成される要素が再び同じ集合の要素である場合、
要素の集合が操作の下において閉じられていると呼ばれます。Lispコミュニティでは(残念なことに)
用語``closure''を全く関係のない概念にも使用しています。closureとは自由変数を持つ
手続を表現するための実装テクニックです。私達は``closure''をこの本の中では2つ目の意味では
用いません。}
閉包はどのような目的の組み合わせをも強力にする鍵となります。なぜなら\newterm{hierarchical}(\jnewterm{階層})構造---
複数のパーツから成る構造であり、パーツ自身も複数のパーツから成るような構造を作成することが
可能になるためです。



\link{Chapter 1}の始めから、手続の取扱において閉包を本質的に利用してきました。
とても簡単なプログラムを除けば全てのプログラムは組み合わせの要素はそれ自身も
また組み合わせであるという事実に依存しているためです。
この節では複合データにとっての閉包の重要性を取り上げます。
ペアを使用して列と木を表現するための、いくつかの便利なテクニックを説明します。
そして鮮烈な方法でクロージャを図示するグラフィック言語を提示します。\footnote{
組み合わせは閉包であるべきだという手段の概念は単純なアイデアです。
残念なことに多くの人気の有るプログラミング言語が提供するデータの組み合わせ手法は
閉包性を満たしませんし、閉包性の活用が面倒です。FortranやBASICではデータ要素を
組合せる典型的な1つの手段は配列にそれらをまとめることです。しかし配列の要素自身が
配列である配列を形成できません。PascalとCは構造体の要素が構造体であることを認めます。
しかしこれはプログラマが明示的にポインタを取り扱うことを要求し、構造体の各フィールドが
事前に指定された形式の要素のみを保管できるという制約に帰着します。Lispのペアとは
異なりこれらの言語は複合データを統一的な方法で扱うことを簡単にする組み込みの汎用目的な糊
を持っていません。この制約がこの本の前書きにおけるAlan Perlisのコメントの背景にあります。
``Pascalにおける過剰な宣言可能なデータ構造は関数内にて特殊化を引き起こし、カジュアルな連携を
不利にし、抑制してしまう。1つのデータ構造を操作する100の関数を持つほうが、10のデータ構造を
操作する10の関数を持つよりも良い。''}

\subsection{列の表現}
\label{Section 2.2.1}



ペアを用いて構築可能な便利な構造の1つが\newterm{sequence}(\jnewterm{列})---順に並べたデータ
オブジェクトの集合です。もちろんペアを用いて列を表現する方法は数多く存在します。
特に簡単な表現方法の1つを\link{Figure 2.4}に示します。列1, 2, 3, 4がペアの連鎖として
表わされています。各ペアの\code{car}は鎖内で相対するアイテムであり、各ペアの\code{cdr}は
鎖内での次のペアです。最後のペアの\code{cdr}は列の終端をペアではないことを識別する値を
指し示すことで合図します。箱とポインタの図では斜めの線にて表現され、プログラムでは
変数\code{nil}の値にて示されます。列全体は入れ子の\code{cons}命令にて構築されます。

\begin{scheme}
(cons 1
      (cons 2
            (cons 3
                  (cons 4 nil))))
\end{scheme}

\begin{figure}[tb]
\phantomsection\label{Figure 2.4}
\centering
\begin{comment}
\heading{Figure 2.4:} The sequence 1, 2, 3, 4 represented as a chain of pairs.

\begin{example}
     +---+---+     +---+---+     +---+---+     +---+---+
---->| * | *-+---->| * | *-+---->| * | *-+---->| * | / |
     +-|-+---+     +-|-+---+     +-|-+---+     +-|-+---+
       |             |             |             |
       V             V             V             V
     +---+         +---+         +---+         +---+
     | 1 |         | 2 |         | 3 |         | 4 |
     +---+         +---+         +---+         +---+
\end{example}
\end{comment}
\includegraphics[width=76mm]{fig/chap2/Fig2.4c.pdf}
\begin{quote}
\heading{Figure 2.4:} ペアの鎖として表現された列1, 2, 3, 4
\end{quote}
\end{figure}

\noindent
そのようなペアの列は入れ子の\code{cons}にて形成され、\newterm{list}(\jnewterm{リスト})と呼ばれます。
そしてSchemeは\code{list}と呼ばれるプリミティブを提供しリストの構築を手助けします。\footnote{
この本では\newterm{list}をリスト終端マーカーにて終端化されたペアの鎖を意味するように
使用します。一方で用語\newterm{list structure}(\jnewterm{リスト構造})はペアから作り上げられた
任意のデータ構造を参照し、ただのリストは意味しません。}
上の列は\code{(list 1 2 3 4)}により生成可能です。

\begin{scheme}
(list ~\( \dark \langle \)~~\( \dark a_1 \)~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark a_2 \)~~\( \dark \rangle \)~ ~\( \dots \)~ ~\( \dark \langle \)~~\( \dark a_n \)~~\( \dark \rangle \)~)
\end{scheme}

\noindent
is equivalent to

は以下と等価です。

\begin{scheme}
(cons ~\( \dark \langle \)~~\( \dark a_1 \)~~\( \dark \rangle \)~
      (cons ~\( \dark \langle \)~~\( \dark a_2 \)~~\( \dark \rangle \)~
            (cons ~\( \dots \)~
                  (cons ~\( \dark \langle \)~~\( \dark a_n \)~~\( \dark \rangle \)~
                        nil)~\( \dots \)~)))
\end{scheme}

\noindent
Lispシステムは慣習としてリストを括弧で括られた要素の列を表示することで表します。
従って\link{Figure 2.4}のデータオブジェクトは\code{(1 2 3 4)}の様に表示されます。

\begin{scheme}
(define one-through-four (list 1 2 3 4))
one-through-four
~\textit{(1 2 3 4)}~
\end{scheme}

\noindent
式\code{(list 1 2 3 4)}とリスト\mbox{\code{(1 2 3 4)}}を取り違えないよう気をつけて下さい。
リストは式が評価された時に得られた結果です。式\code{(1 2 3 4)}を評価しようとする試みは
インタプリタが手続\code{1}を引数\code{2}, \code{3}, \code{4}に適用しようとした時にエラーを
発します。



\code{car}をリスト内の最初のアイテムを選択すると考えることもでき、\code{cdr}を
最初のアイテム以外の全てにより成り立つサブ(副)リストを選択すると考えることも
可能です。\code{car}と\code{cdr}の入れ子の適用はリスト内の2つ目、3つ目、そして
その後に続く複数のアイテムを抽出するために利用可能です。\footnote{
\code{car}と\code{cdr}の入れ子の適用は書くのが面倒なためLispの各種方言はそれらに対する
略記法を提供しています。例えば、

\begin{smallscheme}
(cadr ~\( \dark \langle \)~~\( \dark arg \)~~\( \dark \rangle \)~) = (car (cdr ~\( \dark \langle \)~~\( \dark arg \)~~\( \dark \rangle \)~))
\end{smallscheme}

そのような手続全ての名前は\code{c}で始まり\code{r}で終わります。それらの間の各\code{a}は\code{car}命令を
意図し、\code{d}は\code{cdr}命令を意図し、その名前に現れた順と同じ順にて適用されます。\code{car}と\code{cdr}の
名前は存続します。なぜなら\code{cadr}のような単純な組み合わせが発音可能だからです。}


コンストラクタ\code{cons}は元のリストと同様のリストを作りますが、最初に追加のアイテムを入れます。

\begin{scheme}
(car one-through-four)
~\textit{1}~
(cdr one-through-four)
~\textit{(2 3 4)}~
(car (cdr one-through-four))
~\textit{2}~
(cons 10 one-through-four)
~\textit{(10 1 2 3 4)}~
(cons 5 one-through-four)
~\textit{(5 1 2 3 4)}~
\end{scheme}

\noindent
code{nil}の値はペアの鎖を終了するために使用されますが、全く要素が無い列\newterm{empty list}
(\jnewterm{空リスト})として考えることもできます。\newterm{nil}という単語はラテン語の単語\emph{nihil}
の省略形で、``無''を意味します。\footnote{
どれだけのエネルギーがLisp方言の標準化において文字通り意味の無い議論に浪費されたかについて
は特筆に値します。\code{nil}は普通の名前であるべきか? \code{nil}の値は記号であるべきか?
それはリストであるべきか? それはペアであるべきか? Schemeでは\code{nil}は普通の名前であり
この節では変数として扱いその値はリスト終端マーカーです。(\code{true}が普通の変数であり、真の値を
持つのと同様です)。Common Lispを含む他のLisp方言は\code{nil}を特別な記号として扱います。
この本の著者達は、言語の標準化における数多くの乱闘に耐えてきたので、この問題全体を避けたいと
思います。\link{Section 2.3}にてquoteを紹介した後には空リストに\code{'()}という名前を付け、全体的に
変数\code{nil}を免除します。}

\subsubsection*{リスト命令}


複数のペアを使用して要素の列をリストのように表現することは、慣習的なプログラミングテクニック
である連続してリストを``\code{cdr}で縮小する''ことによりリストを操作するのと同時に生じます。
例えば手続\code{list\-/ref}は引数としてリストと数値\( n \)を取り、リストの\( n \)番目の項目を
返します。リストの要素を数えるのに0から始めるのが慣習です。
\code{list\-/ref}を計算する方法は以下の通りです。

\begin{itemize}

\item
\( n = 0 \)の場合、\code{list\-/ref}はリストの\code{car}を返す。

\item
そうでなければ、\code{list\-/ref}はリストの\code{cdr}の\( (n - 1) \)番目の項目を返す。

\end{itemize}

\begin{scheme}
(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))
(define squares (list 1 4 9 16 25))
(list-ref squares 3)
~\textit{16}~
\end{scheme}

\noindent
時折、私達はリスト全体を\code{cdr}で下ります。これを手助けするために、Schemeは
プリミティブな手続\code{null?}を持っており、その引数が空リストであるかどうかを試験します。
手続\code{length}はリスト内の要素数を返しますが、\code{null?}の使用の典型的なパターンを説明します。

\begin{scheme}
(define (length items)
  (if (null? items)
      0
      (+ 1 (length (cdr items)))))
(define odds (list 1 3 5 7))
(length odds)
~\textit{4}~
\end{scheme}

\noindent
手続\code{length}は単純な最近計画を実装します。集約ステップは以下の通りです。

\begin{itemize}

\item
任意のリストの\code{length}はリストの\code{cdr}の\code{length}に1を足した値

\end{itemize}

\noindent
これが底となるケースに到達するまで繰り返し適用される

\begin{itemize}

\item
空リストの\code{length}は0

\end{itemize}

\noindent
また\code{length}は反復スタイルでも計算可能です。

\begin{scheme}
(define (length items)
  (define (length-iter a count)
    (if (null? a)
        count
        (length-iter (cdr a) (+ 1 count))))
  (length-iter items 0))
\end{scheme}

\noindent
もう1つの慣習的なプログラミングテクニックは\code{cdr}を繰り返し利用しリストを下る間に、
答のリストを``\code{cons}で積み上げ''ることです。これは手続\code{append}にて利用され、
\code{append}は2つのリストを引数として取り、それらの要素を結合し、新しいリストを作ります。

\begin{scheme}
(append squares odds)
~\textit{(1 4 9 16 25 1 3 5 7)}~
(append odds squares)
~\textit{(1 3 5 7 1 4 9 16 25)}~
\end{scheme}

\noindent
\code{append}もまた再帰計画を用いて実装されます。リスト\code{list1}と\code{list2}を
\code{append}するためには以下の通りに行います。

\begin{itemize}

\item
もし\code{list1}が空リストであれば、結果は単に\code{list2}

\item
そうでない場合、\code{list1}の\code{cdr}と\code{list2}を\code{append}し、その結果の上に
\code{list1}の\code{car}を\code{cons}する

\end{itemize}

\begin{scheme}
(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1) (append (cdr list1) list2))))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.17}Exercise 2.17:} 与えられた(空でない)
リストの最初の要素のみを持つリストを返す手続\code{last\-/pair}を定義せよ。

\begin{scheme}
(last-pair (list 23 72 149 34))
~\textit{(34)}~
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.18}Exercise 2.18:}リストを引数として取り、同じ要素を逆順に持つリストを返す手続\code{reverse}を定義せよ。

\begin{scheme}
(reverse (list 1 4 9 16 25))
~\textit{(25 16 9 4 1)}~
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.19}Exercise 2.19:} \link{Section 1.2.2}の
両替数え上げプログラムについて考える。プログラムにて用いられる
通貨を容易に変更できるようになればとても良いだろう。そうすることで例えば
イギリスのポンドの両替方法の数を計算できるようになるだろう。プログラムが書かれた時には、
通貨の知識はある部分は手続\code{first\-/denomination}の中に、またある部分は手続\code{count\-/change}の
中に存在した。(\code{count\-/change}は米国の貨幣には5種類あることを知っていた)。
両替を行うため利用される貨幣のリストが提供できるようになればより良くなるだろう。


\code{cc}を変更することで、その2つ目の引数がどの貨幣を使用するかを指定する整数ではなく、
使用する貨幣の値のリストとなるようにしたいと考える。そして通貨の各種類を定義する
リストを持つことにする。

\begin{scheme}
(define us-coins (list 50 25 10 5 1))
(define uk-coins (list 100 50 20 10 5 2 1 0.5))
\end{scheme}


次に\code{cc}を以下のように呼び出す。

\begin{scheme}
(cc 100 us-coins)
~\textit{292}~
\end{scheme}


これを行うためにはプログラム\code{cc}に何らかの変更が必要だ。同じ形態を保つが、
2つ目の引数に異なる方法でアクセスする。以下のようになる。

\begin{scheme}
(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (no-more? coin-values)) 0)
        (else
         (+ (cc amount
                (except-first-denomination 
                 coin-values))
            (cc (- amount
                   (first-denomination 
                    coin-values))
                coin-values)))))
\end{scheme}

リスト構造に対するプリミティブな命令を用いて
手続\code{first\-/denomination}, \code{except\-/first\-/de- nomination}, and \code{no\-/more?}を定義せよ。
リスト\code{coin\-/values}の順は\code{cc}により生成される解答に影響を与えるか?
それは何故か? または何故そうでないのか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.20}Exercise 2.20:}手続
\code{+}, \code{*}, \code{list}は任意の数の引数を取る。そのような手続を定義する1つの
方法として\newterm{dotted-tail notation}(\jnewterm{ドット付き末尾記法})と共に\code{define}を使用することが上げられる。
手続定義において、最後のパラメータ名の前にドットがあるパラメータリストは手続が呼び出された時に、
最初以下のパラメータが(もし存在したら)初期引数の値を通常通りに持つが、最後のパラメータの値は
残りの引数全てのリストとなる。例えば、以下の定義を与えられた時に、

\begin{scheme}
(define (f x y . z) ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
手続\code{f}は2つ以上の引数で呼び出すことが可能だ。もし次を評価すれば、

\begin{scheme}
(f 1 2 3 4 5 6)
\end{scheme}

\noindent
\code{f}のボディでは\code{x}が1、 \code{y}が2、そして\code{z}はリスト\mbox{\code{(3 4 5 6)}}となる。
以下の定義を与えられた時、

\begin{scheme}
(define (g . w) ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
手続\code{g}はゼロ個以上の引数にて呼び出し可能となる。
次を評価すれば、

\begin{scheme}
(g 1 2 3 4 5 6)
\end{scheme}

\noindent
\code{g}のボディでは\code{w}はリスト\code{(1 2 3 4 5 6)}となる。\footnote{
To define \code{f} and \code{g} using \code{lambda} we would
write


\code{f}と\code{g}を\code{lambda}を用いて定義するには、以下のように記述する。

\begin{smallscheme}
(define f (lambda (x y . z) ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~))
(define g (lambda w ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~))
\end{smallscheme}
}



この記法を用いて手続\code{same\-/parity}を書け。\code{same\-/parity}は1つまたは
それ以上の整数を引数として取り、最初の引数と同じ偶奇性を持つ全ての引数の
リストを返す。例えば、

\begin{scheme}
(same-parity 1 2 3 4 5 6 7)
~\textit{(1 3 5 7)}~
(same-parity 2 3 4 5 6 7)
~\textit{(2 4 6)}~
\end{scheme}
\end{quote}

\subsubsection*{リストに渡るmap}

あるとても便利な命令は、ある変換をリストの各要素に適用し、結果のリストを返します。
例えば以下の手続はリストの各数値を与えられた因数で拡大します。

\begin{scheme}
(define (scale-list items factor)
  (if (null? items)
      nil
      (cons (* (car items) factor)
            (scale-list (cdr items) 
                        factor))))
(scale-list (list 1 2 3 4 5) 10)
~\textit{(10 20 30 40 50)}~
\end{scheme}

\noindent
私達は\link{Section 1.3}のように、この一般的な考えを抽象化し、高階手続にて表現された共通なパターン
として捉えることができます。ここでの高階手続は\code{map}と呼ばれます。\code{map}は引数として
1引数の手続とリストを取り、返り値としてその手続をリストの各要素に適用することで得られた
結果のリストを返します。\footnote{\label{Footnote 12}
Schemeは標準としてここで説明される物よりもより汎用的な\code{map}手続を提供します。
このより汎用的な\code{map}は\( n \)引数の手続を、\( n \)個のリストと共に取り、
全てのリストの最初の要素を手続に適用し、次に全ての2つ目の要素を適用し、以下それを繰り返し、
結果のリストを返します。例えば、

\begin{smallscheme}
(map + (list 1 2 3) (list 40 50 60) (list 700 800 900))
~\textit{(741 852 963)}~
(map (lambda (x y) (+ x (* 2 y)))
     (list 1 2 3)
     (list 4 5 6))
~\textit{(9 12 15)}~
\end{smallscheme}
}

\begin{scheme}
(define (map proc items)
  (if (null? items)
      nil
      (cons (proc (car items))
            (map proc (cdr items)))))
(map abs (list -10 2.5 -11.6 17))
~\textit{(10 2.5 11.6 17)}~
(map (lambda (x) (* x x)) (list 1 2 3 4))
~\textit{(1 4 9 16)}~
\end{scheme}

\noindent
これで\code{map}を用いた新しい\code{scale\-/list}の定義を与えられる。

\begin{scheme}
(define (scale-list items factor)
  (map (lambda (x) (* x factor))
       items))
\end{scheme}

\noindent
\code{map}は重要な構造です。それが共通なパターンを掴むからだけでなく、リストを扱う
より高いレベルの抽象化を確立させるためです。\code{scale\-/list}の元の定義では
プログラムの再帰構造はリストのエレメント毎の処理に注意を引きました。
\code{map}を用いた\code{scale\-/list}の定義はそのレベルの詳細を抑制し、要素のリストから
結果のリストへの拡大変換を強調します。2つの定義の間の違いはコンピュータが異なる
処理を行うことではなく(異なりますが)、私達が過程について異って考えていることです。
実際に、\code{map}はリストの要素がどのように抽出され、また結合されるかの詳細から
リストを変換する手続の実装を分離する抽象化バリアを強化することを手助けします。
\link{Figure 2.1}にて示されるバリアのように、この抽象化は私達に列がどのように実装さ
れるかの低レベルの詳細を変更する柔軟性を提供し、その上で列から列へと変換する操作の
概念上のフレームワークを保っている。\link{Section 2.2.3}はこのプログラムを構成するためのフレームワーク
としての列の利用を拡張している。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.21}Exercise 2.21:} T手続
\code{square\-/list}は数値のリストを引数として取りそれらの数値の二乗のリストを返す。

\begin{scheme}
(square-list (list 1 2 3 4))
~\textit{(1 4 9 16)}~
\end{scheme}


ここに2つの異なる\code{square\-/list}がある。失なわれた式を埋めることで両者を
完成させよ。

\begin{scheme}
(define (square-list items)
  (if (null? items)
      nil
      (cons ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~)))
(define (square-list items)
  (map ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.22}Exercise 2.22:} Louis Reasonerは
\link{Exercise 2.21}の最初の\code{square\-/list}手続を書き直し、
反復プロセスを展開させようと試みている。

\begin{scheme}
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons (square (car things))
                    answer))))
  (iter items nil))
\end{scheme}



残念なことに、\code{square\-/list}をこのように定義しては解答のリストは希望の逆順に
なってしまう。何故か?


Louisはそこで彼のバグを\code{cons}への引数を逆順にすることで直そうと試みた。

\begin{scheme}
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons answer
                    (square (car things))))))
  (iter items nil))
\end{scheme}

これもまたうまく行かない。説明せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.23}Exercise 2.23:} 手続
\code{for\-/each}は\code{map}に似ている。手続と要素のリストを引数として取る。しかし
結果のリストを形成するのではなく、\code{for\-/each}はただ手続を左から右へと毎回各要素に適用する。
手続を要素に適用し返された値は全く利用しない---\code{for\-/each}は表示のような行動を起こす手続と共に
利用される。例えば、

\begin{scheme}
(for-each (lambda (x)
            (newline)
            (display x))
          (list 57 321 88))
~\textit{57}~
~\textit{321}~
~\textit{88}~
\end{scheme}



(上では示されていない)\code{for\-/each}呼出による返り値は真のような不定な何かである。
\code{for\-/each}の実装を与えよ。
\end{quote}

\subsection{階層構造}
\label{Section 2.2.2}



リストを用いた列の表現は要素が列自身である列を表現することを自然に一般化する。
例えば以下の様に構築されたオブジェクト\code{((1 2) 3 4)}を

\begin{scheme}
(cons (list 1 2) (list 3 4))
\end{scheme}

\noindent
最初の項目はそれ自身がリスト\code{(1 2)}である、3つの項目のリストであると見做すことができる。
実際に、インタプリタにより表示される結果の形式によりこれは推奨されている。
\link{Figure 2.5}がペアを用いたこの構造の表現を示している。

\begin{figure}[tb]
\phantomsection\label{Figure 2.5}
\centering
\begin{comment}
\heading{Figure 2.5:} Structure formed by \code{(cons (list 1 2) (list 3 4))}.

\begin{example}
                                          (3 4)
                                            |
                                            V
((1 2) 3 4)  +---+---+                  +---+---+     +---+---+
        ---->| * | *-+----------------->| * | *-+---->| * | / |
             +-|-+---+                  +-|-+---+     +-|-+---+
               |                          |             |
               V                          V             V
      (1 2)  +---+---+     +---+---+    +---+         +---+
        ---->| * | *-+---->| * | / |    | 3 |         | 4 |
             +-|-+---+     +-|-+---+    +---+         +---+
               |             |
               V             V
             +---+         +---+
             | 1 |         | 2 |
             +---+         +---+
\end{example}
\end{comment}
\includegraphics[width=91mm]{fig/chap2/Fig2.5c.pdf}
\begin{quote}
\heading{Figure 2.5:} \code{(cons (list 1 2) (list 3 4))}により形作られた構造
\end{quote}
\end{figure}

\noindent
要素それ自身が列である列のもう1つの考え方は木としての考え方である。
列の要素は木の枝であり、それ自身が列である\mbox{elements}(複数の要素)は部分木である。
\link{Figure 2.6}は木として見た場合の\link{Figure 2.5}を示している。

\begin{figure}[tb]
\phantomsection\label{Figure 2.6}
\centering
\begin{comment}
\heading{Figure 2.6:} The list structure in \link{Figure 2.5} viewed as a tree.

\begin{example}
 ((1 2) 3 4)
     /\\
    /  | \
(1 2)  3 4
 / \
 1 2
\end{example}
\end{comment}
\includegraphics[width=22mm]{fig/chap2/Fig2.6a.pdf}
\begin{quote}
\heading{Figure 2.6:} 木として見た\link{Figure 2.5}のリスト構造
\end{quote}
\end{figure}

\noindent
再帰は木構造を扱うのに自然なツールです。良く木に対する操作を枝に対する操作へと
還元でき、それは順に枝の枝への操作へと還元され、木の葉に辿り着くまで繰り返され
ます。例として、\link{Section 2.2.1}の\code{length}手続を木の葉の総数を求める\code{count\-/leaves}
手続と比べてみましょう。

\begin{scheme}
(define x (cons (list 1 2) (list 3 4)))
(length x)
~\textit{3}~
(count-leaves x)
~\textit{4}~
(list x x)
~\textit{(((1 2) 3 4) ((1 2) 3 4))}~
(length (list x x))
~\textit{2}~
(count-leaves (list x x))
~\textit{8}~
\end{scheme}

\noindent
\code{count\-/leaves}を実装するには\code{length}を求める再帰計画を思い出します。

\begin{itemize}

\item
リスト\code{x}の\code{length}は\code{x}の\code{cdr}の\code{length}に1を足した物

\item
空リストの\code{length}は0

\end{itemize}

\noindent
\code{count\-/leaves}も同様えす。空リストの値は同じで

\begin{itemize}

\item
空リストの\code{count\-/leaves}は0

\end{itemize}

\noindent
しかし集約ステップにおいて、リストの\code{car}を取り除く時、\code{car}はそれ自身が
後で数えねばならない木である可能性があることを計算に入れねばなりません。
従って適切な集約ステップは

\begin{itemize}

\item
木\code{x}の\code{count\-/leaves}は\code{x}の\code{car}の\code{count\-/leaves}と、
\code{x}の\code{cdr}の\code{count\-/leaves}の和

\end{itemize}

\noindent
最終的に\code{car}を取ることにより実際の葉に届くので別の規範を必要とする。

\begin{itemize}

\item
葉の\code{count\-/leaves}は1

\end{itemize}

\noindent
木に対する再帰手続を書くのを助けるために、Schemeはプリミティブな手続\code{pair?}を提供します。
\code{pair?}は引数がペアであるかをテストします。以下に完成した手続を置きます。\footnote{
\code{cond}の最初の2つの項の順が大事です。空リストは\code{null?}を満たし、その上でペアでも
ありません}

\begin{scheme}
(define (count-leaves x)
  (cond ((null? x) 0)
        ((not (pair? x)) 1)
        (else (+ (count-leaves (car x))
                 (count-leaves (cdr x))))))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.24}Exercise 2.24:} 式
\code{(list 1 (list 2 (list 3 4)))}を評価したとする。インタプリタの表示する
結果、対応する箱と点構造、木としての解釈(\link{Figure 2.6}相当)を示せ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.25}Exercise 2.25:} 以下の
各リストから7を抽出する\code{car}と\code{cdr}の組み合わせを与えよ。

\begin{scheme}
(1 3 (5 7) 9)
((7))
(1 (2 (3 (4 (5 (6 7))))))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.26}Exercise 2.26:} 2つのリスト\code{x}と\code{y}を定義したとする。

\begin{scheme}
(define x (list 1 2 3))
(define y (list 4 5 6))
\end{scheme}


以下の各式を評価した場合にレスポンスとしてインタプリタがどのような結果を表示するか?

\begin{scheme}
(append x y)
(cons x y)
(list x y)
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.27}Exercise 2.27:} \link{Exercise 2.18}の
\code{reverse}手続を変更してリストを引数として取り、
全ての要素が逆順に、さらに全てのサブリストも同様に逆順にされたリストをその値として
返す手続\code{deep\-/reverse}を作れ。例として、

\begin{scheme}
(define x (list (list 1 2) (list 3 4)))
x
~\textit{((1 2) (3 4))}~
(reverse x)
~\textit{((3 4) (1 2))}~
(deep-reverse x)
~\textit{((4 3) (2 1))}~
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.28}Exercise 2.28:} リストとして
表現された木を引数に取り、その木の全ての葉を左から右への順で要素とした
リストを返す手続\code{fringe}を書け。

\begin{scheme}
(define x (list (list 1 2) (list 3 4)))
(fringe x)
~\textit{(1 2 3 4)}~
(fringe (list x x))
~\textit{(1 2 3 4 1 2 3 4)}~
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.29}Exercise 2.29:} バイナリモバイル(binary mobile)\footnote{
訳注：天井から糸で釣ってあり、絶妙なバランスで揺れ、回る数々の棒のインテリア。
枝が必ず2つに分かれるのでバイナリ(二進)と名付けられている。Google Imagesで
mobileを検索すると実物が見られる。}
は左の枝と右の枝の2つの枝で構成される。各枝はある長さを持つ
棒であり、そこから重りか別のバイナリモバイルをぶら下げる。
バイナリモバイルを複合データを用いて2つの枝から組み立てることで表現できる。
(例えば\code{list}を用いる。)

\begin{scheme}
(define (make-mobile left right)
  (list left right))
\end{scheme}


枝は\code{length}(数値であること)と\code{structure}から組み立てられ、\code{structure}は
数値(簡単に重りを表わす)かまたは他のモバイルである。

\begin{scheme}
(define (make-branch length structure)
  (list length structure))
\end{scheme}

\begin{enumerate}[a]

\item
対応するセレクタ\code{left\-/branch}を\code{right\-/branch}を書け。このセレクタは
モバイルの複数の枝を返す。また\code{branch\-/length}と\code{branch\-/structure}
は枝のそれぞれのコンポーネント(構成要素)を返す。

\item
セレクタを用いて手続\code{total\-/weight}を定義せよ。それはモバイルの総重量を
返す。

\item
モバイルは一番上の左枝にかかるトルク(回転力)が一番上の右の枝にかかるトルクと等しい時
(これはつまり、もし左の棒の長さと
その棒にかかる重さを掛けた値が、相対する右側の積の値と同じ場合である)、かつ
各部分モバイルも全て同様である場合に限り、
\newterm{balanced}(\jnewterm{バランスが取れた状態})であると言う。
あるバイナリモバイルがバランスが取れているかテストする述語を設計せよ。

\item
モバイルの表現をコンストラクタが以下になるように変更すると考える。

\begin{scheme}
(define (make-mobile left right) (cons left right))
(define (make-branch length structure)
  (cons length structure))
\end{scheme}



新しい表現へとあなたのプログラムを変更するのにどれほどが必要か?

\end{enumerate}
\end{quote}

\subsubsection*{木に渡るmap}



\code{map}が列を扱うのに強力な抽象化であるのと同様に、再帰を伴なう\code{map}は木を
扱うのに強力な抽象化です。例えば\link{Section 2.2.1}の\code{scale\-/list}に同類な\code{scale\-/tree}
手続は引数として因数と葉が数値である木を取ります。これは同じ形の木を返しますが、
各数値は因数により乗算されます。\code{scale\-/tree}の再帰計画は\code{count\-/leaves}に対する物に
似ています。

\begin{scheme}
(define (scale-tree tree factor)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (* tree factor))
        (else (cons (scale-tree (car tree) factor)
                    (scale-tree (cdr tree) factor)))))
(scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10)
~\textit{(10 (20 (30 40) 50) (60 70))}~
\end{scheme}

\noindent
\code{scale\-/tree}を実装するもう1つの方法は木を部分木の列と見做し\code{map}を使用します。
列全体に\code{map}をかけ、各部分木を順に拡大し、結果のリストを返します。その木が葉である
場合には単純に因数を掛けます。

\begin{scheme}
(define (scale-tree tree factor)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (scale-tree sub-tree factor)
             (* sub-tree factor)))
       tree))
\end{scheme}

\noindent
多くの木の操作が同様な列操作と再帰の組み合わせにて実装可能です。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.30}Exercise 2.30:} \link{Exercise 2.21}の
\code{square\-/list}と同様の手続\code{square\-/tree}を定義せよ。
\code{square\-/tree}は以下の振舞を行う。

\begin{scheme}
(square-tree
 (list 1
       (list 2 (list 3 4) 5)
       (list 6 7)))
~\textit{(1 (4 (9 16) 25) (36 49))}~
\end{scheme}

\code{square\-/tree}を直接な(つまり高階関数を全く用いない)方法と\code{map}と再帰を
用いる方法の両者を定義せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.31}Exercise 2.31:} 
\link{Exercise 2.30}への解答を抽象化し、手続\code{tree\-/map}を作れ。
\code{tree\-/map}を用いて\code{square\-/tree}は以下のように定義できる。

\begin{scheme}
(define (square-tree tree) (tree-map square tree))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.32}Exercise 2.32:} 集合は
識別可能な要素のリストとして表現できる。そして集合の全ての部分集合集合を
リストのリストとして表わせられる。例えば、集合が\code{(1 2 3)}である時、全ての
部分集合の集合は\code{(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))}だ。
以下の集合の全ての部分集合の集合を生成する手続の定義を完成し、なぜうまくいくのか
を明確に説明せよ。

\begin{scheme}
(define (subsets s)
  (if (null? s)
      (list nil)
      (let ((rest (subsets (cdr s))))
        (append rest (map ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ rest)))))
\end{scheme}
\end{quote}

\subsection{慣習的インターフェイスとしての列}
\label{Section 2.2.3}



複合データを用いて働く場合、これまでデータ抽象化がどれだけプログラムの設計を
データ表現の詳細に陥らずに行えるか、また抽象化がどれだけ代替的な表現方法を
試みる柔軟性を保つかについて強調してきました。この節ではもう1つの強力なデータ構造を用いる
設計原則を紹介します。\newterm{conventional interfaces}(\jnewterm{慣習的インターフェイス})の使用です。



\link{Section 1.3}においてプログラム抽象化、高階手続としての実装がどのようにして数値データを取り扱う
プログラムの共通パターンを掴むことができるのかを学んできました。複合データを扱う類似の操作を
形式化する能力は決定的にデータ構造を扱うスタイルに依存します。例えば次の手続について考えて
みて下さい。\link{Section 2.2.2}の\code{count\-/leaves}手続に類似しており、木を引数として取り、奇数の葉の
二乗の合計を求めます。

\begin{scheme}
(define (sum-odd-squares tree)
  (cond ((null? tree) 0)
        ((not (pair? tree))
         (if (odd? tree) (square tree) 0))
        (else (+ (sum-odd-squares (car tree))
                 (sum-odd-squares (cdr tree))))))
\end{scheme}

\noindent
表面上では、この手続は以下の物ととても異なっています。以下では全ての偶数のフィボナッチ数
\( {\rm Fib}(k) \)のリストを、\( k \)が与えられた\( n \)以下の範囲にて作成しています。

\begin{scheme}
(define (even-fibs n)
  (define (next k)
    (if (> k n)
        nil
        (let ((f (fib k)))
          (if (even? f)
              (cons f (next (+ k 1)))
              (next (+ k 1))))))
  (next 0))
\end{scheme}

\noindent
これらの2つの手続は構造的にとても異なっているという事実にも係らず、2つの計算の
より抽象的な記述は大きな類似性を明らかにします。最初のプログラムは

\begin{itemize}

\item
木の葉を列挙する

\item
フィルタを通して奇数のみを選ぶ

\item
選択された数の二乗を求める

\item
初期値0にて\code{+}を用いて集積する。

\end{itemize}

\noindent
2つ目のプログラムは

\begin{itemize}

\item
0から\( n \)を列挙する

\item
各整数のフィボナッチ数を求める

\item
フィルタを通して偶数を選択する

\item
初期値は空リストにて\code{cons}を用いて結果を集積する

\end{itemize}

\noindent
信号処理のエンジニアはこれらの処理をステージのカスケードを通して流れる信号を
用いて処理するという概念的説明を自然だと思われるでしょう。各ステージはプログラム設計の
部分を\link{Figure 2.7}に示すように実装しています。
\code{sum\-/odd\-/squares}では\newterm{enumerator}(\jnewterm{エニュメレータ})にて始めました。それは
与えられた木の葉から成る``信号''を生成します。この信号は\newterm{filter}(\jnewterm{フィルタ})を
通して奇数要素以外を全て取り除きます。残った信号は順に``変換器''である\newterm{map}を通し、
それが\code{square}手続を各要素に適用します。mapの出力は次に\newterm{accumulator}(\jnewterm{集積機})に
与えられ、それが要素を初期値0と\code{+}を用いて連結します。\code{even\-/fibs}の設計も同様です。



残念ながら上記の2つの手続の定義はこの信号の流れの構造を提示するのは失敗しています。
例えば\code{sum\-/odd\-/squares}を調べてみるとenumeration(列挙)は部分的に\code{null?}の\code{pair?}の
テストにて実装され、別の部分では手続の木再帰構造により実装されています。
同様に集積は部分的にテストの中に見つかり、また部分的に再帰中で使用される足し算に見つかり
ます。全体的にどちらの手続も信号の流れの記述内の要素に関連する明確な部分は存在しません。
2つの手続は演算を異なる方法で分解し、列挙をプログラム全体に広げてmap, filter, accumulation
に混ぜました。もしプログラムを手続中に信号処理構造の宣言を作るように構成できるのであれば
結果としてのコードの概念の明快さを増すことができるでしょう。

\begin{figure}[tb]
\phantomsection\label{Figure 2.7}
\centering
\begin{comment}
\begin{quote}
\heading{Figure 2.7:} The signal-flow plans for the
procedures \code{sum\-/odd\-/squares} (top) and \code{even\-/fibs} (bottom) reveal
the commonality between the two programs.

\begin{example}
+-------------+   +-------------+   +-------------+   +-------------+
| enumerate:  |-->| filter:     |-->| map:        |-->| accumulate: |
| tree leaves |   | odd?        |   | square      |   | +, 0        |
+-------------+   +-------------+   +-------------+   +-------------+

+-------------+   +-------------+   +-------------+   +-------------+
| enumerate:  |-->| map:        |-->| filter:     |-->| accumulate: |
| integers    |   | fib         |   | even?       |   | cons, ()    |
+-------------+   +-------------+   +-------------+   +-------------+
\end{example}
\end{quote}
\end{comment}
\includegraphics[width=111mm]{fig/chap2/Fig2.7d.pdf} 
\par\bigskip
\noindent
\heading{Figure 2.7:} 手続\code{sum\-/odd\-/squares}(上)と\code{even\-/fibs}(下)の信号の流れの計画が
二つのプログラムの間の共通点を明かす
\end{figure}

\subsubsection*{列命令}



プログラムを体系化し信号伝達構造をより明確に反映する鍵はある段階の処理から次へと流れる
``信号''に集中することです。もしこれらの信号をリストとして表現するなら、各段階の処理を
リスト操作を用いて実装できます。例えば信号伝達図のmapの段階を\link{Section 2.2.1}の\code{map}手続を
用いて実装できます。

\begin{scheme}
(map square (list 1 2 3 4 5))
~\textit{(1 4 9 16 25)}~
\end{scheme}

\noindent
列をフィルタリングして与えられた述語を満足する要素のみを選択することは以下の様に達成できます。

\begin{scheme}
(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))
\end{scheme}

\noindent
例として、

\begin{scheme}
(filter odd? (list 1 2 3 4 5))
~\textit{(1 3 5)}~
\end{scheme}

\noindent
集積は次のように実装します。

\begin{scheme}
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))
(accumulate + 0 (list 1 2 3 4 5))
~\textit{15}~
(accumulate * 1 (list 1 2 3 4 5))
~\textit{120}~
(accumulate cons nil (list 1 2 3 4 5))
~\textit{(1 2 3 4 5)}~
\end{scheme}

\noindent
信号伝達図を実装するのに残っているもの全ては処理すべき要素の列を列挙することです。
\code{even\-/fibs}のためには与えられた区間の整数の列を生成しなければならず、以下のように
行うことができます。

\begin{scheme}
(define (enumerate-interval low high)
  (if (> low high)
      nil
      (cons low (enumerate-interval (+ low 1) high))))
(enumerate-interval 2 7)
~\textit{(2 3 4 5 6 7)}~
\end{scheme}

\noindent
木の葉を列挙するには、以下の様にして可能です。\footnote{これは実際には
\link{Exercise 2.28}の\code{fringe}手続そのものです。ここではその名を変えて
列操作手続一般に属するパーツであることを強調しています。}

\begin{scheme}
(define (enumerate-tree tree)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (list tree))
        (else (append (enumerate-tree (car tree))
                      (enumerate-tree (cdr tree))))))
(enumerate-tree (list 1 (list 2 (list 3 4)) 5))
~\textit{(1 2 3 4 5)}~
\end{scheme}

\noindent
これで\code{sum\-/odd\-/squares}と\code{even\-/fibs}を信号伝達図の様に再形式化することができます。
\code{sum\-/odd\-/squares}のためには木の葉の列を列挙し、これをフィルタにかけ列の奇数のみを保持し、
各要素を二乗し、結果の合計を求めます。

\begin{scheme}
(define (sum-odd-squares tree)
  (accumulate
   + 0 (map square (filter odd? (enumerate-tree tree)))))
\end{scheme}

\noindent
\code{even\-/fibs}に対しては0から\( n \)の整数を列挙し、これらの整数のそれぞれに対する
フィボナッチ数を生成し、結果列をフィルタにかけ偶数の要素のみを保持し、結果をリストの
中に集積します。

\begin{scheme}
(define (even-fibs n)
  (accumulate
   cons
   nil
   (filter even? (map fib (enumerate-interval 0 n)))))
\end{scheme}

\noindent
列操作としての伝達プログラムの価値はこれがモジュラ形式のプログラムデザインを
行うことを手助けしてくれることにあります。モジュラであるとは相対的に独立した
部品を組み立てることで構築される設計です。柔軟な形でコンポーネントを
接続するための慣習的なインターフェイスと共に、標準コンポーネントのライブラリを
提供することで、モジュラ設計を推進することができます。



モジュラ構築は複雑性を工学的設計において複雑性をコントロールすることに対して強力な戦略です。
例えば現実の信号処理アプリケーションでは、設計者は恒常的にフィルタと変換器の標準化された
グループから選択された要素を繋げることでシステムを構築します。同様に列操作は標準的プログラム要素
を様々に組合せたライブラリを提供します。実例として私達は\code{sum\-/odd\-/squares}と\code{even\-/fibs}の手続の
部品を用いて、フィボナッチ数の最初から\( n + 1 \)個の二乗のリストを作成できます。


\begin{scheme}
(define (list-fib-squares n)
  (accumulate
   cons
   nil
   (map square (map fib (enumerate-interval 0 n)))))
(list-fib-squares 10)
~\textit{(0 1 1 4 9 25 64 169 441 1156 3025)}~
\end{scheme}

\noindent
部品を再配置し、列の奇数の二乗の積を計算するのに使うことも可能です。

\begin{scheme}
(define (product-of-squares-of-odd-elements sequence)
  (accumulate * 1 (map square (filter odd? sequence))))
(product-of-squares-of-odd-elements (list 1 2 3 4 5))
~\textit{225}~
\end{scheme}

\noindent
慣習的なデータ処理アプリケーションを列操作を用いて説明することもできます。
個人の記録の列があるとし、最も高給なプログラマの給料を見つけたいとします。
記録の給料を返すセレクタ\code{salary}と記録がプログラマの物であるかを判定する
述語\code{programmer?}があるとします。すると以下のように書けます。

\begin{scheme}
(define (salary-of-highest-paid-programmer records)
  (accumulate 
   max 0 (map salary (filter programmer? records))))
\end{scheme}

\noindent
この例は列操作として表わすことができる広範囲な処理のヒントを与えたにすぎません。\footnote{
Richard \link{Waters (1979)}は伝統的なFrotranプログラムを自動的に解析し、map, フィルタ,
集積を用いてそらを俯瞰するプログラムを開発しました。彼はFortranの科学サブルーチンパッケージの
コードの実に90\%がこのパラダイムにうまくはまることを発見しました。
Lispがプログラミング言語として成功した理由の1つにリストが順序有り集合を表すのに
標準的な手段を提供したことがあり、そのため高階手続を用いて操作することが可能になりました。
プログラミング言語APLはその力と魅力の多くを同様の選択のおかげで得ました。APLでは
全てのデータは配列として表現され、統一的、かつ便利な全ての種類の配列操作のための
包括的な命令集合が存在します。}



ここではリストとして実装された列は処理モジュールを接続することを可能にする
慣習的インターフェイスとしての役割を行います。その上、私達が構造を列として
統一的に表現した時、私達はプログラム中のデータ構造依存性を少ない数の列操作へと
局所化しました。これらを変更することで、プログラム設計を全体的に保存したまま
列の代替的表現方法を試みることができます。私達はこの能力を\link{Section 3.5}にて
列処理パラダイムを無限列を許可するよう一般化する時に利用します。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.33}Exercise 2.33:} 
欠けた式を埋めて次の集積としてのいくつかの基本的なリスト操作命令の定義を完成させよ。

\begin{scheme}
(define (map p sequence)
  (accumulate (lambda (x y) ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~) nil sequence))
(define (append seq1 seq2)
  (accumulate cons ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~))
(define (length sequence)
  (accumulate ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ 0 sequence))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.34}Exercise 2.34:} 
\( x \)の多項式を\( x \)の与えられた値にて評価することは集積として表すことができる。
以下の多項式を良く知られた\newterm{Horner's rule}(\jnewterm{ホーナー法})と呼ばれるアルゴリズムを用いて評価する。
\begin{comment}

\begin{example}
a_n x^n + a_(n-1) x^(n-1) + ... + a_1 x + a_0
\end{example}

\end{comment}
\begin{displaymath}
 a_n x^n + a_{n-1} x^{n-1} + \ldots + a_1 x + a_0 
\end{displaymath}
\noindent
ホーナー法は上記の計算を以下のような構造にする。

\begin{comment}

\begin{example}
(... (a_n x + a_(n-1)) x + ... + a_1) x + a_0
\end{example}

\end{comment}
\begin{displaymath}
 (\ldots (a_n x + a_{n-1}) x + \ldots + a_1) x + a_0. 
\end{displaymath}
\noindent
すなわち\( a_n \)で始め、\( x \)を掛け、\( a_{n-1} \)を足し、\( x \)を掛け、を\( a_0 \)
に到達するまで繰り返す。\footnote{\link{Knuth 1981}によるとこの方法はW. G. Hornerにより
19世紀始めに考案された。しかしその手法は実際にはニュートンにより100年を越えた前に使用されていた。
ホーナー法は多項式を最初に\( a_n x^n \)を計算し、\( a_{n-1}x^{n-1} \)を足すを繰り返す直接的な
方法より少ない回数の和と積を用いて評価する。実際に任意の多項式を評価するためのどんなアルゴリズムも
ホーナー法が必要な数と同じ数の和と積を使用する必要があることを証明することが可能である。
従ってホーナー法は多項式評価において最適なアルゴリズムである。
これは(和の数において)A. M. Ostrowskiによる1954年の論文にて証明され、これが現代の最適アルゴリズム
研究の基礎を築いた。同様の説明が積の数についてV. Y. Panにより1966年に証明された。
\link{Borodin and Munro (1975)}による本がこれらと他の最適アルゴリズムについての結果について概観
している。}


以下のテンプレートを埋めホーナー法を用いて多項式を評価する手続を作り出せ。
多項式の係数\( a_0 \)から\( a_n \)は列で用意されると想定せよ。

\begin{scheme}
(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms) ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~)
              0
              coefficient-sequence))
\end{scheme}



例えば\( 1 + 3x + 5x^3 + x^5 \)を\( x = 2 \)の時の値を求める場合、
次のように評価を行う。

\begin{scheme}
(horner-eval 2 (list 1 3 0 5 0 1))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.35}Exercise 2.35:} 
\link{Section 2.2.2}の\code{count\-/leaves}を集積として再定義せよ。

\begin{scheme}
(define (count-leaves t)
  (accumulate ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ (map ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~)))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.36}Exercise 2.36:} 
手続\code{accumulate\-/n}は\code{accumulate}に似ているが3番目の引数として列の列を取り、
その要素の列の長さは全て一定である。指定された集積手続を複数の列の最初の要素、二番目の要素、
以下繰り返し、を全て連結するため適用し、結果の列を返す。例えばもし\code{s}が4つの列を含む列、
\code{((1 2 3) (4 5 6) (7 8 9) (10 11 12))}である時、\code{(accumulate\-/n + 0 s)}の値は列
\code{(22 26 30)}にならなければならない。以下の\code{accumulate\-/n}の定義の欠けた式を補え。

\begin{scheme}
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op init ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~)
            (accumulate-n op init ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~))))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.37}Exercise 2.37:}
ベクトル\( {\bf v} = (v_i) \)を数値の列として表現し、行列\( {\bf m} = (m_{ij}) \)を
ベクトル(行列の行)の列として表現するとする。例えば以下の行列は、
\begin{comment}

\begin{example}
+-         -+
|  1 2 3 4  |
|  4 5 6 6  |
|  6 7 8 9  |
+-         -+
\end{example}

\end{comment}
\begin{displaymath}
%  
% \left(\matrix{	1 & 2 & 3 & 4 \cr
% 		4 & 5 & 6 & 6 \cr
% 		6 & 7 & 8 & 9 \cr }\right) 
\left(
\begin{array}{cccc}
  1 & 2 & 3 & 4 \\
  4 & 5 & 6 & 6 \\
  6 & 7 & 8 & 9 
\end{array}
\right) 
\end{displaymath}
\noindent
列\code{((1 2 3 4) (4 5 6 6) (6 7 8 9))}として表現される。この表現と共に列操作を
用いることで簡潔に基本的な行列とベクトルの操作を表現することができる。これらの
操作は(行列演算のどんな本にも記述されている)次のものである。
\begin{comment}

\begin{example}
                                       __
(dot-product v w)      returns the sum >_i v_i w_i

(matrix-*-vector m v)  returns the vector t,
                                   __
                       where t_i = >_j m_(ij) v_j

(matrix-*-matrix m n)  returns the matrix p,
                                      __
                       where p_(ij) = >_k m_(ik) n_(kj)

(transpose m)          returns the matrix n,
                       where n_(ij) = m_(ji)
\end{example}

\end{comment}
\begin{displaymath}
%  
% \eqalign{ 
% 	\hbox{\tt (dot-product v w)} 		&\; {\rm returns\;the\;sum\;} 
% 		\Sigma_i v_i w_i, \cr
% 	\hbox{\tt (matrix-*-vector m v)} 	&\; {\rm returns\;the\;vector\;} {\bf t}, 
% 		\; {\rm where\;} t_i = \Sigma_j m_{ij} v_j, \cr
% 	\hbox{\tt (matrix-*-matrix m n)} 	&\; {\rm returns\;the\;matrix\;} {\bf p},
% 		\; {\rm where\;} p_{ij} = \Sigma_k m_{ik} n_{kj}, \cr
% 	\hbox{\tt (transpose m)} 			&\; {\rm returns\;the\;matrix\;} {\bf n}, 
% 		\; {\rm where\;} n_{ij} = m_{ji}. \cr
% } 
\begin{array}{rl}
	\hbox{\tt (dot-product v w)} 		&\; {\rm returns\;the\;sum\;} 
		\Sigma_i v_i w_i, \\
	\hbox{\tt (matrix-*-vector m v)} 	&\; {\rm returns\;the\;vector\;} \hbox{\bf t}, \\ 
		&\; {\rm where\;} t_i = \Sigma_j m_{ij} v_j, \\
	\hbox{\tt (matrix-*-matrix m n)} 	&\; {\rm returns\;the\;matrix\;} \hbox{\bf p}, \\
		&\; {\rm where\;} p_{ij} = \Sigma_k m_{ik} n_{kj}, \\
	\hbox{\tt (transpose m)} 			&\; {\rm returns\;the\;matrix\;} \hbox{\bf n}, \\
		&\; {\rm where\;} n_{ij} = m_{ji}.
\end{array}
\end{displaymath}
ドット積を次のように定義できる。\footnote{この定義は\link{Footnote 12}にて説明した
\code{map}の拡張バージョンを使用する}

\begin{scheme}
(define (dot-product v w)
  (accumulate + 0 (map * v w)))
\end{scheme}



以下の他の行列操作を演算するための手続の欠けた式を補え。(手続\code{accumulate\-/n}は
\link{Exercise 2.36}で定義されている。)

\begin{scheme}
(define (matrix-*-vector m v)
  (map ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ m))
(define (transpose mat)
  (accumulate-n ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ mat))
(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ m)))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.38}Exercise 2.38:} 
\code{accumulate}手続はまた\code{fold\-/right}としても知られている。それが列の最初の要素と
右側の要素全てを結合した結果とを結合するためである。\code{fold\-/left}も存在し、\code{fold\-/right}と
似ているが、要素の結合を逆の向きに行う。

\begin{scheme}
(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))
\end{scheme}


以下の式の値はいくらか。

\begin{scheme}
(fold-right / 1 (list 1 2 3))
(fold-left / 1 (list 1 2 3))
(fold-right list nil (list 1 2 3))
(fold-left list nil (list 1 2 3))
\end{scheme}



\code{op}が\code{fold\-/right}と\code{fold\-/left}にて同じ値を任意の列に対し生成することを保証するのに
必要な特性を答えよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.39}Exercise 2.39:} 
以下の\code{reverse}(\link{Exercise 2.18})の\code{fold\-/right}と\code{fold\-/left}(\link{Exercise 2.38})を用いた
定義を完成させよ。

\begin{scheme}
(define (reverse sequence)
  (fold-right (lambda (x y) ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~) nil sequence))
(define (reverse sequence)
  (fold-left (lambda (x y) ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~) nil sequence))
\end{scheme}
\end{quote}

\subsubsection*{入れ子のmap}



列のパラダイムを拡張し、一般的に入れ子ループを用いて表現される多くの演算を含めてみます。\footnote{
この入れ子マッピングへの取り組み方はDavid Turnerにより示されました。彼の言語であるKRCとMirandaは
これらの構成概念を取り扱うための洗練された形式主義を与えました。この節の例(また\link{Exercise 2.42}
も参照)は\link{Turner 1981}より翻案されました。\link{Section 3.5.3}ではこのやり方が無限長列に対しどのように
一般化されるかを学びます。}
次の問題について考えてみて下さい：正の整数\( n \)を与えられた時、異なる正の整数\( i \)と\( j \)の
全ての順序付けペアを見つけよ。条件として\( 1 \le j < i \le n \)、かつ\( i + j \)は素数である。
例として、もし\( n \)が6ならばペアは以下の通りである。

\begin{comment}

\begin{example}
  i   | 2 3 4 4 5 6 6
  j   | 1 2 1 3 2 1 5
------+---------------
i + j | 3 5 5 7 7 7 11
\end{example}

\end{comment}
\begin{displaymath}
\vbox{
\offinterlineskip
\halign{
\strut \hfil \quad #\quad \hfil & \vrule 
	\hfil \quad #\quad \hfil &
	\hfil \quad #\quad \hfil &
	\hfil \quad #\quad \hfil &
	\hfil \quad #\quad \hfil &
	\hfil \quad #\quad \hfil &
	\hfil \quad #\quad \hfil &
	\hfil \quad #\quad \hfil \cr

$i$ 	& 2 & 3 & 4 & 4 & 5 & 6 & 6 \cr
$j$ 	& 1 & 2 & 1 & 3 & 2 & 1 & 5 \cr
\noalign{\hrule}
$i + j$	& 3 & 5 & 5 & 7 & 7 & 7 & 11 \cr}
}
\end{displaymath}


この演算を体系化する自然な方法は全ての順序付けられた\( n \)以下の正の整数のペア
を生成し、フィルタを通してその合計が素数であるもののみを選択し、フィルタを通った
各ペア\( (i, j) \)に対し三つ組\( (i, j, i + j) \)を生成することです。



ここでペアの列を生成する方法を上げます：全ての整数\( i \le n \)に対し、
整数\( j < i \)を列挙し、全てのそのような\( i \)と\( j \)に対し、
ペア\( (i, j) \)を生成します。列操作を用いて、列\code{(enumerate\-/interval 1 n)}に
沿ってmapを行います。この列の各\( i \)に対し、列\code{(enumerate\-/interval 1 (- i 1))}に
沿ってmapを行います。この後者の列の\( j \)に対し、ペア\code{(list i j)}を生成します。
これが全ての\( i \)に対するペアの列を与えます。全ての\( i \)に対する全ての列を
(\code{append}を用いて集積することにより)接続することで要求されたペアの列を生成します。\footnote{
ここではペアを2つの要素のリストとして表現しており、Lispのペアとしてではありません。
従って``ペア''\( (i, j) \)は\code{(list i j)}であり、\code{(cons i j)}ではありません。}

\begin{scheme}
(accumulate
 append nil (map (lambda (i)
                   (map (lambda (j) (list i j))
                        (enumerate-interval 1 (- i 1))))
                 (enumerate-interval 1 n)))
\end{scheme}

\noindent
mapと集積の組み合わせを\code{append}と共に用いるのはこの種のプログラムにおいて
とても一般的ですので、これを分離したプログラムとして分けます。

\begin{scheme}
(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))
\end{scheme}

\noindent
これでこのペアの列をフィルタにかけ和が素数であるものを探します。フィルタの述語が
各要素に対して呼ばれます。その引数はペアであり、ペアから整数を抽出せねばなりません。
従って列の各要素に適用される述語は以下のようになります。

\begin{scheme}
(define (prime-sum? pair)
  (prime? (+ (car pair) (cadr pair))))
\end{scheme}

\noindent
最後に、フィルタを通ったペア全体に以下の手続を用いてmapをかけた結果の列を生成します。
以下の手続は2つの要素のペアとそれらの和を用いて3つ組を構築します。

\begin{scheme}
(define (make-pair-sum pair)
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))
\end{scheme}

\noindent
これらのステップ全てを接続すれば手続は完了です。

\begin{smallscheme}
(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum?
               (flatmap
                (lambda (i)
                  (map (lambda (j) (list i j))
                       (enumerate-interval 1 (- i 1))))
                (enumerate-interval 1 n)))))
\end{smallscheme}

\noindent
入れ子のmapは区間を列挙するもの以外の列に対しても便利です。ある集合\( S \)の全ての順列を
生成したいとします。つまり集合内の項目の全ての並べ方です。例えば\( \{1, 2, 3\} \)の順列は
\( \{1, 2, 3\} \), \( \{1, 3, 2\} \), \( \{2, 1, 3\} \), \( \{2, 3, 1\} \),
\( \{3, 1, 2\} \), and \( \{3, 2, 1\} \)です。
ここに集合\( S \)の順列を生成するための計画を上げます：\( S \)中の全て項目\( x \)に対し
再帰的に\( S - x \)の順列の列を生成し、\footnote{集合\( S - x \)は\( S \)の全ての要素から
\( x \)を除いた集合}次に\( x \)をそれぞれの先頭に置く。これは\( S \)の全ての\( x \)に対し
\( S \)の\( x \)で始まる順列の列を生成する。これらの全ての\( x \)に対する列を接続すると
\( S \)の全ての順列が与えられる。\footnote{Schemeのコードではセミコロンは\newterm{comments}(\jnewterm{コメント})
を書く場合に利用されます。セミコロンから始まり行末までの全てはインタプリタに無視されます。この本では
あまり多くのコメントを使用していません。私達はプログラムに対し説明的な名前を付けることで
それ自身がドキュメントであるかのように作るよう努力しています。}

\begin{scheme}
(define (permutations s)
  (if (null? s)              ~\textrm{; 集合は空か?}~
      (list nil)             ~\textrm{; 空集合を持つ列}~
      (flatmap (lambda (x)
                 (map (lambda (p) (cons x p))
                      (permutations (remove x s))))
               s)))
\end{scheme}

\noindent
この戦略がどのように\( S \)の順列を生成する問題から\( S \)よりもより少ない要素の
集合の順列生成の問題へと縮小しているかに注意して下さい。境界条件に関しては要素無しの
集合を表す空リストまで順に処理を繰り返します。空リストに対して\code{(list nil)}を
生成しました。これは1要素の列であり、要素無しの集合を表します。\code{permutations}内で
利用される\code{remove}手続は与えられた式から与えられた項目以外の全ての要素を返します。
これは簡単なフィルタにて表すことができます。


\begin{scheme}
(define (remove item sequence)
  (filter (lambda (x) (not (= x item)))
          sequence))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.40}Exercise 2.40:} 
整数\( n \)を与えられ、ペア\( (i, j) \)を\( 1 \le j < i \le n \)の条件で
生成する手続\code{unique\-/pairs}を定義せよ。\code{unique\-/pairs}を用いて
上で与えられた\code{prime\-/sum\-/pairs}の定義をより簡単にせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.41}Exercise 2.41:} 
与えられた整数\( n \)以下でかつ合計が与えられた整数\( s \)である、全ての異なる正の整数
\( i \), \( j \), \( k \)の順序有りの3つ組を求める手続を書け。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.42}Exercise 2.42:} 

\begin{figure}[tb]
\phantomsection\label{Figure 2.8}
\centering
\begin{comment}
\heading{Figure 2.8:} A solution to the eight-queens puzzle.

\begin{example}
+---+---+---+---+---+---+---+---+
|   |   |   |   |   | Q |   |   |
+---+---+---+---+---+---+---+---+
|   |   | Q |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
| Q |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   | Q |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   | Q |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   | Q |
+---+---+---+---+---+---+---+---+
|   | Q |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|   |   |   | Q |   |   |   |   |
+---+---+---+---+---+---+---+---+
\end{example}
\end{comment}
\includegraphics[width=48mm]{fig/chap2/Fig2.8c.pdf}      % 73mm
\par\bigskip
\noindent
\heading{Figure 2.8:} 8クイーンパズルの解の一例
\end{figure}

``8クイーンパズル''は8つのクイーンをチェス盤の上に、どのクイーンも他のクイーンを
取ることができないようにするにはどのように置くかを尋ねる。(これはつまりどの2つのクイーンも
同じ列、行、または斜めの線上に有ってはならないということである)。
考えられる解の1つを\link{Figure 2.8}に示す。このパズルを解く1つの方法は盤上に渡って
各列にクイーンを置く。\( k - 1 \)個のクイーンを置いたら\( k \)番目のクイーンは
既に盤上に置いてあるどのクイーンも取れない場所に置かなければならない。この取り組み方を
再帰的に形式化できる：盤上の最初の\( k - 1 \)列内の\( k - 1 \)個のクイーンの可能な置き方
全ての列を既に生成したと想定する。これら全ての方法に対し拡張した位置の拡張集合を
\( k \)番目の列の各行にクイーンを置くことで生成する。次にこれらをフィルタにかけて
\( k \)番目の列のクイーンが他のクイーンを考慮しても安全な位置のみを保持する。
これは\( k \)個のクイーンを最初の\( k \)列内に置く全ての方法を生成する。
この過程を繰り返すことで1つの解答のみでなく、このパズルの全ての解答を生成できる。


この解法を手続\code{queens}として実装した。\( n \)個のクイーンを\( n \times n \)の
チェス盤上に置く問題に対する全ての解の列を返す。\code{queens}は内部手続\code{queen\-/cols}を
持ち、それは盤の最初の\( k \)列中にクイーンを置く全ての方法の列を返す。

\begin{scheme}
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position new-row 
                                    k 
                                    rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))
\end{scheme}



この手続の中で、\code{rest\-/of\-/queens}は最初の\( k - 1 \)列内に\( k - 1 \)個のクイーンを
置く方法であり、\code{new\-/row}は\code{k}番目の列に対してクイーンを置くように提案された行である。
盤上の位置の集合に対する表現を、新しい列の位置を位置の集合に付け足す手続\code{adjoin\-/position}と
位置の空集合を表す\code{empty\-/board}を含めて実装することでプログラムを完成させよ。
あなたは\code{k}番目の列にあるクイーンが他に対して安全であるかどうかを位置の集合に対して決定する
\code{safe?}もまた書かなければならない。(新しいクイーンが安全であるかどうかのみをチェックする
必要であることに注意すること---他のクイーンは既にお互いに安全であることが保証されている)。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.43}Exercise 2.43:} 
Louis Reasonerは\link{Exercise 2.42}を行うことで酷い時間を過している。彼の\code{queens}手続は
動いているように見える。しかし実行がとても遅い。(Louisは\( 6\times6 \)の場合でさえそれを
解くのにかかる長い時間を待つことができなかった)。LouisがEva Lu Atorに助けを求めた時、
彼女はLouisが\code{flatmap}内の入れ子のマッピングの順を交換してしまったことを指摘した。
以下のように書いていた。

\begin{scheme}
(flatmap
 (lambda (new-row)
   (map (lambda (rest-of-queens)
          (adjoin-position new-row k rest-of-queens))
        (queen-cols (- k 1))))
 (enumerate-interval 1 board-size))
\end{scheme}

この交換がなぜプログラムの実行を遅くするのか説明せよ。Louisのプログラムが8クイーンパズルを
解くのにどれだけの時間がかかるか推察せよ。\link{Exercise 2.42}のプログラムが同じパズルを解く
のに必要な時間が\( T \)であるとの前提で行え。
\end{quote}

\subsection{例: ピクチャー言語}
\label{Section 2.2.4}


この節では絵を描く簡単な言語をお見せします。これがデータ抽象と閉包の力を図示し、
また高階手続を本質的な方法で利用します。この言語は\link{Figure 2.9}のようなパターンを
試験することを簡単にするように設計されております。この図は要素が移動し、縮小しを
繰り返しながら組み立てられています。\footnote{ピクチャー言語はPeter Hendersonが
作成した言語を基にしており、この言語はM.C. Escherの木版画``Square Limit''(\link{Henderson 1982}参照)
のようなイメージを構築するために作成されました。その木版画は繰り返しサイズが変更された
パターンが組込まれており、この節の\code{square\-/limit}手続を用いて描かれた配置と
似ております。}
この言語内では、組み立てられるデータオブジェクトはリスト構造ではなく手続として
表現されます。閉包の特性を見たす\code{cons}が簡単に自由に複雑なリスト構造を構築できるように、
この言語内の命令もまた閉包の特性を満たし、簡単に自由に複雑なパターンを構築できます。

\subsubsection*{この本のピクチャー言語}



\link{Section 1.1}でプログラミングの学習を始めたとき、言語のプリミティブ、その組み合わせの手段、
抽象化の手段に集中することが言語の説明の重要性だと強調しました。
ここではその枠組みに従います。

\begin{figure}[tb]
\phantomsection\label{Figure 2.9}
\centering
\begin{comment}
\heading{Figure 2.9:} Designs generated with the picture language.

[two graphic images not included]
\end{comment}
\includegraphics[width=111mm]{fig/chap2/Fig2.9-bigger.png}
\par\bigskip
\noindent
\heading{Figure 2.9:} ピクチャー言語を用いて生成したデザイン
\end{figure}

\begin{figure}[tb]
\phantomsection\label{Figure 2.10}
\centering
\begin{comment}
\heading{Figure 2.10:} Images produced by the \code{wave}
painter, with respect to four different frames.  The frames, shown with dotted
lines, are not part of the images.

[four graphic images not included]
\end{comment}
\includegraphics[width=50mm]{fig/chap2/Fig2.10.pdf}
\par\bigskip
\noindent
\heading{Figure 2.10:} \code{wave}により生成されたイメージ
\end{figure}

\noindent
このピクチャー言語の優雅さの部分は要素の種類が\newterm{painter}(\jnewterm{ペインタ})と呼ばれる
ものたった1つしかないことです。ペインタは指定された平行四辺形の枠の中にイメージを
移動し、拡大縮小して描きます。例えば\code{wave}と呼ぶペインタがありそれは\link{Figure 2.10}
に見られるような粗野な線の絵を描きます。実際の絵の下腿はフレームに依存します---\link{Figure 2.10}の
4つの絵全ては同じ\code{wave}ペインタにより生成されていますが、4つの異なるフレームを
考慮しています。ペインタはこれよりもより複雑にすることが可能です。\code{rogers}と
呼ばれるプリミティブなペインタは\acronym{MIT}の創始者であるWilliam Barton Rogersの
絵を\link{Figure 2.11}に示されるように描きます。\footnote{
William Barton Rogers (1804-1882)は
\acronym{MIT}の創始者であり、かつ初代学長です。地質学者であり、才能溢れる教師である彼は
William and Mary CollegeとUniversity of Virginiaにて教鞭を取りました。1859年に
彼はボストンへ移りそこでより研究に打ち込み、``技術専門の研究所''を設立する計画を
進めました。またマサチューセッツ州の最初のガスメータの州検査官も務めました。




\acronym{MIT}が1861年に創設された時、Rogersは最初の学長に選ばれました。
Rogersは``useful learning''(実用的学習)の活用を信奉しました。これは当時の
大学教育からは異なるものでした。彼に依れば古典の過度の強調が``より幅広く、
高く、より現実的な教育と自然科学、及び社会科学の前に立ち塞がっている''と書いています。
同様に彼の教育は職業専門学校の狭い教育からも異なるものになろうとしていました。

\begin{quote}
実利的であることと科学実務者の間の区別を強制する世界は全く無益だ。現代の経験全てが
その完全な無益さを示している。
\end{quote}



Rogersは\acronym{MIT}の学長を健康上の理由で辞任する1870年まで務めました。
1878年に二代目の\acronym{MIT}学長John Runkleは1873年からの大不況によりもたらさ
れた財政危機のプレッシャーとHarvardによる\acronym{MIT}の買収の試みに対する抵抗
の緊張により辞任しました。
Rogerは学長のオフィスを支えるため1881年まで戻りました。



Rogersは1882年、\acronym{MIT}の大学院の卒業試験に取り組む最中に倒れ、亡くなられました。
RunkleがRogerの最後の言葉を同年に送られた弔事から引用しています。

\begin{quote}
``本日ここに立ち本校とは何であるかを考えると\( \dots \) 科学の始まりを思い受かべます。
150年前にStephen Halesは灯用のガスを主題にした小論文を発表しました。その中で彼は
彼の研究が128グレインの瀝青炭-- '' ``瀝青炭'' これが地上での彼の最後の言葉でした。
ここで彼は体を前に曲げ、彼の前のテーブルの上にある端書を確認するようでいて、そして
ゆっくりと直立した体制を取り戻し、両腕を上げ、そして
彼の地上の労働と業績の場面から``死の明日''へと形を変えたのです。そこでは人生の謎は
解決され、肉体から解放された魂は新しく、未だ測りしれない無限の未来の謎を熟考する
ことに終りの無い充足を見つけるのです。
\end{quote}

Francis A. Walker(\acronym{MIT}の三代目の学長)の言葉では

\begin{quote}
彼自身が負うた彼の人生全ては最も誠実で雄々しく、そして彼は騎士が心から望んだか
のごとく、仕事中に、その役職のまま、公務の行いの最中に亡くなった。
\end{quote}
} \link{Figure 2.11}の4つのイメージは\link{Figure 2.10}の\code{wave}のイメージと
同じ4つのフレームを考慮して描かれています。

\begin{figure}[tb]
\phantomsection\label{Figure 2.11}
\centering
\begin{comment}
\heading{Figure 2.11:} Images of William Barton Rogers,
founder and first president of \acronym{MIT}, painted with respect to the same
four frames as in \link{Figure 2.10} (original image reprinted with the
permission of the \acronym{MIT} Museum).

[four graphic images not included]
\end{comment}
\includegraphics[width=48mm]{fig/chap2/Fig2.11.pdf}
\par\bigskip
\noindent
\heading{Figure 2.11:} William Barton Rogersのイメージ
\end{figure}

\noindent
イメージを結合するには与えられたペインタから新しいペインタを構築する種々の命令を
使用します。例えば\code{beside}命令は2つのペインタを取り新しい最初のペインタのイメージを
フレームの左半分に、2つ目のペインタのイメージをフレームの右半分に描く複合ペインタを
生成します。同様に\code{below}は2つのペインタを取り、1つ目のペインタのイメージを2つ目の
ペインタのイメージの下に描きます。いくつかの命令は単一のペインタを変換し新しいペインタを
生成します。例えば\code{flip\-/vert}はペインタを取りそのイメージを上下逆さに描くペインタを
生成し、\code{flip\-/horiz}は元のペインタのイメージを左右逆に描くペインタを生成します。


\link{Figure 2.12}は\code{wave4}を呼んだペインタの描画を見せており、これは\code{wave}で始め
2段階を経て構築されています。

\begin{scheme}
(define wave2 (beside wave (flip-vert wave)))
(define wave4 (below wave2 wave2))
\end{scheme}

\begin{figure}[tb]
\phantomsection\label{Figure 2.12}
\centering
\begin{comment}
\heading{Figure 2.12:} Creating a complex figure, starting
from the \code{wave} painter of \link{Figure 2.10}.

[two graphic images not included]

\begin{scheme}
(define wave2                      (define wave4
  (beside wave (flip-vert wave)))    (below wave2 wave2))
\end{scheme}
\end{comment}
\includegraphics[width=50mm]{fig/chap2/Fig2.12.pdf}
\par\bigskip
\noindent
\heading{Figure 2.12:} \link{Figure 2.10}の\code{wave}ペインタから始めて複雑な図を作成する
\end{figure}

\noindent
複雑なイメージをこの様式で構築する場合はペインタが言語の接続手段の下で閉じている
という事実を利用しています。2つのペインタの\code{beside}や\code{below}はそれ自身がペインタです。
従ってそれをより複雑なペインタを作るための要素として使用できます。
\code{cons}を用いてリスト構造を構築するのと同様に、結合手段の下のデータの閉包は
ほんのわずかな命令を用いて複雑な構造を作成する能力にとって重大です。



ペインタを結合できれば直ぐに、ペインタを接続する典型的なパターンを抽象化できるように
なりたいと願うでしょう。ペインタ操作をSchemeの手続として実装することにします。それは
私達がピクチャー言語内のメカニズムとして専用の抽象化を必要としないことを意味します。
接続の手段が普通のSchemeの手続ですから、手続の範囲で行えるペインタの操作を用いて、何でもできる
能力が自動的に得られます。例えば\code{wave4}内のパターンを抽象化できます。

\begin{scheme}
(define (flipped-pairs painter)
  (let ((painter2 (beside painter (flip-vert painter))))
    (below painter2 painter2)))
\end{scheme}

\noindent
そして\code{wave4}をこのパターンのインスタンスとして定義します。

\begin{scheme}
(define wave4 (flipped-pairs wave))
\end{scheme}

\begin{figure}[tb]
\phantomsection\label{Figure 2.13}
\centering
\begin{comment}
\begin{quote}
\heading{Figure 2.13:} Recursive plans for \code{right\-/split} and \code{corner\-/split}.

\begin{example}
+-------------+-------------+    +------+------+-------------+
|             |             |    | up-  | up-  |             |
|             | right-split |    | split| split| corner-split|
|             |             |    |      |      |             |
|             |     n-1     |    |  n-1 |  n-1 |     n-1     |
|             |             |    |      |      |             |
|  identity   +-------------+    +------+------+-------------+
|             |             |    |             | right-split |
|             | right-split |    |             |     n-1     |
|             |             |    |  identity   +-------------+
|             |     n-1     |    |             | right-split |
|             |             |    |             |     n-1     |
+-------------+-------------+    +-------------+-------------+

       right-split n                    corner-split n
\end{example}
\end{quote}
\end{comment}
\includegraphics[width=111mm]{fig/chap2/Fig2.13a.pdf}
\begin{quote}
\heading{Figure 2.13:} \code{right\-/split}と\code{corner\-/split}の再帰計画
\end{quote}
\end{figure}

\noindent
また再帰命令を定義することも可能です。以下はペインタを分割し、\link{Figure 2.13}に示すように
右へ向けて枝分かれします。

\begin{scheme}
(define (right-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (right-split painter (- n 1))))
        (beside painter (below smaller smaller)))))
\end{scheme}

\noindent
右に向けてと同じように上方向にも枝分かれすることでバランスの取れたパターンを生成することも可能です。
(課題\link{Exercise 2.44}と図\link{Figure 2.13}と\link{Figure 2.14}を参照して下さい)。

\begin{scheme}
(define (corner-split painter n)
  (if (= n 0)
      painter
      (let ((up (up-split painter (- n 1)))
            (right (right-split painter (- n 1))))
        (let ((top-left (beside up up))
              (bottom-right (below right right))
              (corner (corner-split painter (- n 1))))
          (beside (below painter top-left)
                  (below bottom-right corner))))))
\end{scheme}

\noindent
\code{corner\-/split}の4つのコピーを置くことで\code{square\-/limit}と呼ばれるパターンを
獲得することができ、\code{wave}と\code{rogers}に対する適用が\link{Figure 2.9}に
示されます。

\begin{scheme}
(define (square-limit painter n)
  (let ((quarter (corner-split painter n)))
    (let ((half (beside (flip-horiz quarter) quarter)))
      (below (flip-vert half) half))))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.44}Exercise 2.44:} 
\code{corner\-/split}にて使用された手続\code{up\-/split}を定義せよ。\code{right\-/split}に
似ているが、\code{below}と\code{beside}の役割を入れ替える。
\end{quote}

\begin{figure}[tbp]
\phantomsection\label{Figure 2.14}
\centering
\begin{comment}
\heading{Figure 2.14:} The recursive operations \code{right\-/split} and \code{corner\-/split} applied to the painters \code{wave} and \code{rogers}.  Combining four \code{corner\-/split} figures produces symmetric \code{square\-/limit} designs as shown in \link{Figure 2.9}.

[two graphic images not included]

\begin{scheme}
(right-split wave 4)         (right-split rogers 4)
\end{scheme}

[two graphic images not included]

\begin{scheme}
(corner-split wave 4)        (corner-split rogers 4)
\end{scheme}
\end{comment}
\includegraphics[width=91mm]{fig/chap2/Fig2.14b.pdf}
\begin{quote}
\heading{Figure 2.14:} ペインタ\code{wave}と\code{rogers}に適用された再帰命令\code{right\-/split}と\code{corner\-/split}。
4つの図\code{corner\-/split}を組み合わせることで\link{Figure 2.9}で示された対照的な\code{square\-/limit}のデザインを生成する。
\end{quote}
\end{figure}

\subsubsection*{高階命令}



ペインタ命令のパターンを抽象化するのに加えて、より高いレベルのペインタ命令接続の
抽象化パターンについて取り組むことができます。
それはペインタ命令を操作を行うための要素---ペインタ命令を引数として
取り新しいペインタ命令を作成する手続と見做し、そしてこれらの要素のための
組み合わせの手段の記述が可能だということです。



例として、\code{flipped\-/pairs}と\code{square\-/limit}はペインタのイメージを四角のパターン内にて
4つのコピーをそれぞれが準備します。それらはどのような位置と向きに置くかということのみ
において異なります。このペインタ接続のパターンを抽象化する1つの方法は以下のプロシジャを
用いて、4つの1引数ペインタ命令を取り与えられたペインタをそれら4つの命令で変換する命令を
生成し、結果を四角の中に配置します。\code{tl}, \code{tr}, \code{bl}, and \code{br}は左上、右上、
左下、右下のコピーに対応する変換です。

\begin{scheme}
(define (square-of-four tl tr bl br)
  (lambda (painter)
    (let ((top (beside (tl painter) (tr painter)))
          (bottom (beside (bl painter) (br painter))))
      (below bottom top))))
\end{scheme}

\noindent
すると\code{flipped\-/pairs}は\code{square\-/of\-/four}を以下のように用いて定義可能です。\footnote{
同等に、こうも書けます。

\begin{smallscheme}
(define flipped-pairs
  (square-of-four identity flip-vert identity flip-vert))
\end{smallscheme}
}

\begin{scheme}
(define (flipped-pairs painter)
  (let ((combine4 (square-of-four identity flip-vert
                                  identity flip-vert)))
    (combine4 painter)))
\end{scheme}

\noindent
そして\code{square\-/limit}は以下の様に表現可能です。\footnote{\code{Rotate180}は
ペインタを180度回転します(\link{Exercise 2.50}参照)。\code{rotate180}の代わりに
\code{(compose flip\-/vert flip\-/horiz)}と言うこともできます。\code{compose}手続は
\link{Exercise 1.42}から使用しました。}

\begin{scheme}
(define (square-limit painter n)
  (let ((combine4 (square-of-four flip-horiz identity
                                  rotate180 flip-vert)))
    (combine4 (corner-split painter n))))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.45}Exercise 2.45:} 
\code{right\-/split}と\code{up\-/split}は一般的な分割命令のインスタンスだと言うことができる。
手続\code{split}を以下の式を評価する場合に、

\begin{scheme}
(define right-split (split beside below))
(define up-split (split below beside))
\end{scheme}

\noindent
既に定義住みのものと全く同じ振舞を行う手続\code{right\-/split}と\code{up\-/split}を
生成するよう定義せよ。
\end{quote}


\subsubsection*{フレーム}


ペインタとどのように実装しその接続手段を示す前に、始めにフレームについて考えなけ
ればなりません。フレームは3つのベクトル---始点ベクトルと2つの辺ベクトルで説明でき
ます。始点ベクトルは平面上においてある絶対的な始点からフレームの始点までのオフセットを
指定します。そして辺ベクトルは始点から角までのオフセットを指定します。もし2つの辺が
垂直であればフレームは長方形になります。それ以外ではフレームはより一般的な平行四辺形に
なります。


\link{Figure 2.15}はフレームとその対応するベクトルを示します。
データ抽象化に従い、まだフレームがどのように表現されるかについては、
3つのベクトルを取りフレームを生成するコンストラクタ\code{make\-/frame}と関連する3つの
セレクタ\code{origin\-/frame}, \code{edge1\-/frame}, \code{edge2\-/frame}が存在すること以外を
特定する必要がありません。(\link{Exercise 2.47}を参照して下さい)。

\begin{figure}[tb]
\phantomsection\label{Figure 2.15}
\centering
\begin{comment}
\heading{Figure 2.15:} A frame is described by three vectors
-- an origin and two edges.

\begin{example}
                         __
                     __--  \
                 __--       \
      __     __--            \   __
     |\  __--                 \__-|
       \-                  __--
frame   \              __--
edge2    \         __--    frame
vector    \    __--        edge1
           \_--            vector
            -   <--+
          frame    |
          origin   +-- (0, 0) point
          vector       on display screen
\end{example}
\end{comment}
\includegraphics[width=51mm]{fig/chap2/Fig2.15a.pdf}
\begin{quote}
\heading{Figure 2.15:} 3つのベクトル --- 始点と2つの辺により記述されたフレーム
\end{quote}
\end{figure}

\noindent
私達は単位正方形\( (0 \le x, y \le 1) \)内の座標をイメージを指定するのに用いることにします。
各フレームは、フレームに適合するようにイメージの移動と拡大縮小をするのに使われる
\newterm{frame coordinate map}(\jnewterm{フレーム座標マップ})に関連付けられます。
マップは単位正方形をベクトル\( {\bf v} = (x, y) \)を次のベクトルの和にマッピングすることで
変換します。

\begin{comment}

\begin{example}
Origin(Frame) + x * Edge_1(Frame) + y * Edge_2(Frame)
\end{example}

\end{comment}
\begin{displaymath}
 {\rm Origin(Frame)} + x \cdot {\rm Edge_1(Frame)} + y \cdot {\rm Edge_2(Frame)}. 
\end{displaymath}
\noindent
例えば、(0, 0)はフレームの始点に、(1, 1)は対角線上に始点の反対の頂点へ、そして
(0.5, 0.5)はフレームの中心点にマッピングされます。フレーム座標マップは以下の手続により
作成できます。\footnote{\code{frame\-/coord\-/map}はこの先の\link{Exercise 2.46}にて説明される
ベクトル操作を用います。ここでは何らかのベクトルの表現を用いて実装済みと仮定します。
データ抽象化のおかげでこのベクトルの表現がどんなものかは、ベクトル操作が正しく振る舞われる
限りにおいて問題にはなりません。}

\begin{scheme}
(define (frame-coord-map frame)
  (lambda (v)
    (add-vect
     (origin-frame frame)
     (add-vect (scale-vect (xcor-vect v)
                           (edge1-frame frame))
               (scale-vect (ycor-vect v)
                           (edge2-frame frame))))))
\end{scheme}

\noindent
\code{frame\-/coord\-/map}をフレームに適用すると、ベクトルを取りベクトルを返す手続を返すことに
注意して下さい。もし引数ベクトルが単位正方形の中なら、結果のベクトルはフレームの範囲内に
なります。例として、

\begin{scheme}
((frame-coord-map a-frame) (make-vect 0 0))
\end{scheme}

\noindent
は以下のベクトルと同じものを返します。

\begin{scheme}
(origin-frame a-frame)
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.46}Exercise 2.46:} 
始点からある点へと走る2次元ベクトル\( \bf v \)は\( x \)-座標と\( y \)-座標から成る
ペアにより表現できる。ベクトルに対するデータ抽象をコンストラクタ\code{make\-/vect}と関連する
セレクタ\code{xcor\-/vect}と\code{ycor\-/vect}を与えることにより実装せよ。
セレクタとコンストラクタを用いてベクトルの足し算、引き算、スカラによる乗算を求める操作を実行する
手続 \code{add\-/vect}, \code{sub\-/vect}, \code{scale\-/vect}を実装せよ。

\begin{comment}

\begin{example}
(x_1, y_1) + (x_2, y_2) = (x_1 + x_2, y_1 + y_2)
(x_1, y_1) - (x_2, y_2) = (x_1 - x_2, y_1 - y_2)
             s * (x, y) = (sx, sy)
\end{example}
\end{comment}
\begin{displaymath}
%  
% \eqalign{
% 	(x_1, y_1) + (x_2, y_2) 	&= (x_1 + x_2, y_1 + y_2), \cr
% 	(x_1, y_1) - (x_2, y_2) 	&= (x_1 - x_2, y_1 - y_2), \cr
% 	s \cdot (x, y) 			&= (sx, sy). \cr }
% 
\begin{array}{r@{{}={}}l}
	(x_1, y_1) + (x_2, y_2) 	& (x_1 + x_2, y_1 + y_2), \\
	(x_1, y_1) - (x_2, y_2) 	& (x_1 - x_2, y_1 - y_2), \\
	s \cdot (x, y) 			& (sx, sy). 
\end{array}
\end{displaymath}
\end{quote}


\begin{quote}
\heading{\phantomsection\label{Exercise 2.47}Exercise 2.47:} 
ここに2つの有り得そうなフレームのコンストラクタがある

\begin{scheme}
(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))
(define (make-frame origin edge1 edge2)
  (cons origin (cons edge1 edge2)))
\end{scheme}


各コンストラクタに適切な、フレームに対応する実装を生成するセレクタを提供せよ。
\end{quote}

\subsubsection*{ペインタ}


ペインタはフレームを引数として与え、特定のイメージをフレームにはまるように移動、拡大縮小
して描く手続として表現される。すなわちもし\code{p}がペインタで\code{f}がフレームである場合、
\code{f}を引数として\code{p}を呼び出すことで\code{f}の中に\code{p}のイメージを生成する。



プリミティブなペインタがどのように実装されているかの詳細は特定のグラフィックシステムの
特質と描画されるイメージのタイプに依存します。例えばスクリーン上の2つの指定された点の間に
線を引く手続\code{draw\-/line}があると想定します。すると線分のリストから線を引くためのペインタ、
例えば\link{Figure 2.10}の\code{wave}ペインタのようなものを以下のように作ることができます。\footnote{
\code{Segments\-/>painter}は線分の表現に下記の\link{Exercise 2.48}で説明されたものを使っています。
また\link{Exercise 2.23}で説明された\code{for\-/each}を使っています。}

\begin{scheme}
(define (segments->painter segment-list)
  (lambda (frame)
    (for-each
     (lambda (segment)
       (draw-line
        ((frame-coord-map frame) 
         (start-segment segment))
        ((frame-coord-map frame)
         (end-segment segment))))
     segment-list)))
\end{scheme}

\noindent
線分は単位正方形に対しての座標を用いて与えられます。リスト中の各線分に対して
ペインタは線分の終端をフレーム座標マップを用いて変換し、変換後の点の間に線を引きます。



手続としてペインタを表現することは強力な抽象化バリアをピクチャーランゲージの中に
確立します。私達は全ての種類のプリミティブなペインタを種々のグラフィック機能の基盤の
上に作り、混ぜることができます。それらの実装の詳細は問題ではありません。
フレームを引数として取りフレームに適切なサイズにスケールして何かを描く
任意の手続がペインタの役を演じることができます。\footnote{
例えば\link{Figure 2.11}の\code{rogers}ペインタはグレーレベルのイメージから構築されています。
与えられたフレームの中の各点に対し\code{rogers}ペインタはイメージ中のマッピングされる位置を
フレーム座標マップの下に決定し、適切に影を付けます。異なるタイプのペインタを許可することで、
\link{Section 2.1.3}で議論された分数表現は適切な条件を満たせば全く任意でかまわないという抽象データの
考えからより大きな利点を得ています。ここではペインタは指定されたフレーム内に何かを描くので
あれば全くどのように実装されても構わないという事実を用いています。\link{Section 2.1.3}はまた
ペアがどのように手続として実装され得るかということも示しました。
ペインタはデータに対する手続表現の二つ目の例です。}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.48}Exercise 2.48:} 
平面上で方向を持つ線分はベクトルのペア---原点から
線分の始点へと向かうベクトルと原点から線分の終点へと向かうベクトルとして
表現可能だ。\link{Exercise 2.46}のベクトル表現を用いて、コンストラクタ\code{make\-/segment}と
セレクタ\code{start\-/segment}と\code{end\-/segment}を持つ線分表現を定義せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.49}Exercise 2.49:} 
\code{segments\-/>painter}を用いて以下のプリミティブなペインタを定義せよ。

\begin{enumerate}[a]

\item
指定したフレームの外枠を描くペインタ

\item
フレームの反対の角を繋いで``X''を描くペインタ

\item
フレームの辺の中点を結んでダイヤモンドの形を描くペインタ

\item
\code{wave}ペインタ

\end{enumerate}
\end{quote}

\subsubsection*{変形とペインタの組み合わせ}



ペインタに対する操作(例えば\code{flip\-/vert}や\code{beside})はフレーム引数に由来する
フレームに対して元のペインタを実行するペインタを作成することで働いています。
従って例えば\code{flip\-/vert}は引っくり返す場合にもそれがどのように描かれるのかは
知る必要がありません---ただフレームをどのように引っくり返すのか知る必要がある
のみです。逆転したペインタはただ元のペインタを用いますが、フレームは逆転されて
いるのです。



ペインタ操作は\code{transform\-/painter}手続を基にしており、それはペインタとどのように
フレームを変換するかの情報を引数に取り、新しいペインタを生成します。変換されたペインタは
フレーム上にて呼ばれた時に、フレームを変換して基のペインタを変換済みのフレーム上で
呼び出します。\code{transform\-/painter}に対する引数は新しいフレームの角を指定する
(ベクトルとして表現される)複数の点です。フレームにマッピングされる時、最初の点は
新しいフレームの始点を指定し、他の2つのは辺ベクトルの終点を指定します。従って、
単位正方形内の引数は元のフレームの中に含まれるフレームを指定します。

\begin{scheme}
(define (transform-painter painter origin corner1 corner2)
  (lambda (frame)
    (let ((m (frame-coord-map frame)))
      (let ((new-origin (m origin)))
        (painter (make-frame 
                  new-origin
                  (sub-vect (m corner1) new-origin)
                  (sub-vect (m corner2) new-origin)))))))
\end{scheme}

\noindent
次はどのようにペインタのイメージを縦方向に逆向きにするかです。

\begin{scheme}
(define (flip-vert painter)
  (transform-painter painter
                     (make-vect 0.0 1.0)   ~\textrm{; new \code{origin}}~
                     (make-vect 1.0 1.0)   ~\textrm{; new end of \code{edge1}}~
                     (make-vect 0.0 0.0))) ~\textrm{; new end of \code{edge2}}~
\end{scheme}

\noindent
\code{transform\-/painter}を用いることで簡単に新しい変換を定義することができます。
右上4分の1のフレームは次のようにして与えられます。

\begin{scheme}
(define (shrink-to-upper-right painter)
  (transform-painter
   painter (make-vect 0.5 0.5)
   (make-vect 1.0 0.5) (make-vect 0.5 1.0)))
\end{scheme}

\noindent
他の変換はイメージを時計回りの逆に90度回転したり、\footnote{\code{rotate90}は
四角形のフレームに対してのみの純粋な回転です。イメージもまた拡大縮小して
回転したフレームに合わせられるためです。}

\begin{scheme}
(define (rotate90 painter)
  (transform-painter painter 
                     (make-vect 1.0 0.0)
                     (make-vect 1.0 1.0)
                     (make-vect 0.0 0.0)))
\end{scheme}

\noindent
イメージをフレームの中心に向けて潰したりします。\footnote{\link{Figure 2.10}と
\link{Figure 2.11}内のひし形のイメージは\code{squash\-/inwards}を
\code{wave}と\code{rogers}に適用することで作成されました。}

\begin{scheme}
(define (squash-inwards painter)
  (transform-painter painter
                     (make-vect 0.0 0.0)
                     (make-vect 0.65 0.35)
                     (make-vect 0.35 0.65)))
\end{scheme}

\noindent
フレーム変換は2つ以上のペインタを接続する手段を定義するための鍵でもあります。
例えば\code{beside}手続は2つのペインタを取りそれらを引数のフレームの左半分と右半分に
それぞれ描画するように変換する新しい複合ペインタを生成します。複合ペインタがフレームを
与えられ時、1つ目の変換済みペインタを呼びフレームの左半分に描き、次に二つ目の変換済み
ペインタを呼びフレームの右半分を描きます。

\begin{scheme}
(define (beside painter1 painter2)
  (let ((split-point (make-vect 0.5 0.0)))
    (let ((paint-left
           (transform-painter 
            painter1
            (make-vect 0.0 0.0)
            split-point
            (make-vect 0.0 1.0)))
          (paint-right
           (transform-painter
            painter2
            split-point
            (make-vect 1.0 0.0)
            (make-vect 0.5 1.0))))
      (lambda (frame)
        (paint-left frame)
        (paint-right frame)))))
\end{scheme}

\noindent
ペインタのデータ抽象化と、特にペインタの手続としての表現がどのように\code{beside}の
実装を簡単にしているのか注目して下さい。\code{beside}手続はコンポーネントのペイントの
詳細について各ペインタが指定されたフレームに何かを描くこと以外は一切知る必要がありません。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.50}Exercise 2.50:} 
ペインタを水平方向に引っくり返す変換\code{flip\-/horiz}を定義せよ。
またペインタを時計と逆回りに180度と270度回す変換を定義せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.51}Exercise 2.51:} 
ペインタに対する\code{below}命令を定義せよ。\code{below}は2つのペインタを引数に取る。
結果のペインタはフレームを与えられ、1つ目のペインタにてフレームの底部を描き、
2つ目のペインタにて上部を描く。\code{below}を2つの異なる方法で定義せよ。
1つは上で与えた\code{beside}と同様な方法で、2つ目は\code{beside}と適切な(\link{Exercise 2.50}の)
回転命令を利用せよ。
\end{quote}

\subsubsection*{堅牢な設計のための言語のレベル}



ピクチャー言語は私達が紹介した手続とデータにようる抽象化についての重要なアイデアの
いくつかを訓練しました。基本的なデータ抽象化であるペインタは手続表現を用いて実装され
言語に異なる基礎的な描画能力を統一した方法で扱うことを可能にしました。
接続手段は閉包の性質を満たし簡単に複雑な設計を組み上げることを可能にしました。
最後に、抽象化手続に対する全てのツールはペインタに対する接続手段の抽象化にとって
有効でした。


私達はまた言語とプログラム設計に関する素晴しい考えを垣間見ることができました。
これは\newterm{stratified design}(\jnewterm{階層化設計})の方法で、複雑なシステムは一連の
言語を用いて記述される一連のレベルとして構造化されるべきであるという概念です。
各レベルはパーツをパーツを接続して構築され、それらは次のレベルではプリミティブとして
参照されます。そして各レベルで構築されたパーツは次のレベルにてプリミティブとして
使用されます。階層化された設計の各レベルで使用される言語はプリミティブ、
接続手段、そしてそのレベルの詳細さに適切な抽象化手段を持っています。



階層化された設計は複雑なシステムの設計において普及しています。例えば
計算機設計では抵抗とトランジスタは接続され(そしてアナログ回路
言語を用いて記述され)ANDゲートやORゲートのようなパーツを生じ、それらがデジタル回路
の言語のプリミティブを形成します。\footnote{\link{Section 3.3.4}がそのような言語について
記述します。} このようなパーツはプロセッサ、バス構造、メモリシステムを構築するために
接続され、それらはコンピュータを形成するために接続され、コンピュータアーキテクチャに
相応しい言語を用います。コンピュータは分散システムを形成するために接続され、
ネットワーク相互接続その他を記述するに適切な言語を用います。


階層化の簡単な例として、ピクチャー言語はプリミティブな要素(プリミティブペインタ)を
用い、それらは点と線を指定し\code{segments\-/>painter}のための線分のリストを提供したり、
\code{rogers}のようなペインタに対するシェーディングの詳細を提供したりする言語を
用いて作成されました。私達のピクチャー言語の説明の大部分がこれらのプリミティブを接続し
\code{beside}や\code{below}のような幾何学的なコンバイナ(結合器)に充てられました。
私達はまたより高階なレベルにおいて\code{beside}と\code{below}をプリミティブとして見做し
\code{square\-/of\-/four}のような命令を持つ言語において幾何学的結合器を接続する共通の
パターンを獲得することに努めました。



階層化設計はプログラムを\newterm{robust}(\jnewterm{堅牢})にすることを手助けします。
それはつまりプログラムにおける仕様上の小さな変更が相応した小さな変更を
要求することを意味します。例えば\link{Figure 2.9}で示された\code{wave}のイメージ
を変更したいとします。\code{wave}要素の詳細な表現を変更する最も低レベルで行うことも
可能ですが、中間のレベルにおいて\code{corner\-/split}が\code{wave}をどのように複製するか
について行うことも可能ですし、最高レベルにおいて\code{square\-/limit}がどのように角の
4つのコピーを配置するかについて変更することも可能です。一般的に階層設計の各レベル
は異なる語彙をシステムの特徴を表すのに提供します。そして異なる種類の変更方法をも
提供します。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.52}Exercise 2.52:} 
\link{Figure 2.9}の\code{wave}のsquare-limitに、上で説明された各レベルで働くことで
変更を加えよ。より詳細には、

\begin{enumerate}[a]

\item
\link{Exercise 2.49}のプリミティブな\code{wave}ペインタにいくつか線分を加えよ。
(例えば笑顔を追加せよ)

\item
\code{corner\-/split}により構築されるパターンを変更せよ
(例えば\code{up\-/split}や\code{right\-/split}のイメージを2つでなく1つにせよ)

\item
\code{square\-/of\-/four}を用いる\code{square\-/limit}のバージョンを変更し角を異なるパターンで
組み立てるようにせよ。
(例えば正方形の各角にてMr. Rogersをそれぞれ外に向けよ)

\end{enumerate}
\end{quote}

\section{記号データ}
\label{Section 2.3}



私達がここまで使用した全ての複合データオブジェクトは最終的には数値から構築されていました。
この節では任意のシンボル(記号)をデータとして用いる能力を紹介することで、言語の表現力を拡張します。



\subsection{クォート}
\label{Section 2.3.1}



もし記号を用いて複合データを形成できれば以下のようなリストを持つことができます。

\begin{scheme}
(a b c d)
(23 45 17)
((Norah 12) (Molly 9) (Anna 7) (Lauren 6) (Charlotte 4))
\end{scheme}

\noindent
記号を含むリストは言語の式と全く同じように見えます。

\begin{scheme}
(* (+ 23 45) 
   (+ x 9))
(define (fact n) 
  (if (= n 1) 1 (* n (fact (- n 1)))))
\end{scheme}

\noindent
記号を扱う目的のためには言語に新しい要素を必要とします。データオブジェクトを
\newterm{quote}(\jnewterm{引用})する能力です。例えばリスト\code{(a b)}を構築したいとします。
私達はこれを\code{(list a b)}を用いては達成できません。なぜならこの式は\code{a}と
\code{b}の値からリストを構築する式であり、記号それ自体ではないからです。
この問題は自然言語の文脈では良く知られていて、単語と文が意味上の要素として見做さ
れているか、または文字列(文法上の要素)として見做されているかの場合が有り得ます。
自然言語での共通な慣例は単語や文が文字通りに扱われることを示すためにクォーテーション
マークを用いることです。例えば``John''の最初の文字は明らかに``J''です。
もし私達が誰かに``貴方の名前を大きな声で言って''と伝えれば、その人の名前を
聞くことを期待します。しかしもし誰かに`` `貴方の名前'と大きな声で言って''と伝えれば
``貴方の名前''という語を聞くことを期待するでしょう。私達がクォーテーションマークを
入れ子にすることを第三者が何を言うだろうかを説明するために強制されていることに
注意して下さい。\footnote{言語の中でクォーテーションを許可することが簡単な語で
言語について推論する能力を与えると共に大きな破壊をもたらしています。それが
等値な物は等値な物と置換できるという概念を破壊するためです。例えば1足す2は3ですが
``3''という語は``1足す2''という語句ではありません。クォーテーションは他の表現を
操作する表現を構築する手段を提供するため強力です。(\link{Chapter 4}でインタプリタを
書く時に学びます)。しかし言語の中で、同じ言語の他の文について話す文を許すことは
``等値な物は等値な物と交換できる''が何を意味すべきかという任意の一貫性を保守すること
をとても難しくします。例えばもし私達が宵の明星が明けの明星と同じであることを知っている
場合、``宵の明星は金星''という文から``明けの明星は金星''であることを推論できます。
しかし``Johnは宵の明星が金星であることを知っている''を与えられても``Johnは明けの明星
が金星であることを知っている''とは推論することはできません。}



データオブジェクトとして扱われるべきであり、式として評価
されるべきではないリストとシンボルを区別するために、これと同じ習慣に従うことができます。
しかしクォートする形式は自然言語のそれとは異なり、クォーテーションマーク(伝統的に
シングルクォートの記号 \code{'})はクォートされるべきオブジェクトの先頭にのみ置かれます。
Schemeの文法でこの様に逃れられるのはオブジェクトを区切るのに空白と括弧を信頼することが
できるためです。従ってシングルクォート文字の意味は次のオブジェクトをクォートすることに
なります。\footnote{シングルクォートは表示される文字列を囲むのに使用してきたダブルクォート
とは異なります。シングルクォートがリストやシンボルを示すのに対し、ダブルクォートは
文字列と共にのみ利用されます。この本では文字列の使用方法は表示されるための項目としてのみ
です。}


これでシンボルとその値を区別することが可能です。

\begin{scheme}
(define a 1)
(define b 2)
(list a b)
~\textit{(1 2)}~
(list 'a 'b)
~\textit{(a b)}~
(list 'a b)
~\textit{(a 2)}~
\end{scheme}

\noindent
クォーテーションはまた慣習的なリストに対する印字された表現を用いて
複合オブジェクトの入力も可能にします。\footnote{厳密には私達のクォーテーションマークの
使用方法は言語における全ての複合式は括弧で区切られリストのように見えるという
全体のルールを破ります。この整合性に対しては特殊形式\code{quote}を紹介することで
回復することが可能です。これはクォーテーションマークと同じ目的を演じます。
従って\code{'a}の代わりに\code{(quote a)}と入力できますし、\code{'(a b c)}の代わりに
\code{(quote (a b c))}と入力できます。これはインタプリタは正確にはどのように働くか
ということです。クォーテーションマークは単一文字による省略形に過ぎず次の完全な
式を\code{quote}でラッピングすることで
\( \hbox{\ttfamily(quote}\;\langle\kern0.06em\hbox{\ttfamily\slshape expression}\kern0.08em\rangle\hbox{\ttfamily)} \)
を形成します。これは重要なことです。なぜならインタプリタに読まれる任意の式がデータオブジェクト
として扱うことができるという原則を保持するからです。例えば\code{(car '(a b c))}という式は
\code{(car (quote (a b c)))}と同じで、\code{(list 'car (list 'quote '(a b c)))}
を評価することで構築できます。}

\begin{scheme}
(car '(a b c))
~\textit{a}~
(cdr '(a b c))
~\textit{(b c)}~
\end{scheme}

\noindent
これを守ることで、空リストを\code{'()}を評価して得ることができます。
従って、変数\code{nil}の使用を止められます。



記号を操作するのに使われるもう1つ追加のプリミティブとして\code{eq?}があります。
これは2つのシンボルを引数として取りそれらが同じであるかテストします。\footnote{
2つのシンボルが同じ文字で同じ順に構成されている場合にそれらが``同じ''であると
考えることができます。そのような定義はまだ私達が解決するには準備の足りない深い
問題を回避しています。プログラミング言語における``同一性''の意味です。
私達はこの問題に\link{Chapter 3} (\link{Section 3.1.3})にて戻ります。}
\code{eq?}を用いることで\code{memq}と呼ばれる便利な手続を実装できます。これは2つの引数、
シンボルとリストを取ります。もしシンボルがリストに含まれていない場合(つまり
リスト中のどの項目にも\code{eq?}でない場合)\code{memq}はfalseを返します。そうでなければ
リスト中のそのシンボルが最初に出現する場所からのサブリストを返します。

\begin{scheme}
(define (memq item x)
  (cond ((null? x) false)
        ((eq? item (car x)) x)
        (else (memq item (cdr x)))))
\end{scheme}

\noindent
例えば、次の式の値は

\begin{scheme}
(memq 'apple '(pear banana prune))
\end{scheme}

\noindent
falseになります。そして次の式の値は

\begin{scheme}
(memq 'apple '(x (apple sauce) y apple pear))
\end{scheme}

\noindent
\code{(apple pear)}です。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.53}Exercise 2.53:} 
以下の式のそれぞれを評価した応答としてインタプリタは何を表示するか?

\begin{scheme}
(list 'a 'b 'c)
(list (list 'george))
(cdr '((x1 x2) (y1 y2)))
(cadr '((x1 x2) (y1 y2)))
(pair? (car '(a short list)))
(memq 'red '((red shoes) (blue socks)))
(memq 'red '(red shoes blue socks))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.54}Exercise 2.54:} 
2つのリストはそれぞれが同じ要素を同じ順で持っている場合に\code{equal?}と言える。
例えば

\begin{scheme}
(equal? '(this is a list) '(this is a list))
\end{scheme}

\noindent
は真であるが

\begin{scheme}
(equal? '(this is a list) '(this (is a) list))
\end{scheme}

\noindent
は偽である。具体的には基本となる\code{eq?}の記号の等価性を再帰的に用いて\code{equal?}
を定義できる。\code{a}と\code{b}が\code{equal?}であるとはそれらが両方とも記号である場合、かつ
記号が\code{eq?}である場合、または両方ともリストであり\code{(car a)}が\code{(car b)}に
\code{equal?}であり、かつ\code{(cdr a)}が\code{(cdr b)}に\code{equal?}であるような場合である。
この考えを用いて\code{equal?}を手続として実装せよ。\footnote{
実際には、プログラマは\code{equal?}を数値と同じくシンボルを含むリストの比較に用いる。
数値は記号とは認識されない。数の上で等しい二つの数値(\code{=}でテストした場合の様に)が
\code{eq?}でもそうであるかという問題は高度に実装依存である。\code{equal?}の
(Schemeにプリミティブとして提供されているような)より良い定義でも、もし\code{a}と\code{b}が
数値であるなら、それらが数値として等しい場合に\code{equal?}であると明記するだろう。}
 
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.55}Exercise 2.55:} 
Eva Lu Atorはインタプリタに次の式を入力した。

\begin{scheme}
(car ''abracadabra)
\end{scheme}

驚いたことにインタプリタは\code{quote}を応答として表示した。説明せよ。
\end{quote}


\subsection{例: 記号微分}
\label{Section 2.3.2}



記号操作の説明として、及びより一層のデータ抽象の説明として、代数式の記号微分を
行う手続の設計について考えてみましょう。手続は引数として代数式と変数を取り
変数に対する式の導関数を返すことにします。例えば手続に対する引数が
\( ax^2 + bx + c \)と\( x \)の時、手続は\( 2ax + b \)を返さなければいけません。
記号微分はLispにとって歴史的に特別な意味があります。記号操作のためのコンピュータ言語
の開発の裏にこれがその動機の一例として存在しました。さらにこれが現在増大する応用数学者
及び科学者に用いられている記号数理の成果の
ための強力なシステムの開発へと導く一連の研究の始まりに跡を残しました。



記号微分プログラムの開発においても\link{Section 2.1.1}の分数システムの開発と
同じデータ抽象化の戦略に従います。最初に``sums,'' ``products,'' ``variables''
のような抽象オブジェクトを操作する微分アルゴリズムを定義します。
これらがどのように表現されているのかについて心配することありません。
後程、表現上の問題については解決しましょう。

\subsubsection*{抽象データを用いた微分プログラム}



問題を簡単にするために、二引数の足し算とかけ算の命令のみから構築される式のみを扱う
とても簡単な記号微分プログラムについて考えましょう。任意のそのような式の微分は以下の
簡約ルールを適用することで実行されます。

\begin{comment}

\begin{example}
dc
-- = 0  for c a constant, or a variable different from x
dx

dx
-- = 1
dx

d(u + v)   du   dv
-------- = -- + --
   dx      dx   dx

d(uv)     / dv \     / du \
----- = u | -- | + v | -- |
 dx       \ dx /     \ dx /
\end{example}

\end{comment}
\begin{displaymath}
{{\it dc} \over {\it dx}} 		= 0, 
	\quad c\ \mbox{は定数か、} x\ \mbox{と異なる変数}, 
\end{displaymath}
\begin{displaymath}
{{\it dx} \over {\it dx}} 		= 1, 
\end{displaymath}
\begin{displaymath}
{{\it d\,(u + v\,)} \over {\it dx}} 	= {{\it du} \over {\it dx}} + {{\it dv} \over {\it dx}}, 
\end{displaymath}
\begin{displaymath}
{{\it d\,(uv\,)} \over {\it dx}} 	= u {{\it dv} \over {\it dx}} + v {{\it du} \over {\it dx}}. 
\end{displaymath}


\noindent
後者の2つのルールは自然に再帰的であることに注意して下さい。つまり和の導関数を得る
ためには最初に項の導関数を求めそれらを足す必要があります。各項は順に分解が必要な
式に成り得ます。順により小さな部分へと分解していくことはやがて定数か、その導関数が
0か1のどちらかになる変数になります。



これらのルールを手続で具体化するために、分数実装の設計で行ったように少し希望的観測
に耽ります。もし代数式を表現するための手段があるのなら式が和か積か定数であるかを
判別することができるはずです。式のパーツを抽出することができるはずです。例えば
足し算に対して加数(第一項)と被加数(第二項)を抽出できるはずです。またパーツから式を
構築することもできるはずです。既に以下のセレクタ、コンストラクタ、述語を実装するための
手続を持っていると仮定しましょう。

\begin{scheme}
(variable? e)            ~\textrm{\code{e}は変数であるか?}~
(same-variable? v1 v2)   ~\textrm{\code{v1}と\code{v2}は同じ変数であるか?}~
(sum? e)                 ~\textrm{\code{e}は和か?}~
(addend e)               ~\textrm{和\code{e}の加数.}~
(augend e)               ~\textrm{和\code{e}の被加数.}~
(make-sum a1 a2)         ~\textrm{\code{a1}と\code{a2}の和を構築する}~
(product? e)             ~\textrm{\code{e}は積か?}~
(multiplier e)           ~\textrm{積\code{e}の乗数}~
(multiplicand e)         ~\textrm{積\code{e}の被乗数}~
(make-product m1 m2)     ~\textrm{\code{m1}と\code{m2}の積を構築する}~
\end{scheme}

\noindent
これらと数値であるかを判断するプリミティブな述語\code{number?}を用いて、以下の手続の
様に微分のルールを表現できます。

\begin{scheme}
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        ((sum? exp) (make-sum (deriv (addend exp) var)
                              (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand exp) var))
           (make-product (deriv (multiplier exp) var)
                         (multiplicand exp))))
        (else
         (error "unknown expression type: DERIV" exp))))
\end{scheme}

\noindent
この\code{deriv}手続は完全な微分アルゴリズムに立脚しています。代数データの項により
表現されているため、適切なセレクタとコンストラクタを設計する限りにおいて、どのように
代数式を表現しても動きます。この条件の部分が次に解決すべき問題です。

\subsubsection*{代数式を表現する}



代数式を表現するリスト構造を使用する手法は数多く想像できます。例えば通常の代数
記法を真似する記号のリストを用い、\( ax + b \)をリスト\code{(a * x + b)}の様に
表現することもできるでしょう。しかし特に直接的な1つの選択はLispが複合式に用いる
のと同じく括弧で括った接頭辞記述法です。つまり\( ax + b \)は\code{(+ (* a x) b)}と
表現されます。従って微分問題に対するデータ表現は以下のとおりです。

\begin{itemize}

\item
変数はシンボルである。プリミティブな述語\code{symbol?}で判別される。

\begin{scheme}
(define (variable? x) (symbol? x))
\end{scheme}

\item
2つの変数はそれらを表現するシンボルが\code{eq?}である時同じだ。

\begin{scheme}
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
\end{scheme}

\item
和と積はリストとして構築される。

\begin{scheme}
(define (make-sum a1 a2) (list '+ a1 a2))
(define (make-product m1 m2) (list '* m1 m2))
\end{scheme}

\item
和は最初の要素がシンボル\code{+}のリストだ。

\begin{scheme}
(define (sum? x) (and (pair? x) (eq? (car x) '+)))
\end{scheme}

\item
加数は和のリストの二つ目の項だ。

\begin{scheme}
(define (addend s) (cadr s))
\end{scheme}

\item
被加数は和のリストの三つめの項だ。

\begin{scheme}
(define (augend s) (caddr s))
\end{scheme}

\item
積は最初の要素がシンボル\code{*}のリストだ。

\begin{scheme}
(define (product? x) (and (pair? x) (eq? (car x) '*)))
\end{scheme}

\item
乗数は積のリストの二つ目の項だ。

\begin{scheme}
(define (multiplier p) (cadr p))
\end{scheme}

\item
被乗数は積のリストの三つめの項だ。

\begin{scheme}
(define (multiplicand p) (caddr p))
\end{scheme}

\end{itemize}

\noindent
従って記号微分プログラムを得るためには、これらを\code{deriv}により組込まれた
アルゴリズムを用いて組み立てることのみが必要でです。いくつかの例とその振舞を
見てみましょう。

\begin{scheme}
(deriv '(+ x 3) 'x)
~\textit{(+ 1 0)}~
(deriv '(* x y) 'x)
~\textit{(+ (* x 0) (* 1 y))}~
(deriv '(* (* x y) (+ x 3)) 'x)
~\textit{(+ (* (* x y) (+ 1 0))}~
   ~\textit{(* (+ (* x 0) (* 1 y))}~
      ~\textit{(+  x 3)))}~
\end{scheme}

\noindent
プログラムは正しい解答を生成します。しかし、それらは簡略化されていません。
\begin{comment}

\begin{example}
d(xy)
----- = x * 0 + 1 * y
 dx
\end{example}

\end{comment}
\begin{displaymath}
 {{\it d\,(xy)} \over {\it dx}} = x \cdot 0 + 1 \cdot y, 
\end{displaymath}
\noindent
しかし私達はこのプログラムに\( x \cdot 0 = 0 \), \( 1 \cdot y = y \),
\( 0 + y = y \)を理解して欲しいと望みます。二つ目の例の解答は単純に\code{y}となるべき
です。三つめの例が示すように、これは式が複雑な場合には深刻な問題となります。



この困難は分数実装において出くわしたものととても似ています。最も単純な形式に解答を
約分していませんでした。分数を約分するためには実装のコンストラクタとセレクタのみを
変更する必要がありました。ここでも同様の戦略を受け入れることができます。\code{deriv}には
全く変更は加えません。その代わりに\code{make\-/sum}を変更し両方の加数が数値である場合、
\code{make\-/sum}はそれらを足してその和を返します。また加数の1つが0ならば\code{make\-/sum}は
もう一方の加数を返します。

\begin{scheme}
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2))
         (+ a1 a2))
        (else (list '+ a1 a2))))
\end{scheme}

\noindent
これには手続\code{=number?}を用いました。式が与えられた数値と等しいかチェックします。

\begin{scheme}
(define (=number? exp num) (and (number? exp) (= exp num)))
\end{scheme}

\noindent
同様に\code{make\-/product}を変更し任意の項に0を掛ければ0、任意の項に1を掛ければそれ自身に
するルールを構築します。


\begin{scheme}
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list '* m1 m2))))
\end{scheme}

\noindent
これがこのバージョンが先程の3つの例でどのように動くかです

\begin{scheme}
(deriv '(+ x 3) 'x)
~\textit{1}~
(deriv '(* x y) 'x)
~\textit{y}~
(deriv '(* (* x y) (+ x 3)) 'x)
~\textit{(+ (* x y) (* y (+ x 3)))}~
\end{scheme}

\noindent
これはとても改善が見られますが、三つめの例は
式を``最も単純''だと同意を得られる形式に変形するプログラムを得るまでには
今だ長い道程があることを示します。代数の簡約の問題は複雑です。他の理由の中でも、
ある目的にとって最も単純な形式が他の目的にとってはそうではないことが有り得る
ためです。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.56}Exercise 2.56:} 
より多くの種類の式を扱うために基本的な微分をどのように拡張すべきか示せ。
例として、以下の微分ルールを実装せよ。
\begin{comment}

\begin{example}
d(u^n)            du
------ = nu^(n-1) --  
  dx              dx
\end{example}

\end{comment}
\begin{displaymath}
 {{\it d\,(u^n\,)} \over {\it dx}} = nu^{n-1} {{\it du} \over {\it dx}} 
\end{displaymath}
\noindent
\code{deriv}プログラムに新しい節を追加し、適切な手続\code{exponentiation?}, \code{base}, \code{exponent},
\code{make\-/exponentiation}を定義せよ。(シンボル\code{**}を指数演算の表記に用いても良い)。
任意の数の0乗は1であり、任意の数の1乗はそれ自身であるというルールを構築せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.57}Exercise 2.57:} 
微分プログラムを拡張し、(2以上の)任意の数の項の和と積を扱えるようにせよ。
すると上の最後の例は以下のように表現できる。

\begin{scheme}
(deriv '(* x y (+ x 3)) 'x)
\end{scheme}



この問題を和と積の表現のみを変更することで行え。\code{deriv}手続には全く変更を加えない。
例えば和の\code{addend}(加数)は最初の項になり、\code{augend}(被加数)は残りの項の和と
なるであろう。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.58}Exercise 2.58:} 
微分プログラムを変更し通常の数学の記法を扱えるようにしたいとする。\code{+}と\code{*}は
接中辞となり接頭辞演算子ではなくなる。微分プログラムは抽象データを用いて定義されて
いるので、もっぱら微分プログラムが操作する代数式を表現する述語、セレクタ、コンストラクタを
変更することで式の異なる表現を対応するように変更することができる。

\begin{enumerate}[a]

\item
\code{(x + (3 * (x + (y + 2))))}の様な接中辞で表される代数式を微分することを
どのように行うのか示せ。作業を簡単にするために\code{+}と\code{*}は常に2つの引数を取り
式は完全に括弧で括られていると仮定せよ。

\item
\code{(x + 3 * (x + y + 2))}のような標準的な代数記法を認めることで問題は大幅に難しくなる。
これは必要の無い括弧を省略し、乗算は加算の前に行われると仮定している。
私達の微分プログラムがそれでも働くこの記法に対する適切な述語、セレクタ、コンストラクタを設計できるだろうか?

\end{enumerate}
\end{quote}

\subsection{例: 集合を表現する}
\label{Section 2.3.3}



以前の例において2つ種類の複合データオブジェクトの表現を構築しました。分数と代数式
です。これらの例の1つでは組立時と選択時のどちらかで式を単純化(簡約化)を行うか選択肢が
ありました。しかしそれ以外では
リストを用いたこれらの構造に対する表現の選択肢は直接的なものでした。
私達が集合の表現に向かう時、表現の選択肢はあまり明白ではありません。
本当に数多くの可能な表現が存在し、それらはお互いからいくつかの点において著しく
異なります。



非公式には集合は異なる要素の単純な集まりです。より正確な定義を与えるために
私達はデータ抽象の手法を用いることができます。それは``集合''を集合上で用いられる
操作を特定することで定義することです。これらは\code{union\-/set}, \code{intersection\-/set}, 
\code{element\-/of\-/set?}, \code{adjoin\-/set}です。\code{element\-/of\-/set?}は与えられた要素が
集合のメンバーであるかを判定する述語です。\code{adjoin\-/set}はオブジェクトと集合を
引数として取り、元の集合の要素と挿入された要素をも含む集合を返します。
\code{union\-/set}はどちらかの引数に現れる全ての
要素含む集合である、2つの集合の和集合を計算します。
\code{intersection\-/set}は両方の引数の中に現れる要素のみを含む、2つの集合の共通集合を計算します。
データ抽象の視点から見れば、私達は上で与えられた解釈と一致する方法であれば、これらの
命令を実装するどんな表現を設計することも自由です。\footnote{
もしより正式でありたければ、``上で与えられた解釈と一致する''の部分を、命令群が
以下のようなルールの集合を満たすと指定することができます。

\noindent
任意の集合\code{S}と任意のオブジェクト\code{x}に対し、
\code{(element\-/of\-/set? x (adjoin\-/set x S))}は真(非公式には``オブジェクトを集合にadjoin
すればそのオブジェクトを含む集合を生成する'')

\noindent
任意の集合\code{S}と\code{T}と任意のオブジェクト\code{x}に対し、
\code{(element\-/of\-/set? x (union\-/set S T))}は
\code{(or (element\-/of\-/set? x S) (element\-/of\-/set? x T))}に等しい
(非公式には``\code{(union S T)}の要素は\code{S}または\code{T}に存在する要素'')

\noindent
任意のオブジェクト\code{x}に対し\code{(element\-/of\-/set? x '())}は偽
(非公式には``どのオブジェクトも空集合の要素ではない'')
}

\subsubsection*{順序無しリストとしての集合}


集合を表現するための1つの方法は、どの要素も一度より多くは現れない要素のリストとします。
空集合は空リストとして表現されます。この表現では\code{element\-/of\-/set?}は\link{Section 2.3.1}の
手続\code{memq}と似ています。\code{eq?}の代わりに\code{equal?}を用いているので集合要素は
シンボルである必要はありません。

\begin{scheme}
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((equal? x (car set)) true)
        (else (element-of-set? x (cdr set)))))
\end{scheme}

\noindent
これを用いて\code{adjoin\-/set}を書けます。adjoinされるオブジェクトが既に集合に
存在する場合、単に元の集合を返します。そうでなければ\code{cons}を用いて
オブジェクトを集合を表すリストに追加します。

\begin{scheme}
(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))
\end{scheme}

\noindent
\code{intersection\-/set}に対して再帰の戦略を使用できます。もし\code{set2}と
\code{set1}の\code{cdr}の共通集合の求める方がわかれば、これに\code{set1}の\code{car}を
含めるかどうか決定することのみが必要です。しかしこれは\code{(car set1)}が\code{set2}
にも存在するかに依存します。以下に結果の手続を示します。

\begin{scheme}
(define (intersection-set set1 set2)
  (cond ((or (null? set1) (null? set2)) '())
        ((element-of-set? (car set1) set2)
         (cons (car set1)
               (intersection-set (cdr set1) set2)))
        (else (intersection-set (cdr set1) set2))))
\end{scheme}

\noindent
表現の設計において、私達が考慮しなければならない問題の1つは効率です。
集合操作により必要とされるステップ数を考えて下さい。
それら全てが\code{element\-/of\-/set?}を使用するので、この命令のスピードは総じて
集合実装の効率上に主要な影響を与えます。ここで、あるオブジェクトが集合の要素であるか
をチェックするために、\code{element\-/of\-/set?}は集合全体をスキャンしなければならない
かもしれません。(最悪の場合、そのオブジェクトがその集合の中に存在しないことが分かる
かもしれません)。それ故にもしその集合が\( n \)要素を持つ場合、\code{element\-/of\-/set?}は
最大\( n \)ステップかかるかもしれません。従って必要とされるステップ数は\( \Theta(n) \)
で増加します。\code{adjoin\-/set}により必要とされるステップ数は、それがこの命令を用いるので、
これもまた\( \Theta(n) \)で増加します。
\code{intersection\-/set}は、\code{set1}の各要素に対し\code{element\-/of\-/set?} のチェックを行うため、
必要とされるステップ数は関係する集合のサイズの積か、またはサイズ\( n \)の2つの集合に対し
\( \Theta(n^2) \)で増加します。\code{union\-/set}に対しても同じことが言えます。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.59}Exercise 2.59:} 
集合の順序無しリスト表現に対する\code{union\-/set}命令を実装せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.60}Exercise 2.60:}
集合は重複無しのリストとして表現されると指示した。ここで重複を許可すると
仮定してみる。例として集合\( \{1, 2, 3\} \)はリスト\code{(2 3 2 1
3 2 2)}として表現できるだろう。この表現上で操作を行う手続\code{element\-/of\-/set?}, \code{adjoin\-/set},
\code{union\-/set}, \code{intersection\-/set}を設計せよ。
それぞれの効率は対応する重複無し表現に対する手続に比べてどれ程だろうか?
重複無しの集合に優先してこの表現を用いるだろうアプリケーションはあるだろうか?
\end{quote}

\subsubsection*{順序有りリストとしての集合}


私達の集合操作を高速化するための1つの方法として表現を変更することで集合要素を
昇順に並べる方法があります。これを行うには2つのオブジェクトを比較する何らかの
方法が必要です。それによりどちらが大きいを言うことができます。例えばシンボルを
辞書順で比較したり、オブジェクトに一意の番号を付けその後要素を対応する番号で比較
するための何らかの方法について同意できるでしょう。議論を単純にするため私達は集合
要素が数値である場合のみについて考えます。それにより要素を\code{>}と\code{<}を用いて
比較することができます。数値の集合をその要素を昇順に並べることで表現しましょう。
上の最初の表現は集合\( \{1, 3, 6, 10\} \)を要素を任意の順で並べることで表現でき
る一方で、新しい表現はリスト\code{(1 3 6 10)}のみを許します。



順序付けの1つの利点は\code{element\-/of\-/set?}にて現れます。項目の存在をチェックする
場合において、集合全体をスキャンする必要がありません。もし探している項目よりも
大きな要素に出会ったならばその集合にこの項目が無いことがわかります。

\begin{scheme}
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((= x (car set)) true)
        ((< x (car set)) false)
        (else (element-of-set? x (cdr set)))))
\end{scheme}

\noindent
これがどれだけのステップを割引くでしょうか? 最悪の場合、探している項目は
集合の中で一番大きい物かもしれません。その場合ステップ数は順序無し表現と
同じです。しかし一方でもし多くの異なるサイズの項目を探している場合、時々は
リストの先頭近くの点で検索を停止することができることを期待できます。そして
他の場合にはやはりリストのほとんどを試験しなければいけません。平均では集合の
項目数の半分近くを試験しなければいけないことが期待できるはずです。
従って必要とされる平均のステップ数は約\( n / 2 \)になります。これはそれでも
\( \Theta(n) \)で増加しますが、以前の実装に対して平均的にはステップ数において
半分に節約します。



\code{intersection\-/set}ではより目覚ましい高速化を得ます。順序無し表現ではこの命令
は\( \Theta(n^2) \)ステップを必要としました。\code{set1}の各要素に対して\code{set2}の
完全なスキャンを実行していたためです。しかし順序有り表現ではより賢い方法を用いる
ことができます。二つの集合の最初の要素\code{x1}と\code{x2}を比較することで始め、もし
\code{x1}と\code{x2}が等しい場合にはそれらは共通集合の要素です。そして共通集合の残りは
2つの集合の\code{cdr}の共通集合です。そうでなく\code{x1}が\code{x2}より小さい場合を考えます。
\code{x2}は\code{set2}の最小の要素ですから直ぐに\code{x1}は\code{set2}のどこにも現れず、従って
共通集合には有り得ません。従って共通集合は\code{set2}と\code{set1}の\code{cdr}の共通集合に
等しいとなります。同様にもし\code{x2}が\code{x1}より小さい場合、共通集合は\code{set1}と
\code{set2}の\code{cdr}の共通集合にて与えられます。以下に手続を与えます。

\begin{scheme}
(define (intersection-set set1 set2)
  (if (or (null? set1) (null? set2))
      '()
      (let ((x1 (car set1)) (x2 (car set2)))
        (cond ((= x1 x2)
               (cons x1 (intersection-set (cdr set1)
                                          (cdr set2))))
              ((< x1 x2)
               (intersection-set (cdr set1) set2))
              ((< x2 x1)
               (intersection-set set1 (cdr set2)))))))
\end{scheme}

\noindent
この処理により必要とされるステップ数を推定するために、各ステップにて共通集合問題は
縮小され、\code{set1}か\code{set2}、又はその両方の最初の要素を削除することで、
より小さな集合の共通部分を求める問題になっていることに注意して下さい。
従って必要とされるステップ数は最大でも\code{set1}と\code{set2}のサイズの合計であり、
順序無し表現におけるサイズの積とはなりません。これは\( \Theta(n^2) \)でなく、
\( \Theta(n) \)で増加するため、例え中程度のサイズの集合に対してでも考慮に値する高速化です。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.61}Exercise 2.61:} 
順序有り表現を用いた\code{adjoin\-/set}の実装を与えよ。\code{element\-/of\-/set?}との類似点にて、
どのように順序の利点を用いて順序無し表現に対し平均で約半分のステップを必要とする手続を
生成するかを示せ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.62}Exercise 2.62:} 
順序付きリストとして表現された集合に対する\code{union\-/set}の実装を\( \Theta(n) \)の
範囲で行え。
\end{quote}

\subsubsection*{二分木としての集合}



集合要素を木の形式にて準備することで順序有りリスト表現よりも良く行なうことができます。
木の各ノードはそのノードにおける``エントリ''と呼ばれる集合の1つの要素と他の2つの(空にも有り得る)
ノードへのリンクを持ちます。``左''のリンクはそのノードよりも小さな値を差し、``右''のリンクはその
ノードの値より大きな値のノードを差します。\link{Figure 2.16}は集合\( \{1, 3, 5, 7, 9, 11\} \)
を表現するいくつかの木を示しています。

\begin{figure}[tb]
\phantomsection\label{Figure 2.16}
\centering
\begin{comment}
\heading{Figure 2.16:} Various binary trees that represent the set \( \{1, 3, 5, 7, 9, 11\} \).

\begin{example}
   7          3             5
   /\         /\            /\
  3  9       1  7          3  9
 /\   \         /\        /   /\
1  5  11       5  9      1   7  11
                   \
                   11
\end{example}
\end{comment}
\includegraphics[width=70mm]{fig/chap2/Fig2.16b.pdf}
\begin{quote}
\heading{Figure 2.16:} 集合\( \{1, 3, 5, 7, 9, 11\} \)を表現するさまざまな二分木
\end{quote}
\end{figure}

\noindent
木表現の優位点は次のとおりです。ある数値\( x \)がある集合に含まれているかどうかをチェック
したいと想定します。\( x \)をトップノードのエントリと比較することから始めます。
もし\( x \)がこれよりも小さければ、左の部分木のみを探索すれば良いことがわかります。
もし\( x \)が大きければ、右の部分木のみを探索する必要があります。ここで、木が
``バランスが取れた''状態であるとは各部分木のサイズが元の約半分であるということです。
従って一度のステップにおいてサイズ\( n \)の木の探索問題を、サイズ\( n / 2 \)の
木の探索問題に縮小したことになります。各ステップにより木の探索に必要なステップは半分に
なるのでサイズ\( n \)の木の探索に必要なステップ数は\( \Theta(\log n) \)で増加することが
期待されます。\footnote{
\link{Section 1.2.4}の高速指数アルゴリズムや\link{Section 1.2.4}の半区間検索手法で学んだように各ステップにて
問題のサイズを半分にすることは対数増加の特徴的な性質です。}
大きな集合に対しては以前の表現に比べこれは著しい高速化になるでしょう。


木はリストを用いて表現できます。各ノードは3つの項目のリストになります。ノードのエントリ、
左部分木、右部分木です。左、または右部分木が空リストの場合はそこに接続された部分木が存在
しないことを示します。この表現を以下の手続にて説明できます。\footnote{
私達は集合を木を用いて表現しており、そして木はリストを用いています---事実上、データ抽象化が
データ抽象化の上に構築されています。手続\code{entry}, \code{left\-/branch},\code{right\-/branch},
\code{make\-/tree}を
私達がそのような木をリスト構造を用いて表現することを望んだ特定の方法から``二分木''の抽象化を
分離する方法として見做すことができます。}

\begin{scheme}
(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left right)
  (list entry left right))
\end{scheme}

\noindent
これで\code{element\-/of\-/set?}手続を上で説明された戦略を用いて書くことができます。

\begin{scheme}
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((= x (entry set)) true)
        ((< x (entry set))
         (element-of-set? x (left-branch set)))
        ((> x (entry set))
         (element-of-set? x (right-branch set)))))
\end{scheme}

\noindent
集合に項目を付加することは同様に実装され、そしてまた\( \Theta(\log n) \)ステップを
必要とします。項目\code{x}を付加するためには、\code{x}をノードのエントリと比較し\code{x}が右か
左のどちらの枝に追加されるべきを判断し、\code{x}を適切な枝に追加し、この新しく構築された枝を元の
エントリともう一方の枝と共に接続します。もし\code{x}を空の木に付加するよう求められたら
エントリに\code{x}を持ち、右と左の枝は空である木を生成します。以下がこの手続です。

\begin{scheme}
(define (adjoin-set x set)
  (cond ((null? set) (make-tree x '() '()))
        ((= x (entry set)) set)
        ((< x (entry set))
         (make-tree (entry set)
                    (adjoin-set x (left-branch set))
                    (right-branch set)))
        ((> x (entry set))
         (make-tree (entry set) (left-branch set)
                    (adjoin-set x (right-branch set))))))
\end{scheme}

\noindent
上の木の検索は対数ステップで実行可能であるとの主張は木は``バランスが取れている''
という前提に依存しています。すなわち、全ての木の左と右の部分木は大体同じ要素の
数を持っているため、各部分木はその親の約半分の要素持っていることになります。
しかしどのようにすれば私達が構築した木がバランスが取れていると確信することが
できるのでしょうか。例えもしバランスの取れた木で開始したとしても、\code{adjoin\-/set}
にて要素を足していけばバランスが取れていない結果を生み出します。新しく付加される
要素の位置は集合に既に存在する項目とどのように比較されるかに依存するために、
もし要素を``ランダム''に追加すればその木が平均ではバランスが取れることが予想でき
ます。しかしこれは保証されません。例えばもし空集合から始めて数値を1から7まで順番に
追加していけば\link{Figure 2.17}で示されるとてもアンバランスな木になってしまいます。
この木では全ての左の部分木は空であり、単純な順序有りリストに対する優位点が存在
しません。この問題を解く1つの方法として任意の木をバランスの取れた木に同じ要素を
用いて変換する操作を定義することが上げられます。そうすれば数回毎の\code{adjoin\-/set}
の後にこの変換を実行することで集合のバランスを保つことができます。この問題を解く
他の方法もまた存在しますが、その多くは検索と挿入の両方が\( \Theta(\log n) \)
ステップで行える新しいデータ構造を設計することを含みます。\footnote{そのような
構造の例には\newterm{B-trees}(\jnewterm{B木})や\newterm{red-black trees}(\jnewterm{赤黒木})があります。この問題に
ささげられた巨大な文献が存在します。 \link{Cormen et al. 1990}を参照して下さい。}

\begin{figure}[tb]
\phantomsection\label{Figure 2.17}
\centering
\begin{comment}
\heading{Figure 2.17:} Unbalanced tree produced by adjoining 1 through 7 in sequence.

\begin{example}
1
 \
  2
   \
    4
     \
      5
       \
        6
         \
          7
\end{example}
\end{comment}
\includegraphics[width=40mm]{fig/chap2/Fig2.17a.pdf}
\begin{quote}
\heading{Figure 2.17:} 1から7まで順にadjoinすることで生成した不均衡な木
\end{quote}
\end{figure}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.63}Exercise 2.63:} 
以下の2つの手続はそれぞれ二分木をリストに変換する。

\begin{scheme}
(define (tree->list-1 tree)
  (if (null? tree)
      '()
      (append (tree->list-1 (left-branch tree))
              (cons (entry tree)
                    (tree->list-1 
                      (right-branch tree))))))
(define (tree->list-2 tree)
  (define (copy-to-list tree result-list)
    (if (null? tree)
        result-list
        (copy-to-list (left-branch tree)
                      (cons (entry tree)
                            (copy-to-list 
                              (right-branch tree)
                              result-list)))))
  (copy-to-list tree '()))
\end{scheme}

\begin{enumerate}[a]

\item
2つの手続は全ての木に対して同じ結果を生成するか? もしそうでなければどのように
結果は異なるか? \link{Figure 2.16}の木に対して2つの手続はどんなリストを生成するか?

\item
2つの手続は\( n \)要素のバランスの取れた木をリストに変換するのに同じステップ数増加の
オーダであるか? もしそうでなければどちらがより遅く増加するか?

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.64}Exercise 2.64:} 
以下の手続\code{list\-/>tree}は順序有りリストをバランスの取れた木に変換する。
ヘルパ手続\code{partial\-/tree}は引数として整数\( n \)と少なくとも\( n \)要素のリスト
を取り、リストの最初の\( n \)要素を含むバランスの取れた木を生成する。
\code{partial\-/tree}の結果として返されるのは(\code{cons}で構築された)ペアであり、
\code{car}が構築された木で\code{cdr}が木に含まれなかった要素のリストである、

\begin{scheme}
(define (list->tree elements)
  (car (partial-tree elements (length elements))))
(define (partial-tree elts n)
  (if (= n 0)
      (cons '() elts)
      (let ((left-size (quotient (- n 1) 2)))
        (let ((left-result 
               (partial-tree elts left-size)))
          (let ((left-tree (car left-result))
                (non-left-elts (cdr left-result))
                (right-size (- n (+ left-size 1))))
            (let ((this-entry (car non-left-elts))
                  (right-result 
                   (partial-tree 
                    (cdr non-left-elts)
                    right-size)))
              (let ((right-tree (car right-result))
                    (remaining-elts 
                     (cdr right-result)))
                (cons (make-tree this-entry
                                 left-tree
                                 right-tree)
                      remaining-elts))))))))
\end{scheme}

\begin{enumerate}[a]

\item
できるだけ明確に\code{partial\-/tree}がどのように働くのか文章で答えよ。
リスト\code{(1 3 5 7 9 11)}に対し\code{list\-/>tree}により生成される木を描け。

\item
\code{list\-/>tree}が\( n \)要素のリストを変換するのに必要とされるステップ数の
増加んオーダはいくらか?

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.65}Exercise 2.65:} 
\link{Exercise 2.63}と\link{Exercise 2.64}の結果を用いて(バランスの取れた)二分木として
実装された集合の\( \Theta(n) \)における実装を与えよ。\footnote{
\link{Exercise 2.63}から\link{Exercise 2.65}はPaul Hilfingerによるものである。}
\end{quote}

\subsubsection*{集合と情報検索}


リストを集合を表現するのに使用する選択肢について調べ、データオブジェクトに対する
表現の選択がどのようにそのデータを使用するプログラムのパフォーマンスに大きな
影響を与えるかについて学びました。集合に専念するもう1つの理由としてここで議論された
テクニックが情報検索を含むアプリケーションにおいて何度も何度も現われることが
上げられます。



企業が持つ個人情報や会計システムの取引等、大量の個人レコードを持つデータベースに
ついて考えてみて下さい。典型的なデータ管理システムはレコードの中のデータへの
アクセスや変更に多大な時間を過ごします。従ってレコードにアクセスする効率的な
手法を必要とします。これは各レコードの一部に識別子である\newterm{key}(\jnewterm{キー})としての
役割を果たさせることで行われます。キーはレコードを一意に識別する任意の物で
かまいません。個人情報に対しては従業員番号であったりします。会計システムにおいては
取引番号であったりします。キーが何であれレコードをデータ構造として定義する時、
与えられたレコードに関連するキーを取得する\code{key}セレクタ手続を含まなければなりません。



さて、データベースをレコードの集合として表現します。与えられたキーでレコードを指し示す
ためには手続\code{lookup}を用い、引数としてキーとデータベースを取り、そのキーを持つレコード
を返すか、そのようなレコードが無ければfalseを返します。例えばもしレコードの集合が
順序無しリストで実装されていれば、以下を用いることができます。

\begin{scheme}
(define (lookup given-key set-of-records)
  (cond ((null? set-of-records) false)
        ((equal? given-key (key (car set-of-records)))
         (car set-of-records))
        (else (lookup given-key (cdr set-of-records)))))
\end{scheme}

\noindent
もちろん、巨大な集合を表現するのには順序無しリストよりもより良い方法が存在します。
レコードが``ランダムアクセス''される情報検索システムは一般的に木をベースにした手法で
実装されます。以前に議論された二分木のような物です。そのようなシステムを設計する場合、
データ抽象化の方法論はとても大きな手助けになります。設計者は順序無しリストの様な、
簡単で直接的な表現を用いて初期実装を作成することができます。これは最終的なシステムには
相応しくありません。しかし、``quick and dirty''(迅速だが汚い)データベースを残りのシステム
をテストするために提供する目的には便利でしょう。後でデータ表現はより洗練された物に
変更することが可能です。もしデータベースが抽象セレクタとコンストラクタによりアクセス
されるのならば、この表現上の変更は残りのシステムに対し何の変更も要求しません。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.66}Exercise 2.66:} 
レコードの集合が二分木として構造化され、キーの数値で順序付けられている場合の
\code{lookup}手続を実装せよ。
\end{quote}

\subsection{例: ハフマン符号化木}



この節では集合と木を操作するためのリスト構造とデータ抽象化の使用のための練習を提供
します。アプリケーションの狙いは1と0の(ビットの)列としてのデータを表現するための
手法です。例えばASCII標準コードはコンピュータ内にて各文字を7ビットの列に
符号化してテキストを表現するのに利用されます。7ビットを用いることは\( 2^7 \)、
または128の異なる文字を区別することができます。一般的に、もし\( n \)個の異なる
記号を区別したい場合、記号当たりに\( \log_2\!n \)ビットの使用が必要となります。
もし全てのメッセージが8つのシンボル、A, B, C, D, E, F, G, Hで作られている場合、
一文字当たり3ビットのコードを選択することができます。以下に例を上げます。

\begin{example}
A 000    C 010    E 100    G 110
B 001    D 011    F 101    H 111
\end{example}

\noindent
この符号を用いて、以下のメッセージは

\begin{example}
BACADAEAFABBAAAGAH
\end{example}

\noindent
54ビットの列として符号化されます。

\begin{example}
001000010000011000100000101000001001000000000110000111
\end{example}

\noindent
ASCIIや上記のAからHの符号は\newterm{fixed-length}(\jnewterm{固定長})符号として知られています。
それらがメッセージの各記号を同じ数のビットを用いて表現するためです。
時には\newterm{variable-length}(\jnewterm{可変長})符号を使用することが有利な場合もあります。
異なるシンボルが異なる数のビットで表現され得るものです。例えばモールス符号は
アルファベットの各文字に対して同じ数の点と長音を用いはしません。
具体的にはEは最も頻繁に現われる文字ですので単一のドットで表現されます。
一般的にはもしメッセージにおいてある記号がとても良く現れ、ある記号はとても稀に
現れる場合、短い符号を頻出のシンボルに割り振ることでデータをより効率的に(つまり
メッセージ当たりでより少ないビット数で)符号化することができます。

\begin{example}
A 0      C 1010    E 1100    G 1110
B 100    D 1011    F 1101    H 1111
\end{example}

\noindent
この符号では上の同じメッセージが以下の列として符号化されます。

\begin{example}
100010100101101100011010100100000111001111
\end{example}

\noindent
この列は42ビットですから上で示した固定長符号に比べ記憶域において20\%以上節約できています。



可変長符号を用いる上での難点の1つとして0と1の列を読んでいる時にいつシンボルの終わりに
辿り着いたか知ることが上げられます。モールス符号はこの問題を各文字に対するトンとツーの
列の後に特別な\newterm{separator code}(\jnewterm{分離符号})(この場合には一息置くこと)を用いることで
解決しました。他の解法としてはどの任意のシンボルに対する完全な符号も他のシンボルの符号の
始め(または\newterm{prefix}(\jnewterm{接頭辞}))ではない様に符号を設計するという物があります。
このような符号は\newterm{prefix code}(\jnewterm{接頭符号})と呼ばれます。上の例ではAは0で符号化され
Bは100で符号化されるので、他のどのシンボルも0、または100で始まる符号を持つことができません。



一般的に、もし符号化対象のメッセージ中のシンボルの相対頻度の利点を得られる
可変長接頭符号を用いれば著しい倹約を達成することができます。これを行うための
1つの特定な理論体系としてその発見者David Huffmanに因んでハフマン符号と呼ばれる
手法があります。ハフマン符号は葉が符号化された記号である二分木として表現するこ
とができます。木の葉でないノードのそれぞれには
そのノードの下に位置する葉の中のシンボル全てを含む集合があります。
加えて各葉のシンボルには重み(相対的な頻度)が割り振られており、葉でないノードの
それぞれはその下に位置する葉の重み全ての合計である重みを持っています。
重みはエンコード、またはデコード処理では利用されません。以下では重みがどのように
木の構築を手助けするかについて学びます。



\link{Figure 2.18}は上で与えられたAからH符号に対するハフマン木を示しています。
葉の重みは
この木がAは相対頻度8、Bは相対頻度3、他の文字は相対頻度1で現われるメッセージに対し
設計されたことを示しています。

\begin{figure}[tb]
\phantomsection\label{Figure 2.18}
\centering
\begin{comment}
\heading{Figure 2.18:} A Huffman encoding tree.

\begin{example}
           {A B C D E F G H} 17
                    *
                   / \
                  /   \
                A 8    * {B C D E F G H} 9
            __________/ \_____________
           /                          \
{B C D} 5 *                            * {E F G H} 4
         / \                       ___/ \___
        /   \                     /         \
      B 3    * {C D} 2   {E F} 2 *           * {G H} 2
            / \                 / \         / \
           /   \               /   \       /   \
         C 1   D 1           E 1   F 1   G 1   H 1
\end{example}
\end{comment}
\includegraphics[width=81mm]{fig/chap2/Fig2.18a.pdf}
\par\bigskip
\noindent
\heading{Figure 2.18:} ハフマン符号化木
\end{figure}

\noindent
ハフマン木を与えられることで、任意のシンボルの符号を木の根から始めてそのシンボル
を持つ葉に辿り着くまで降りていくことで見つけることができます。
左の枝に降りる度に符号に0を追加し、右の枝に降りる度に1を追加します。(どの枝を降り
るかはどの枝がそのシンボルに対する葉を含むか、つまりその集合にシンボルを含むか
をテストして判断することで決定します)。例えば\link{Figure 2.18}の木の根から始めて
Dに対する葉に辿り付くには右の枝を選択し、次に左の枝、次に右の枝、次に右の枝を
辿ります。従ってDに対する符号は1011になります。



ビット列をハフマン木を用いて複合するには、根から始めてビット列の一連の0と1を用いて
左か右の枝を下りるのか決定します。葉に着く度に、メッセージの新しいシンボルを生成し、
その時点で木の根から再開し次のシンボルを見つけます。例えば上記の木と列10001010を
与えられたとします。根から始めて右の枝へと下ります。(列の最初のビットが1だからです)。
次に左の枝を下ります。(2つ目のビットが0だからです)。次に左の枝を下ります。(3つ目の
ビットもまた0だからです)。この様にしてBに対する葉に辿り着くので複合されたメッセージ
の最初のシンボルはBです。ここでまた根から再開し、次のビットが0なので左に移動します。
これによりAの葉に辿り着きます。そしてまた根から残りの列1010と共に再開し、右、左、右
左と動きCに辿り着きます。従ってメッセージ全体はBACです。

\subsubsection*{ハフマン木の生成}


シンボルの``アルファベット''とそれらに対応する頻度を与えられた時、どのように
``最高の''符号を構築できるでしょうか? (言い替えれば、どの木がメッセージを最も少ない
ビット数で符号化するでしょうか?)。ハフマンはこれを行うアルゴリズムを与え、結果の符号が
相対的なシンボルの頻度と符号が構築された時の頻度が合致した場合に、実際にメッセージに
対する最良の可変長符号であることを示しました。
このハフマン符号の最適性についてはここでは証明しません。しかしハフマン木がどのように構築
されるかについては示します。\footnote{ハフマン符号の数学上の特性についての議論に対しては
\link{Hamming 1980}を参照して下さい。}


ハフマン木を生成するためのアルゴリズムはとても簡単です。その考えは木を再配置することで
最も低い頻度のシンボルが根から最も遠く現れるようにします。シンボルと頻度を含む葉のノード
の集合と共に
符号が構築される初期データにより決定されるに従う
まず重みが最低の2つの葉を見つけ、それらをマージしてこの2つのノードを左と右の枝に持つ
ノードを生成します。新しいノードの重みは2つの重みの和です。元の集合から2つの葉を削除し
それらをこの新しいノードで置き換えます。この処理を続けます。各ステップにて最も小さな
重みを持つ2つのノードをマージし、集合から削除し、これらの2つを左と右の枝に持つノードで
置き換えします。処理は1つのノードのみが残った時に停止し、それが木全体の根になります。
以下に\link{Figure 2.18}のハフマン木がどのように生成されるかを示します。

\begin{example}
Initial  
leaves   {(A 8) (B 3) (C 1) (D 1) (E 1) (F 1) (G 1) (H 1)}
Merge    {(A 8) (B 3) ({C D} 2) (E 1) (F 1) (G 1) (H 1)}
Merge    {(A 8) (B 3) ({C D} 2) ({E F} 2) (G 1) (H 1)}
Merge    {(A 8) (B 3) ({C D} 2) ({E F} 2) ({G H} 2)}
Merge    {(A 8) (B 3) ({C D} 2) ({E F G H} 4)}
Merge    {(A 8) ({B C D} 5) ({E F G H} 4)}
Merge    {(A 8) ({B C D E F G H} 9)}
Final    {({A B C D E F G H} 17)}
merge
\end{example}

\noindent
このアルゴリズムは常に同じ木を特定しません。各ステップにおいて重みが最小の
ノードのペアが一意となるとは限らないためです。またどの2つのノードがマージされるかの順も
決定しません。(つまりどれが右になり、どれが左になるのかはわかりません)。

\subsubsection*{ハフマン木の表現}


以下ではハフマン木を用いてメッセージの符号化・複合化を行い、かつ上で概説した
アルゴリズムに基づきハフマン木を作成します。木はどのように表現されるかの議論から
始めます。



木の葉はシンボル\code{leaf}、葉に対するシンボル、そして重みから構成される
リストにて表現されます。

\begin{scheme}
(define (make-leaf symbol weight)
  (list 'leaf symbol weight))
(define (leaf? object)
  (eq? (car object) 'leaf))
(define (symbol-leaf x) (cadr x))
(define (weight-leaf x) (caddr x))
\end{scheme}

\noindent
一般的な木は左側の枝、右側の枝、シンボルの集合、そして重みのリストになります。
シンボルの集合は単純にシンボルのリストとなり、より洗練された集合の表現を用いは
しません。2つのノードをマージして木を作る時、木の重みを各ノードの重みの和として取得し、
シンボルの集合は各ノードのシンボルの集合の和集合とします。シンボルの集合はリストとして
表現されていますので和集合は\link{Section 2.2.1}で定義した\code{append}手続を用いて形成することが
できます。

\begin{scheme}
(define (make-code-tree left right)
  (list left
        right
        (append (symbols left)
                (symbols right))
        (+ (weight left)
           (weight right))))
\end{scheme}

\noindent
もしこのように木を作るのなら以下のようなセレクタを持つことになります。

\begin{scheme}
(define (left-branch  tree) (car  tree))
(define (right-branch tree) (cadr tree))

(define (symbols tree)
  (if (leaf? tree)
      (list (symbol-leaf tree))
      (caddr tree)))
(define (weight tree)
  (if (leaf? tree)
      (weight-leaf tree)
      (cadddr tree)))
\end{scheme}

\noindent
手続\code{symbols}と\code{weight}はそれらが葉と一般的な木のどちらと共に呼ばれたかに
より少々異なったことをしなければなりません。これらは\newterm{generic procedures}
(\jnewterm{ジェネリック手続}：二種類以上のデータを扱える手続)の簡単なサンプルであり、\link{Section 2.4}と
\link{Section 2.5}にてより多くのことについて述べます。

\subsubsection*{複合化手続}


以下の手続は複合化アルゴリズムを実装します。0と1のリストをハフマン木と共に引数として
取ります。

\begin{scheme}
(define (decode bits tree)
  (define (decode-1 bits current-branch)
    (if (null? bits)
        '()
        (let ((next-branch
               (choose-branch 
                (car bits) current-branch)))
          (if (leaf? next-branch)
              (cons (symbol-leaf next-branch)
                    (decode-1 (cdr bits) tree))
              (decode-1 (cdr bits) next-branch)))))
  (decode-1 bits tree))
(define (choose-branch bit branch)
  (cond ((= bit 0) (left-branch branch))
        ((= bit 1) (right-branch branch))
        (else (error "bad bit: CHOOSE-BRANCH" bit))))
\end{scheme}

\noindent
手続\code{decode\-/1}は2つの引数を取ります。残りのビット列のリストと木における現在の
位置です。木を``下り''続けるためリストの中の次のビットが0であるか1であるかに
従って左、または右の枝を選択します。(これは手続\code{choose\-/branch}と共に行われます)。
葉に辿りついた時、その葉のシンボルをメッセージの次のシンボルとして、残りのメッセージ
を木の根から再開して複合した結果の頭に\code{cons}することで返します。\code{choose\-/branch}
の最終条項のエラーチェックに注目して下さい。もし手続が0または1以外の物を入力データに
見つけた場合にエラーを発します。

\subsubsection*{重み付き要素の集合}

私達の木の表現において、各葉ではないノードは簡単にリストとして表現したシンボルの
集合を持ちます。しかし上で議論した木の生成アルゴリズムはまた葉と木の集合に対しても
働き、2つの最小の項目のマージを続けなければなりません。集合の中の最も小さな項目を
繰り返し見つけなければなりませんから、このような集合に対しては順序有りの表現を用いる
と便利です。

葉と木の集合を重みの昇順で配置した要素のリストとして表現することにします。
以下の集合を構築するための\code{adjoin\-/set}手続は\link{Exercise 2.61}にて説明した
ものと似ています。しかし項目はその重みにて比較され、集合に追加される要素はその中に
既に存在はしないとします。

\begin{scheme}
(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((< (weight x) (weight (car set)))
         (cons x set))
        (else (cons (car set)
                    (adjoin-set x (cdr set))))))
\end{scheme}

\noindent
以下の手続は\code{((A 4) (B 2) (C 1) (D 1))}の様なシンボルと頻度のペアのリストを
取り、葉の初期順序有り集合を構築し、ハフマンアルゴリズムに従いマージできるよう
準備します。

\begin{scheme}
(define (make-leaf-set pairs)
  (if (null? pairs)
      '()
      (let ((pair (car pairs)))
        (adjoin-set (make-leaf (car pair)    ~\textrm{; symbol}~
                               (cadr pair))  ~\textrm{; frequency}~
                    (make-leaf-set (cdr pairs))))))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.67}Exercise 2.67:} 
符号化木とサンプルのメッセージを定義する。

\begin{scheme}
(define sample-tree
  (make-code-tree (make-leaf 'A 4)
                  (make-code-tree
                   (make-leaf 'B 2)
                   (make-code-tree (make-leaf 'D 1)
                                   (make-leaf 'C 1)))))
(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
\end{scheme}

\code{decode}手続を用いてメッセージを複合し結果を与えよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.68}Exercise 2.68:} 
\code{encode}手続は引数としてメッセージと木を取り、符号化されメッセージを与える
ビットのリストを生成する。

\begin{scheme}
(define (encode message tree)
  (if (null? message)
      '()
      (append (encode-symbol (car message) tree)
              (encode (cdr message) tree))))
\end{scheme}


\code{encode\-/symbol}はあなたが書かねばならぬ手続である。与えられた木に従って与えられた
シンボルの符号化を行いビットのリストを返す。\code{encode\-/symbol}をもしシンボルが
その木に存在しない場合にエラーを発するように設計せよ。あなたの手続を\link{Exercise 2.67}
で得られた結果とサンプルの木で符号化することでテストし、元のサンプルメッセージと
同じであるか確認せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.69}Exercise 2.69:} 
以下の手続はその引数としてシンボルと頻度のペアのリストを取り(どのシンボルも1つ
より多くのペアには存在しない)、ハフマンアルゴリズムに従いハフマン符号化木を生成する。

\begin{scheme}
(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))
\end{scheme}



\code{make\-/leaf\-/set}は上で与えられた手続でペアのリストを葉の順序有り集合へと変換する。
\code{successive\-/merge}はあなたが書かなければならぬ手続である。\code{make\-/code\-/tree}を
用いて集合の重みが最小の要素を残り要素が1つになるまで繰り返しマージせよ。残った一要素こそ
が望まれたハフマン木である。(この手続は少しトリッキーであるがそんなに複雑ではない。
もしあなたが自分の設計が複雑だと思うなら、ほとんど確実に何かを間違えている。順序有りの
集合表現を用いているという事実から著しい利点を得ることができる。)
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.70}Exercise 2.70:} 
以下の8つのシンボルによるアルファベット(文字体系)と関連する頻度は効率的に1950年代のロック
の歌を符号化するために設計された。(``アルファベット''の``シンボル''は単体の
文字である必要は無いことに注意せよ。)

\begin{example}
A    2   GET 2   SHA 3   WAH 1
BOOM 1   JOB 2   NA 16   YIP 9
\end{example}


\code{generate\-/huffman\-/tree}(\link{Exercise 2.69}参照)を用いて対応するハフマン木を
生成し、\code{encode} (\link{Exercise 2.68}参照)を用いて以下のメッセージを符号化
せよ。

\begin{example}
Get a job
Sha na na na na na na na na
Get a job
Sha na na na na na na na na
Wah yip yip yip yip yip yip yip yip yip
Sha boom
\end{example}

符号化には何ビットが必要であるか? この歌をもし固定長符号を8つシンボルによる
アルファベットに用いた時、最小で何ビットが必要であるか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.71}Exercise 2.71:} 
\( n \)個のシンボルのアルファベットに対するハフマン木を持っているとする。
各シンボルに関連する頻度は\( 1, 2, 4, \dots, 2^{n-1} \)だとしよう。
\( n=5 \)、\( n=10 \)の場合の木をスケッチせよ。そのような(任意の\( n \)に対する)
木において、最も頻度の高いシンボルを符号化するには何ビットが必要であるか?
最も頻度の低いシンボルに対してはいくらか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.72}Exercise 2.72:} 
あなたが\link{Exercise 2.68}にて設計した符号化手続について考える。シンボルを符号化する
のに必要なステップ数の増加のオーダーはいくらか? 各ノードに辿りついた時にシンボルリスト
を検索するのに必要なステップ数を含めることを確認するように。この質問の一般的な解答は
難しい。\( n \)個のシンボルの相対頻度が\link{Exercise 2.71}で説明された特別な場合に
ついて考えよ。そしてアルファベットにおける最大頻度と最小頻度のシンボルを符号化するのに
必要なステップ数の(\( n \)の関数としての)増加のオーダーを与えよ。
\end{quote}

\section{抽象データの多重表現}
\label{Section 2.4}

ここまでデータ抽象化について紹介してきました。これはプログラムが操作するデータ
オブジェクトの実装における選択に独立して多くのプログラムが指定され得る様な方法で
システムを構造化するメソドロジ(方法論)でした。例えば\link{Section 2.1.1}にてどのように
分数を用いるプログラムの設計タスクを、複雑なデータを構築するためのコンピュータ言語の
プリミティブなメカニズムを用いて分数を実装するタスクから分離するのかについて学び
ました。鍵となる考えは抽象化バリアを建てること---分数の使用法をそれらの根底にある
リスト構造を用いた表現から分離することでした。同様の抽象化バリアは分数演算(
\code{add\-/rat}, \code{sub\-/rat}, \code{mul\-/rat}, \code{div\-/rat})を実行する手続の詳細を
分数を用いる``より高いレベル''の手続から分離します。結果のプログラムは\link{Figure 2.1}
で示される構造を持ちます。

これらのデータ抽象化バリアは複雑さをコントロールする強力なツールです。
基礎をなすデータオブジェクトの表現を分離することで、大きなプログラムを設計する
タスクを小さなタスクに分割し別々に実行することを可能にします。しかしこの種の
データ抽象化はまだ十分に強力ではありません。データオブジェクトに対して
``基礎をなす表現''について話すことが常に意味があるとは限らないためです。



一例として、あるデータオブジェクトに対しては便利な表現が1つよりも多くあるかも
しれません。そして私達はシステムを複数の表現を扱えるように設計したいと願う
でしょう。簡単な例を得るために、複素数が2つのほとんど同様な方法で表現される
としましょう。(実数と虚数から成る)直行形式と(大きさと角度から成る)極形式です。
ある時は直行形式がより適切で、ある時には極形式がより適切になります。実際に
複素数が両者の方法にて表現され、複素数を操作する手続がどちらの表現でも働くこと
ができるシステムを考えることは完全に適切であろうと思われます。



より重要なこととして、プログラミングシステムは時折、長期間に渡り多くの人々が
働くことにより設計されるため、長い間仕様変更にさらされます。
そのような環境では、データ表現の選択を前もって同意することが誰にとっても可能と
いうことは単純に有り得ません。そのため使用から表現を分離するデータ抽象化バリア
に加えて、お互いから異なる設計の選択を分離し、単一のプログラム内にて異なる選択の
共存を許す抽象化バリアを必要とします。さらに、巨大なプログラムは時折、以前から
存在する独立して設計されたモジュールを組み合わせることで作成されるため、
プログラマにモジュールを\newterm{additively}(\jnewterm{付加的})に組み合わせて巨大なシステムに
することを許可するための約束事が必要です。それはつまりこれらのモジュールを再設計、
または再実装する必要が無いようにするためです。


この節ではプログラムの異なるパーツにより異なる方法で表現され得るデータをどのように
処理するかについて学びます。これは\newterm{generic procedures}(\jnewterm{ジェネリック手続})---
二種類以上の方法で表現され得るデータを処理可能な手続の構築が必要となります。
ジェネリック手続を構築する主なテクニックは\newterm{type tags}(\jnewterm{タイプタグ})を持つ
データオブジェクトを利用して処理することになります。それはつまりデータオブジェクト自身が
どのように処理されるべきであるかについての情報を明示的に含むことです。
また\newterm{data-directed}(\jnewterm{データ適従})プログラミングについても議論します。これは強力、かつ便利な
ジェネリック命令を用いて付加的にシステムを組み立てる実装戦略です。


簡単な複素数の例から始めます。どのようにタイプタグとデータに従うスタイルが
抽象的な``複素数''データオブジェクトの概念を維持しながら
複素数の直交形式と極形式の表現を分けて設計を行うことを可能にしているかについて学びます。
私達はこれを、複素数に対する数値演算手続(\code{add\-/complex}, \code{sub\-/complex},
\code{mul\-/complex}, \code{div\-/complex})を、複素数がどのように表現されるのかから独立して
複素数の部分にアクセスするジェネリックなセレクタを用いて定義することで達成します。
結果としての複素数システムは\link{Figure 2.19}に示されるとおり、2つの異なる種類の
抽象化バリアを含みます。``水平方向''の抽象化バリアは\link{Figure 2.1}
と同じ役割を演じます。それらは``高レベル''の命令を``低レベル''の表現から分離します。
それに加えて``垂直方向''のバリアが存在し、代替的な表現を分離して設計しインストールする
能力を与えます。

\begin{figure}[tb]
\phantomsection\label{Figure 2.19}
\centering
\begin{comment}
\begin{quote}
\heading{Figure 2.19:} Data-abstraction barriers in the complex-number system.

\begin{example}
           Programs that use complex numbers
  +-------------------------------------------------+
--| add-complex sub-complex mul-complex div-complex |--
  +-------------------------------------------------+
              Complex arithmetic package
---------------------------+---------------------------
          Rectangular      |         Polar
        representation     |     representation
---------------------------+---------------------------
    List structure and primitive machine arithmetic
\end{example}
\end{quote}
\end{comment}
\includegraphics[width=108mm]{fig/chap2/Fig2.19a.pdf}
\begin{quote}
\heading{Figure 2.19:} 複素数システムのデータ抽象化バリア
\end{quote}
\end{figure}

\noindent
\link{Section 2.5}にてどのようにタイプタグとデータ適従スタイルを用いてジェネリックな数値演算パッケージを
開発するかについて示します。これは全ての種類の``数値''を操作するのに用いることができる手続(\code{add},
\code{mul}, その他)を提供します。\link{Section 2.5.3}ではどのようにして記号代数を実行するジェネリックな
数値演算をシステム内にて用いるかについて示します。


\subsection{複素数のための表現}
\label{Section 2.4.1}
\label{Sec. 2.4.1}



ジェネリックな命令を用いる単純な代わりに非現実的なプログラムの例として複素数上で
数値演算命令を実行するシステムを開発します。順序有りペアとしての複素数に対する
2つのもっともらしい表現について議論することから始めます。直行形式(実数部と虚数部)と
極形式(大きさと角度)です。\footnote{実際の計算システムにおいては直行形式のほうが
極形式よりも多くの場合には好まれます。直行形式と極形式の間の変換における丸め誤差
のためです。これがなぜ複素数システムのサンプルが非現実的であるかの理由です。
それにもかかわらず、この例はジェネリック命令を用いたシステムの設計の明確な説明を
提供し、またこの章の中で後に開発されるより実質的なシステムに対する良い導入部で
あります。}
\link{Section 2.4.2}がどのようにして両方の表現がタイプタグとジェネリック命令の使用を通して
単一のシステム内にて共存できるように作成され得るのかについてを示します。


分数と同様に、複素数は自然に順序有りペアとして表現されます。複素数の集合は
2つの直行する軸を持つ二次元空間として考えることができます。この視点から複素数
\( z = x + iy \) (ここで \( i^2 = -1 \))はその平面中の実数座標が\( x \)かつ、
虚数座標が\( y \)の点として考えることが可能です。
複素数の和はこの表現において座標の和と還元できます。
\begin{comment}

\begin{example}
Real-part(z_1 + z_2) = Real-part(z_1) + Real-part(z_2)

Imaginary-part(z_1 + z_2) = Imaginary-part(z_1) + Imaginary-part(z_2)
\end{example}

\end{comment}
\begin{displaymath}
%  \eqalign{
% \hbox{Real-part} (z_1 + z_2)\; 		&= 
% 	\hbox{ Real-part} (z_1)\; + \hbox{ Real-part} (z_2), \cr
% \hbox{Imaginary-part} (z_1 + z_2)\; 	&= 
% 	\hbox{ Imaginary-part} (z_1)\; + \hbox{ Imaginary-part} (z_2). \cr 
% } 
\begin{array}{r@{{}={}}l}
  \hbox{Real-part} (z_1 + z_2)\; 	& 
	\hbox{ Real-part} (z_1)\; + \hbox{ Real-part} (z_2), \\
  \hbox{Imaginary-part} (z_1 + z_2)\; 	& 
	\hbox{ Imaginary-part} (z_1)\; + \hbox{ Imaginary-part} (z_2). 
\end{array}
\end{displaymath}

\begin{figure}[tb]
\phantomsection\label{Figure 2.20}
\centering
\begin{comment}
\heading{Figure 2.20:} Complex numbers as points in the plane.

\begin{example}
 Imaginary
    ^
    |
  y |.........................* z = x + ?y = r e^(?A)
    |                    __-- .
    |                __--     .
    |          r __--         .
    |        __--             .
    |    __-- \               .
    |__--    A |              .
----+----------+-------------------> Real
                              x
\end{example}
\end{comment}
\includegraphics[width=79mm]{fig/chap2/Fig2.20.pdf}
\par\bigskip
\noindent
\heading{Figure 2.20:} 平面上の点としての複素数
\end{figure}

\noindent
複素数をかけ算する場合、複素数を大きさと角度(\link{Figure 2.20}内の\( r \)と\( A \))
としての極形式の表現を用いて考える方がより自然です。2つの複素数の積は一方の複素数を
もう一方の長さで延し次にもう一方の角度の分、回転することで得られるベクトルになります。
\begin{comment}

\begin{example}
Magnitude(z_1 * z_2) = Magnitude(z_1) * Magnitude(z_2)

Angle(z_1 * z_2) = Angle(z_1) + Angle(z_2)
\end{example}

\end{comment}
\begin{displaymath}
%  \eqalign{
% 	\hbox{Magnitude} (z_1 \cdot z_2)\; 	&= 
% 		\hbox{ Magnitude} (z_1)\; \cdot \hbox{ Magnitude} (z_2), \cr
% 	\hbox{Angle} (z_1 \cdot z_2)\; 		&= 
% 		\hbox{ Angle} (z_1)\; + \hbox{ Angle} (z_2). \cr
% } 
\begin{array}{r@{{}={}}l}
	\hbox{Magnitude} (z_1 \cdot z_2)\; 	& 
		\hbox{ Magnitude} (z_1)\; \cdot \hbox{ Magnitude} (z_2), \\
	\hbox{Angle} (z_1 \cdot z_2)\; 		& 
		\hbox{ Angle} (z_1)\; + \hbox{ Angle} (z_2). 
\end{array}
\end{displaymath}
\begin{displaymath}
\begin{array}{r@{{}={}}l}
	\hbox{大きさ} (z_1 \cdot z_2)\; 	&
		\hbox{ 大きさ} (z_1)\; \cdot \hbox{ 大きさ} (z_2), \\
	\hbox{角度} (z_1 \cdot z_2)\; 		&
		\hbox{ 角度} (z_1)\; + \hbox{ 角度} (z_2).
\end{array}
\end{displaymath}

\noindent
従って複素数には2つの異なる表現が存在し、それぞれは異なる操作に適しています。
けれども、複素数を用いるプログラムを書いている誰かさんの視点からは、データ抽象化の
主義が複素数を操作するための全ての命令はどの表現がコンピュータにより用いられるかに
係らず存在するべきだと提案します。例えば直行形式にて指定される複素数の大きさを
求められることはしばしば便利であります。同様に極形式にて指定される複素数の実数部を
決定できることも時折便利であります。


そのようなシステムを設計するために、\link{Section 2.1.1}にて分数パッケージの設計において従った
のと同じデータ抽象化戦略に従えます。複素数上の命令が4つのセレクタを使用して実装される
と想定します。\code{real\-/part}, \code{imag\-/part}, \code{magnitude}, \code{angle}です。
また複素数を構築する2つの手続を持っているとも想定します。\code{make\-/from\-/real\-/imag}は指定
された実数部と虚数部を持つ複素数を返し、\code{make\-/from\-/mag\-/ang}は指定された大きさと角度
を持つ複素数を返します。これらの手続は任意の複素数に対し同じ特性を持ちます。

\begin{scheme}
(make-from-real-imag (real-part z) (imag-part z))
\end{scheme}

\noindent
と

\begin{scheme}
(make-from-mag-ang (magnitude z) (angle z))
\end{scheme}

\noindent
の両方が\code{z}に等しい複素数を生成します。



これらのコンストラクタとセレクタを用いて、\link{Section 2.1.1}で分数に対して行ったのと全く
同様に、コンストラクタとセレクタにて指定された``抽象データ''を用いて複素数上での
数値演算を実装可能です。前述の式にて示されたように、複素数の和と差は実数部と虚数部
を用いることで、また複素数の積と商は大きさと角度を用いることで実装できます。

\begin{scheme}
(define (add-complex z1 z2)
  (make-from-real-imag (+ (real-part z1) (real-part z2))
                       (+ (imag-part z1) (imag-part z2))))
\end{scheme}

\begin{scheme}
(define (sub-complex z1 z2)
  (make-from-real-imag (- (real-part z1) (real-part z2))
                       (- (imag-part z1) (imag-part z2))))
\end{scheme}

\begin{scheme}
(define (mul-complex z1 z2)
  (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                     (+ (angle z1) (angle z2))))
\end{scheme}

\begin{scheme}
(define (div-complex z1 z2)
  (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                     (- (angle z1) (angle z2))))
\end{scheme}

\noindent
複素数パッケージを完了させるためには表現を選択し、コンストラクタとセレクタを
プリミティブな数値とリスト構造を用いて実装しなければなりません。これを行うために
2つ明らかな方法があります。``直行形式''の複素数はペア(実数部, 虚数部)として表現し、
また極形式はペア(大きさ, 角度)にて表現します。どちらを選択するべきでしょうか?


異なる選択を具体的にするために、二人のプログラマ、Ben BitdiddleとAlyssa P. Hacker
がいると想像して下さい。二人は複素数システムのための表現を独立して設計します。
Benは複素数を直行形式にて表現することを選択しました。この選択により現状として
複素数を与えられた実数部と虚数部から構築するため、実数部と虚数部を複素数から選択する
のは直接的です。大きさと角度を求めるためには、または複素数を与えられた大きさと角度から
構築するために彼は三角法の関係を用いました。

\begin{comment}

\begin{example}
                      __________
x = r cos A     r = ./ x^2 + y^2

y = r sin A     A = arctan(y,x)
\end{example}

\end{comment}
\begin{displaymath}
%  \eqalign{
% 	x = r \cos A, \qquad 	& r = \sqrt{x^2 + y^2}, \cr
% 	y = r \sin A, \qquad 	& A = \arctan(y, x), \cr
% } 
\begin{array}{r@{{}={}}lr@{{}={}}l}
	x & r \cos A, \qquad 	& r & \sqrt{x^2 + y^2}, \\
	y & r \sin A, \qquad 	& A & \arctan(y, x), 
\end{array}
\end{displaymath}
\noindent
これは実数部と虚数部\( (x, y) \)を大きさと角度\( (r, A) \)へと関係づけます。\footnote{
ここで参照されたアークタンジェント関数は、Schemeの\code{atan}手続にて計算されますが、2つの
引数\( y \)と\( x \)を取りタンジェントが\( y / x \)となる角度を返すように定義
されました。引数の符号が角度の象限を決定します。}
Benの表現は従って以下のセレクタとコンストラクタにより与えられます。

\begin{scheme}
(define (real-part z) (car z))
(define (imag-part z) (cdr z))
(define (magnitude z)
  (sqrt (+ (square (real-part z))
           (square (imag-part z)))))
(define (angle z)
  (atan (imag-part z) (real-part z)))
(define (make-from-real-imag x y) (cons x y))
(define (make-from-mag-ang r a)
  (cons (* r (cos a)) (* r (sin a))))
\end{scheme}

\noindent
一方、Alyssaは複素数を極形式にて表現することを選択しました。彼女にとっては大きさと
角度を選択するのは直接的です。しかし実数部と虚数部を得るためには三角法の関係を用い
ねばなりません。Alyssaの表現は次のとおりです。

\begin{scheme}
(define (real-part z) (* (magnitude z) (cos (angle z))))
(define (imag-part z) (* (magnitude z) (sin (angle z))))
(define (magnitude z) (car z))
(define (angle z) (cdr z))
(define (make-from-real-imag x y)
  (cons (sqrt (+ (square x) (square y)))
        (atan y x)))
(define (make-from-mag-ang r a) (cons r a))
\end{scheme}

\noindent
データ抽象化の規律は\code{add\-/complex}, \code{sub\-/complex}, \code{mul\-/complex},
\code{div\-/complex}の同じ実装がBenの表現とAlyssaの表現のどちらに対してもうまく
いくことを保証します。

\subsection{タグ付きデータ}
\label{Section 2.4.2}



データ抽象化を考え方の1つは``最小責務の原則''の適用としてです。\link{Section 2.4.1}の
複素数システムの実装において、私達はBenの直行形式表現とAlyssaの極形式表現の
どちらも使用することができました。セレクタとコンストラクタにより形成された
抽象化バリアが最後の可能な瞬間にデータオブジェクトに対する具体的な表現の
選択に従うことを可能にしています。従ってシステム設計において最高の柔軟性を
維持することができるのです。



最小責務の原則はさらにもっと高みへと到達することができます。もし私達が望めば、
セレクタとコンストラクタを設計した``後''にさえ表現の多義性を維持することが
可能です。そしてBenの表現``と''Alyssaの表現の両方の使用を選択できます。
もし両方の表現が単一のシステムに含まれる場合、極形式のデータを直行形式のデータから
識別するための何らかの方法が必要になります。そうでなけば、例えばペア(3, 4)の大きさ
を求めるよう尋ねられた場合に(数値を直行形式だと考えて)5と答えるべきか(数値が極形式
であると考えて)3と答えるべきであるのか分かりません。この識別を直接的な方法で達成する
ために\newterm{type tag}(\jnewterm{タイプタグ})---\code{rectangular}または\code{polar}のシンボル---を
各複素数の部分として導入します。すると複素数を操作せねばならない時にタグを用いてどち
らのセレクタを適用するべきか決定することができます。



タグ付きデータを操作するためにデータオブジェクトからタグと(複素数の場合には極形式、
または直行形式の)実際のコンテンツを抽出する手続\code{type\-/tag}と\code{contents}を持つと
想定します。またタグとコンテンツを取りタグ付きデータオブジェクトを生成する
手続\code{attach\-/tag}を仮定します。これを実装する直接的な方法は普通のリスト構造を用いる
ことです。

\begin{scheme}
(define (attach-tag type-tag contents)
  (cons type-tag contents))
(define (type-tag datum)
  (if (pair? datum)
      (car datum)
      (error "Bad tagged datum: TYPE-TAG" datum)))
(define (contents datum)
  (if (pair? datum)
      (cdr datum)
      (error "Bad tagged datum: CONTENTS" datum)))
\end{scheme}

\noindent
これら手続を用いて述語\code{rectangular?}と\code{polar?}を定義し、直行形式と
極形式のそれぞれを認識することができます。

\begin{scheme}

(define (rectangular? z) (eq? (type-tag z) 'rectangular))
(define (polar? z) (eq? (type-tag z) 'polar))
\end{scheme}

\noindent
タイプタグを用いてBenとAlyssaはこれで彼等のコードを変更し2つの異なる表現が同じ
システム内にて共存させることができるようになりました。Benが複素数を構築する度に
彼は直行形式であるとタグを付けます。Alyssaが複素数を構築する度に、彼女はそれを
極形式であるとタグを付けます。加えて、BenとAlyssaは手続の名前が衝突しないように
確認しなければなりません。これを行う1つの方法としてBenは彼の各表現手続に接尾辞
\code{rectangular}を追加し、Alyssaは彼女の手続に対し\code{polar}を付け加えます。
以下はBenの\link{Section 2.4.1}から改正した直行形式表現です。

\begin{scheme}
(define (real-part-rectangular z) (car z))
(define (imag-part-rectangular z) (cdr z))
(define (magnitude-rectangular z)
  (sqrt (+ (square (real-part-rectangular z))
           (square (imag-part-rectangular z)))))
(define (angle-rectangular z)
  (atan (imag-part-rectangular z)
        (real-part-rectangular z)))
(define (make-from-real-imag-rectangular x y)
  (attach-tag 'rectangular (cons x y)))
(define (make-from-mag-ang-rectangular r a)
  (attach-tag 'rectangular
              (cons (* r (cos a)) (* r (sin a)))))
\end{scheme}

\noindent
そして以下はAlyssaの改訂版極形式表現です。

\begin{scheme}
(define (real-part-polar z)
  (* (magnitude-polar z) (cos (angle-polar z))))
(define (imag-part-polar z)
  (* (magnitude-polar z) (sin (angle-polar z))))
(define (magnitude-polar z) (car z))
(define (angle-polar z) (cdr z))

(define (make-from-real-imag-polar x y)
  (attach-tag 'polar
              (cons (sqrt (+ (square x) (square y)))
                    (atan y x))))
(define (make-from-mag-ang-polar r a)
  (attach-tag 'polar (cons r a)))
\end{scheme}

\noindent
各ジェネリックなセレクタは引数のタグをチェックし、そのタイプのデータを扱うのに
適切な手続を呼び出す様に実装されます。例として、複素数の実数部を得る場合、
\code{real\-/part}はタグを確かめBenの\code{real\-/part\-/rectangular}かAlyssaの\code{real\-/part\-/polar}の
どちらを使うのかを決定します。どちらの場合でも\code{contents}を用いて生のタグの無いデータを
抽出し直交形式、または極形式の手続を必要に応じて呼び出します。

\begin{scheme}
(define (real-part z)
  (cond ((rectangular? z)
         (real-part-rectangular (contents z)))
        ((polar? z)
         (real-part-polar (contents z)))
        (else (error "Unknown type: REAL-PART" z))))

(define (imag-part z)
  (cond ((rectangular? z)
         (imag-part-rectangular (contents z)))
        ((polar? z)
         (imag-part-polar (contents z)))
        (else (error "Unknown type: IMAG-PART" z))))

(define (magnitude z)
  (cond ((rectangular? z)
         (magnitude-rectangular (contents z)))
        ((polar? z)
         (magnitude-polar (contents z)))
        (else (error "Unknown type: MAGNITUDE" z))))
(define (angle z)
  (cond ((rectangular? z)
         (angle-rectangular (contents z)))
        ((polar? z)
         (angle-polar (contents z)))
        (else (error "Unknown type: ANGLE" z))))
\end{scheme}

\noindent
複素数演算命令を実装するためには\link{Section 2.4.1}から同じ手続\code{add\-/complex}, 
\code{sub\-/complex}, \code{mul\-/complex}, \code{div\-/complex}を使うことができます。
なぜならそれらが呼び出すセレクタはジェネリックであるためどちらの表現に対して
も働くからです。例として手続\code{add\-/complex}は今でも以下のとおりです。

\begin{scheme}
(define (add-complex z1 z2)
  (make-from-real-imag (+ (real-part z1) (real-part z2))
                       (+ (imag-part z1) (imag-part z2))))
\end{scheme}

\noindent
最後に、複素数をBenの表現とAlyssaの表現のどちらを利用して構築するのか決定
しなければなりません。妥当な選択として実数部と虚数部がある場合には直行形式を
用い、大きさと角度がある場合には極形式を用いて構築します。

\begin{scheme}
(define (make-from-real-imag x y)
  (make-from-real-imag-rectangular x y))
(define (make-from-mag-ang r a)
  (make-from-mag-ang-polar r a))
\end{scheme}

\noindent
結果としての複素数システムは\link{Figure 2.21}にて表される構造を持ちます。
システムは3つの関連する独立した部分に分離されます。複素数演算命令、Alyssaの
極形式実装、そしてBenの直行形式実装です。極形式と直行形式の実装はBenとAlyssaが
別々に働きながら書かれることが可能でした。そして両者が
抽象コンストラクタ、セレクタのインターフェイスを用いながら複素数演算手続を実装する
第三者のプログラマにより基礎を成す表現として利用されることが可能です。

\begin{figure}[tb]
\phantomsection\label{Figure 2.21}
\centering
\begin{comment}
\begin{quote}
\heading{Figure 2.21:} Structure of the generic complex-arithmetic system.

\begin{example}
    +-------------------------------------------------+
----| add-complex sub-complex mul-complex div-complex |----
    +-------------------------------------------------+
                Complex arithmetic package
                 +-----------------------+
                 | real-part   imag-part |
-----------------|                       |------------------
                 | magnitude   angle     |
                 +-----------+-----------+
           Rectangular       |          Polar
          representation     |     representation
-----------------------------+------------------------------
       List structure and primitive machine arithmetic
\end{example}
\end{quote}
\end{comment}
\includegraphics[width=108mm]{fig/chap2/Fig2.21a.pdf}
\begin{quote}
\heading{Figure 2.21:} ジェネリックな複素数演算システムの構造
\end{quote}
\end{figure}

\noindent
各データオブジェクトはその型にてタグ付けられているので、セレクタはデータに対し
ジェネリックな方法で操作します。これは各セレクタがそれが適用される個々のデータの
型に従う振舞を持つように定義されているということです。分けられた表現を結び付ける
ための一般的なメカニズムについて注意して下さい。与えられた表現実装(例えばAlyssaの
極形式パッケージ)の中では複素数は型の無いペア(大きさ, 角度)です。ジェネリックな
セレクタが極形式の型(タイプ)の複素数を操作する時、タグを取り中身をAlyssaのコードに
渡します。反対にAlyssaが通常の使用のために数値を構築する時、彼女が型でタグを付ける
ことでより高いレベルの手続により適切に認識されることができます。データオブジェクトが
あるレベルから別のレベルへと渡されるに従い、このタグの取り付けと除去の規律が重要な
組織的戦略となります。\link{Section 2.5}にてこれについて学びます。


\subsection{データ適従プログラミングと付加性}
\label{Section 2.4.3}



データの型をチェックし適切な手続を呼ぶ一般的な戦略は
\newterm{dispatching on type}(\jnewterm{タイプ別処理})と呼ばれる。これはシステム設計において
モジュール方式を得るための強力な戦略です。一方で\link{Section 2.4.2}のような呼出の実装は
2つの明らかな弱点が存在します。1つはジェネリックインターフェイス手続(\code{real\-/part},
\code{imag\-/part}, \code{magnitude}, \code{angle})は全ての異なる表現について知っていなければ
なりません。例えば複素数に対する新しい表現を複素数システムに組み入れたいとしましょう。
この新しい表現を型にて識別し、次に全てのジェネリックインターフェイス手続に新しい型を
チェックする条項を追加し、その表現に対する適切なセレクタを適用する必要が出てくるでしょう。


もう1つのこのテクニックの弱点は例え個々の表現が別々に設計できたとしても、システム全体の
中でどの2つの手続も同じ名前を持たないことを保証せねばなりません。これがなぜBenとAlyssa
が\link{Section 2.4.1}の彼等の元の手続の名前を変更しなければいけないかの理由でした。



両者の弱点の根底にある問題はジェネリックインターフェイスを実装するためのテクニック
が\newterm{additive}(\jnewterm{付加的})でないことです。ジェネリックセレクタ手続を実装する人は
これらの手続を新しい表現がインストールされる度に変更せねばならず、また個々の表現を
接続する人々は名前衝突が起こらぬ様に彼等のコードを変更せねばなりません。
これらのケースのそれぞれでコードに対して加えられなければならない変更は簡単ですが、
それでも必ず行わねばならず、不自由さと障害の原因となります。これは複素数システムに
対しては現時点ではあまり大きな問題ではありません。しかしただ2つではなく数百もの異なる
表現が複素数に対して存在すると仮定してみて下さい。その上どのプログラマも全ての
インターフェイス手続や全ての表現について知らないと想定してみて下さい。問題は現実的で
あり大規模なデータベース管理システムのようなプログラムでは必ず解決される必要があります。



私達に必要なものはより一層のシステム設計のモジュール化のための手段です。
これは\newterm{data-directed programming}(\jnewterm{データ適従プログラミング})として知られる
プログラミングテクニックにより提供されます。データ適従プログラミングがどのように
働くかを理解するためには、
異なる型の集合に対して共通なジェネリックな命令の集合を扱う度に、
実際に予想される命令を1つの軸に、予想される型をもう一方の軸に持つ二次元の表に取り組み、
その観察結果から始めます。
表の項目には与えられた各引数の型に対する各命令を実装する手続です。
前の章にて開発された複素数システムでは命令の名前、データタイプ、実際の手続の間の対応は
ジェネリックなインターフェイス手続の種々の条件節の間に広がっています。
しかし同じ情報が\link{Figure 2.22}の中に示されるように1つのテーブルの中に組込まれることが
できたはずです。



データ適従プログラミングはそのようなテーブルと直接連携するためのプログラム設計の
テクニックです。以前は私達は複素数演算コードをそれぞれが明示的に型に従う呼び出し
を行う手続の集合としての2つの表現パッケージと接続するメカニズムを実装しました。
ここではインターフェイスを命令の名前と引数タイプの組み合わせをテーブルの中から調べ
適用すべき正しい手続を見つける単一の手続として実装します。そして次にその手続を
引数の中身に対して適用します。これを行なえば、システムに対して新しい
表現パッケージの追加するために既存の手続に何の変更を行う必要もありません。
必要なのは表に新しい項目を追加することです。

\begin{figure}[tb]
\phantomsection\label{Figure 2.22}
\centering
\begin{comment}
\begin{quote}
\heading{Figure 2.22:} Table of operations for the complex-number system.

\begin{example}
           |               Types
Operations | Polar           | Rectangular
===========+=================+======================
real-part  | real-part-polar | real-part-rectangular
imag-part  | imag-part-polar | imag-part-rectangular
magnitude  | magnitude-polar | magnitude-rectangular
angle      | angle-polar     | angle-rectangular
\end{example}
\end{quote}
\end{comment}
\includegraphics[width=102mm]{fig/chap2/Fig2.22.pdf}
\begin{quote}
\heading{Figure 2.22:} 複素数システムの命令表
\end{quote}
\end{figure}

\noindent
この計画を実装するために、2つの手続\code{put}と\code{get}を命令と型のテーブルを操作するために
持っていると仮定します。

\begin{itemize}

\item
\( \hbox{\tt(put}\;\langle \)\var{op}\( \kern0.1em\rangle\;\langle \)\var{type}\( \kern0.08em\rangle\;\langle \)\var{item}\( \kern0.08em\rangle\hbox{\tt)} \)は\( \langle \)\var{item}\( \kern0.08em\rangle \)をテーブルに挿入し、
\( \langle \)\var{op}\( \kern0.1em\rangle \)と\( \langle \)\var{type}\( \kern0.08em\rangle \)で索引付けられる

\item
\( \hbox{\tt(get}\;\langle \)\var{op}\( \kern0.1em\rangle\;\langle \)\var{type}\( \kern0.08em\rangle\hbox{\tt)} \)は
\( \langle \)\var{op}\( \kern0.08em\rangle \), \( \langle \)\var{type}\( \kern0.08em\rangle \)の項目をテーブルから探し
見つかった項目を返す。 もし見つからない場合には\code{get}はfalseを返す

\end{itemize}

\noindent
今のところは\code{put}と\code{get}が私達の言語に含まれていると仮定しましょう。
\link{Chapter 3} (\link{Section 3.3.3})においてこれらと他のテーブル操作の命令をどのように実装するか
について学びます。



ここからはデータ適従プログラミングが複素数システムにおいてどのように使用できるかについて
示します。直行形式表現を開発したBenは彼が元々行ったとおりにコードを実装しました。
彼は手続の集合、つまりは\newterm{package}(\jnewterm{パッケージ})を定義し、システムに
どのように直行形式の数値を取り扱うかを教えるテーブルに項目を追加する
ことで、パッケージをシステムの残りに対して接続します。
これは以下の手続を呼び出すことにより達成されます。

\begin{scheme}
(define (install-rectangular-package)
  ~\textrm{;; internal procedures}~
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a)
    (cons (* r (cos a)) (* r (sin a))))

  ~\textrm{;; interface to the rest of the system}~
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
\end{scheme}

\noindent
この中の内部手続はBenが\link{Section 2.4.1}にて分離を行った時に彼が書いたものと同じ
手続であることに注意して下さい。これらをシステムの残りに接続するためには
全く変更が必要がありません。さらに、これらの手続の定義はインストールを行う
手続の内部であるため、Benは直行形式パッケージの外部の他の手続に対して
名前の衝突が起こることを全く心配する必要がありません。
これらをシステムの残りに対し接続するために、Benは彼の\code{real\-/part}手続を
命令名\code{real\-/part}と型\code{(rectangular)}の元にインストールしました。
そして他のセレクタに対しても同様に行いました。\footnote{
私達はシンボル\code{rectangular}ではなくリスト\code{(rectangular)}を用いました。
全てが同じ型ではない複数の引数を伴なう命令の可能性を考慮するためです。}
このインターフェイスはまた外部システムにより利用されるコンストラクタも
定義します。\footnote{コンストラクタがその下にインストールされる型は
リストである必要がありません。なぜならコンストラクタは常にある特定の型の
オブジェクトを作成するために使用されるためです。}これらはBenの内部定義
コンストラクタと全く同じです。ただしタグを付加することが異なります。


Alyassaの極形式パッケージも同様です。

\begin{scheme}
(define (install-polar-package)
  ~\textrm{;; internal procedures}~
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y)
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  ~\textrm{;; interface to the rest of the system}~
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
\end{scheme}

\noindent
BenとAlyssaの両者が今でも御互いに同じ名前(例えば\code{real\-/part})にて定義された
彼等の元々の手続を使用してようとも、これらの定義は今では異なる手続の内部定義(\link{Section 1.1.8}参照)
です。従って名前の衝突は起こりません。



複素数演算のセレクタは\code{apply\-/generic}と呼ばれる普遍的な``operation''手続を
用いてテーブルにアクセスします。これはジェネリックな命令を引数に対して適用します。
\code{apply\-/generic}は命令の名前と引数の型の下に表を調べ結果としての手続が存在すれば
適用します。\footnote{


\code{apply\-/generic}は\link{Exercise 2.20}で説明したドット付き
末尾記法を用います。異なるジェネリック命令は異なる数の引数を取る場合が考えられる
ためです。\code{apply\-/generic}では\code{op}がその値として\code{apply\-/generic}の第一引数を
持ち、\code{args}はその値として残りの引数のリストを持ちます。



\code{apply\-/generic}はまたプリミティブな手続\code{apply}を用います。これは2つの引数、
手続とリストを取ります。\code{apply}はリストの要素を引数として手続を適用します。
例えば、

\begin{smallscheme}
(apply + (list 1 2 3 4))
\end{smallscheme}

\noindent
は10を返します。}

\begin{scheme}
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (error
            "No method for these types: APPLY-GENERIC"
            (list op type-tags))))))
\end{scheme}

\noindent
\code{apply\-/generic}を用いることで、私達のジェネリックなセレクタを以下のように定義する
ことができます。

\begin{scheme}
(define (real-part z) (apply-generic 'real-part z))
(define (imag-part z) (apply-generic 'imag-part z))
(define (magnitude z) (apply-generic 'magnitude z))
(define (angle z) (apply-generic 'angle z))
\end{scheme}

\noindent
もし新しい表現がシステムに追加されたとしてもこれらが全く変更されないことに注意して
下さい。


またテーブルからコンストラクタを抽出することもできます。コンストラクタはパッケージの
外部プログラムにより使用でき、実数部と虚数部か大きさと角度から複素数を作ります。
\link{Section 2.4.2}にあるとおり、実数部と虚数部がある場合には直交形式で構築し、大きさと
角度がある場合には極形式にて構築します。

\begin{scheme}
(define (make-from-real-imag x y)
  ((get 'make-from-real-imag 'rectangular) x y))
(define (make-from-mag-ang r a)
  ((get 'make-from-mag-ang 'polar) r a))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.73}Exercise 2.73:} 
\link{Section 2.3.2}は記号微分を行うプログラムについて説明した。

\begin{scheme}
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) 
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum (make-product
                    (multiplier exp)
                    (deriv (multiplicand exp) var))
                   (make-product 
                    (deriv (multiplier exp) var)
                    (multiplicand exp))))
        ~\( \dark \langle \)~~\var{\dark more rules can be added here}~~\( \dark \rangle \)~
        (else (error "unknown expression type: 
                      DERIV" exp))))
\end{scheme}



このプログラムを微分する式のタイプにより呼出を行っていると解釈することもできる。
このシチュエーションではデータの``タイプタグ''が代数演算子の記号(例えば\code{+})であり
実行される命令は\code{deriv}である。このプログラムを基本の微分手続を書き直すことで
データ適従プログラミングスタイルに変換することができる。

\begin{scheme}
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) 
         (if (same-variable? exp var) 1 0))
        (else ((get 'deriv (operator exp)) 
               (operands exp) var))))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
\end{scheme}

\begin{enumerate}[a]

\item
上で何が行われたのか説明せよ。なぜ手続\code{number?}と\code{variable?}をデータ適従呼出に
吸収することができないのか?

\item
和と積の微分のための手続とそれらを上記のプログラムで使用されたテーブルにインストールする
補助コードを書け。

\item
貴方の好きな追加の微分ルール、例えば指数に対する物(\link{Exercise 2.56})を選択し、
このデータ適従システムにインストールせよ。

\item
この単純な代数操作において、式の型はそれを一緒に束縛する代数演算子である。
しかし手続を逆の向きに索引付けし\code{deriv}の呼出行を以下のようにした場合、

\begin{scheme}
((get (operator exp) 'deriv) (operands exp) var)
\end{scheme}

\noindent
微分システムへの対応する変更は何が必要か?

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.74}Exercise 2.74:} 
Insatiable Enterprises, Inc.(強欲エンタープライズ社)は高いレベルで非集中化された
数多くの独立事業所を世界中に抱える複合企業である。社のコンピュータ施設は接続された
ばかりであるが、賢いネットワーク接続計画を用いてネットワーク全体がどのユーザに対し
ても1台のコンピュータとして現れる。強欲社の社長は初めてネットワークの機能を用い
て事業所ファイルから管理者情報を取得しようと試みたが、全ての事業所ファイルは
Schemeのデータ構造として実装されているのにも係らず、使用されている個々のデータ構造は
事業所の間で異なっていることに狼狽した。事業所長の会議が大急ぎで開催され既存の事業所の
自立性を保ちつつ本社の要求を満足できるファイル統合の戦略を探すことになった。



そのような戦略がデータ適従戦略を用いてどのように実装できるか示せ。例として各事業所
の職員記録は単一のファイルから成る従業員の名前をキーにしたレコードの集合であると
想定せよ。集合の構造は事業所毎に変わる。さらに各従業員のレコードはそれ自身が集合
(事業所毎で異なる構造)であり\code{address}と\code{salary}のような識別子の下で鍵付けられた
情報を含んでいる。具体的には

\begin{enumerate}[a]

\item
本社のために指定された従業員のレコードを指定された職員記録ファイルから取得する
\code{get\-/record}手続を実装せよ。手続は任意の事業所のファイルに適用できなければならない。
個々の事業所のファイルがどのように構造化されねばならないか説明せよ。
具体的にはどんな型の情報が提供されねばならないか

\item
本社のために任意の事業所の職員記録ファイルから与えられた職員記録から給与情報を返す
\code{get\-/salary}手続を実装せよ。
記録はこの操作が動くようどのように構造化されねばならないか?

\item
本社のために\code{find\-/employee\-/record} 手続を実装せよ。これは全ての事業所のファイルに対し
与えられた従業員のレコードを探し、レコードを返さねばならない。この手続が引数として
従業員の名前と全ての事業所のファイルのリストを与えられると仮定せよ。

\item
強欲社が新しい会社を吸収した時、どんな変更が新しい職員情報を中央システムに受け入れるため
に必要であるか?

\end{enumerate}
\end{quote}

\subsubsection*{メッセージパッシング}



データ適従プログラミングの鍵となる考えはプログラム中のジェネリックな命令を
\link{Figure 2.22}の様な命令と型のテーブルを明示的に処理することで扱うことです。
\link{Section 2.4.2}で用いたプログラミングスタイル要求された型に基く呼出を各命令がそれ自身の
呼出の世話を行うことで組織化しました。実際にこれは命令と型のテーブルを、
テーブルの行を表す各ジェネリックな操作手続を用いて行に分解します。



代替的な実装戦略はテーブルを列に分解し、データ型に基き呼び出しを行う``知的な命令''を
用いる代わりに、命令名に基づき呼び出しを行う``知的なデータオブジェクト''を用いて動かす
ものです。直行形式の複素数の様なデータオブジェクトが入力として必要な命令名を取り指定され
た命令を実行するように準備を行うことで行うことができます。そのような規律の下では
\code{make\-/from\-/real\-/imag}は以下のように書くことができます。

\begin{scheme}
(define (make-from-real-imag x y)
  (define (dispatch op)
    (cond ((eq? op 'real-part) x)
          ((eq? op 'imag-part) y)
          ((eq? op 'magnitude)
           (sqrt (+ (square x) (square y))))
          ((eq? op 'angle) (atan y x))
          (else (error "Unknown op: 
                        MAKE-FROM-REAL-IMAG" op))))
  dispatch)
\end{scheme}

\noindent
対応する\code{apply\-/generic}手続はジェネリックな命令を引数に適用しますが、ここでは
単純に命令の名前をデータオブジェクトに与えオブジェクトに仕事を行わせます。\footnote{
この構造の1つの制約は一引数のジェネリック手続のみを許容することです。}

\begin{scheme}
(define (apply-generic op arg) (arg op))
\end{scheme}

\noindent
\code{make\-/from\-/real\-/imag}により返される値は手続---内部手続\code{dispatch}のである
ことに注意して下さい。これが\code{apply\-/generic}が命令に実行を要求した時に起動
される手続です。



このプログラミングスタイルは\newterm{message passing}(\jnewterm{メッセージパッシング})と
呼ばれます。その名前はデータオブジェクトが要求された命令の名前を``メッセージ''として
受け取った要素であるというイメージから来ています。私達は既にメッセージパッシングの例を
\link{Section 2.1.3}にて見ています。その時は\code{cons}, \code{car}, \code{cdr}がデータオブジェクト無し、
手続のみでどのように定義され得るかを学びました。ここではメッセージパッシングは数学上の
トリックではなくジェネリック命令を用いてシステムを構造化するのに便利なテクニックである
ことを学びます。この章の残りではメッセージパッシングではなくデータ適従プログラミングの
使用を続け、全般的な数値演算操作について議論します。そしてそれがシミュレーションプログラム
の構造化に対して強力なツールに成り得ることを学びます。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.75}Exercise 2.75:} 
コンストラクタ\code{make\-/from\-/mag\-/ang}をメッセージパッシングスタイルにて実装せよ。
この手続は上で与えられた\code{make\-/from\-/real\-/imag}と同様でなければならない。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.76}Exercise 2.76:} 
ジェネリックな命令を用いた巨大システムが発展するにつれ、新しい型のデータオブジェクトや
命令が必要となるかもしれない。3つの戦略---ジェネリック命令の明示的呼出、データ適従スタイル、
メッセージパッシング---のそれぞれに対して新しい型や命令を追加するために必要な
システムに対する変更について説明せよ。
どの構造化が新しい型が良く追加されるシステムに対して最も適切であるか?
どれが新しい命令が良く追加されねばならぬシステムに対して最も適切であるか?
\end{quote}

\section{ジェネリック命令を持つシステム}
\label{Section 2.5}



前の節ではデータオブジェクトが2つ以上の方法で表現されるシステムをどのように設計するか
について学んだ。鍵となる考えはデータ操作を指定するコードをいくつかの表現に対し
ジェネリックなインターフェイス手続を用いてリンクすることでした。ここではこれと同じ
考えを異なる表現上のジェネリックな命令の定義のみでなく、異なる種類の引数上の
ジェネリックな命令を定義するためにどのように用いるかについて学びます。私達は既に
いくつかの数値演算命令の異なるパッケージを見てきました。言語内に構築された
プリミティブ数値演算(\code{+}, \code{-}, \code{*}, \code{/})、\link{Section 2.1.1}の分数演算
(\code{add\-/rat}, \code{sub\-/rat}, \code{mul\-/rat}, \code{div\-/rat})、\link{Section 2.4.3}で実装した
複素数演算です。ここではデータ適従のテクニックを用いて私達がこれまでに構築した
全ての数値演算パッケージを内蔵する数値演算のパッケージを構築します。


\begin{figure}[tb]
\phantomsection\label{Figure 2.23}
\centering
\begin{comment}
\label{Figure 2.23}
\heading{Figure 2.23:} Generic arithmetic system.

\begin{example}
                        Programs that use numbers
                           +-----------------+
---------------------------| add sub mul div |-------------------
                           +-----------------+
                        Generic arithmetic package
 +-----------------+   +-------------------------+
 | add-rat sub-rat |   | add-complex sub-complex |   +---------+
-|                 |-+-|                         |-+-| + - * / |-
 | mul-rat div-rat | | | mul-complex div-complex | | +---------+
 +-----------------+ | +-------------------------+ |
      Rational       |     Complex artithmetic     |   Ordinary
     arithmetic      +--------------+--------------+  arithmetic
                     | Rectangular  |     Polar    |
---------------------+--------------+--------------+-------------
             List structure and primitive machine arithmetic
\end{example}
\end{comment}
\includegraphics[width=111mm]{fig/chap2/Fig2.23a.pdf}
\par\bigskip
\noindent
\heading{Figure 2.23:} ジェネリックな数値演算システム
\end{figure}

\noindent
\link{Figure 2.23}は私達が構築するシステムの構造を示しています。
抽象化バリアに注目して下さい。``数値''を扱う第三者の視点からはそこにあるのは
どの種類の数値が提供されても単一の手続\code{add}です。\code{add}はジェネリックインターフェイスの
部分で別々の実数演算、分数演算、複素数演算のパッケージに、数値を使用するプログラムから統一的な
アクセスを可能にします。(複素数の様な)任意の個別数値演算パッケージはそれ自身が
(直行形式と極形式の様な)異なる表現のために設計されたパッケージを結合する
(\code{add\-/complex}の様な)ジェネリックな手続を通してアクセスできます。
さらに、システムの構造は付加的なため個々の数値演算パッケージは別々に設計することが可能で、
それらを結合してジェネリックな数値演算システムを生成できます。



\subsection{ジェネリックな数値演算命令}
\label{Section 2.5.1}


ジェネリックな数値演算命令の設計タスクはジェネリックな複素数命令を設計するのと同様です。
例えば、実数上での通常の加算のプリミティブ\code{+}、分数上の\code{add\-/rat}や複素数上の
\code{add\-/complex}のように振る舞うジェネリックな加算手続\code{add}を持ちたいとします。
\code{add}と他のジェネリックな数値演算命令を\link{Section 2.4.3}にて複素数に対するジェネリックな
セレクタを実装するのに用いたのと同じ戦略に従うことで実装することが可能です。
全ての種類の数値にタイプタグをアタッチすることでジェネリック手続にその引数のデータタイプ
に従って適切なパッケージを呼び出す理由とします。

ジェネリックな数値演算は以下のように定義されます。

\begin{scheme}
(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
\end{scheme}

\noindent
\newterm{ordinary}(通常の)数値を扱うためのパッケージをインストールすることで始めます。
これは私達の言語のプリミティブな数値のことです。これらにシンボル\code{scheme\-/number}で
タグを付けます。このパッケージ内の数値演算命令はプリミティブな数値演算手続です。
(そのためタグの無い数値を扱うために拡張手続を定義する必要はありません)。
これらの命令はそれぞれが2つの引数を取るためリスト\code{(scheme\-/number scheme\-/number)}を
鍵にしてテーブルにインストールされます。

\begin{scheme}
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))
  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'make 'scheme-number (lambda (x) (tag x)))
  'done)
\end{scheme}

\noindent
scheme-numberパッケージのユーザは(タグ付きの)普通の数値を手続を用いて作成します。

\begin{scheme}
(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))
\end{scheme}

\noindent
さてこのジェネリック数値演算システムのフレームワークが準備できたので新しい種類の
数値も容易に含めることができます。ここに分数演算を実行するパッケージがあります。
付加的あることの利点として\link{Section 2.1.1}の分数コードをパッケージ内の内部手続として変更無しに
利用できることに注目して下さい。

\begin{scheme}
(define (install-rational-package)
  ~\textrm{;; internal procedures}~
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  ~\textrm{;; interface to rest of the system}~
  (define (tag x) (attach-tag 'rational x))
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  'done)
(define (make-rational n d)
  ((get 'make 'rational) n d))
\end{scheme}

\noindent
複素数を扱うために同様のパッケージをタグ\code{complex}を用いてインストールできます。
パッケージを作る際に、直行形式と極形式のパッケージにて定義された\code{make\-/from\-/real\-/imag}と
\code{make\-/from\-/mag\-/ang}の命令をテーブルから抽出します。付加性が内部命令として同じ
\link{Section 2.4.1}の手続\code{add\-/complex}, \code{sub\-/complex}, \code{mul\-/complex}, \code{div\-/complex}を
使用することを可能にします。

\begin{scheme}
(define (install-complex-package)
  ~\textrm{;; imported procedures from rectangular and polar packages}~
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))
  ~\textrm{;; internal procedures}~
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2))
                         (+ (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))
  ~\textrm{;; interface to rest of the system}~
  (define (tag z) (attach-tag 'complex z))
  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
\end{scheme}

\noindent
複素数パッケージの外側のプログラムは複素数を実数部と虚数部からでも大きさと角度からでも
構築することができます。元は直行形式と極形式のパッケージ内にて定義された内在する手続が
どのように複素数パッケージにエクスポートされているか、そしてそこからどのようにして
外部の世界へとエクスポートされているかについて注意して下さい。

\begin{scheme}
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))
\end{scheme}

\noindent
ここで私達が行ったのは2つのレベルのタグシステムです。典型的な複素数、直交形式で
\( 3 + 4i \)のような物は\link{Figure 2.24}で示されるように表現されます。
外型のタグ(\code{complex})は数値を複素数パッケージへと導きます。複素数パッケージに入れば、
次のタグ(\code{rectangular})が数値を直行形式パッケージへと導きます。
巨大で複雑なシステムでは多くのレベルが存在するかもしれず、それぞれはジェネリックな命令を
用いて次へと接続されます。データオブジェクトが``下方''へ渡されるにつれ、適切なパッケージへ
導く外側のタグは(\code{contents}を適用することで)取り去られ、次のレベルのタグ(もし存在すれば)が
さらなる呼出のために使用されるため見えるようになります。

\begin{figure}[tb]
\phantomsection\label{Figure 2.24}
\centering
\begin{comment}
\heading{Figure 2.24:} Representation of \( 3 + 4i \) in rectangular form.

\begin{example}
     +---+---+     +---+---+     +---+---+
---->| * | *-+---->| * | *-+---->| * | * |
     +-|-+---+     +-|-+---+     +-|-+-|-+
       |             |             |   |
       V             V             V   V
 +---------+   +-------------+  +---+ +---+
 | complex |   | rectangular |  | 3 | | 4 |
 +---------+   +-------------+  +---+ +---+
\end{example}
\end{comment}
\includegraphics[width=64mm]{fig/chap2/Fig2.24c.pdf}
\begin{quote}
\heading{Figure 2.24:} 直行形式による\( 3 + 4i \)の表現
\end{quote}
\end{figure}

\noindent
上記のパッケージでは、\code{add\-/rat}, \code{add\-/complex}, それに他の数値演算手続を
全く元々書かれた状態で利用しました。しかし、これらの定義が異なるインストール手続の内部と
なれば直ぐに、お互いから識別可能である名前にする必要は無くなります。単純に両者のパッケージにて
\code{add}, \code{sub}, \code{mul}, \code{div}と名付けることが可能になります。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.77}Exercise 2.77:} 
Louis Reasonerは\code{z}が\link{Figure 2.24}で示されるオブジェクトである場合に式
\code{(magnitude z)}を評価しようとした。驚いたことに、答の5の代わりに彼が受け取ったのは
\code{apply\-/generic}からのエラーメッセージで、型\code{(complex)}上に\code{magnitude}命令の
手段が存在しないと言う。彼はこの応答をAlyssa P. Hackerに見せた所、彼女は``問題は複素数セレクタが
\code{complex}の数値に対して定義されていない、\code{polar}と\code{rectangular}の数値に対してのみ
行われている。これを動かすためにしなければならないことは以下を\code{complex}パッケージに追加する
ことだ。''と述べた。

\begin{scheme}
(put 'real-part '(complex) real-part)
(put 'imag-part '(complex) imag-part)
(put 'magnitude '(complex) magnitude)
(put 'angle '(complex) angle)
\end{scheme}


これでなぜ動くのか詳細を説明せよ。例として式\code{(magnitude z)}を\code{z}が\link{Figure 2.24}にて
示されるデータオブジェクトの場合に評価する時、呼び出される全ての手続をトレースせよ
具体的には、\code{apply\-/generic}は何回起動されるか? どの手続が各ケースに対して呼び出されるか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.78}Exercise 2.78:} 
\code{scheme\-/number}パッケージの内部手続は本質的にプリミティブな手続\code{+}, \code{-}, その他の
呼出し以上の物ではない。言語のプリミティブを直接使用することはできない。
私達のタイプタグシステムが各データオブジェクトに対し型付けられていることを要件とするため
である。しかし実際には全てのLisp実装は型システムを持っており、内部にて使用している。
\code{symbol?}や\code{number?}のようなプリミティブな述語はデータオブジェクトが特定の型を持つか
決定する。\link{Section 2.4.2}の\code{type\-/tag}, \code{contents}, and \code{attach\-/tag}の定義を変更し
私達のジェネリックシステムがSchemeの内部型システムの利点を得るようにせよ。
これは言い替えれば、
システムは以前と同じように動作する必要があるが、ただし普通の数値はその\code{car}がシンボル
\code{scheme\-/number}であるペアでなく、単純にSchemeの数値として表現されるようにせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.79}Exercise 2.79:} 
2つの数値の等値関係をテストするジェネリックな等値の述語\code{equ?}を定義し、
ジェネリック数値演算パッケージにインストールせよ。この命令は通常の数値、分数、
複素数に対しても働くこと。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.80}Exercise 2.80:} 
引数が0であるかテストするジェネリックな述語\code{=zero?}を定義しジェネリック数値
演算パッケージにインストールせよ。この命令は通常の数値、分数、
複素数に対しても働くこと。
\end{quote}

\subsection{異なる型のデータを組み合わす}
\label{Section 2.5.2}



通常の数値、複素数、分数、そして開発するだろう任意の他の型の数値を包括する
統一数値演算システムをどのように定義するかについて学びました。しかし私達は
重要な問題を無視してきました。今まで私達が定義した命令は異なるデータの型を
完全に独立しているとして扱ってきました。従って追加すべき分かれたパッケージが、
例えば2つの普通の数値や2つの複素数が存在します。私達がまだ考慮していないことは
型の境界を渡る命令を定義することには意義があるという事実です。例えば複素数と実数の
加算です。私達はこれまでプログラムの間にバリアを築くために大きな努力をしてきました。
それが分離して開発、理解されることを可能にするためでした。私達は型を渡る命令を
ある程度注意深くコントロールされた手段にて導入したいと思います。そうすることで
私達のモジュール境界を重大な侵害が起こらないようにそれらをサポートすることがで
きるようにです。


クロスタイプ(型を渡る)命令を扱う1つの方法は命令が有効な型の可能な組み合わせそれぞれに
対して異なる手続を設計することです。例えば複素数パッケージを拡張し、それが複素数と実数
の加算を提供し、タグ\code{(complex scheme\-/number)}を用いてテーブルにインストールするように
します。\footnote{私達はまたほとんど同一の手続を型\code{(scheme\-/number complex)}を扱うために
提供しなければなりません。}

\begin{scheme}
~\textrm{;; to be included in the complex package}~
(define (add-complex-to-schemenum z x)
  (make-from-real-imag (+ (real-part z) x) (imag-part z)))
(put 'add '(complex scheme-number)
     (lambda (z x) (tag (add-complex-to-schemenum z x))))
\end{scheme}

\noindent
このテクニックはうまく行きますが、面倒です。このようなシステムでは新しい型を導入する
コストはその型のための手続のパッケージを構築するだけでなく、クロスタイプの命令を
実装する手続の構築とインストールに及びます。これは簡単にその型自身の命令を定義するため
に必要なものよりより多くのコードとなるでしょう。この手法はまた分かれたパッケージを付加的に接続する
能力を弱めたり、最低でも個々のパッケージの実装者が他のパッケージの考慮をしなければなら
ない範囲を制約する能力をダメにしてしまいます。
例えば、上の例では複素数と実数上の混合命令の扱いが複素数パッケージの責任となるのは
妥当に見えます。しかし分数と複素数の接続においては複素数パッケージで行われるかもしれないし、
分数パッケージかもしれないし、これらの2つのパッケージから抽出した命令を用いる
何らかの第三者パッケージかもしれません。パッケージ間の区分上における整合性のポリシー
の形式化が、多くのパッケージと多くのクロスタイプ命令を伴なうシステム設計において
計り知れなくなってしまいます。

\subsubsection*{型の強制}



完全に依存しない型達上にて振る舞う完全に依存しない命令群が一般的な状況においては
明示的にクロスタイプ命令を実装することは、面倒かもしれませんが、人が望む最高の
物かもしれません。幸運なことに私達は通常、私達の型システム内の潜在的に存在する
だろう付加的な構造の利点を用いることによりより良く行うことが可能です。
時折、異なるデータの型は完全には独立しておらず、ある型のオブジェクトが
他の型であるように見られる場合が複数存在するでしょう。
この過程は\newterm{coercion}(\jnewterm{強制})と呼ばれます。例えばもし私達が算術上、
実数と複素数を合成するよう求められた場合に、私達は実数を虚数部が0の複素数だと
見做すことができます。これはこの問題を2つの複素数の合成へと変換し、複素数パッケージ
により通常の方法にて取り扱うことが可能になります。



一般的に、ある型のオブジェクトを等価な他の型のオブジェクトに変換する強制手続を
設計することでこの考えを実装することができます。以下は典型的な強制手続です。
これは与えられた普通の数値(実数)を実数部とゼロである虚数部を持つ複素数に変換します。

\begin{scheme}
(define (scheme-number->complex n)
  (make-complex-from-real-imag (contents n) 0))
\end{scheme}

\noindent
これらの強制手続を2つの型の名前により索引付けした特別な強制テーブルにインストールします。

\begin{scheme}
(put-coercion 'scheme-number
              'complex 
              scheme-number->complex)
\end{scheme}

\noindent
(このテーブルを操作するために手続\code{put\-/coercion}と\code{get\-/coercion}が存在すると仮定します)。
一般にこのテーブルの枠のいくつかは空になります。全ての型の任意のデータオブジェクトを全ての
他の型へと強制することは一般には不可能です。例えば任意の複素数を実数に強制することはできません。
そのため普遍的な\code{complex\-/>scheme\-/number}手続はテーブルに含まれることはありません。



強制テーブルが準備されれば、\link{Section 2.4.3}の\code{apply\-/generic}手続を変更することで
統一的な作法で強制を取り扱うことができます。命令を適用するよう求められた時、
最初にその命令が引数の型に対して定義されているかどうかを以前と同様にチェックします。
もしそうであれば命令と型のテーブルで見つかった手続を呼び出します。そうでなければ
強制を試みます。単純化のために、2つの引数を伴う場合のみについて考えることにします。\footnote{
一般化については\link{Exercise 2.82}を参照して下さい。}
強制テーブルをチェックし、最初の型のオブジェクトが2つ目の型に強制できるか確認します。
もしそうであれば、最初の引数を強制し、命令の試行を再び行います。もし最初の型のオブジェクトが
一般に2つ目の型に強制できない場合、逆に2つ目の引数を1つ目の引数の型に強制できるか試します。
最後にどちらの型も他方の型に強制できない場合、諦めます。以下がこの手続です。

\begin{smallscheme}
(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (let ((t1->t2 (get-coercion type1 type2))
                      (t2->t1 (get-coercion type2 type1)))
                  (cond (t1->t2 
                         (apply-generic op (t1->t2 a1) a2))
                        (t2->t1 
                         (apply-generic op a1 (t2->t1 a2)))
                        (else (error "No method for these types"
                                     (list op type-tags))))))
              (error "No method for these types"
                     (list op type-tags)))))))
\end{smallscheme}

\noindent
この強制スキームは上で概説された様に明示的なクロスタイプ命令の定義手法上に多くの利点を持ちます。
私達は依然、型に関係する強制手続を書かねばなりませんが(\( n \)個の型のシステムに対し
場合により\( n^2 \)の手続)、全ての型の集合と各ジェネリック命令に対し異なる手続を書くのでなく、
型のペア1組につき1つの手続を書くだけで済みます。\footnote{
もし私達が賢いならば普通は\( n^2 \)よりも少ない強制手続で済みます。例えばもし型1から型2
への変換方法と型2から型3への変換方法を知っている場合、この知識を用いて型1から型3へ変換することが
できます。これはシステムに新しい型を追加する時に明示的に提供せねばならない強制手続の数を
劇的に減らします。もしシステムに必要なだけの洗練を組み入れたいのなら、システムにタイプ間の
``グラフ''を検索させて自動的に明示的に提供された物から推論可能な強制手続を生成させることが可能です。}
ここで私達が信頼しているものはタイプ間の適切な変換は型それ自身のみに依存し、適用される命令には
依存しないという事実です。



一方で、私達の強制スキームが十分に汎用ではないアプリケーションが存在するかもしれません。
たとえ合成されるオブジェクトの両方ともが他方に変換できないとしても両者を第三の型に
変換することで命令を実行することが可能になるかもしれません。そのような複雑さに対処する
ため、そしてそれでもプログラムのモジュール方式を維持するために、通常はより一層タイプ間の
関係の構造の利点を得るシステムを構築することが、次で議論するように必要です。

\subsubsection*{型の階層}



上で展開された強制スキームは型のペアの間の自然な関係の存在に当てにしていました。
より``一般的な''構造が、異なる型のお互いへの関係の仕方には良く存在します。
例えば、私達が整数、分数、実数、複素数を扱う一般的な数値演算システムを構築していると
仮定します。そのようなシステムにおいては整数を特別な種類の分数として見做すことは
とても自然です。分数は同様に特別な種類の実数であり、実数は同様に特別な種類の
複素数であります。私達が実際に手にしている物は\newterm{hierarchy of types}(\jnewterm{型の階層})
呼ばれるもので、その中では例えば整数は分数の\newterm{subtype}(\jnewterm{サブタイプ})です(すなわち
分数に適用できる任意の命令は自動的に整数に適用できます)。逆に分数は整数の
\newterm{supertype}(\jnewterm{スーパータイプ}、親の型)と呼びます。今手にした階層はとても単純な
種類で、各型はたかだか1つのスーパータイプを持ち、たかだか1つのサブタイプを持ちます。
そのような構造は\newterm{tower}(\jnewterm{タワー}、塔)と呼ばれ\link{Figure 2.25}で示されます。

\begin{figure}[tb]
\phantomsection\label{Figure 2.25}
\centering
\begin{comment}
\heading{Figure 2.25:} A tower of types.

\begin{example}
 complex
   ^
   |
  real
   ^
   |
rational
   ^
   |
integer
\end{example}
\end{comment}
\includegraphics[width=11mm]{fig/chap2/Fig2.25.pdf}
\par\bigskip
\noindent
\heading{Figure 2.25:} 型の塔
\end{figure}

\noindent
もしタワー構造を持つ場合、階層に新しい型を追加する問題を著しく単純化できます。
新しい型がどのようにその上のスーパータイプの隣に組込まれるか、そしてどのように
その型がその下の型に対してスーパータイプであるかを指定するだけです。
例えばもし複素数に対して整数を追加したい場合、明示的に特別な強制手続
\code{integer\-/>complex}を定義する必要はありません。その代わりに整数がどのように分数に
変換できるか、分数がどのように実数に変換できるか、実数がどのように複素数に変換でき
るかを定義します。そうしたらシステムに整数を複素数に変換することをこれらのステップ
を通して変換することを許可し、次に2つの複素数を加算します。


\code{apply\-/generic}手続を以下のように再設計することもできます。各型に対して
\code{raise}手続を与える必要があります。これはある型のオブジェクトをタワーにおいて
1レベル上げます。そうすればシステムが異なる型のオブジェクト上にて操作する必要がある時、
全てのオブジェクトがタワー内にて同じレベルになるまで連続して上げることができます
(\link{Exercise 2.83}と\link{Exercise 2.84}がそのような戦略の実装の詳細について
考察しています)。



タワーの別の利点には全ての型がスーパータイプ上に定義された全ての命令を``継承''する
概念を簡単に実装できることが上げられます。例えばもし整数の実数部を求めるための
特別な手続を提供しない場合、それにもかかわらず
整数は複素数のサブタイプであるという事実のおかげで、整数のための\code{real\-/part}が
定義されることが期待できます。タワーでは\code{apply\-/generic}を変更するという統一的な
方法でこの様なことが起こるよう準備することが可能です。
もし必要な命令が与えられたオブジェクトの型のために直接定義されていない場合、
オブジェクトをそのスーパータイプに上げることで再試行できます。従ってタワーを
這い上がりながら望まれた命令が実行可能になるまで引数を変換するか、頂上まで辿り
ついてそこで諦めることができます。



別のより一般的な階層に比べた場合、もう1つタワーの利点はデータオブジェクトをより簡単な
表現へ``下げる''簡単な方法を提供することです。例えば\( 2 + 3i \)を\( 4 - 3i \)に
足した場合、その答は複素数\( 6 + 0i \)よりも整数6で得るほうがより良いと言えるでしょう。
\link{Exercise 2.85}はそのようなレベルを下げる命令の実装について議論します。
(この仕掛けには\( 6 + 0i \)のような階層のレベルを下げられるオブジェクトを
\( 6 + 2i \)のような下げられないオブジェクトから見分ける一般的な方法が必要です)。

\subsubsection*{階層の不十分さ}



もしシステムのデータの型が自然にタワーに配置できる場合、ここまで見てきた通りに、
異なる型上のジェネリック命令の取扱の問題を著しく単純化できます。
残念なことに、これは普通の場合ではありません。\link{Figure 2.26} は雑多な型のより複雑な
配置を図示しています。この図は幾何学的図形の異なる型の間の関係を見せています。
一般的に1つの型が複数のサブタイプを持つことがわかります。例えば三角形と四角形は
共に多角形のサブタイプです。加えてある型は複数のスーパータイプを持つことがあり得ます。
例えば二等辺直角三角形は二等辺三角形、または直角三角形と見做すことができます。
この複数スーパータイプ問題は特に困難で、階層内において型を``上げる''単一の方法が
存在しません。オブジェクトに命令を適用するため``正しい''スーパータイプを求めることは
\code{apply\-/generic}の様な手続に不可欠な型ネットワーク全体を通しての多大な検索を巻き起す
可能性があります。一般的にある型に対して複数のサブタイプが存在するので値に対し型階層を
``下げる''強制にも同様の問題が存在します。巨大システムの設計におけるモジュール化方式を
それでも維持しながら多くの数の相互に関係する型の取り扱うことはとても難しく、現在の多くの
研究領域です。\footnote{
第一版でも存在したこの文は12年前と同じく今も変わりません。実用的で汎用的な異なる型の
要素間の関係の表現するフレームワーク(哲学者が``オントロジー''(存在論)と呼ぶもの)を
開発することは不可能に見えるほど難しいことです。10年前に存在した混乱と現在に存在する混乱との間の
違いは、種々の不適切な存在論上の理論が、相応して不適切なプログラミング言語に過剰に組込まれてい
ることです。例えばオブジェクト指向言語の複雑性の多くは---そして現在のオブジェクト指向言語間の
微妙で混乱させる違いは---相互に関係する型上のジェネリック命令の扱いを中心とします。
\link{Chapter 3}での私達自身による計算オブジェクトの議論はこれらの問題を完全に避けます。
オブジェクト指向言語に親しみのある読者は\link{Chapter 3}においてローカルの状態について多くの
触れるべきことが存在すると気付くでしょう。しかし私達は``クラス''や``継承''についてさえ
述べることはしません。実際に私達はこれらの問題が知識表現上の成果の利用と自動的な推論無しに
コンピュータ言語設計のみで適切に解決されることは無いと疑っています。}

\begin{figure}[tb]
\phantomsection\label{Figure 2.26}
\centering
\begin{comment}
\heading{Figure 2.26:} Relations among types of geometric figures.

\begin{example}
                     polygon
                    /       \
                   /         \
            triangle         quadrilateral
            /     \              /     \
           /       \            /       \
     isosceles   right      trapezoid   kite
     triangle    triangle       |         |
      |     \      |            |         |
      |      \     |            |         |
equilateral   isosceles   parallelogram   |
triangle      right          |       \    |
              triangle       |        \   |
                          rectangle  rhombus
                                \    /
                                 \  /
                                square
\end{example}
\end{comment}
\includegraphics[width=96mm]{fig/chap2/Fig2.26e.pdf}
\par\bigskip
\noindent
\heading{Figure 2.26:} 幾何学的図形の型の間の関係
\end{figure}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.81}Exercise 2.81:} 
Louis Reasonerは\code{apply\-/generic}が引数に対しそれらが既に同じ型であってもお互いの
型に強制を試行することに気付いた。そのため彼は強制テーブルに各型の引数をそれら自身の
型に\newterm{coerce}(\jnewterm{強制})するための手続を追加する必要があるのではないかと``reason''(推論)
した。

\begin{scheme}
(define (scheme-number->scheme-number n) n)
(define (complex->complex z) z)
(put-coercion 'scheme-number 
              'scheme-number
              scheme-number->scheme-number)
(put-coercion 'complex 'complex complex->complex)
\end{scheme}

\begin{enumerate}[a]

\item
Louisの強制手続がインストールされると\code{apply\-/generic}が命令に対する
2つの引数の型が\code{scheme\-/number}、または2つの引数の型が\code{complex}であり
それらの型に対する命令がテーブルに存在しない場合何が起こるだろうか?
例えばジェネリックな指数関数命令を定義したとしよう。

\begin{scheme}
(define (exp x y) (apply-generic 'exp x y))
\end{scheme}

\noindent
そしてScheme-numberパッケージの指数関数に対する手続を追加したとする。
ただし他の型に関しては全て行わない。

\begin{scheme}
~\textrm{;; following added to Scheme-number package}~
(put 'exp '(scheme-number scheme-number)
     (lambda (x y) (tag (expt x y)))) 
     ~\textrm{; using primitive \code{expt}}~
\end{scheme}

\noindent
2つの複素数引数により\code{exp}を呼び出した場合、何が起こるだろうか?

\item
同じ型の引数に伴なう強制に関して何かが行われるべきかについてLouisは正しいだろうか?
それとも\code{apply\-/generic}はそのままで正しく動作するだろうか?

\item
\code{apply\-/generic}を変更し2つの引数が同じ型である場合に強制を試行しないようにせよ。

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.82}Exercise 2.82:} 
\code{apply\-/generic}を複数引数の全体的な場合に強制を扱わせるような一般化を行わせるには
どのように行うかを示せ。1つの戦略として全ての引数を最初の引数の型に強制するよう
試行し、次に2つ目、以降繰り返しが上げられる。この戦略(と上で与えられた2引数版が
同様に)全体には不十分である例を示せ。(ヒント：テーブルにいくつか適切な型が混ざった
命令が存在し、それが試行されない場合について考えよ。)
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.83}Exercise 2.83:} 
\link{Figure 2.25}で示される型のタワーを取り扱うジェネリックな数値演算システムの
設計を行っているとする。整数、分数、実数、複素数に対応する。各型(複素数を除く)に
対してその型のオブジェクトをタワー内にて1レベル上げる手続を設計せよ。
(複素数を除く)各型に対し動作するジェネリックな\code{raise}命令をどのようにインストールするか
示せ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.84}Exercise 2.84:} 
\link{Exercise 2.83}の\code{raise}命令を用いて\code{apply\-/generic}手続を変更し、
複数の引数が一連の``上げる''動作を行うことによりこの節で語られた様に同じ型を持つようにせよ。
2つの型のどちらがタワー内にてより高いレベルであるかテストする手段を開発する必要がある。
これを残りのシステムと``互換性''を保ち、タワーに新しいレベルを追加する場合にも
問題が無いような手段で行え。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.85}Exercise 2.85:} 
この節では可能な限りタワー内の型レベルを下げることによりデータオブジェクトの``単純化''を
行う手段について説明した。\link{Exercise 2.83}に記述されたタワーに対しこれを達成する手続\code{drop}
を設計せよ。いくつかの一般的な方法の中から決定する鍵は、オブジェクトを下げることができるか
どうかである。例えば複素数\( 1.5 + 0i \)は\code{real}(実数)である限り下げられ、複素数\( 1 + 0i \)
は\code{integer}(整数)である限り下げることができ、複素数\( 2 + 3i \)は下げることが絶対にできない。
以下に、あるオブジェクトが下げることができるか決定する計画を示す。
オブジェクトをタワー内にて``押し下げる''ジェネリックな命令\code{project}(射影)を定義することから始める。
例えば複素数の射影は虚数部を捨てることになる。すると数値は\code{project}した結果を
元の型に\code{raise}(上げ)た時に開始した時点と同じ値になれば\code{drop}(落とす)ことができる
ことになる。可能な場合にオブジェクトを落とす手続\code{drop}を書くことで、この考えをどのように実装するか
詳細に示せ。色々な射影命令を設計し、ジェネリックな命令として\code{project}をシステム内にインストール
する必要がある。\footnote{
実数は引数に最も近い整数を返すプリミティブ\code{round}を用いて整数に射影することができる。}
また\link{Exercise 2.79}で説明した等値関係のジェネリックな述語を利用する必要もある。
最後に\code{drop}を用いて\link{Exercise 2.84}の\code{apply\-/generic}を書き直し解答を``単純化''する。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.86}Exercise 2.86:} 
実数部、虚数部、大きさ、角度が通常の数値、分数、またはシステムに追加したくなるかも
しれない数のどれかを用いることができる複素数を扱えるようにしたいとする。
これを達成するために必要なシステムに対する変更を説明し、実装せよ。
普通の数と分数に対してジェネリックな\code{sine}や\code{cosine}のような命令を定義する必要が
出てくるであろう。
\end{quote}

\subsection{例: 記号代数}
\label{Section 2.5.3}


記号代数表現の操作は巨大なスケールのシステムの設計において起こり得る最も困難な問題の
多くを説明する複雑な処理です。代数表現は一般的に階層構造であると見ることができ、
演算子の木がオペランドに適用されます。代数表現を定数と変数のようなプリミティブな
オブジェクトの集合から始めて、これらを加算や乗算のような代数演算子を用いて接続する
ことで構築することができます。他の言語と同様に、複合オブジェクトに簡単な用語で参照する
ことを可能にするための抽象化を形式化します。典型的な記号代数における抽象化は線形結合、
多項式、有理関数、三角関数のような考えです。これらを式の処理を方向付けするのによく便利である
複合``型''と見做すことができます。例えば私達は以下の式を
\begin{comment}

\begin{example}
x^2 sin (y^2 + 1) + x cos 2y + cos(y^3 - 2y^2)
\end{example}

\end{comment}
\begin{displaymath}
 x^2 \sin (y^2 + 1) + x \cos 2y + \cos(y^3 - 2y^2) 
\end{displaymath}
\noindent
係数を伴なう\( x \)の多項式と係数が整数である\( y \)の三角関数として記述することが
できます。


私達は完全な代数操作システムをここで開発しようとはしません。
そのようなシステムは非常に複雑なプログラムであり、深い代数学の知識と洗練されたアルゴリズムを
具体化する必要があります。私達が行うのは代数操作の単純だが重要な部分について考えること、
つまり多項式の演算です。そのようなシステムの設計者が直面する決定すべきことや、
この試みのまとめを手助けするために抽象データやジェネリックな命令をどのようにして適用するか
のような事柄について説明します。

\subsubsection*{多項式の計算}

多項式上の数値演算を実行するシステムの設計における最初のタスクは多項式とは何かを
決定することです。多項式は通常いくつかの変数(多項式の\newterm{indeterminates}(\jnewterm{不定元}))
に関連して定義されます。簡単にするために多項式はただ1つの不定元
(\newterm{univariate polynomials}(\jnewterm{一変数多項式}))に制約します。\footnote{
一方で係数は別の変数にてそれ自身が多項式であることを許可します。これにより本質的に
完全に多変量システムと同じ表現力を得ますが、強制においてこの先で記述される問題が発生します。}
多項式とは項の和であり、各項は係数、不定元の累乗数、または係数と不定元の累乗数の積であると
定義します。係数は多項式の不定元に依存しない代数表現であると定義します。例えば、
\begin{comment}

\begin{example}
5x^2 + 3x + 7
\end{example}

\end{comment}
\begin{displaymath}
 5x^2 + 3x + 7 
\end{displaymath}
\noindent
は簡単な\( x \)の多項式であり、
\begin{comment}

\begin{example}
(y^2 + 1)x^3 + (2y)x + 1
\end{example}

\end{comment}
\begin{displaymath}
 (y^2 + 1)x^3 + (2y)x + 1 
\end{displaymath}
\noindent
は係数が\( y \)の多項式である\( x \)の多項式です。


既にいくつかの困難な問題を回避しています。これらの多項式の最初の物は多項式
\( 5y^2 + 3y + 7 \)と同じかそれとも異なるでしょうか? 妥当な答は``多項式を純粋に
数学の関数であると考えれば答はYESです。しかしもし多項式を文法上の形式であると
考えれば答はNOです''となるでしょう。2つ目の多項式は代数学的に係数が
\( x \)の多項式である\( y \)の多項式に等価です。私達のシステムはこれを認識する
べきでしょうか? さらに他にも多項式を表現する方法は存在します---例えば因数の積として
や(1変数多項式に対しては)累乗根の集合として、また指定した点の集合における多項式の
値の列挙として。\footnote{
1変数多項式に対しては与えられた点の集合における多項式の値を与えることは特に良い表現
に成り得ます。これは多項式数値演算をとても簡単にすることができます。例として
この方法で表現された2つの多項式の和を求めるには相対する点の多項式の当たい を足すだけ
で済みます。より親しみ易い表現に戻すには\( n + 1 \)個の点における多項式の値を与えら
れた場合に\( n \)次の多項式の係数を取り戻すラグランジュ補完公式を用いることができます。}
これらの問題を私達の数値演算操作システムにおいて、根底にある数学上の意味でなく、
``多項式''が特定の文法形式であることを決定することでうまく行うことができます。



さて、多項式上で数値演算を行なうことについてどのように進めるか考えねばなりません。
この簡単なシステムでは加算と乗算についてのみしか考えません。さらに接続される2つの多項式は
同じ不定元を持たなければならないとします。



私達のシステムの設計はデータ抽象化にて馴染のある規律に従うことで取り組みます。
多項式を\newterm{poly}と呼ぶ新しいデータ構造を用いて表現します。\newterm{poly}は
変数と項の係数により構成されます。polyからそれらの部分を抽出するセレクタ\code{variable}と
\code{term\-/list}と与えられた変数と項のリストからpolyを組み上げるコンストラクタ\code{make\-/poly}
が既にあると仮定します。変数はただのシンボルであり\link{Section 2.3.2}の\code{same\-/variable?}手続を
用いて変数の比較が可能です。以下の手続はpolyの加算と乗算を定義します。

\begin{scheme}
(define (add-poly p1 p2)
  (if (same-variable? (variable p1) (variable p2))
      (make-poly (variable p1)
                 (add-terms (term-list p1)
                            (term-list p2)))
      (error "Polys not in same var: ADD-POLY"
             (list p1 p2))))

(define (mul-poly p1 p2)
  (if (same-variable? (variable p1) (variable p2))
      (make-poly (variable p1)
                 (mul-terms (term-list p1)
                            (term-list p2)))
      (error "Polys not in same var: MUL-POLY"
             (list p1 p2))))
\end{scheme}

\noindent
多項式を私達の数値演算システムに組込むためにはそれらをタイプタグと共に提供する
必要があります。タグ\code{polynomial}を用いることにし、タグ付き多項式上の適切な
命令を命令テーブルにインストールします。\link{Section 2.5.1}と同様に、多項式パッケージに
対するインストール手続に私達の全てのコードを組み込んでしまうことにします。

\begin{scheme}
(define (install-polynomial-package)
  ~\textrm{;; 内部手続}~
  ~\textrm{;; polyの表現}~
  (define (make-poly variable term-list)
    (cons variable term-list))
  (define (variable p) (car p))
  (define (term-list p) (cdr p))
  ~\( \dark \langle \)~~\emph{procedures \code{same\-/variable?} and \code{variable?} from section 2.3.2}~~\( \dark \rangle \)~

  ~\textrm{;; 項と項のリストの表現}~
  ~\( \dark \langle \)~~\emph{procedures \code{adjoin\-/term} \( \dots \) \code{coeff} from text below}~~\( \dark \rangle \)~

  (define (add-poly p1 p2) ~\( \dots \)~)
  ~\( \dark \langle \)~~\emph{\code{add\-/poly}で使用される手続}~~\( \dark \rangle \)~
  (define (mul-poly p1 p2) ~\( \dots \)~)
  ~\( \dark \langle \)~~\emph{\code{mul\-/poly}で使用される手続}~~\( \dark \rangle \)~

  ~\textrm{;; システムの残りへのインターフェイス}~
  (define (tag p) (attach-tag 'polynomial p))
  (put 'add '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial)
       (lambda (p1 p2) (tag (mul-poly p1 p2))))
  (put 'make 'polynomial
       (lambda (var terms)
         (tag (make-poly var terms))))
  'done)
\end{scheme}

\noindent
多項式の加算は項別に実行されます。同じ次数の項(つまり同じ指数の不定元)が合成され
ねばなりません。これは係数は加数の係数の合計である同じ次数の新しい項を形成すること
により行われます。ある加数の項の同じ次数の項がもう一方に無い場合には単純に構築される
和の多項式に積み上げられます。



項のリストを操作するために、空の項リストを返すコンストラクタ\code{the\-/empty\-/termlist}と
新しい項を項リストに挿入するコンストラクタ\code{adjoin\-/term}を既に持っていると仮定します。
また与えられた項リストが空であるか判断する述語\code{empty\-/termlist?}と項リストから最大次数の項を
抽出するセレクタ\code{first\-/term}、最大次数の項を除く全てを返すセレクタ\code{rest\-/terms}もまた
持っていると仮定します。項を操作するために、与えられた次数と係数から項を構築する
コンストラクタ\code{make\-/term}と項の次数と係数をそれぞれ返すセレクタ\code{order}と\code{coeff}
を既に持っていると仮定します。これらの命令は項と項のリストの両方を実際の表現については分離して考えられる
データ抽象として捉えることを許します。



以下は2つの多項式の和のために項リストを構築する手続です。\footnote{
この命令は\link{Exercise 2.62}にて開発した\code{union\-/set}命令にとても似ています。
実際にもし多項式の項を不定元の指数に従い並べた集合だと考えるなら、和のために
項リストを生成するプログラムは\code{union\-/set}とほとんど同じです。}

\begin{scheme}
(define (add-terms L1 L2)
  (cond ((empty-termlist? L1) L2)
        ((empty-termlist? L2) L1)
        (else
         (let ((t1 (first-term L1)) 
               (t2 (first-term L2)))
           (cond ((> (order t1) (order t2))
                  (adjoin-term
                   t1 (add-terms (rest-terms L1) L2)))
                 ((< (order t1) (order t2))
                  (adjoin-term
                   t2 (add-terms L1 (rest-terms L2))))
                 (else
                  (adjoin-term
                   (make-term (order t1)
                              (add (coeff t1) (coeff t2)))
                   (add-terms (rest-terms L1)
                              (rest-terms L2)))))))))
\end{scheme}

\noindent
ここで注意すべき最も重要な点はジェネリックな加算手続\code{add}を用いて合成される
2つの項の係数を一緒に足したことです。これは以下で見るように強力な帰結です。



2つの項リストを乗算するために最初のリストの各項をもう一方のリストの全ての項で乗算するのに
繰り返し\code{mul\-/term\-/by\-/all\-/terms}を使用ます。\code{mul\-/term\-/by\-/all\-/terms}は与えられた項を
全ての与えられた項リストの項で乗算します。結果の項リスト(最初のリストの各項に対して1つ)は
合計に積み上げられます。2つの項の乗算は次数が乗数の次数の和で係数が乗数の係数の積となる項
を形成します。

\begin{scheme}
(define (mul-terms L1 L2)
  (if (empty-termlist? L1)
      (the-empty-termlist)
      (add-terms (mul-term-by-all-terms (first-term L1) L2)
                 (mul-terms (rest-terms L1) L2))))
(define (mul-term-by-all-terms t1 L)
  (if (empty-termlist? L)
      (the-empty-termlist)
      (let ((t2 (first-term L)))
        (adjoin-term
         (make-term (+ (order t1) (order t2))
                    (mul (coeff t1) (coeff t2)))
         (mul-term-by-all-terms t1 (rest-terms L))))))
\end{scheme}

\noindent
これが本当に多項式の和と積のためにあるもの全てです。ジェネリック手続\code{add}と\code{mul}を
用いて項を操作するため、多項式パッケージはジェネリック数値演算パッケージにより知られている
任意の型の係数を自動的に取り扱うことが可能であることに注意して下さい。
もし\link{Section 2.5.2}で議論されたような強制メカニズムを含めていた場合、型の異なる係数の多項式上でも
命令を取り扱うことが自動的にできます。
\begin{comment}

\begin{example}
                         /        2                 \
[3x^2 + (2 + 3i)x + 7] * | x^4 + --- x^2 + (5 + 3i) |
                         \        3                 /
\end{example}

\end{comment}
\begin{displaymath}
 [3x^2 + (2 + 3i)x + 7] \cdot \! \left[ x^4 + {2\over3} x^2 + (5 + 3i) \right]\!\!. 
\end{displaymath}

多項式の加算と乗算の手続、\code{add\-/poly}と\code{mul\-/poly} をジェネリックな数値演算システムに
型\code{polynomial}のための命令\code{add}と\code{mul}としてインストールしたため、私達のシステムは
また自動的に以下のような多項式操作を取り扱うことが可能です。
\begin{comment}

\begin{example}
[(y + 1)x^2 + (y^2 + 1)x + (y - 1)] * [(y - 2)x + (y^3 + 7)]
\end{example}

\end{comment}
\begin{displaymath}
 \Big[(y + 1)x^2 + (y^2 + 1)x + (y - 1)\Big] \cdot \Big[(y - 2)x + (y^3 + 7)\Big]. 
\end{displaymath}

その理由はシステムが係数を合成しようと試す時、\code{add}と\code{mul}を通して呼出を行うためです。
係数はそれ自身(\( y \)の)多項式ですから、これらは\code{add\-/poly}と\code{mul\-/poly}を用いて合成され
ます。結果は``データ適従再帰''のような物で、例えば\code{mul\-/poly}の呼出は係数の乗算のために
\code{mul\-/poly}の再帰呼出に帰着します。もし係数の係数がそれ自身多項式(多項式を3変数で表現した場合)
の場合、データ適従はシステムがまた別のレベルの再帰呼出に従うことを保証します。そして
データの構造が指示するだけのより多くのレベルについてもまた同様です。\footnote{

これを完全に順調に行うには私達のジェネリック数値演算システムに``数値''を次数が0で係数がその数である
多項式であると見做すことで多項式に強制する能力も追加する必要があります。これは以下のような
式に対して実行を行いたい場合に必要です。
\begin{comment}

\begin{example}
[x^2 + (y + 1)x + 5] + [x^2 + 2x + 1]
\end{example}

\end{comment}
\begin{displaymath}
 [x^2 + (y + 1)x + 5] + [x^2 + 2x + 1], 
\end{displaymath}
\noindent
これは係数\( y + 1 \)を係数2に対し足す必要があります。}

\subsubsection*{項リストの表現}


ようやく項リストに対する良い表現を実装する仕事に直面せねばなりません。
項リストは実際には項の次数をキーにした係数の集合です。従って\link{Section 2.3.3}にて議論したような
任意の集合表現の手法がこのタスクに適用可能です。一方で手続\code{add\-/terms}と\code{mul\-/terms}は
常に高い次数から低い次数へと連続して項リストを常にアクセスします。従って何らかの
順序付きリスト表現を用いることにしましょう。



項リストを表現するリストをどのように構造化するべきでしょうか。1つの考慮点は
私達が操作しようとする多項式の``濃度''です。多項式は多くの次数に関して0でない
係数を持つ場合\newterm{dense}(\jnewterm{密})と呼ばれます。もし多くの0の項を持つ場合には
\newterm{sparse}(\jnewterm{疎})と呼ばれます。例えば、
\begin{comment}

\begin{example}
A : x^5 + 2x^4 + 3x^2 - 2x - 5
\end{example}

\end{comment}
\begin{displaymath}
 A: \quad x^5 + 2x^4 + 3x^2 - 2x - 5 
\end{displaymath}
\noindent
は密多項式です。
\begin{comment}

\begin{example}
B : x^100 + 2x^2 + 1
\end{example}

\end{comment}
\begin{displaymath}
 B: \quad x^{100} + 2x^2 + 1 
\end{displaymath}
\noindent
は疎です。

密多項式の項リストは係数のリストとして最も効率良く表現されます。例えば上の\( A \)は
\code{(1 2 0 3 -2 -5)}としてうまく表わされます。この表現の項の次数は
その項の係数で始まるサブリストの長さから1を引いた数です。\footnote{
これらの多項式の例では\link{Exercise 2.78}で提案された型メカニズムを用いてジェネリック
数値演算システムを実装したと前提しています。従って普通の数値の係数は数値それ自身で表現され、
\code{car}がシンボル\code{scheme\-/number}のペアではありません。}
これは\( B \)のような疎多項式には酷い表現に成り得ます。少なく孤立した非ゼロな項により
中断される巨大なゼロのリストになるでしょう。疎多項式のより適切な項リストの表現は各項が
項の次数とその次数に対する係数を含むリストである非ゼロ項のリストです。
そのような仕組みでは多項式\( B \)は効率的に\code{((100 1) (2 2) (0 1))}として表現されます。
多くの多項式操作が疎多項式上にて実行されるため、私達はこちらの手法を用います。
項リストは項のリストとして表現され高次から低次の項へと並べられます。これを決定すれば
項と項リストに対するセレクタとコンストラクタの実装は簡単です。\footnote{
項リストが順序有りだと想定していますが、\code{adjoin\-/term}を単純に新しい項を既存の項リスト上に
\code{cons}するように実装しました。\code{adjoin\-/term}を用いる(\code{add\-/terms}のような)手続が
常にリスト内の物より高次な項と共にそれを呼ぶことを保証するならばこのままにしておくことが
できます。もしそのような保証を行うことが望ましくなかったならば\code{adjoin\-/term}を集合の
順序付きリスト表現のための\code{adjoin\-/set}(\link{Exercise 2.61})と同様に実装しておくべきだったでしょう。}
\begin{scheme}
(define (adjoin-term term term-list)
  (if (=zero? (coeff term))
      term-list
      (cons term term-list)))

(define (the-empty-termlist) '())
(define (first-term term-list) (car term-list))
(define (rest-terms term-list) (cdr term-list))
(define (empty-termlist? term-list) (null? term-list))

(define (make-term order coeff) (list order coeff))
(define (order term) (car term))
(define (coeff term) (cadr term))
\end{scheme}

\noindent
\code{=zero?}は\link{Exercise 2.80}で定義されています。(下の\link{Exercise 2.87}も参照して下さい)。


多項式パッケージのユーザは(タグ付き)多項式を以下の手続で作成します。

\begin{scheme}
(define (make-polynomial var terms)
  ((get 'make 'polynomial) var terms))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.87}Exercise 2.87:} 
対抗式に対する\code{=zero?}をジェネリック数値演算パッケージにインストールせよ。
これは\code{adjoin\-/term}に係数それ自身が多項式である多項式に対して動作を可能にする。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.88}Exercise 2.88:} 
多項式システムを拡張し多項式の減算を含めよ。(ヒント：ジェネリックな単項算術否定演算子
を定義することが手助けとなるだろう。)
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.89}Exercise 2.89:} 
密多項式に対して適切だと上で説明された項リスト表現を実装する手続を定義せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.90}Exercise 2.90:} 
疎と密、両方の多項式に対して効率の良い多項式システムを得たいとする。
これを行う1つの方法は両方の種類の項リスト表現をシステム内にて許可することである。
状況は\link{Section 2.4}の複素数の例と同様で、そこでは直行形式と極形式の両表現を許可した。
これを行うため、異なる型の項リストを識別し、項リスト上の命令をジェネリックにせね
ばならない。多項式システムをこの汎化を行うために再設計せよ。これは局所的な変更ではなく
大域的な変更になる。

\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.91}Exercise 2.91:} 
1変数多項式は別の1変数多項式により割ることができ、多項式の商と多項式の剰余を
算出する。例えば、
\begin{comment}

\begin{example}
x^5 - 1
------- = x^3 + x, remainder x - 1
x^2 - 1
\end{example}

\end{comment}
\begin{displaymath}
 {x^5 - 1 \over x^2 - 1} = x^3 + x, \hbox{  remainder  } x - 1. 
\end{displaymath}

除算は長除法を通して行うことができる。これは被除数の最高次の項を除数の最高次の項
で割る。結果は商の最初の項である。次に結果に除数を掛け、被除数からその結果を引く。
そして残りの答を再帰的に差を除数で割ることにより求める。除数の次数が被除数の次数を
越えた時に停止し、その時の被除数を剰余であると宣言する。またもし被除数がゼロになった
場合には商と剰余の両者をゼロとして返す。


\code{add\-/poly}と\code{mul\-/poly}のモデルの上に\code{div\-/poly}手続を設計することが可能だ。
この手続は2つの多項式が同じ変数を持つかチェックする。そうであれば\code{div\-/poly}は
変数を取り去りその問題を\code{div\-/terms}に渡す。\code{div\-/terms}は除算命令を項リスト上にて
実行する。\code{div\-/poly}は最終的に変数を再度\code{div\-/terms}の結果に取り付ける。
除算の商と剰余の両者を求める\code{div\-/terms}を設計することは便利だ。\code{div\-/terms}は
2つの項リストを引数として取り商の項リストと剰余の項リストのリストを返す。


以下の\code{div\-/terms}の定義を欠けた式を埋めることにより完成させよ。これを用いて
\code{div\-/poly}を実装せよ。\code{div\-/poly}は2つの多項式を引数として取り商と剰余の
多項式のリストを返す。

\begin{smallscheme}
(define (div-terms L1 L2)
  (if (empty-termlist? L1)
      (list (the-empty-termlist) (the-empty-termlist))
      (let ((t1 (first-term L1))
            (t2 (first-term L2)))
        (if (> (order t2) (order t1))
            (list (the-empty-termlist) L1)
            (let ((new-c (div (coeff t1) (coeff t2)))
                  (new-o (- (order t1) (order t2))))
              (let ((rest-of-result
                     ~\( \langle \)~~\var{compute rest of result recursively}~~\( \rangle \)~
                     ))
                ~\( \langle \)~~\var{form complete result}~~\( \rangle \)~
                ))))))
\end{smallscheme}
\end{quote}

\subsubsection*{記号代数の型の階層}

私達の多項式システムはある型(polynomials)のオブジェクトがどのようにして事実上
多くの異なる型のオブジェクトをその部分として持つ複雑なオブジェクトになり得るのか
について説明しました。これはジェネリックな命令を定義する場合の実際の困難さは
何も引き起していません。複合型の部分の必要な操作を実行するために適切なジェネリック命令を
インストールすることのみが必要です。実際に
多項式がある種の``再帰的データ抽象化''を形成し、多項式のその部分においてそれ自身が
多項式である場合があることを学びました。私達のジェネリック命令とデータ適従プログラミング
スタイルはこの複雑さを大した問題無しに扱うことができます。


一方で多項式代数はデータ型が自然にタワーに配置できないシステムです。例えば
係数が\( y \)の多項式である\( x \)の多項式を持つことができます。また
係数が\( x \)の多項式である\( y \)の多項式を持つことも可能です。
これらの型のどちらももう一方の``上''には自然には成り得ません。その上
各集合から両者の要素を足す必要は良くあります。
これを行う方法はいくつか存在します。1つの可能性としてはある多項式をもう一方の多項式の
型に項の展開と再配置を行うことで両者の多項式が同じ主な変数を持つように変換する
方法が考えられます。この上に変数で順序付けるタワーの様な構造を強制することで、常に
任意の多項式を最優先の変数が主で低優先度の変数が係数に埋め込まれた``基底形式''
に変換することができます。この戦略はとても良く行きます。ただし変換が多項式を
不必要に展開するかもしれないため、読み難くそして恐らく非効率にしてしまいます。
タワーの戦略は全くこの領域では全く自然ではありません。またはユーザが新しい型を
古い型を用いて種々の接続形式にて動的に創作する領域、例えば三角関数、羃級数、積分等
の任意の領域には自然ではないでしょう。



強制をコントロールすることが巨大スケールの代数操作システムの設計において深刻な問題
であることは驚くべきことではありません。そのようなシステムの多くの複雑性は様々な型
の間の関係性に携わっています。私達はまだ完全には強制を理解していないと言うこ
とは本当に公正でしょう。実際に私達はまだデータ型の概念を完全には理解していません。
それでもなお、私達が知っていることは強力な構造化とモジュラー方式の原則を伴ない
巨大システムの設計の支援を与えてくれます。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.92}Exercise 2.92:} 
変数の順序付けを強要することで多項式パッケージを拡張し多項式の加算と乗算が異なる
変数の多項式に対しても働くようにせよ。(これは簡単ではない!)
\end{quote}

\subsubsection*{延長課題: 分数関数}


私達のジェネリック数値演算システムを拡張し\newterm{rational functions}(\jnewterm{分数関数})を
含むようにすることができます。分子と分母が多項式である以下の様な``分数''が存在します。
\begin{comment}

\begin{example}
 x + 1
-------
x^3 - 1
\end{example}

\end{comment}
\begin{displaymath}
 {x + 1 \over x^3 - 1}\,. 
\end{displaymath}

システムは分数関数の加算、減算、乗算、除算をできなければなりません。そして以下の様な
計算を行うために、
\begin{comment}

\begin{example}
 x + 1       x      x^3 + 2x^2 + 3x + 1
------- + ------- = -------------------
x^3 - 1   x^2 - 1    x^4 + x^3 - x - 1
\end{example}

\end{comment}
\begin{displaymath}
 {x + 1 \over x^3 - 1} + {x \over x^2 - 1} = 
	{x^3 + 2x^2 + 3x + 1 \over x^4 + x^3 - x - 1}\,. 
\end{displaymath}
\noindent

(ここでは加算は共通因数を取り除くことで簡約されています。通常の``たすき掛け''なら
5次多項式分の4次多項式の分数を生成しているでしょう。)


私達の分数演算パッケージを変更することでジェネリック命令を用いるようにすると
分数を最小の項に簡約する問題を除いて望むことができます。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.93}Exercise 2.93:} 
分数演算パッケージを変更しジェネリック命令を使用するようにせよ。ただし\code{make\-/rat}
を変更し分数を最小の項に簡約することは試行しないようにせよ。あなたのシステムを
\code{make\-/rational}を2つの多項式上にて呼び出し分数関数を生成することでテストせよ。

\begin{scheme}
(define p1 (make-polynomial 'x '((2 1)(0 1))))
(define p2 (make-polynomial 'x '((3 1)(0 1))))
(define rf (make-rational p2 p1))
\end{scheme}

ここで\code{rf}を自身に\code{add}を用いて足せ。この加算手続が分数を最小項に簡約しない
ことを確認するだろう。
\end{quote}

\noindent
多項式の分数を整数で用いたのと同じ考えを用いて最小の項に簡約することができます。
\code{make\-/rat}を変更し分子と分母の両方を最大公約数で割ります。``Greatest Common Denominator''
(GCD:最大公約数)の概念は多項式に対しても意味を成します。実際に2つの多項式の\acronym{GCD}を
整数に対して働く、基本的に同じユークリッドのアルゴリズムを用いて求めることができます。\footnote{
ユークリッドのアルゴリズムが多項式に対して働くという事実は代数学において多項式が
\newterm{Euclidean ring}(\jnewterm{ユークリッド環})と呼ばれるある種の代数の定義域を形成すると述べることにより
形式化されます。ユークリッド環とは加算、減算、そして可換な乗算を許す定義域であり、
環の各元\( x \)に対する正の整数の``大きさ''\( m(x) \)の割り当て方法とそれに対する性質として
任意の非ゼロな\( x \)と\( y \)に対し\( m(xy) \ge m(x) \)であると共に、
与えられた任意の\( x \)と\( y \)に対し\( y = qx + r \)となる\( q \)が存在し、
\( r = 0 \)または\( m(r) < m(x) \)であることが言えます。
抽象化の視点からこれがユークリッドのアルゴリズムがうまく行くのに必要な条件です。
整数の定義域に対して、整数の大きさ\( m \)はその整数の絶対値です。多項式の定義域においては
多項式の大きさはその次数です。}整数版は以下のとおりです。


\begin{scheme}
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
\end{scheme}

\noindent
これを用いて、項リスト上で働く\acronym{GCD}命令を定義するための明かな変更を行うことができます。

\begin{scheme}
(define (gcd-terms a b)
  (if (empty-termlist? b)
      a
      (gcd-terms b (remainder-terms a b))))
\end{scheme}

\noindent
ここで\code{remainder\-/terms}は\link{Exercise 2.91}で実装された項リストの除算命令
\code{div\-/terms}により返されるリストの剰余部を取り出します。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.94}Exercise 2.94:} 
\code{div\-/terms}を用いて手続\code{remainder\-/terms}を実装し、それを用いて\code{gcd\-/terms}を
上記のように定義せよ。次に2つの多項式の多項式\acronym{GCD}を求める手続\code{gcd\-/poly}
を書け。(この手続は2つの多項式が同じ変数でなければエラーを発しなければならない)。
多項式に対しては\code{gcd\-/poly}を簡約し、通常の数値に対しては通常の\code{gcd}に簡約する
ジェネリック命令\code{greatest\-/common\-/divisor}をシステムにインストールせよ。テストとして以下を試せ。

\begin{scheme}
(define p1 (make-polynomial 
            'x '((4 1) (3 -1) (2 -2) (1 2))))
(define p2 (make-polynomial 'x '((3 1) (1 -1))))
(greatest-common-divisor p1 p2)
\end{scheme}

\noindent

次にその結果を手でチェックせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.95}Exercise 2.95:} 
以下の多項式\( P_1 \), \( P_2 \), \( P_3 \)を定義せよ。
\begin{comment}

\begin{example}
P_1 : x^2 - 2x + 1

P_2 : 11x^2 + 7

P_3 : 13x + 5
\end{example}

\end{comment}
\begin{displaymath}
%  \eqalign{
% 	P_1 	&: \quad x^2 - 2x + 1, \cr
% 	P_2 	&: \quad 11x^2 + 7, \cr
% 	P_3 	&: \quad 13x + 5. \cr
% } 
\begin{array}{l@{{}:}l}
	P_1 	& \quad x^2 - 2x + 1, \\
	P_2 	& \quad 11x^2 + 7, \\
	P_3 	& \quad 13x + 5. 
\end{array}
\end{displaymath}


次に\( P_1 \)と\( P_2 \)の積\( Q_1 \)、\( P_1 \)と\( P_3 \)の積\( Q_2 \)を定義し、
\code{greatest\-/common\-/divisor}(\link{Exercise 2.94})を用いて\( Q_1 \)と\( Q_2 \)
の\acronym{GCD}を求めよ。答が\( P_1 \)と同じにならないことに注意せよ。これが
非整数命令の演算が\acronym{GCD}に伴なう困難さを生じさせることの例を示している。\footnote{
\acronym{MIT} Schemeの様な実装ではこの問題は\( Q_1 \)と\( Q_2 \)の実際の約数を分数係数を
伴なって生成します。多くのSchemeシステムでは整数の除算が精度に限界のある小数を生成するため、
正しい約数を得るのに失敗します。}
何が起こったのか正しく理解するため、\acronym{GCD}を求める間\code{gcd\-/terms}をトレースするか
この除算を手で試行してみよ。
\end{quote}

\noindent
\link{Exercise 2.95}で示された問題を以下に示す(整数係数の多項式の場合のみ実際には動作する)
\acronym{GCD}アルゴリズムの変更を用いることで解決することができます。
\acronym{GCD}の演算中の一切の多項式の除算の前に、被除数を一切の分数が除算処理の間に現れない
よう保証するために選ばれた整数定数因数を掛けます。答は従って実際の\acronym{GCD}より整数定数
因数の分異なります。しかしこれは分数関数を最小の項に簡約する場合には問題になりません。
\acronym{GCD}は分子と分母の両方を割るために利用されるため、整数定数因数は相殺されます。



より正確に述べれば、もし\( P \)と\( Q \)が多項式である場合、\( O_1 \)を\( P \)の次数とし
(つまり\( P \)の最大項の次数とし)、\( O_2 \)を\( Q \)の次数とします。\( c \)を\( Q \)の
第一の係数とします。すると\( P \)を\newterm{integerizing factor}(\jnewterm{整数化因数})\( c^{1 + O_1 - O_2} \)
で掛けると、結果の多項式は\code{div\-/terms}アルゴリズムを用いて一切の分数を生じずに\( Q \)で割る
ことができます。
被除数をこの定数で乗算した後に割る命令は時々\( P \)の\( Q \)による\newterm{pseudodivision}(\jnewterm{擬除算})と呼ばれます。
除算の剰余は\newterm{pseudoremainder}(\jnewterm{擬剰余})と呼ばれます。

\begin{quote}
\heading{\phantomsection\label{Exercise 2.96}Exercise 2.96:}
\begin{enumerate}[a]

\item
手続\code{pseudoremainder\-/terms}を実装せよ。これは\code{remainder\-/terms}と同様であるが
\code{div\-/terms}を呼ぶ前に被除数を上で説明した整数化因数で掛ける。
\code{gcd\-/terms}を変更し\code{pseudoremainder\-/terms}を用いるようにし、\code{greatest\-/common\-/divisor}が
整数係数の答を\link{Exercise 2.95}の例にて生ずることを確認せよ。

\item
\acronym{GCD}はこれで整数係数を得る。しかしそれらは\( P_1 \)の物よりも大きい。
\code{gcd\-/terms}を変更し解の係数から全ての係数をそれらの(整数)の最大公約数により割ることで共通因数を取り除く
ようにせよ。
\end{enumerate}
\end{quote}

\noindent
従って、以下に分数関数をどのようにして規約分数に簡約するかを説明します。

\begin{itemize}

\item
\link{Exercise 2.96}の\code{gcd\-/terms}の版を用いて、分子と分母の\acronym{GCD}を求める

\item
\acronym{GCD}を得たら分子と分母の両方に同じ整数化因数を\acronym{GCD}で割る前に
掛けることで\acronym{GCD}による除算が非整数な係数を生じないようにする。
因数として\acronym{GCD}の最初の係数を\( 1 + O_1 - O_2 \)乗した物を用いることができ、
この時\( O_2 \)は\acronym{GCD}の次数であり、\( O_1 \)は分子と分母の最大次数である。
こうすることで分子と分母を\acronym{GCD}で割っても分数を生じない。

\item
この操作の結果は分子と分母が整数係数になる。係数は通常とても巨大になる。理由の
全ては整数化因数のせいだ。そのため最終ステップは分子と分母の全ての係数の
(整数の)最大公約数を求めてこの約数で割ることで冗長な因数を取り除くことである。

\end{itemize}

\begin{quote}
\heading{\phantomsection\label{Exercise 2.97}Exercise 2.97:}
\begin{enumerate}[a]

\item
このアルゴリズムを、2つの項リスト\code{n}と\code{d}を引数として取り上で説明された
アルゴリズムにて\code{n}と\code{d}を最小の項に簡約したリスト\code{nn}と\code{dd}を返す
手続\code{reduce\-/terms}として実装せよ。また\code{add\-/poly}と同様に2つの多項式が同じ変数を持つか
チェックする手続\code{reduce\-/poly}も書け。もしそうである場合\code{reduce\-/poly}は変数を取り去り
問題を\code{reduce\-/terms}に渡す。そして\code{reduce\-/terms}により与えられた2つの項リストに
再び変数を取り付ける。

\item
元の\code{make\-/rat}が整数に対して行ったことを行う\code{reduce\-/terms}と同様の手続を定義せよ。

\begin{scheme}
(define (reduce-integers n d)
  (let ((g (gcd n d))) (list (/ n g) (/ d g))))
\end{scheme}

\noindent
次に\code{reduce}をジェネリック命令として定義する。
これは\code{apply\-/generic}を呼び、(\code{polynomial}型引数に対しては)\code{reduce\-/poly}を呼び出し、
(\code{scheme\-/number}型引数に対しては)\code{reduce\-/integers}を呼び出す。
これで\code{make\-/rat}に与えられた分子と分母を接続して分数を形成する前に\code{reduce}を
呼ばせることで、簡単に分数数値演算パッケージに分数を最小の項に約分させることができる。

\begin{scheme}
(define  p1 (make-polynomial 'x '((1 1) (0  1))))
(define  p2 (make-polynomial 'x '((3 1) (0 -1))))
(define  p3 (make-polynomial 'x '((1 1))))
(define  p4 (make-polynomial 'x '((2 1) (0 -1))))
(define rf1 (make-rational p1 p2))
(define rf2 (make-rational p3 p4))
(add rf1 rf2)
\end{scheme}

正しい答を得るかどうか、正しく最小の項に簡約されるかどうか確認せよ。
\end{enumerate}
\end{quote}

\noindent
\acronym{GCD}の計算は分数関数の操作を行うどんなシステムにおいても心臓部に存在します。
上で用いられたアルゴリズムは数学的には簡単ですが非常に遅いです。。遅さの原因の一部は
除算命令の大きな値であり、他には擬除算により生じる非常に大きな中間時の係数のため
となります。代数操作システムの活発な開発領域の1つは多項式の\acronym{GCD}を求める
より良いアルゴリズムの設計です。\footnote{多項式の\acronym{GCD}を求めるための
1つの著しく効率が良く洗練された手法はRichard \link{Zippel (1979)}により発見されました。
この手法は\link{Chapter 1}にて議論した素数性の高速なテストと同様の乱選アルゴリズムです。
Zippelの本(\link{Zippel 1993})はこの手法を多項式の\acronym{GCD}を求める他の方法と共に
解説しています。}
