\chapter{モジュール方式、オブジェクト、状態}
\label{Chapter 3}

\begin{quote}
\begin{greek}
Mεταβάλλον ὰναπαύεται
\end{greek}

(例え変化している間も、それは静止していた)

---Heraclitus
\end{quote}

\begin{quote}
Plus \c{c}a change, plus c'est la m\^{e}me chose.

(より多くが変化する程、より同じであり続ける)

---Alphonse Karr
\end{quote}

\vspace{1.0em}

\noindent
ここまでの章はプログラムが作成される基礎的な要素を紹介しました。どのようにして
プリミティブな手続とプリミティブなデータが接続され複合要素を構築するかについて
学び、また抽象化が巨大システムの複雑さに立ち向かうことを手助けする核心であることを
学習しました。しかしこれらのツールはプログラムを設計するのに十分ではありません。
効果的なプログラム統合はプログラム設計全体の形式化をガイドすることが可能な組織的原則を
必要とします。具体的には巨大システムの構造化を手助けする戦略が必要で、それによりそれらが
\newterm{modular}(\jnewterm{モジュラ})化されるよう、つまり``自然に''分離して開発と保守が可能な
論理的部品に分割されるようにします。



物理システムをモデル化したプログラムの構築に特に適切な1つの強力な設計戦略は
プログラムの構造をモデル化されるシステムの構造を元にすることです。システムの各オブジェクト
に対して対応する演算オブジェクトを構築します。各システムのアクションに対しては演算
モデル内の記号操作を定義します。この戦略を用いる見込は新しいオブジェクトやアクションを
供給するためにモデルを拡張することはプログラムに対する戦略上の変更を必要としないことです。
それらのオブジェクト、またはアクションの新しい記号上の類似物の追加のみ変更が必要です。
システムの組織化にて成功しているのなら、新しい機能の追加や古い物のデバッグにおいては
システムの特定の部分上のみで働く必要があります。



すると大体の場合、巨大プログラムを体系化する方法はモデル化されるシステムの私達の
認知により指示されます。この章では2つの大きく異なるシステム構造の``世界観''から
浮かび上がる2つの顕著な体系化戦略について調査します。最初の体系化戦略は
\newterm{objects}(\jnewterm{オブジェクト})に集中し、巨大システムをその振舞が時間と共に変化する
区別可能なオブジェクトの集合だと見ます。代替となる体系化戦略はシステム内を流れる
情報の\newterm{streams}(\jnewterm{ストリーム})に集中します。これは電子技術者の信号処理システム
の視点と同じです。


オブジェクトベースとストリーム処理の両方のアプローチは共にプログラミングにおける
重大な言語上の問題を浮かび上がらせます。オブジェクトでは演算オブジェクトがどのように
変化可能で、それでもその同一性を維持できるかについて関心を持たなければなりません。
このことがより機械的な、しかし論理的に扱い難い演算の\newterm{environment model}(\jnewterm{環境モデル})
のために、私達の古い演算の置換モデル(\link{Section 1.1.5})を諦めさせることになります。
オブジェクト、変化、同一性の取扱の難しさは私達の計算モデル内で時間に取り組むための
必要性の基本的な結論です。これらの問題はプログラムの並行実行を許可する場合にさらに
大きくなります。ストリームの取り組みは
私達のモデル内でシミュレートされた時間を計算機の中で評価の間に発生したイベントの順から
分断した時に最も全体に利用可能です。
\newterm{delayed evaluation}(\jnewterm{遅延評価})として知られるテクニックを用いてこれを達成します。



\section{代入と局所状態}
\label{Section 3.1}



私達は通常世界を独立したオブジェクトが占める物として見なします。各オブジェクトは
時間に伴ない変化する状態を持ちます。オブジェクトはその過去にその振舞が影響される時、
``状態を持つ''と呼びます。例えば銀行講座は預金と引き出しの取引の記録に依存する
``私は\$100引き出せるか?''という質問の答に状態を持ちます。オブジェクトの状態を1つ以上の
\newterm{state variables}(\jnewterm{状態変数})と見做すことができ、それらの間にオブジェクトの
現在の振舞を決定するための歴史についての十分な情報を保存します。
簡単な銀行システムでは口座の状態を口座の取引履歴全体を記憶するのではなく、現在の差引残高
と見做すことができるでしょう。



多くのオブジェクトから成るシステムではオブジェクトが完全に独立していることは稀です。
あるオブジェクトの状態変数を他のオブジェクトのそれに連結する相互作用を通して
各オブジェクトが他の状態に影響を与えることがあるでしょう。実際に、システムが分離した
オブジェクトから成るという見方は、システムの状態変数が密結合されたサブシステムが、
他のサブシステムとは疎結合であるというグループに分けられる時最も便利です。



このシステムの見方はシステムの演算モデルの体系化に対する強力なフレームワークに成ります。
そのようなモデルをモジュール化するためにはシステム内の実際のオブジェクトをモデル化する
計算オブジェクトに分離せねばなりません。各計算オブジェクトは実際のオブジェクトの状態を
説明するそれ自身の\newterm{local state variables}(\jnewterm{ローカル状態変数})を持たねばなりません。
モデル化されるシステム内のオブジェクトの状態は経時変化するため、計算オブジェクトに相対する
状態変数も変化しなければなりません。もし私達がシステム内の時の流れを計算機内で経過する時で
モデル化することを選択するのならば、振舞がプログラムが実行するにつれ変化する計算オブジェクトを
構築する手段を持たねばなりません。具体的には、もし状態変数をプログラミング言語内の通常の
記号名にてモデル化を行いたいのならば、その言語は名前に関連する値を変化することができる
\newterm{assignment operator}(\jnewterm{代入演算子})を提供せねばなりません。



\subsection{局所状態変数}
\label{Section 3.1.1}



時間的に変化する状態を伴なう計算オブジェクトを持つことにより何を意味するのかを説明するため
に、銀行口座からお金を引き出す状況をモデル化してみましょう。これを引数として引き出される
\code{amount}(金額)を取る手続\code{withdraw}を用いて行います。もし口座の中に引き出しを受け入れるのに
十分なお金があるのならば、\code{withdraw}は引き出しの後に残る差引残高を返さねばなりません。
そうでなければ、\code{withdraw}は\emph{Insufficient funds}(資金不足)というメッセージを返します。
例えば口座を\$100で始めた場合、\code{withdraw}を用いて以下の一連の応答を受け取るはずです。

\begin{scheme}
(withdraw 25)
~\textit{75}~
(withdraw 25)
~\textit{50}~
(withdraw 60)
~\textit{"Insufficient funds"}~
(withdraw 15)
~\textit{35}~
\end{scheme}

\noindent
式\code{(withdraw 25)}が2度評価され異なる値を返していることに注目して下さい。
これは手続にとって新しい種類の振舞です。今までは全ての手続は数学上の関数を
計算する仕様だと見做すことができました。手続の呼出は与えられた引数に適用された
関数の値を計算しました。そして同じ手続に同じ引数を与えば場合の2度の呼出は
常に同じ結果を生じました。\footnote{実際にはこれは全く正しい訳ではありません。
例の1つは\link{Section 1.2.6}の乱数生成です。別の例は\link{Section 2.4.3}で紹介した命令-型テーブルに
に従って生じます。同じ引数を伴なう\code{get}の二度の呼出の値は間に入る\code{put}に
依存します。一方で、代入を紹介するまではそのような手続を自分達で作る方法は
無かった訳です。}



\code{withdraw}を実装するために、口座の差引残高を示す変数\code{balance}を用い、
\code{balance}にアクセスする手続\code{withdraw}を定義します。
\code{withdraw}手続は\code{balance}が少なくとも要求された\code{amount}と同じ大きさであるかを
チェックします。もしそうであれば\code{withdraw}は\code{balance}を\code{amount}分減らし、新しい
\code{balance}の値を返します。そうでなければ\code{withdraw}は残高不足のメッセージを返します。
以下に\code{balance}と\code{withdraw}の定義を示します。

\begin{scheme}
(define balance 100)
(define (withdraw amount)
  (if (>= balance amount)
      (begin (set! balance (- balance amount))
             balance)
      "Insufficient funds"))
\end{scheme}

\noindent
\code{balance}を減らすのは次の式により行われます。

\begin{scheme}
(set! balance (- balance amount))
\end{scheme}

\noindent
これは\code{set!}という特殊形式を用いています。その文法は次のとおりです。

\begin{scheme}
(set! ~\( \dark \langle \)~~\var{\dark name}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark new-value}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
ここでは\( \langle \)\var{name}\( \kern0.08em\rangle \)はシンボルであり、
\( \langle \)\var{new-value}\( \kern0.08em\rangle \)は任意の式です。
\code{set!}は\( \langle \)\var{name}\( \kern0.08em\rangle \)を変更し、その値が
\( \langle \)\var{new-value}\( \kern0.08em\rangle \)を評価して得られた結果に
します。この場合では\code{balance}を変更することでその新しい値が\code{balance}の以前の
値から\code{amount}を引いた結果になります。\footnote{


\code{set!}式の値は実装依存です。\code{set!}はその効果のためのみに用いられ、その値のために
用いられてはなりません。


その名前\code{set!}はSchemeで用いられる名前付けの慣習が反映されています。
変数の値を変更する命令(または\link{Section 3.3}で学ぶデータ構造を変える物)は感嘆符(ビックリマーク)で
終わる名前を与えられます。
これは述語をクエスチョンマークで終わる名前で指定するのと同様です。}



\code{withdraw}はまた\code{begin}という特殊形式も使用しており、これは2つの式を\code{if}のテストが
真の場合に評価されるようにします。最初に\code{balance}を減らし、次に\code{balance}の値を返します。
一般的に以下の式を評価すると

\begin{scheme}
(begin ~\( \dark \langle \)~~\( \dark exp_1 \)~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark exp_2 \)~~\( \dark \rangle \)~ ~\( \dots \)~ ~\( \dark \langle \)~~\( \dark exp_k \)~~\( \dark \rangle \)~)
\end{scheme}

\noindent
\( \langle \)\( exp_1 \)\( \kern0.08em\rangle \)から
\( \langle \)\( exp_k \)\( \kern0.08em\rangle \)までの式は続けて評価され
最後の式\( \langle \)\( exp_k \)\( \kern0.08em\rangle \)が\code{begin}の形式全体の値として
返ります。\footnote{
私達は既に\code{begin}を暗黙的にプログラムの中で使用しています。Schemeでは手続のボディは連続する式と
なるからです。また\code{cond}式の各節の\( \langle \)\var{consequent}\( \kern0.08em\rangle \)の部分
は単一の式でなく一連の式にすることができます。}



\code{withdraw}は望んだ通りに働きますが、変数\code{balance}が問題を表します。
上で指定されたように、\code{balance}はグローバル環境にて定義された名前であり
自由に検査や変更のために任意の手続からアクセスすることができます。
どうにかして\code{balance}を\code{withdraw}の内在にすることで\code{withdraw}のみが
\code{balance}に直接アクセスでき、他の手続のどれもが\code{balance}には間接的に
(\code{withdraw}の呼出を通して)アクセスするようにできればともて良くなるでしょう。
こうすることが口座の状態を追跡するため\code{balance}が\code{withdraw}により利用される
局所状態変数であるという概念をより正確にモデル化します。



定義を以下のように書き直すことで\code{balance}を\code{withdraw}に内在させることができます。

\begin{scheme}
(define new-withdraw
  (let ((balance 100))
    (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))))
\end{scheme}

\noindent
ここで起こなったのは\code{let}を用いて初期値100に束縛されたローカル変数\code{balance}を
持つ環境を設置しました。この局所環境の中では\code{lambda}を用いて\code{amount}を引数に取り
以前の\code{withdraw}手続と同様に振る舞う手続を作成しています。この手続---\code{let}式の
評価の結果として返される物---は\code{new\-/withdraw}であり正確に\code{withdraw}と同じ
振舞をしますが、その変数\code{balance}は他のどの手続からもアクセスできません。\footnote{
プログラミング言語の専門語において変数\code{balance}は手続\code{new\-/withdraw}にカプセル化
されたと言います。カプセル化は\newterm{hiding principle}(\jnewterm{隠蔽原則})として知られる
一般的なシステム設計の原則を反映しています。隠蔽原則とはシステムの部分をお互いから守ることで
よりモジュール化の推進と頑強なシステムを作成することができるということです。それはつまり
情報へのアクセスを``知ることを必要とする''システムの部分ににも与えることによります。}



\code{set!}をローカル変数と組み合わせることはローカルな状態を持つ計算オブジェクトを
構築するのに用いる一般的なプログラミングテクニックです。残念なことに、このテクニックを
用いることは深刻な問題をもたらします。私達が最初に手続を紹介した時、評価の置換モデル(\link{Section 1.1.5})
も手続の適用が何を意味するのかの解釈を説明するために提供しました。
手続の適用は手続のボディを、形式パラメータをそれらの値で置換して評価することだと解釈
されるべきだと述べました。問題は言語に代入を紹介すると直ぐに置換は最早手続の適用モデル
として適切ではなくなります(なぜそうなのかについては\link{Section 3.1.3}で学びます)。結果として
技術的に今の時点ではなぜ\code{new\-/withdraw}手続が上で主張された通りに振る舞うのか理解する
手立てがありません。本当に\code{new\-/withdraw}の様な手続を理解するためには、手続適用の
新しいモデルの開発を必要とします。\link{Section 3.2}においてそのようなモデルを \code{set!}とローカル変数の
説明と共に紹介します。しかし最初に\code{new\-/withdraw}により設定される主題上のいくつかの変化に
ついて調査することにします。



以下の手続\code{make\-/withdraw}は``引き出し処理''を作成します。\code{make\-/withdraw}の
形式パラメータ\code{balance}は口座の初期残高を指定します。\footnote{
上の\code{new\-/withdraw}とは逆に、\code{balance}をローカル変数にするために\code{let}を使用する
必要がありません。形式パラメータは既にローカル変数であるためです。
\link{Section 3.2}の環境の評価モデルの議論の後にこのことはより明白になります。
(\link{Exercise 3.10}も参照して下さい)}

\begin{scheme}
(define (make-withdraw balance)
  (lambda (amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds")))
\end{scheme}

\noindent
\code{make\-/withdraw}は以下のように2つのオブジェクト\code{W1}と\code{W2}を作るのに使用できます。

\begin{scheme}
(define W1 (make-withdraw 100))
(define W2 (make-withdraw 100))

(W1 50)
~\textit{50}~
(W2 70)
~\textit{30}~
(W2 40)
~\textit{"Insufficient funds"}~
(W1 40)
~\textit{10}~
\end{scheme}

\noindent
\code{W1}と\code{W2}が完全独立したオブジェクトであり、各々がそれ自身のローカル状態変数
\code{balance}を持っていることを観察して下さい。ある口座からの引き出しは別の口座には
影響しません。



引き出し同様に預け入れを扱うオブジェクトを作ることもできます。従って簡単な銀行口座を
表現可能です。以下が指定した初期残高を持つ``銀行口座オブジェクト''を返す手続です。

\begin{scheme}
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (error "Unknown request: MAKE-ACCOUNT"
                       m))))
  dispatch)
\end{scheme}

\noindent
各\code{make\-/account}の呼出はローカル状態変数\code{balance}を持つ環境を構築します。
この環境の中で\code{make\-/account}は\code{balance}にアクセスする手続\code{deposit}と\code{withdraw}を定義します。
また追加の手続\code{dispatch}は``メッセージ''を入力として取り2つのローカル手続の内1つを返します。
\code{dispatch}手続それ自身が銀行口座オブジェクトを表現する値として返されます。
これはまさに\link{Section 2.4.3}で学んだ\newterm{message-passing}(\jnewterm{メッセージパッシング})プログラミングスタイルです。
ただしここではそれをローカル変数を変更する能力と合わせて用いています。


\code{make\-/account}は以下のように使用できます。

\begin{scheme}
(define acc (make-account 100))
((acc 'withdraw) 50)
~\textit{50}~
((acc 'withdraw) 60)
~\textit{"Insufficient funds"}~
((acc 'deposit) 40)
~\textit{90}~
((acc 'withdraw) 60)
~\textit{30}~
\end{scheme}

\noindent
各\code{acc}の呼出は局所的に定義された\code{deposit}か\code{withdraw}手続を返し、指定された\code{amount}に適用されます。
\code{make\-/withdraw}を用いる場合でしたので、別の呼出し、

\begin{scheme}
(define acc2 (make-account 100))
\end{scheme}

\noindent
は完全に分離された口座オブジェクトを生成し、それ自身のローカルな\code{balance}を持ちます。

\begin{quote}
\heading{\phantomsection\label{Exercise 3.1}Exercise 3.1:} 
\newterm{accumulator}は1つの数値引数を持ち繰り返し呼ばれる手続で、引数を合計に
蓄積する。呼び出される度に現在の累積和を返す。アキュムレータ(累算器)を返す手続
\code{make\-/accumulator}を書け。アキュムレータはそれぞれが独立した合計を持つ。
\code{make\-/accumulator}への入力は累計の初期値を指定する。例えば、

\begin{scheme}
(define A (make-accumulator 5))
(A 10)
~\textit{15}~
(A 10)
~\textit{25}~
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.2}Exercise 3.2:}
ソフトウェアテストアプリケーションでは演算処理の間に与えらえれた手続が何度呼ばれたか
を数えられると便利である。1引数手続\code{f}を入力として取る手続\code{make\-/monitored}を書け。
\code{make\-/monitored}の返す結果は第三の手続(\code{mf}としよう)は内部カウンタを保持することで
何回呼出されたかを追跡する。もし\code{mf}への入力が特別なシンボル\code{how\-/many\-/calls?}で
あるなら、\code{mf}はカウンタの値を返す。入力が特別なシンボル\code{reset\-/count}であるなら
\code{mf}はカウンタをゼロにリセットする。任意の他の入力に対しては\code{mf}はその入力上の
\code{f}呼出の結果を返しカウンタを1増やす。例えば監視版の\code{sqrt}手続を作ることができる
だろう。

\begin{scheme}
(define s (make-monitored sqrt))
(s 100)
~\textit{10}~
(s 'how-many-calls?)
~\textit{1}~
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.3}Exercise 3.3:} 
\code{make\-/account}手続を変更しパスワードで守られた口座を作成するようにせよ。
即ち\code{make\-/account}はシンボルを追加引数として以下のように取得する。

\begin{scheme}
(define acc (make-account 100 'secret-password))
\end{scheme}


結果の口座オブジェクトはリクエストをアカウント作成時のパスワードが付随する場合のみ
処理を行いその他の場合には間違いだと返す。

\begin{scheme}
((acc 'secret-password 'withdraw) 40)
~\textit{60}~
((acc 'some-other-password 'deposit) 50)
~\textit{"Incorrect password"}~
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.4}Exercise 3.4:} 
\link{Exercise 3.3}の\code{make\-/account}手続に別のローカル状態変数を追加することで
変更し、口座が7回連続間違ったパスワードでアクセスされた場合に手続\code{call\-/the\-/cops}
(警察を呼ぶ)を実行するようにせよ。
\end{quote}

\subsection{代入導入の利点}
\label{Section 3.1.2}



私達が学ぶに従い、代入を私達のプログラミング言語に導入したことは難しい概念上の
問題の藪の中へと導きます。それでもなおシステムをローカルな状態を持つオブジェクトの集合
として見ることはモジュラな設計を維持する為の強力なテクニックです。
簡単な例として、呼ばれる度に無作為な(ランダムな)整数を返す手続\code{rand}の設計について
考えてみて下さい。



``ランダムに選択''が何を意味するのかは全くわかりません。恐らく私達が欲しい物は
\code{rand}への連続した呼出が統計上の性質として均一な分散を持つ一連の数値を生じて
欲しいのでしょう。ここでは適切な数列を生成する手法については議論しません。
そうでなく、数値\( x_1 \)を与えて開始した場合に以下の数列を生成する性質を持つ
手続\code{rand\-/update}を既に持っていると想定しましょう。

\begin{scheme}
~\( \dark x_2 \)~ = (rand-update ~\( \dark x_1 \)~)
~\( \dark x_3 \)~ = (rand-update ~\( \dark x_2 \)~)
\end{scheme}

\noindent
すると数列\( x_1 \), \( x_2 \), \( x_3 \), \( \dots \)は望まれた統計的性質特性を持つでしょう。\footnote{
\code{rand\-/update}を実装する1つの一般的な方法は\( x \)は\( ax + b \) modulo \( m \)に更新されるとする、
この時\( a \), \( b \), \( m \)は適切に選択された整数であるというルールを用いることです。
\link{Knuth 1981}の3章は広範囲に及ぶ乱数列を生成するためのテクニックの議論を含んでおり、また
それらの統計的性質を規定しています。\code{rand\-/update}手続が数学上の関数を計算していることに注意
して下さい。同じ入力を2回与えられれば同じ出力を生成します。従って\code{rand\-/update}により生成
される数列は``ランダム''が数列のどの数値も以前の数値に関係が無いと主張するのであれば、
明らかに``ランダム''ではありません。``真の無作為性(ランダムネス)''と
上手く決定された計算で生成されるがそれでも適切な統計上特性を持つ\newterm{pseudo-random}(\jnewterm{擬似乱数})列の
間の関係は数学と哲学の難しい問題を巻き込む複雑な質問です。
Kolmogorov, Solomonoff, それにChaitinはこれらの問題の解明において大きな進展を上げました。
これに関する議論は\link{Chaitin 1975}に見つかります。
}


\code{rand}をある固定値\code{random\-/init}で初期化されるローカル状態変数\code{x}を持つ手続として
実装できます。\code{rand}への各呼出は現在の\code{x}の値の\code{rand\-/update}を演算し、
これを乱数として返し、また同時にこの値を\code{x}の新しい値として格納します。

\begin{scheme}
(define rand (let ((x random-init))
               (lambda () 
                 (set! x (rand-update x))
                 x)))
\end{scheme}

\noindent
もちろん、代入を用いずに単純に\code{rand\-/update}を直接呼ぶことで同じ乱数列を
生成することも可能でしたでしょう。しかし、これは私達のプログラムの乱数を用いる
任意の部分が明示的に\code{x}の現在の値を\code{rand\-/update}の引数として渡すために
記憶せねばならないことを意味することになります。
これがどれだけ不快であるかを気付くために、乱数を\newterm{Monte Carlo simulation}
(\jnewterm{モンテカルロシミュレーション})と呼ばれるテクニックを実装するために乱数を用いる
場合について考えてみましょう。


モンテカルロ法は巨大集合から無作為にサンプル試行を選択することと、その次に
それらの試行上の結果の集計から推測された確率を基準にして演繹を行うことから成り立ちます。
例えば\( \pi \)を\( 6/\pi^2 \)は2つの無作為に選択された整数に公約数が無い場合の確率
であるという事実を用いて近似値を求められます。言い換えると、2つの整数の最大公約数が1になる
場合ということです。\footnote{この定理はE. Ces\`aroによるものです。その議論と証明については\link{Knuth 1981}の
節4.5.2を参照して下さい。}
\( \pi \)の近似値を求めるためには数多くの試行を行います。各試行において2つの整数を無作為に
選択し、それらの\acronym{GCD}が1であるかをテストします。テストをパスした回数の割合は
\( 6/\pi^2 \)の近似値を与えてくれます。この値から\( \pi \)の近似値を得ます。



プログラムの心臓部は手続\code{monte\-/carlo}です。これは試行回数と引数が無く実行される度に
真偽値を返す手続として表される試行を引数として取ります。\code{monte\-/carlo}は試行を指定された
回数実行し、試行が真と判定された割合を表す数値を返します。

\begin{scheme}
(define (estimate-pi trials)
  (sqrt (/ 6 (monte-carlo trials cesaro-test))))
(define (cesaro-test)
   (= (gcd (rand) (rand)) 1))

(define (monte-carlo trials experiment)
  (define (iter trials-remaining trials-passed)
    (cond ((= trials-remaining 0)
           (/ trials-passed trials))
          ((experiment)
           (iter (- trials-remaining 1) 
                 (+ trials-passed 1)))
          (else
           (iter (- trials-remaining 1) 
                 trials-passed))))
  (iter trials 0))
\end{scheme}

\noindent
さて同じ計算を\code{rand}の代わりに\code{rand\-/update}を用いてやってみましょう。
局所状態をモデル化するために代入を用いない場合に続行を強制される手法です。

\begin{scheme}
(define (estimate-pi trials)
  (sqrt (/ 6 (random-gcd-test trials random-init))))
(define (random-gcd-test trials initial-x)
  (define (iter trials-remaining trials-passed x)
    (let ((x1 (rand-update x)))
      (let ((x2 (rand-update x1)))
        (cond ((= trials-remaining 0)
               (/ trials-passed trials))
              ((= (gcd x1 x2) 1)
               (iter (- trials-remaining 1)
                     (+ trials-passed 1)
                     x2))
              (else
               (iter (- trials-remaining 1)
                     trials-passed
                     x2))))))
  (iter trials 0 initial-x))
\end{scheme}

\noindent
プログラムは今も単純ではありますが、いくつかモジュール方式に対する苦痛を伴なう
侵害行為があります。\code{rand}を用いる最初の版ではモンテカルロ法を直接、引数として
任意の\code{experiment}手続を取る全体的な\code{monte\-/carlo}手続にて表すことができました。
乱数生成に対する状態変数の無い2つ目の版では\code{random\-/gcd\-/test}が明示的に乱数
\code{x1}と\code{x2}を管理し、\code{x2}を繰り返しのループを通して\code{rand\-/update}に対する
新しい入力としてリサイクルしなければなりません。この明示的な乱数の取扱は
テスト結果の蓄積構造と
私達の試行が2つの乱数を利用するという事実を一緒に密に結合します。例え他のモンテカルロの試行が
1つや3つの乱数を使うにしてもです。トップレベルの手続\code{estimate\-/pi}ですら乱数の初期値を
提供することに関心を持たねばなりません。乱数生成器の内部がプログラムの他の部分に漏れ出す
ことはモンテカルロの考えを分離し他のタスクに適用することを難しくします。
プログラムの最初の版では代入が乱数生成器の状態を\code{rand}手続の中にカプセル化しているため
乱数生成器の詳細はプログラムの他の部分からの独立を維持しています。



モンテカルロの例にて説明された一般的な事象は以下のとおりです。複雑なプロセスの
一部の視点からは他の部分は時間に従い変化するように見えます。それらは時間と共に
変化するローカルな状態を隠しています。もしこの分解を反映する構造を持つ計算機プログラム
を書きたいのならば、振舞が時間と共に変換する(銀行口座と乱数生成器の様な)計算オブジェクトを作成します。
私達は状態をローカル状態変数を用いてモデル化し、状態の変化をそれらの変数への代入にて
モデル化します。



この議論を次のよう述べることで結論付けることは魅力的です。曰く、代入と状態を局所変数に
隠す技術を紹介することで、追加のパラメータを渡すことで全ての状態が明示的に操作されなければ
ならない場合よりも、よりモジュール化を行う方法でシステムの構造化を行えます、と。
残念ながらこれから学ぶように、このお話はそんなに簡単ではありません。

\begin{quote}
\heading{\phantomsection\label{Exercise 3.5}Exercise 3.5:} 
\newterm{Monte Carlo integration}(\jnewterm{モンテカルロ積分})はモンテカルロ・シミュレーションを用いて
定積分を推測する手法だ。述語\( P(x, y) \)で記述される空間の領域の面積を計算する場合について
考えてみる。述語\( P(x, y) \)は点\( (x, y) \)が領域の中であれば真であり、そうでなければ偽である。
例えば中心(5, 7)、半径3の円に含まれる領域は\( (x - 5)^2 + (y - 7)^2 \le 3^2 \)であるかテストする
述語にて記述される。そのよう述語で記述された領域の面積を推測するためにその領域を含む長方形を
選択することから始める。例として対角線上の角を(2, 4)と(8, 10)に持つ長方形は先程の円を含む。
期待される積分はその領域が位置する長方形の一部の面積だ。長方形の中の点\( (x, y) \)を
不作為に選択し、各点に対し\( P(x, y) \)をテストしその点が元の領域の中であるかどうかを決定すること
で積分を推定することができる。もしこの試行を数多くの点で行えば領域の中に落ちる点の割合は
長方形の内のその領域の割合の推定値を与えるはずだ。従ってこの割合に長方形全体の面積を掛けること
で積分の推定値を生成可能である。



モンテカルロ積分を手続\code{estimate\-/integral}として実装せよ。これは引数として述語\code{P}、
長方形の上下界として\code{x1}, \code{x2}, \code{y1}, \code{y2}、そして推定値を生成するため実行する
試行回数を取る。手続は上で\( \pi \)を推測するために使用した\code{monte\-/carlo}手続を同じく
使用せねばならない。\code{estimate\-/integral}を用いて\( \pi \)の推測値を単位円の面積を
測ることで求めよ。


与えられた値域から不作為に選択された数値を返す手続を持つことが便利であると発見するかもしれない。
以下の\code{random\-/in\-/range}手続はこれを\link{Section 1.2.6}で使用した\code{random}手続を用いて実装する。
これは入力より小さな非負数を返す。\footnote{\acronym{MIT} Schemeはそのような手続を提供します。
もし\code{random}が(\link{Section 1.2.6}での様に)整数を渡されれば、整数を返します。しかし(この課題のように)
小数を渡された場合には小数を返します。}

\begin{scheme}
(define (random-in-range low high)
  (let ((range (- high low)))
    (+ low (random range))))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.6}Exercise 3.6:} 
乱数生成器を与えられた値から始まる列を生成するためリセットすることができれば便利である。
シンボル\code{generate}またはシンボル\code{reset}のどちらかを引数として呼び出す新しい\code{rand}手続を設計せよ。
これは次のように振る舞う。\code{(rand 'generate)}は新しい乱数を生成する。
\code{((rand 'reset)}\( \;\langle \)\var{new-value}\( \kern0.11em\rangle \)\code{)}は内部の状態変数を指定された
\( \langle \)\var{new-value}\( \kern0.08em\rangle \)でリセットする。
従って状態をリセットすることで繰り返し可能な列の生成が行える。これは乱数を用いるプログラムのテストや
デバッグにおいてとても役に立つ。

\end{quote}

\subsection{代入導入のコスト}
\label{Section 3.1.3}


ここまで見てきたとおり、\code{set!}命令はローカルな状態を持つオブジェクトのモデル化を可能にします。
しかしこの利点は犠牲を伴ないます。私達のプログラミング言語は\link{Section 1.1.5}で紹介した手続適用の置換モデルを用いて説明
することができません。加えて、プログラミング言語の間にオブジェクトと代入を取り扱うための適切なフレームワークとなる
``良い''数学上の特性を伴なう簡単なモデルが存在しません。



代入を使わない限り、同じ引数を伴なう同じ手続の二度の評価は同じ結果を生じ、手続は数学上の関数の計算と
見ることができます。私達がこの本の最初の二章を通じて行ってきたような代入を使用しないプログラミングは、
それ故に\newterm{functional programming}(\jnewterm{関数型プログラミング})として知られています。



代入が問題をどのように困難にするかを理解するために、\link{Section 3.1.1}の\code{make\-/withdraw}手続を
残額が十分であるかのチェックを行わない様に単純化した版について考えます。

\begin{scheme}
(define (make-simplified-withdraw balance)
  (lambda (amount)
    (set! balance (- balance amount))
    balance))
(define W (make-simplified-withdraw 25))
(W 20)
~\textit{5}~
(W 10)
~\textit{-5}~
\end{scheme}

\noindent
この手続と以下の\code{set!}を使用しない\code{make\-/decrementer}手続とを比べてみて下さい。

\begin{scheme}
(define (make-decrementer balance)
  (lambda (amount)
    (- balance amount)))
\end{scheme}

\noindent
\code{make\-/decrementer}は指定された残高\code{balance}からその入力を引きます。
しかし連続した呼び出しにおいて\code{make\-/simplified\-/withdraw}のような累積効果はありません。

\begin{scheme}
(define D (make-decrementer 25))
(D 20)
~\textit{5}~
(D 10)
~\textit{15}~
\end{scheme}

\noindent
\code{make\-/decrementer}がどのように働くかの説明には置換モデルを使用できます。
例えば以下の式の評価を解析してみましょう。

\begin{scheme}
((make-decrementer 25) 20)
\end{scheme}

\noindent
最初に結合のオペレータを\code{make\-/decrementer}のボディの\code{balance}を25と置き換えることにより
簡約します。式は以下のようになります。

\begin{scheme}
((lambda (amount) (- 25 amount)) 20)
\end{scheme}

\noindent
\code{lambda}式のボディにある\code{amount}を20と置き換えることでオペレータを適用します。

\begin{scheme}
(- 25 20)
\end{scheme}

\noindent
最終的な答は5です。


しかしもし\code{make\-/simplified\-/withdraw}に対しても同様の置換分析を試みれば何が起こるか観察して
みて下さい。

\begin{scheme}
((make-simplified-withdraw 25) 20)
\end{scheme}

\noindent
最初に\code{make\-/simplified\-/withdraw}のボディにある\code{balance}を25に置き換えることでオペレータを簡約します。
これにより式は以下のようになります。\footnote{
\code{set!}式に存在する\code{balance}は置き換えません。なぜなら\code{set!}内の
\( \langle \)\var{name}\( \kern0.08em\rangle \)は評価されないからです。
もしこれを置き換えれば\code{(set! 25 (- 25 amount))}を得ることになりますが、これは意味がありません。}

\begin{scheme}
((lambda (amount) (set! balance (- 25 amount)) 25) 20)
\end{scheme}

\noindent
ここで\code{lambda}式のボディの中の\code{amount}を20に置き換えてオペレータを適用します。

\begin{scheme}
(set! balance (- 25 20)) 25
\end{scheme}

\noindent
もし置換モデルに執着するのであれば、手続の適用の意味は最初に\code{balance}を5に設定し、
次に式の値として25を返すと言わざるを得ません。これは間違った答を得ます。
正しい答を得るためには、どうにかして最初の位置の\code{balance}(\code{set!}の効果以前)を
2つ目の\code{balance}(\code{set!}の効果の後)から区別せねばなりません。そして置換モデルはこれを行うことが
できません。


ここでの問題は置換は詰まるところ、私達の言語のシンボルが本質的に値の名前であるという概念に
基いています。しかし\code{set!}と変数の値が変更できるという考えを紹介してから直ぐに、
変数は最早単純な名前ではあり得ません。今では変数はどうにかして値が格納できる場所を
参照し、その場所に格納された値は変更することが可能です。\link{Section 3.2}にて、環境がどのようにして
この``場所''の役割を演じるのかについて学びます。

\subsubsection*{同一性と変更}



ここで表出した問題は特定の演算モデルが単に崩壊したよりもずっと深淵です。
私達の計算モデルに変更を紹介して直ぐに、以前は簡単であった多くの概念が
難問と化します。2つの物が``同じ''であるという観念について考えてみましょう。



\code{make\-/decrementer}を同じ引数を与えて二度呼び二つの手続を作成したとします。

\begin{scheme}
(define D1 (make-decrementer 25))
(define D2 (make-decrementer 25))
\end{scheme}

\noindent
\code{D1}と\code{D2}は同じでしょうか? 無難な答はYESです。\code{D1}と\code{D2}は同じ
計算上の振舞を持ち、それぞれが入力から25を引く手続です。
実際に\code{D1}は任意の計算において結果を変えることなく\code{D2}の代替にできます。



これと\code{make\-/simplified\-/withdraw}の二度の呼出とを対比します。

\begin{scheme}
(define W1 (make-simplified-withdraw 25))
(define W2 (make-simplified-withdraw 25))
\end{scheme}

\noindent
\code{W1}と\code{W2}は同じでしょうか? もちろん違います。\code{W1}と\code{W2}の呼出は区別可能な効果を持ちます。
以下の応答列によりそれが示されます。

\begin{scheme}
(W1 20)
~\textit{5}~
(W1 20)
~\textit{-15}~
(W2 20)
~\textit{5}~
\end{scheme}

\noindent
例え\code{W1}と\code{W2}が同じ式\code{(make\-/simplified\-/withdraw 25)}を評価することで
作成されたという点で``同じ''であっても、\code{W1}が式の評価の結果を変えずに
任意の式で\code{W2}の代替になるかというのは正しくありません。



式において式の値を変化せずに``等しい物は等しい物で置き換えられる''という観念を支持する
言語は\newterm{referentially transparent}(\jnewterm{参照透明})と呼ばれます。
参照透明は私達の計算機言語に\code{set!}を含めた時侵害されました。これがいつ式を等価な式で
置き換えることで簡約できるかを決定することを扱いにくくします。
結果的に、代入を用いるプログラムについての推測は大幅により難しくなります。


参照透明を無しで済ませば、計算オブジェクトが``同じ''であることを意味する概念が
形式的に捉えることが難しくなります。本当に実際の世界での``等価''の意味は
私達のプログラムモデルはそれ自身において全く明確になりません。一般的に2つの
恐らく同じオブジェクトが本当に``同じ物''であるかは一方のオブジェクトを変更した場合に
もう一方のオブジェクトが同様に変化したかを観察するしか手立てがありません。
しかしオブジェクトが``変更された''ことを``同じ''オブジェクトを2回観察し,オブジェクトのある
属性が1回目の観察から次に対して異なるかどうかを見る以外にどうやって判断できるのでしょうか。
従って``同一性''の何らかの\emph{a priori}(先験的な)概念無しに``変化''を判断することができません。
そして変化の結果を観察せずに同一性を判断することはできないのです。


この問題がプログラミングにおいてどのように発生するかの例として、PeterとPaulが\$100入っている
口座を持っている状態について考えましょう。これをモデル化するに当たって以下の定義と

\begin{scheme}
(define peter-acc (make-account 100))
(define paul-acc (make-account 100))
\end{scheme}

\noindent
以下の定義では大きな違いがあります。

\begin{scheme}
(define peter-acc (make-account 100))
(define paul-acc peter-acc)
\end{scheme}

\noindent
最初の状況では、2つの銀行口座は区別できます。Peterにより行われた取引はPaulの口座には
影響を与えません。逆も同じです。2つ目の状況ではしかし、\code{paul\-/acc}が\code{peter\-/acc}と
同じ物になるよう定義しました。実際にPeterとPaulは今では連結銀行口座を持っており
Peterが\code{peter\-/acc}から引き出しを行えばPaulは\code{paul\-/acc}の残額が減ったことを観察
するでしょう。これらの2つの似ているが区別できる状況は計算モデルの構築において混乱の
元となり得ます。具体的には、共有口座のために1つのオブジェクト(銀行口座)が2つの
異なる名前(\code{peter\-/acc}と\code{paul\-/acc})を持つことは特に混乱します。プログラムの中で
\code{paul\-/acc}を変更することができる箇所を全て探す場合、\code{peter\-/acc}を変更する箇所もまた
探さねばならないことを覚えておかなければなりません。\footnote{
単一の計算オブジェクトが複数の名前によりアクセスされる事象は\newterm{aliasing}(\jnewterm{エイリアシング})
として知られています。連結銀行口座の状況はエイリアスのとても簡単な例を説明します。
\link{Section 3.3}では``識別可能''な複合データ構造が一部を共有するようなさらに複雑な例について学びます。
バグはプログラムの中でオブジェクトに対する変更が``副作用''として``異なる''オブジェクトに
対しても変更を行い得る場合を忘れている時に発生します。2つの``異なる''オブジェクトが実際には
異なるエイリアスの下に現れる単一のオブジェクトであるためです。これらは
\newterm{side\-/effect bugs}(\jnewterm{副作用バグ})と呼ばれる物で位置の特定や分析がとても難しいため
一部の人々はプログラミング言語は副作用やエイリアスを許可しないよう設計されるべきだと
提案しています。(\link{Lampson et al. 1981}; \link{Morris et al. 1980})}

上記の``同一性''と``変更''上の見解への参照と共に、もしPeterとPaulは差引残高を調べられるだけで
差引残高を変更する命令を実行することができない場合、2つの口座が区別できるかどうかという
問題が無意味になるのかについて注意して下さい。一般的に、データオブジェクトを変更しない限り、
複合データオブジェクトをまさにそれの部分の全体であると見做すことができます。例えば、
分数はその分子と分母により決定されます。しかしこの見方は変更が存在する時には、
複合データオブジェクトがそれが組み立てられている部品とは異質の``アイデンティティ(自己同一性)''を持つ場合には
有効ではありません。
銀行口座は例え引き出しを行うことで残高を変更しても依然として``同じ''銀行口座です。反対に、
同じ状態情報を持つ2つの異なる銀行口座を持つこともできるでしょう。この複雑さは私達のプログラミング言語に
よる物ではなく、私達のオブジェクトとしての銀行口座の認知によるものです。
例えば私達は通常分数を同一性を保ちながら変更可能なオブジェクトだとは見做しません。分子を変更
したら``同じ''分数をだとは思いません。


\subsubsection*{命令型プログラミングの落とし穴}



関数型プログラミングとは反対に、代入を広範囲に用いるプログラミングは
\newterm{imperative programming}(\jnewterm{命令型プログラミング})として知られています。
計算モデルに関する複雑さを上げるのに加えて、命令型スタイルで書かれたプログラムは
関数型プログラムでは起こり得ないバグを起こしやすくなります。
例えば\link{Section 1.2.1}の反復指数プログラムを思い出して下さい。

\begin{scheme}
(define (factorial n)
  (define (iter product counter)
    (if (> counter n)
        product
        (iter (* counter product) (+ counter 1))))
  (iter 1 1))
\end{scheme}

\noindent
内部の反復ループ内で引数を渡す代わりに変数\code{product}と\code{counter}の値の明示的な代入を用いることで
より命令型のスタイルを受け入れることができます

\begin{scheme}
(define (factorial n)
  (let ((product 1)
        (counter 1))
    (define (iter)
      (if (> counter n)
          product
          (begin (set! product (* counter product))
                 (set! counter (+ counter 1))
                 (iter))))
    (iter)))
\end{scheme}

\noindent
これはプログラムにより生成される結果に違いがありません。しかし微妙な罠を招いています。
私達は代入の順序をどのように決めたのでしょうか。たまたま上のプログラムは正しく書かれています。
しかし代入を逆順に書くことは

\begin{scheme}
(set! counter (+ counter 1))
(set! product (* counter product))
\end{scheme}

\noindent
異なる間違った結果を生じることでしょう。一般的に代入を伴なうプログラミングは
各命令が変更された変数の正しい版を用いることを確認するために、
私達に注意深く代入の相対順序を考えることを強制します。
この問題は単純に関数型プログラミングでは起こりません。\footnote{
この視点ではプログラミング入門が高度に命令型スタイルを用いながら最も頻繁に教えられている
ことは皮肉な事です。これは1960年代から1970年代までの間中、手続を呼ぶプログラムは本質的に
代入を実行するプログラムよりも非効率であるに違いないという共通の信念の名残でしょう。
(\link{Steele 1977}がこの論争が誤りであることを示しました)。
あるいは行毎の代入を思い浮かべることが初心者にとって手続呼出よりも簡単であるという見方も
あるでしょう。どのような理由しろ、このことは初級プログラマに対し
``私はこの変数をあれより前か後に設定するべきか?''といったプログラミングを複雑にし、重要な
考慮点を不明瞭にする心配事をしばしば負わせることになります。}



命令型プログラムの複雑さは複数のプロセスが並行に実行されるアプリケーションを
考える場合により悪くなります。この点については\link{Section 3.4}にて戻ります。
しかし最初に代入を含む表現のための計算モデルを提供する場合の問題を提示します。
そしてシミュレーションの設計においてローカルな状態を持つオブジェクトの使用を
検討します。

\begin{quote}
\heading{\phantomsection\label{Exercise 3.7}Exercise 3.7:} 
\link{Exercise 3.3}で記述したパスワード変更を用いる\code{make\-/account}により作成された
銀行口座オブジェクトについて考える。私達の銀行システムが連結口座の開設能力を
必要とすると仮定しよう。これを達成する手続\code{make\-/joint}を定義せよ。
\code{make\-/joint}は3つの引数を取らねばならない。第一はパスワードで守られた口座である。
第二引数はパスワードで\code{make\-/joint}命令が成功するためには口座が開設された時点の
パスワードに合致しなければならない。第三引数は新しいパスワードである。
\code{make\-/joint}は元の口座に対して新しいパスワードを用いる追加のアクセスを作成する。
例えば\code{peter\-/acc}がパスワード\code{open\-/sesame}を用いる銀行口座であれば、

\begin{scheme}
(define paul-acc
  (make-joint peter-acc 'open-sesame 'rosebud))
\end{scheme}

\noindent
上記は\code{peter\-/acc}に対し名前\code{paul\-/acc}とパスワード\code{rosebud}を用いて取引することを
可能にする。この新しい機能に対応するためあなたの\link{Exercise 3.3}への解答を
変更したいと思うだろう。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.8}Exercise 3.8:} 
\link{Section 1.1.3}にて評価モデルを定義した時、式の評価の最初のステップはその部分式を評価することだと
述べました。しかし部分式を評価する順については指定しませんでした。(例えば左から右や右から左です)。
代入を導入する時、手続に対する引数が評価される順は結果に違いを起こせます。以下の式を評価した時に、

\begin{scheme}
(+ (f 0) (f 1))
\end{scheme}



\code{+}の引数が左から右へ評価された場合に0を返し、右から左へ評価された場合に1を返すようにする
簡単な手続\code{f}を定義せよ。
\end{quote}

\section{評価の環境モデル}
\label{Section 3.2}


複合手続を\link{Chapter 1}で紹介した時、手続を引数に適用することが何を意味するか
定義するため評価の置換モデルを使用しました(\link{Section 1.1.5})。

\begin{itemize}

\item
複合手続を引数に適用するため、手続のボディを各形式パラメータを相対する引数で置き換えて評価する。

\end{itemize}

\noindent
一旦代入を私達のプログラミング言語で認めれば、そのような定義は最早適切でありません。
具体的には\link{Section 3.1.3}で議論しましたが、代入の出現により、変数は最早単に値に対する
名前であると考えることができません。そうでなく、変数はどうにかして値が格納できる``場所''を
指定することになります。私達の新しい評価モデルではこれらの場所は\newterm{environments}(\jnewterm{環境})と
呼ばれる構造に保存されます。



環境は\newterm{frames}(\jnewterm{フレーム})の列です。各フレームは\newterm{bindings}(\jnewterm{束縛})の
(空の可能性のある)テーブルで、変数名とそれらが相対する値とを結び付けます。
(単一のフレームは任意の変数に対してたかだか1つの束縛を保持します)。
各フレームはまた議論の目的のためフレームが\newterm{global}(\jnewterm{グローバル}、大域的)だと認識されない限り、
\newterm{enclosing environment}(\jnewterm{外部環境})へのポインタを持ちます。
環境に対して\newterm{value of a variable}(\jnewterm{変数の値})はその変数に対する束縛を持つ
環境内の最初のフレーム内の変数の束縛により与えられる値です。もし列内の全ての
フレームがその変数に対する束縛を指定しない場合、その変数はその環境に\newterm{unbound}(\jnewterm{束縛されない})
と呼びます。



\link{Figure 3.1}はI, II, IIIとラベリングした3つのフレームから成る簡単な環境構造を示しています。
図の中でA, B, C, Dは環境へのポインタです。CとDは同じ環境を差しています。変数\code{z}と\code{x}は
フレームIIに束縛され、一方\code{y}と\code{x}はフレームIに束縛されます。
環境Dの\code{x}の値は3です。環境Bに対する\code{x}の値もまた3です。これは次のように決定されます。
列の最初のフレーム(フレーム III)を調べますが\code{x}に対する束縛を見つけられません。
そのため外部環境Dで続けてフレーム Iの中に束縛を見つけます。一方で環境Aでの\code{x}の値は7です。
列の最初のフレーム(フレーム II)が\code{x}から7への束縛を含んでいるからです。
環境Aに対して、フレーム II内の\code{x}から7への束縛はフレーム Iの\code{x}から3への束縛を
\newterm{shadow}(\jnewterm{隠蔽する})と言われます。

\begin{figure}[tb]
\phantomsection\label{Figure 3.1}
\centering
\begin{comment}
\heading{Figure 3.1:} A simple environment structure.

\begin{example}
           +--------+
           |      I |
           | x: 3   |
           | y: 5   |
           +--------+
              ^  ^
              |  |
            C |  | D
+---------+   |  |   +----------+
|      II |   |  |   |      III |
| z: 6    +---+  +---+ m: 1     |
| x: 7    |          | y: 2     |
+---------+          +----------+
\end{example}
\end{comment}
\includegraphics[width=48mm]{fig/chap3/Fig3.1.pdf}
\par\bigskip
\noindent
\heading{Figure 3.1:} 単純な環境構造
\end{figure}

\noindent
環境は評価プロセスに対し不可欠な存在です。式が評価されるべきコンテキスト(文脈)を決定するためです。
実際にプログラミング言語の式、それ自身は意味を持たないと言えるでしょう。
そうでなく、式はそれが評価されるある環境に対してのみ意味を獲得します。
\code{(+ 1 1)}のような簡単な式の逐次実行でさえ、\code{+}が加算のためのシンボルであるというコンテキスト
のなかで操作しているという合意に依存しています。従って私達の評価モデルにおいて私達は常に
ある環境に対して式を評価すると述べます。インタプリタとの相互作用を説明するために、単一のフレームから
成り立ち(外部環境を持たず)、プリミティブな手続に関連するシステムの値を持つグローバル環境が
存在すると仮定します。例えば\code{+}が加算に対するシンボルであるという考えは、シンボル\code{+}が
グローバル環境においてプリミティブな加算手続に対し束縛されていると言うことで捉えられます。



\subsection{評価のルール}
\label{Section 3.2.1}



インタプリタが組み合わせをどのように評価するかの全体的な仕様は最初に\link{Section 1.1.3}にて紹介した時と
同じに残っています。

\begin{itemize}

\item
組み合わせを評価するために

\end{itemize}

\begin{enumerate}

\item
組み合わせの部分式を評価する。\footnote{
代入は評価ルールのステップ1に微妙さを取り込みます。\link{Exercise 3.8}に示されるように
代入の存在は組み合わせの部分式がどの順で評価されるかに依存して異なる値を生じます。
従って正確に述べればステップ1における評価順を指定せねばなりません。(例えば左から右や
右から左等)。しかしこの順は常に実装上の詳細と考えられねばなりません。
例えば洗練されたコンパイラはどの部分式が評価されるかの順を最適化のために変えるかもしれません。}

\item
オペレータ部分式の値をオペランド部分式の値に適用する。

\end{enumerate}

\noindent
評価の環境モデルは置換モデルを複合手続を引数に適用することの意味を指定することで
置き換えます。


評価の環境モデルでは手続は常にあるコードと環境へのポインタのペアから成り立ちます。
手続はただ1つの方法で作成されます。それは\( \lambda \)式を評価することです。
これによりコードが\( \lambda \)式のテキストから得られる手続が生成され、その環境は
\( \lambda \)式が手続を生成するために評価された環境になります。例えば以下の手続
定義について考えてみましょう。

\begin{scheme}
(define (square x)
  (* x x))
\end{scheme}

\noindent
この式はグローバル環境で評価されました。この手続定義の文法は根底にある暗黙的な
\( \lambda \)式のための糖衣構文です。これは次を行った場合と等価です。

\begin{scheme}
(define square
  (lambda (x) (* x x)))
\end{scheme}

\noindent
これは\code{(lambda (x) (* x x))}を評価し、全てグローバル環境において\code{square}をその結果に束縛します。



\link{Figure 3.2}はこの\code{define}式の評価結果を示します。手続オブジェクトは手続が1つの
形式パラメータ\code{x}を持ち手続のボディが\code{(* x x)}ことをコードが指定するペアです。
手続の環境部分はグローバル環境へのポインタです。それが\( \lambda \)式が手続を生じるため
評価される環境なためです。シンボル\code{square}と手続オブジェクトを関連付ける新しい束縛は
グローバルなフレームに追加されます。一般的に\code{define}はフレームに束縛を追加することで
定義を作成します。

\begin{figure}[tb]
\phantomsection\label{Figure 3.2}
\centering
\begin{comment}
\heading{Figure 3.2:} Environment structure produced by
evaluating \code{(define (square x) (* x x))} in the global environment.

\begin{example}
           +----------------------+
           | other variables      |
global --->|                      |
env        | square: --+          |
           +-----------|----------+
                       |       ^
(define (square x)     |       |
  (* x x))             V       |
                   .---.---.   |
                   | O | O-+---+
                   `-|-^---'
                     |
                     V
                   parameters: x
                   body: (* x x)
\end{example}
\end{comment}
\includegraphics[width=49mm]{fig/chap3/Fig3.2b.pdf}
\begin{quote}
\heading{Figure 3.2:} 大域環境内にて\code{(define (square x) (* x x))}を評価することにより生成された環境構造
\end{quote}
\end{figure}

\noindent
これで手続がどのように作成されるのか学んだので手続がどのように適用されるのかを
説明することができます。環境モデルは以下のことを指定します。手続を引数に適用するために、
パラメタを引数の値に束縛するフレームを含む新しい環境を作成します。このフレームの
外部環境は手続により指定された環境です。さて、この新しい環境で手続のボディを評価します。



このルールがどのように従われるかについて示すため、\link{Figure 3.3}は式\code{(square 5)}を
グローバル環境にて\code{square}が\link{Figure 3.2}にて生成された手続ある場合に評価することで
作成された環境構造を図示しています。この手続の適用は図でE1と示される新しい環境の作成に帰着し、
手続の形式パラメタ\code{x}が引数5に束縛されているフレームで始まっています。
このフレームから情報へ向かうポインタはフレームの外部環境がグローバル環境であることを示します。
\code{square}手続オブジェクトの一部として示される環境であるためここでグローバル環境が選択されます。
E1の中では手続のボディ\code{(* x x)}を評価します。E1中の\code{x}の値は5であるため結果は\code{(* 5 5)}、
つまり25です。

\begin{figure}[tb]
\phantomsection\label{Figure 3.3}
\centering
\begin{comment}
\heading{Figure 3.3:} Environment created by evaluating
\code{(square 5)} in the global environment.

\begin{example}
          +------------------------------------+
          | other variables                    |
global -->|                                    |
env       | square: --+                        |
          +-----------|---------------------+--+
                      |       ^             ^
(square 5)            |       |             |
                      V       |             |
                  .---.---.   |         +---+--+
                  | O | O-+---+   E1 -->| x: 5 |
                  `-|-^---'             +------+
                    |
                    V
                  parameters: x
                  body: (* x x)
\end{example}
\end{comment}
\includegraphics[width=78mm]{fig/chap3/Fig3.3b.pdf}
\begin{quote}
\heading{Figure 3.3:} 大域環境内にて\code{(square 5)}を評価することにより作られた環境
\end{quote}
\end{figure}

\noindent
手続適用の環境モデルは2つのルールでまとめられます。

\begin{itemize}

\item
手続オブジェクトはフレームを構築、手続の形式パラメタを呼出の引数へ束縛し、
新しく構築された環境のコンテキストにて手続のボディを評価することで引数の集合に
手続を適用することができる。

\item
手続は与えられた環境に関連する\( \lambda \)式を評価することで作成される。
結果としての手続オブジェクトは\( \lambda \)式のテキストと手続が作成された環境への
ポインタから成るペアである。

\end{itemize}

\noindent
\code{define}を用いてのシンボルの定義は現在の環境フレームに束縛を作成し、そのシンボルに
指示された値を束縛することもまた指摘します。\footnote{
もし既にその変数への束縛が現在のフレームに存在する場合、束縛は変更されます。
これはシンボルの再定義を可能にするため便利です。しかし\code{define}が値の変更に使用できる
こと、そしてこれが明示的に\code{set!}を使用せずとも代入の問題を持ち出すことを意味します。
このため既存のシンボルの再定義に対しエラーや警告を発することを好む人達もいます。}
最後に、\code{set!}の振舞を指定します。私達にそもそも環境モデルの導入を強いた命令です。
ある環境で式
\code{(set!}\( \;\langle \)\var{variable}\( \kern0.08em\rangle \)\( \;\langle \)\var{value}\( \kern0.08em\rangle \)\code{)}
を評価することはその環境に束縛を位置付け、その束縛を新しい値を示すよう変更します。
つまり\code{set!}は環境でその変数の束縛を持つ最初のフレームを探しそのフレームを変更します。
もし変数がその環境では束縛されていないのであれば\code{set!}はエラーを発します。



これらの評価ルールは置換モデルより大幅により複雑ですが、依然として適度に容易です。
さらに環境モデルは抽象的ですがインタプリタが式をどのように評価するかの正し説明を
与えます。\link{Chapter 4}ではこのモデルがどのようにうまく働くインタプリタの実装のための
設計図としての役を果たすのかについて学ぶことになります。
残りの節ではいくつかの実例となるプログラムを分析することによりこのモデルについての詳細を
述べます。


\subsection{単純な手続の適用}
\label{Section 3.2.2}



\link{Section 1.1.5}にて置換モデルを紹介した時、以下の手続定義を与えられた場合に
合成\code{(f 5)}がどのように136として評価されるかについて説明しました。

\begin{scheme}
(define (square x)
  (* x x))
(define (sum-of-squares x y)
  (+ (square x) (square y)))
(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))
\end{scheme}

\noindent
同じ式を環境モデルを用いて分析できます。\link{Figure 3.4}は3つの手続オブジェクトが
\code{f}, \code{square}, and \code{sum\-/of\-/squares}の定義を評価することでグローバル環境に
作成されたことを示します。各手続オブジェクトはいくつかのコードとグローバル環境への
ポインタから成り立ちます。

\begin{figure}[tb]
\phantomsection\label{Figure 3.4}
\centering
\begin{comment}
\heading{Figure 3.4:} Procedure objects in the global frame.

\begin{example}
          +--------------------------------------------+
          | sum-of-squares:                            |
global -->| square:                                    |
env       | f: --+                                     |
          +------|--------------+--------------+-------+
                 |     ^        |     ^        |     ^
                 |     |        |     |        |     |
                 V     |        V     |        V     |
             .---.---. |    .---.---. |    .---.---. |
             | O | O-+-+    | O | O-+-+    | O | O-+-+
             `-|-^---'      `-|-^---'      `-|-^---'
               |              |              |
               V              V              V
   parameters: a          parameters: x  parameters: x, y
   body: (sum-of-squares  body: (* x x)  body: (+ (square x)
           (+ a 1)                                (square y))
           (* a 2))
\end{example}
\end{comment}
\includegraphics[width=106mm]{fig/chap3/Fig3.4a.pdf}
\par\bigskip
\noindent
\heading{Figure 3.4:} グローバルフレーム内の手続オブジェクト
\end{figure}

\noindent
\link{Figure 3.5}は式\code{(f 5)}を評価することで作成された環境構造です。
\code{f}の呼出により\code{f}の形式パラメタ\code{a}が引数5に束縛されるフレームで始まる新しい環境E1が作成されます。
E1の中で\code{f}のボディを評価します。

\begin{scheme}
(sum-of-squares (+ a 1) (* a 2))
\end{scheme}

\noindent
この合成式を評価するために最初に部分式を評価します。最初の部分式\code{sum\-/of\-/squares}は
手続オブジェクトである値を持っています。(この値がどのように見つけられるかに注意して下さい。
最初にE1の第一フレームを調べますが\code{sum\-/of\-/squares}の束縛はありません。次に外部環境に
進みます。つまりグローバル環境です。そこで\link{Figure 3.4}に示すように束縛を見つけます)。
他の2つの部分式はプリミティブな命令\code{+}と\code{*}を、2つの合成式\code{(+ a 1)}と\code{(* a 2)}を
評価しそれぞれ6と10を得るために適用することで評価されます。



これで手続オブジェクト\code{sum\-/of\-/squares}を引数6と10に適用します。結果は形式パラメタ
\code{x}と\code{y}が引数に束縛される新しい環境E2へ帰着します。E2内では合成\code{(+ (square x) (square y))}
を評価します。これが\code{(square x)}の評価へと移り、\code{square}はグローバルフレームで見つかり、\code{x}は6です。
もう一度、新しい環境E3を立ち上げ、\code{x}は6に束縛されE3の中で\code{square}のボディ\code{(* x x)}が評価されます。
また\code{sum\-/of\-/squares}の適用の一部として部分式\code{(square y)}も評価さねばならずそこでは\code{y}は10です。
この2つ目の\code{square}の呼出がまた別の環境E4を作成し、そこでは\code{square}の形式パラメタ\code{x}は10に束縛されます。
そしてE4の中では\code{(* x x)}を評価せねばなりません。

\begin{figure}[tb]
\phantomsection\label{Figure 3.5}
\centering
\begin{comment}
\heading{Figure 3.5:} Environments created by evaluating
\code{(f 5)} using the procedures in \link{Figure 3.4}.

\begin{example}
          +-----------------------------------------------------+
global -->|                                                     |
env       +-----------------------------------------------------+
            ^              ^                ^               ^
(f 5)       |              |                |               |
        +------+       +-------+        +------+        +-------+
  E1 -->| a: 5 |  E2 ->| x: 6  |  E3 -->| x: 6 |  E4 -->| x: 10 |
        |      |       | y: 10 |        |      |        |       |
        +------+       +-------+        +------+        +-------+
   (sum-of-squares   (+ (square x)       (* x x)         (* x x)
     (+ a 1)            (square u))
     (+ a 2))
\end{example}
\end{comment}
\includegraphics[width=100mm]{fig/chap3/Fig3.5a.pdf}
\begin{quote}
\heading{Figure 3.5:} \link{Figure 3.4}内の手続を用いて\code{(f 5)}を評価することで作られた環境
\end{quote}
\end{figure}

\noindent
確認すべき重要な点は\code{square}の各呼出が\code{x}の束縛を持つ新しい環境を構築することです。
ここで私達は異なるフレームがどのようにして全て\code{x}と名付けられた異なるローカル変数の
独立を保つのかについて見ることができるます。\code{square}により作られた各フレームがグローバル
環境を差していることに注意して下さい。これは\code{square}手続オブジェクトが指す環境であるためです。



部分式が評価された後に結果が返されます。2つの\code{square}の呼出により作成された値は
\code{sum\-/of\-/squares}により加算され、この結果が\code{f}により返されます。ここでの私達の
焦点は環境構造上にありますのでこれらの返された値が呼出から呼出へどのように渡されるか
については長々と説明は致しません。しかし、これはまた評価処理の重要な側面であり、
\link{Chapter 5}にてこれの詳細に戻ります。

\begin{quote}
\heading{\phantomsection\label{Exercise 3.9}Exercise 3.9:} 
\link{Section 1.2.1}にて指数演算のための2つの手続を解析するために置換モデルを使用した。
以下が再帰版であり、

\begin{scheme}
(define (factorial n)
  (if (= n 1) 1 (* n (factorial (- n 1)))))
\end{scheme}

\noindent
以下は反復版である。

\begin{scheme}
(define (factorial n) (fact-iter 1 1 n))
(define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))
\end{scheme}




各版の\code{factorial}手続を用いて\code{(factorial 6)}を評価した場合に作成される環境構造を示せ。\footnote{
環境モデルはインタプリタは\code{fact\-/iter}のような手続を末尾再帰を用いることで一定量の記憶域にて実行できる
という\link{Section 1.2.1}での私達の主張を明確にはしません。末尾再帰については\link{Section 5.4}にてインタプリタの
コントロール構造を取り扱う時に議論します。}
\end{quote}


\subsection{局所状態のレポジトリとしてのフレーム}
\label{Section 3.2.3}


手続と代入がどのようにしてローカルな状態を持つオブジェクトを表現するために利用できるかを知るために
環境モデルに助けを求めることができます。

\begin{scheme}
(define (make-withdraw balance)
  (lambda (amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds")))
\end{scheme}

\noindent
次の定義の評価について説明してみましょう。

\begin{scheme}
(define W1 (make-withdraw 100))
\end{scheme}

\noindent
以下のように用いたとします。

\begin{scheme}
(W1 50)
~\textit{50}~
\end{scheme}

\noindent
\link{Figure 3.6}はグローバル環境における\code{make\-/withdraw}手続の定義の結果を示します。
グローバル環境へのポインタを持つ手続オブジェクトを作成します。今の所、これは今までに
見た例から異なる点はありません。ただし手続のボディそれ自身が\( \lambda \)式であることが
異なります。

\begin{figure}[tb]
\phantomsection\label{Figure 3.6}
\centering
\begin{comment}
\begin{quote}
\heading{Figure 3.6:} Result of defining \code{make\-/withdraw} in the global environment.

\begin{example}
          +---------------------------+
global -->| make-withdraw: --+        |
env       +------------------|--------+
                             |      ^
                             V      |
                         .---.---.  |
                         | O | O-+--+
                         `-|-^---'
                           |
                           V
         parameters: balance
         body: (lambda (amount)
                 (if (>= balance amount)
                     (begin (set! balance
                                  (- balance amount))
                            balance)
                     "Insufficient funds"))
\end{example}
\end{quote}
\end{comment}
\includegraphics[width=91mm]{fig/chap3/Fig3.6b.pdf}
\begin{quote}
\heading{Figure 3.6:} グローバル環境にて\code{make\-/withdraw}を定義した結果
\end{quote}
\end{figure}

\noindent
演算の面白い部分は手続\code{make\-/withdraw}を引数に適用した時に起こります。

\begin{scheme}
(define W1 (make-withdraw 100))
\end{scheme}

\noindent
通常通りに形式パラメタ\code{balance}が引数100に束縛される環境E1を設定することから始まります。
この環境の中で\code{make\-/withdraw}のボディ、即ち\( \lambda \)式を評価します。
これがコードは\code{lambda}で指定され、環境がE1である新しい手続オブジェクトが構築されます。
そのE1の中で\code{lambda}が手続を生成するため評価されています。
結果の手続オブジェクトは\code{make\-/withdraw}を呼び出して返された値です。
これはグローバル環境にて\code{W1}に束縛されます。\code{define}自身がグローバル環境にて評価されたためです。
\link{Figure 3.7}は結果の環境構造を示します。

これで\code{W1}が引数に適用された時に何が起こるかを解析できます。

\begin{scheme}
(W1 50)
~\textit{50}~
\end{scheme}

\begin{figure}[tb]
\phantomsection\label{Figure 3.7}
\centering
\begin{comment}
\heading{Figure 3.7:} Result of evaluating \code{(define W1 (make\-/withdraw 100))}.

\begin{example}
          +-----------------------------------------------+
          | make-withdraw: -----------------------+       |
global -->|                                       |       |
          | W1: --+                               |       |
          +-------|-------------------------------|-------+
                  |                ^              |     ^
                  |                |              V     |
                  |        +-------+------+   .---.---. |
                  |  E1 -->| balance: 100 |   | O | O-+-+
                  |        +--------------+   `-|-^---'
                  V                ^            |
              .---.---.            |            V
            +-+-O | O-+------------+    parameters: balance
            | `---^---'                 body: ...
            V
    parameters: amount
    body: (if (>= balance amount)
              (begin (set! balance (- balance amount))
                     balance)
              "Insufficient funds")
\end{example}
\end{comment}
\includegraphics[width=100mm]{fig/chap3/Fig3.7a.pdf}
\par\bigskip
\noindent
\heading{Figure 3.7:} \code{(define W1 (make\-/withdraw 100))}を評価した結果
\end{figure}

\noindent
\code{W1}の形式パラメタ\code{amount}が引数50に束縛されるフレームを構築することから始めます。
観察すべき重大な点はこのフレームがその外部環境としてグローバル環境ではなく環境E1を持って
いる点です。これが\code{W1}手続オブジェクトにより指示される環境だからです。
この新しい環境の中で手続のボディを評価します。

\begin{scheme}
(if (>= balance amount)
    (begin (set! balance (- balance amount))
           balance)
    "Insufficient funds")
\end{scheme}

\noindent
結果の環境構造は\link{Figure 3.8}に示されます。評価された式は\code{amount}と\code{balance}の両方を
参照します。\code{amount}は環境の最初のフレームに見つかりますが、\code{balance}は外部環境ポインタに
従ってE1にて見つかります。

\begin{figure}[tb]
\phantomsection\label{Figure 3.8}
\centering
\begin{comment}
\heading{Figure 3.8:} Environments created by applying the procedure object \code{W1}.

\begin{example}
          +---------------------------------------------------+
          | make-withdraw: ...                                |
global -->|                                                   |
env       | W1: --+                                           |
          +-------|-------------------------------------------+
                  |               ^
                  |               |
                  |       +-------+------+ Here is the balance
                  | E1 -->| balance: 100 | that will be changed
                  |       +--------------+ by the set!.
                  V               ^   ^
              .---.---.           |   +----+
              | O | O-+-----------+        |
              `-|-^---'             +------+-----+
                |                   | amount: 50 |
                V                   +------------+
      parameters: amount   (if (>= balance amount)
      body: ...                (begin (set! balance
                                            (- balance amount))
                                      balance)
                               "Insufficient funds")
\end{example}
\end{comment}
\includegraphics[width=99mm]{fig/chap3/Fig3.8c.pdf}
\par\bigskip
\noindent
\heading{Figure 3.8:} 手続オブジェクト\code{W1}を適用したことにより作成された環境
\end{figure}

\noindent
\code{set!}が実行された時、E1中の\code{balance}の束縛は変更されます。\code{W1}の呼出が終了する時
\code{balance}は50で、\code{balance}を含むフレームは依然手続オブジェクト\code{W1}から指されています。
\code{amount}を束縛する(その中で\code{balance}を変更するコードを実行した)フレームは最早関係が存在しません。
それを構築した手続呼出は停止したためです。そしてその環境の他の部分からそのフレームを指す
ポインタは存在しません。次回\code{W1}が呼ばれた時、\code{amount}を束縛する新しいフレームが構築され
その外部環境はE1になります。私達はE1が手続オブジェクト\code{W1}のためのローカル状態を持つ``場所''の
役割を果たすのを見ました。\link{Figure 3.9}は\code{W1}を呼び出した後の状況を示します。



二つ目の``withdraw''オブジェクトを別の\code{make\-/withdraw}呼出を行うことで作成した時に何が起こるかについて
観察して下さい。

\begin{scheme}
(define W2 (make-withdraw 100))
\end{scheme}

\begin{figure}[tb]
\phantomsection\label{Figure 3.9}
\centering
\begin{comment}
\heading{Figure 3.9:} Environments after the call to \code{W1}.

\begin{example}
           +------------------------------------+
           | make-withdraw: ...                 |
global --->|                                    |
env        | W1: --+                            |
           +-------|----------------------------+
                   |                   ^
                   |                   |
                   |            +------+------+
                   |     E1 --->| balance: 50 |
                   |            +-------------+
                   V                   ^
               .---.---.               |
               | O | O-+---------------+
               `-|-^---'
                 |
                 V
          parameters: amount
          body: ...
\end{example}
\end{comment}
\includegraphics[width=96mm]{fig/chap3/Fig3.9a.pdf}
\par\bigskip
\noindent
\heading{Figure 3.9:} \code{W1}呼出後の環境
\end{figure}

\begin{figure}[tb]
\phantomsection\label{Figure 3.10}
\centering
\begin{comment}
\heading{Figure 3.10:} Using \code{(define W2 (make\-/withdraw 100))} to create a second object.

\begin{example}
         +-------------------------------------------------+
         | make-withdraw: ...                              |
global ->| W2: ---------------------------+                |
env      | W1: --+                        |                |
         +-------|------------------------|----------------+
                 |              ^         |              ^
                 |              |         |              |
                 |       +------+------+  |       +------+-------+
                 |  E1 ->| balance: 50 |  |  E2 ->| balance: 100 |
                 |       +-------------+  |       +--------------+
                 V              ^         V              ^
             .---.---.          |     .---.---.          |
             | O | O-+----------+     | O | O-+----------+
             `-|-^---'                `-|-^---'
               | +----------------------+
               V V
        parameters: amount
        body: ...
\end{example}
\end{comment}
\includegraphics[width=108mm]{fig/chap3/Fig3.10a.pdf}
\begin{quote}
\heading{Figure 3.10:} \code{(define W2 (make\-/withdraw 100))}を用いて2つ目のオブジェクトを作成
\end{quote}
\end{figure}

\noindent
これにより\link{Figure 3.10}の環境構造が生成され\code{W2}が手続オブジェクトであり、ある程度のコードと
環境によるペアであることを示しています。\code{W2}のための環境E2は\code{make\-/withdraw}の呼出により作成されます。
それ専用の\code{balance}のためのローカルな状態を持つフレームを含みます。一方で\code{W1}と\code{W2}は同じ
コードを持ちます。\code{make\-/withdraw}のボディ内の\( \lambda \)式によりコードは指定されています。\footnote{
\code{W1}と\code{W2}が計算機内の同じ物理コードを共有しているかどうか、またはそれぞれがコードのコピーを持っているのか
は実装上の詳細です。\link{Chapter 4}で実装するインタプリタではコードは実際に共有されます。}
なぜ\code{W1}と\code{W2}が独立したオブジェクトとして振る舞うのかをここで見ました。
\code{W1}の呼出はE1に格納された状態変数\code{balance}を参照し、一方\code{W2}の呼出はE2に格納された\code{balance}を
参照します。従って一方のオブジェクトのローカル状態への変更は他方のオブジェクトに影響を与えません。

\begin{quote}
\heading{\phantomsection\label{Exercise 3.10}Exercise 3.10:} 
\code{make\-/withdraw}手続ではローカル変数\code{balance}は\code{make\-/withdraw}のパラメタと
して作成される。ローカル状態変数を明示的に\code{let}を使って以下の様に作成することもできる。

\begin{scheme}
(define (make-withdraw initial-amount)
  (let ((balance initial-amount))
    (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))))
\end{scheme}



\link{Section 1.3.2}で\code{let}は手続呼出のための単純な糖衣構文であったことを思い出そう。

\begin{scheme}
(let ((~\( \dark \langle \)~~\var{\dark var}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark exp}~~\( \dark \rangle \)~)) ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
上記は代替的な文法として以下に翻訳される。

\begin{scheme}
((lambda (~\( \dark \langle \)~~\var{\dark var}~~\( \dark \rangle \)~) ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~) ~\( \dark \langle \)~~\var{\dark exp}~~\( \dark \rangle \)~)
\end{scheme}


環境モデルを用いてこの\code{make\-/withdraw}の代替版を解析し、先に記述したような図を描き
相互作用を説明せよ。

\begin{scheme}
(define W1 (make-withdraw 100))
(W1 50)
(define W2 (make-withdraw 100))
\end{scheme}



\code{make\-/withdraw}の2つの版が同じ振舞を持つオブジェクトを作成することを示せ。
環境構造は2つの版でどのように違うか?
\end{quote}


\subsection{内部定義}
\label{Section 3.2.4}


\link{Section 1.1.8}では手続が内部定義を持つこことができ、結果としてブロック構造へと導くことを
説明しました。以下の平方根を求める手続がその例です。

\begin{scheme}
(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
\end{scheme}

\noindent
さて環境モデルを用いてなぜこれらの内部定義が希望通りに振る舞うのかを調べることができます。
\link{Figure 3.11}は内部手続\code{good\-/enough?}が\code{guess}が1に等しい場合に
最初に呼ばれた状態で式\code{(sqrt 2)}を評価した時点を示しています。



環境構造を観察して下さい。\code{sqrt}はグローバル環境におけるシンボルであり
手続オブジェクトに束縛され、その関連する環境はグローバル環境です。
\code{sqrt}が呼ばれた時、新しい環境E1が形成されグローバル環境の下位に置かれ、
その中ではパラメタ\code{x}が2に束縛されます。\code{sqrt}のボディが次にE1の中で
評価されます。\code{sqrt}のボディの最初の式は以下であり、

\begin{scheme}
(define (good-enough? guess)
  (< (abs (- (square guess) x)) 0.001))
\end{scheme}

\noindent
この式を評価すると手続\code{good\-/enough?}が環境E1の中に定義されます。具体的には、
シンボル\code{good\-/enough?}がE1の最初のフレームに追加され環境E1を指す手続オブジェクトに束縛
されます。同様に\code{improve}と\code{sqrt\-/iter}がE1の中に手続として定義されます。
簡潔さのために、\link{Figure 3.11}は\code{good\-/enough?}に対する手続オブジェクトのみを
示しています。

\begin{figure}[tb]
\phantomsection\label{Figure 3.11}
\centering
\begin{comment}
\heading{Figure 3.11:} \code{Sqrt} procedure with internal definitions.

\begin{example}
          +--------------------------------------------------+
global -->| sqrt: --+                                        |
env       |         |                                        |
          +---------|----------------------------------------+
                    V       ^                   ^
                .---.---.   |                   |
     +----------+-O | O-+---+        +----------+------------+
     |          `---^---'            | x: 2                  |
     V                         E1 -->| good-enough?: -+      |
parameters: x                        | improve: ...   |      |
body: (define good-enough? ...)      | sqrt-iter: ... |      |
      (define improve ...)           +----------------|------+
      (define sqrt-iter ...)          ^  ^            |     ^
      (sqrt-iter 1.0)                 |  |            V     |
                            +---------++ |        .---.---. |
                      E2 -->| guess: 1 | |        | O | O-+-+
                            +----------+ |        `-|-^---'
                      call to sqrt-iter  |          |
                                         |          V
                               +---------++    parameters: guess
                         E3 -->| guess: 1 |    body: (< (abs ...)
                               +----------+             ...)
                         call to good-enough?
\end{example}
\end{comment}
\includegraphics[width=107mm]{fig/chap3/Fig3.11a.pdf}
\begin{quote}
\heading{Figure 3.11:} 内部定義を持つ\code{sqrt}手続
\end{quote}
\end{figure}


\noindent
ローカル手続が定義された後に、式\code{(sqrt\-/iter 1.0)}がまた環境E1の中で評価されます。
そのためE1の中で\code{sqrt\-/iter}に束縛された手続オブジェクトが引数1にて呼ばれます。
これが環境E2を作成し\code{sqrt\-/iter}のパラメタである\code{guess}が1に束縛される。
\code{sqrt\-/iter}は次に\code{good\-/enough?}を(E2の)\code{guess}の値を引数として呼びます。
これが別の環境E3を構築し(\code{good\-/enough?}の引数である)\code{guess}が1に束縛されます。
\code{sqrt\-/iter}と\code{good\-/enough?}の両方が\code{guess}という名前のパラメタを持ちますが、
2つの区別可能なローカル変数が異なるフレームの中に存在します。またE2とE3の両方が
E1を外部環境として持ちます。手続\code{sqrt\-/iter}と\code{good\-/enough?}の両方がE1をそれらの
環境部分として持つためです。これの結果の1つとして\code{good\-/enough?}のボディ内のシンボル\code{x}は
E1内に存在する\code{x}の束縛を参照します。即ち元の\code{sqrt}手続が呼ばれた時の\code{x}の値です。


環境モデルは従ってローカル手続定義をプログラムのモジュール化するための便利なテクニックとする
2つの鍵となる性質を説明します。

\begin{itemize}

\item
ローカル手続の名前は(直の)外部手続の外側の名前と衝突しない。ローカル手続の名前は
手続が実行される時に作成したフレーム内にて束縛されるのであり、グローバル環境内で
束縛される訳でありません。

\item
ローカルな手続はそれを内包する外部手続の引数にアクセスすることができます。
単純にパラメタの名前を自由変数として用いるだけです。これはローカル手続のボディは
外部手続のための評価環境の下位に置かれる環境内で評価されるためです。

\end{itemize}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.11}Exercise 3.11:} 
\link{Section 3.2.3}では環境モデルがどのようにローカルな状態を持つ手続の振舞を説明するかについて
学んだ。ここまでで内部定義がどのように働くかについて理解した。典型的なメッセージパッシング
手続はこれらの側面の両方を持っている。\link{Section 3.1.1}の銀行口座について考えよう。

\begin{scheme}
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else 
           (error "Unknown request: 
                   MAKE-ACCOUNT"
                  m))))
  dispatch)
\end{scheme}



以下の応答により生成される環境構造を示せ。

\begin{scheme}
(define acc (make-account 50))
((acc 'deposit) 40)
~\textit{90}~
((acc 'withdraw) 60)
~\textit{30}~
\end{scheme}



\code{acc}の局所状態はどこにあるか? 別の口座を定義したとする。

\begin{scheme}
(define acc2 (make-account 100))
\end{scheme}


2つの口座の局所状態はどのように区別されるか? 環境構造のどの部分が\code{acc}と\code{acc2}にて
共有されるか?
\end{quote}

\section{ミュータブルデータによるモデリング}
\label{Section 3.3}



\link{Chapter 2}では複合データを計算オブジェクトを構築する手段として扱いました。これは
複数の側面を持つ実際の世界のオブジェクトをモデル化するためにいくつかの
部品を持ちます。また\link{Chapter 2}では
データオブジェクトを作成するコンストラクタと、
複合データオブジェクトの部品にアクセスするセレクタを用いてどのデータ構造が指定されるか
に準ずるデータ抽象化の規律についても紹介しました。
しかし今では\link{Chapter 2}が解決しなかったデータの別の側面があることを私達は知りました。
状態が変化するオブジェクトにより成るシステムをモデル化したいという欲求複合データオブジェクトを
構築することやそれらから選択することと同様に変更することの必要性へと導きます。
変換する状態を持つ複合オブジェクトをモデル化するために、セレクタやコンストラクタ
に追加して、データオブジェクトを変更する\newterm{mutators}(\jnewterm{ミューテータ}、変化させる物)と呼ばれる
命令を含むようにデータ抽象化を設計することにします。
例えば、銀行システムのモデル化は口座の差引残高を変更する必要があります。従って銀行口座を表現する
データ構造は以下の命令を許可するでしょう。

\begin{scheme}
(setbalance! ~\( \dark \langle \)~~\var{\dark account}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark newvalue}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
これは指定した口座の差引残高を指定した新しい値に変更します。ミューテータが定義された
データオブジェクトは\newterm{mutable data objects}(\jnewterm{ミュータブルデータオブジェクト}、
変更可能なオブジェクト)として知られます。


\link{Chapter 2}は複合データを合成するため汎用目的の``糊''としてのペアを紹介しました。
この節はペアのための基本的なミューテータを定義することから始め、ペアが変更可能な
データオブジェクトを構築するための架設ブロックとして供給できるようにします。
これらのミューテータはペアの表現力を大きく拡張し、\link{Section 2.2}で用いた列と木以外のデータ構造を
構築することを可能にします。複雑なシステムが局所状態を持つオブジェクトの集合としてモデル化される
シミュレーションのいくつかの例も紹介します。



\subsection{ミュータブルなリスト構造}
\label{Section 3.3.1}



ペア上の基本的な命令---\code{cons}, \code{car}, \code{cdr}---はリスト構造の構築と
リスト構造からの部品の選択に用いることができます。しかしそれらはリスト構造を変更する
能力はありませんでした。同じことが今までに使用した\code{append}や\code{list}の様な
リスト命令にも正しいと言えます。これらが\code{cons}, \code{car}, \code{cdr}を用いて定義できる
ためです。リスト構造を変更するため新しい命令が必要です。



ペアのプリミティブなミューテータは\code{set\-/car!}と\code{set\-/cdr!}です。
\code{set\-/car!}は2つの引数を取り、第一引数はペアでなければなりません。
このペアの\code{car}ポインタを\code{set\-/car!}の第二引数へのポインタで置き換えることでペアを変更します。\footnote{
\code{set\-/car!}と\code{set\-/cdr!}は実装依存な値を返します。\code{set!}と同様にそれらはそれらの効果のためだけに
使用されるべきです。}

\begin{figure}[tp]
\phantomsection\label{Figure 3.12}
\centering
\begin{comment}
\heading{Figure 3.12:} Lists \code{x}: \code{((a b) c d)} and \code{y}: \code{(e f)}.

\begin{example}
     +---+---+     +---+---+     +---+---+
x -->| * | *-+---->| * | *-+---->| * | / |
     +-|-+---+     +-|-+---+     +-|-+---+
       |             V             V
       |           +---+         +---+
       |           | c |         | d |
       |           +---+         +---+
       |           +---+---+     +---+---+
       +---------->| * | *-+---->| * | / |
                   +-|-+---+     +-|-+---+
                     V             V
                   +---+         +---+
                   | a |         | b |
                   +---+         +---+
                   +---+---+     +---+---+
              y -->| * | *-+---->| * | / |
                   +-|-+---+     +-|-+---+
                     V             V
                   +---+         +---+
                   | e |         | f |
                   +---+         +---+
\end{example}
\end{comment}
\includegraphics[width=72mm]{fig/chap3/Fig3.12b.pdf}
\begin{quote}
\heading{Figure 3.12:} リスト \code{x}: \code{((a b) c d)}と\code{y}: \code{(e f)}
\end{quote}
\end{figure}




例として\link{Figure 3.12}に示すように\code{x}がリスト\code{((a b) c d)}に、\code{y}がリスト\code{(e f)}に
束縛されているとします。式\code{ (set\-/car!  x y)}の評価は\code{x}が束縛されているペアを変更し、
その\code{car}を\code{y}の値で置き換えます。命令の結果は\link{Figure 3.13}に示されています。
構造\code{x}が変更され\code{((e f) c d)}となりました。リスト\code{(a b)}を表すペアは、置き換えられた
ポインタにより特定されていましが、元の構造から取り外されました。\footnote{
この点からリストの変更命令はどのアクセス可能な構造の部分でもない``garbage''(ゴミ)を作り得ることが
わかります。\link{Section 5.3.2}にてLispのメモリ管理システムが\newterm{garbage collector}(\jnewterm{ガベージコレクタ}、
清掃局員)を持ち、それにより必要の無いペアにより使用されているメモリ空間を判断しリサイクルを行います。}



\link{Figure 3.13}と\link{Figure 3.14}を比べてください。これは\code{x}と\code{y}が\link{Figure 3.12}の元のリストに
束縛されている時に\code{(define z (cons y (cdr x)))}を実行した結果を図示しています。
変数\code{z}はこれで\code{cons}命令により作成された新しいペアに束縛されます。\code{x}が束縛される
リストは変更されません。


\begin{figure}[bp]
\phantomsection\label{Figure 3.13}
\centering
\begin{comment}
\heading{Figure 3.13:} Effect of \code{(set\-/car! x y)} on the lists in \link{Figure 3.12}.

\begin{example}
     +---+---+     +---+---+     +---+---+
x -->| * | *-+---->| * | *-+---->| * | / |
     +-|-+---+     +-|-+---+     +-|-+---+
       |             V             V
       |           +---+         +---+
       |           | c |         | d |
       |           +---+         +---+
       |           +---+---+     +---+---+
       |           | * | *-+---->| * | / |
       |           +-|-+---+     +-|-+---+
       |             V             V
       |           +---+         +---+
       |           | a |         | b |
       |           +---+         +---+
       +---------->+---+---+     +---+---+
                   | * | *-+---->| * | / |
              y -->+-|-+---+     +-|-+---+
                     V             V
                   +---+         +---+
                   | e |         | f |
                   +---+         +---+
\end{example}
\end{comment}
\includegraphics[width=72mm]{fig/chap3/Fig3.13b.pdf}
\par\bigskip
\noindent
\heading{Figure 3.13:} \link{Figure 3.12}のリスト上での\code{(set\-/car! x y)}の効果
\end{figure}


\begin{figure}[tp]
\phantomsection\label{Figure 3.14}
\centering
\begin{comment}
\heading{Figure 3.14:} Effect of \code{(define z (cons y (cdr x)))} on the lists in \link{Figure 3.12}.

\begin{example}
     +---+---+     +---+---+     +---+---+
x -->| * | *-+---->| * | *-+---->| * | / |
     +-|-+---+ +-->+-|-+---+     +-|-+---+
       |       |     V             V
       |       |   +---+         +---+
       |       |   | c |         | d |
       |       |   +---+         +---+
       |       |   +---+---+     +---+---+
       +-------+-->| * | *-+---->| * | / |
               |   +-|-+---+     +-|-+---+
     +---+---+ |     V             V
z -->| * | *-+-+   +---+         +---+
     +-|-+---+     | a |         | b |
       |           +---+         +---+
       +---------->+---+---+     +---+---+
                   | * | *-+---->| * | / |
              y -->+-|-+---+     +-|-+---+
                     V             V
                   +---+         +---+
                   | e |         | f |
                   +---+         +---+
\end{example}
\end{comment}
\includegraphics[width=72mm]{fig/chap3/Fig3.14b.pdf}
\begin{quote}
\heading{Figure 3.14:} \link{Figure 3.12}のリスト上での\code{(define z (cons y (cdr x)))}の効果
\end{quote}
\end{figure}

\clearpage


\noindent
\code{set\-/cdr!}命令は\code{set\-/car!}と同様です。違いは\code{car}ポインタでなく、\code{cdr}ポインタが置き換えられます。
\link{Figure 3.12}のリスト上での\code{(set\-/cdr! x y)}の実行の結果は\link{Figure 3.15}に示されます。
ここでは\code{x}の\code{cdr}ポインタは\code{(e f)}へのポインタにて置き換えられます。また\code{x}の\code{cdr}として用いられる
リスト\\\code{(c d)}はこれで構造から取り外されます。

\enlargethispage{\baselineskip}

\begin{figure}[bp]
\phantomsection\label{Figure 3.15}
\centering
\begin{comment}
\heading{Figure 3.15:} Effect of \code{(set\-/cdr! x y)} on the lists in \link{Figure 3.12}.

\begin{example}
     +---+---+     +---+---+     +---+---+
x -->| * | * |     | * | *-+---->| * | / |
     +-|-+-|-+     +-|-+---+     +-|-+---+
       |   |         V             V
       |   |       +---+         +---+
       |   |       | c |         | d |
       |   |       +---+         +---+
       |   |       +---+---+     +---+---+
       +---+------>| * | *-+---->| * | / |
           |       +-|-+---+     +-|-+---+
           |         V             V
           |       +---+         +---+
           |       | a |         | b |
           |       +---+         +---+
           +------>+---+---+     +---+---+
                   | * | *-+---->| * | / |
              y -->+-|-+---+     +-|-+---+
                     V             V
                   +---+         +---+
                   | e |         | f |
                   +---+         +---+
\end{example}
\end{comment}
\includegraphics[width=72mm]{fig/chap3/Fig3.15b.pdf}
\par\bigskip
\noindent
\heading{Figure 3.15:} \link{Figure 3.12}のリスト上での\code{(set\-/cdr! x y)}の効果
\end{figure}

\code{cons}は新しいリスト構造を新しいペアを作成することで構築します。一方、\code{set\-/car!}と\code{set\-/cdr!}は
既存のペアを変更します。実際に2つのミューテータと既存のリスト構造の一部ではない新しいペアを返す
\code{get\-/new\-/pair}を一緒に用いて\code{cons}を実装することができます。
新しいペアを得てからその\code{car}と\code{cdr}ポインタに指定されたオブジェクトを設定し、\code{cons}の結果として
返します。\footnote{
\code{get\-/new\-/pair}はLisp実装にて必要とされるメモリ管理の一部として実装されなければならない
命令の1つです。これについては \link{Section 5.3.1}にて議論します。}

\begin{scheme}
(define (cons x y)
  (let ((new (get-new-pair)))
    (set-car! new x)
    (set-cdr! new y)
    new))
\end{scheme}

\clearpage

\begin{quote}
\heading{\phantomsection\label{Exercise 3.12}Exercise 3.12:} 
リストを接続するための以下の手続は\link{Section 2.2.1}で紹介した。

\begin{scheme}
(define (append x y)
  (if (null? x)
      y
      (cons (car x) (append (cdr x) y))))
\end{scheme}



\code{append}は\code{y}に連続して\code{x}の要素を\code{cons}することで新しいリストを作る。
手続\code{append!}は\code{append}と同様だが、コンストラクタではなくミューテータである。
これは\code{x}の最後のペアを変更しその\code{cdr}を\code{y}にし両者を繋ぎ合わせることで
append(付け加え)する。
(\code{append!}を空の\code{x}にて呼ぶのはエラーとなる)。

\begin{scheme}
(define (append! x y)
  (set-cdr! (last-pair x) y)
  x)
\end{scheme}


ここで\code{last\-/pair}はその引数の最後のペアを返す手続である。

\begin{scheme}
(define (last-pair x)
  (if (null? (cdr x)) x (last-pair (cdr x))))
\end{scheme}



以下の応答について考えよ。

\begin{scheme}
(define x (list 'a 'b))
(define y (list 'c 'd))
(define z (append x y))
z
~\textit{(a b c d)}~
(cdr x)
~\( \dark \langle \)~~\var{\dark response}~~\( \dark \rangle \)~
(define w (append! x y))
w
~\textit{(a b c d)}~
(cdr x)
~\( \dark \langle \)~~\var{\dark response}~~\( \dark \rangle \)~
\end{scheme}



欠けている\( \langle \)\var{response}\( \rangle \)は何か?
箱とポインタの図をあなたの答を説明するために描け。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.13}Exercise 3.13:}
次の\code{make\-/cycle}手続について考えよ。これは\link{Exercise 3.12}で定義した
\code{last\-/pair}手続を用いる。

\begin{scheme}
(define (make-cycle x)
  (set-cdr! (last-pair x) x)
  x)
\end{scheme}


以下の様に作成される\code{z}を表す箱とポインタの図を描け。

\begin{scheme}
(define z (make-cycle (list 'a 'b 'c)))
\end{scheme}


\code{(last\-/pair z)}を演算すると何が置こるか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.14}Exercise 3.14:} 
以下の手続はとても便利であるが不明瞭である。

\begin{scheme}
(define (mystery x)
  (define (loop x y)
    (if (null? x)
        y
        (let ((temp (cdr x)))
          (set-cdr! x y)
          (loop temp x))))
  (loop x '()))
\end{scheme}



\code{loop}は``temporary''(一時的)な変数\code{temp}を用いて\code{x}の\code{cdr}を保存する。
次の行の\code{set\-/cdr!}が\code{cdr}を破壊するためである。\code{mystery}が通常何を行うのか
説明せよ。\code{v}が\code{(define v (list 'a 'b 'c 'd))}で定義されているとする。
\code{v}が束縛されるリストを表す箱とポインタの図を描け。次に\code{(define w (mystery v))}を
評価したとする。この式を評価した後の\code{v}と\code{w}の構造を表す箱とポインタの図を描け。
\code{v}と\code{w}の値として何が表示されるか?
\end{quote}

\subsubsection*{共有と自己同一性}



\link{Section 3.1.3}で代入の導入に伴う``同一性''と``変更''という論理的な問題について記述しました。
これらの問題は実際の所個々のペアが異なるデータオブジェクトの間で\newterm{shared}(\jnewterm{共有})
されている時に問題となります。例えば、以下の様に形成される構造について考えてみて下さい。

\begin{scheme}
(define x (list 'a 'b))
(define z1 (cons x x))
\end{scheme}

\noindent
\link{Figure 3.16}で示されるように、\code{z1}はその\code{car}と\code{cdr}の両者が同じペア\code{x}を
指している。この\code{z1}の\code{car}と\code{cdr}による\code{x}の共有は\code{cons}が
直接的な方法で実装されていることによる結果です。一般的に\code{cons}を用いてリストを構築する
ことは多くの個別のペアが多くの異なる構造において共有される、ペアの連結構造に帰着します。


\link{Figure 3.16}とは対照的に、\link{Figure 3.17}は以下の式で作成された構造を示します。

\begin{scheme}
(define z2 (cons (list 'a 'b) (list 'a 'b)))
\end{scheme}

\noindent
この構造においては、2つの\code{(a b)}リスト内のペアは実際のシンボルが共有されていても区別可能です。\footnote{
2つのペアは各\code{cons}呼出が新しいペアを返すため区別可能です。シンボルは共有されています。
Schemeではどの与えられた名前にも固有のシンボルが存在します。Schemeがシンボルを変更する手段を
全く提供しないため、この共有は判別不可能です。共有が単純にポインタの等価性をチェックする\code{eq?}を用いて
シンボルで比較することを可能にする物であることにも注意して下さい。}

\begin{figure}[tb]
\phantomsection\label{Figure 3.16}
\centering
\begin{comment}
\heading{Figure 3.16:} The list \code{z1} formed by \code{(cons x x)}.

\begin{example}
      +---+---+
z1 -->| * | * |
      +-|-+-|-+
        V   V
      +---+---+     +---+---+
 x -->| * | *-+---->| * | / |
      +-|-+---+     +-|-+---+
        V             V
      +---+         +---+
      | a |         | b |
      +---+         +---+
\end{example}
\end{comment}
\includegraphics[width=46mm]{fig/chap3/Fig3.16b.pdf}
\begin{quote}
\heading{Figure 3.16:} \code{(cons x x)}.で形成されたリスト\code{z1}
\end{quote}
\end{figure}

\begin{figure}[tb]
\phantomsection\label{Figure 3.17}
\centering
\begin{comment}
\begin{quote}
\heading{Figure 3.17:} The list \code{z2} formed by \code{(cons (list 'a 'b) (list 'a 'b))}.

\begin{example}
      +---+---+     +---+---+     +---+---+
z2 -->| * | *-+---->| * | *-+---->| * | / |
      +-|-+---+     +-|-+---+     +-|-+---+
        |             V             V
        |           +---+         +---+
        |           | a |         | b |
        |           +---+         +---+
        |             ^             ^
        |             |             |
        |           +-|-+---+     +-|-+---+
        +---------->| * | *-+---->| * | / |
                    +---+---+     +---+---+
\end{example}
\end{quote}
\end{comment}
\includegraphics[width=71mm]{fig/chap3/Fig3.17b.pdf}
\begin{quote}
\heading{Figure 3.17:} \code{(cons (list 'a 'b) (list 'a 'b))}により形成されたリスト\code{z2}
\end{quote}
\end{figure}

\noindent
リストとして考えた時、\code{z1}と\code{z2}の両方が``同じ''リスト\code{((a b) a b)}を表現します。
一般的に共有はリスト上で用いる命令が\code{cons}, \code{car}, \code{cdr}だけならば完全に検出不可能です。
しかしリスト構造上で変更を許可するのであれば、共有に気付くことができます。
共有が作成できる違いの例として、適用された引数の構造の\code{car}を変更する以下の手続について
考えてみましょう。

\begin{scheme}
(define (set-to-wow! x) (set-car! (car x) 'wow) x)
\end{scheme}

\noindent
例え\code{z1}と\code{z2}が``同じ''構造だとしても、\code{set\-/to\-/wow!}をそれらに適用すると異なる結果を返します。
\code{z1}では\code{car}の変更は\code{cdr}も変更します。\code{z1}では\code{car}と\code{cdr}が同じペアであるためです。
\code{z2}では\code{car}と\code{cdr}は区別可能なので\code{set\-/to\-/wow!}は\code{car}のみを変更します。

\begin{scheme}
z1
~\textit{((a b) a b)}~
(set-to-wow! z1)
~\textit{((wow b) wow b)}~
z2
~\textit{((a b) a b)}~
(set-to-wow! z2)
~\textit{((wow b) a b)}~
\end{scheme}

\noindent
リスト構造中の共有を見つける一つの方法は\link{Section 2.3.1}で2つのシンボルが等しいかテストする方法として
紹介した述語\code{eq?}を用います。より一般的には\code{(eq?  x y)}は\code{x}と\code{y}が同じオブジェクトであるか
をテストします(これはつまり\code{x}と\code{y}はポインタとして等しいかです)。従って\link{Figure 3.16}と
\link{Figure 3.17}で示すよう定義された\code{z1}と\code{z2}


以降の節で示されるように、ペアで表現可能なデータ構造のレパートリを大きく拡張することが共有を用いてできます。
一方で、共有はまた危険であり構造に対して行われる変更がたまたま部品を共有する他の構造に対しても影響を与えます。
ミューテータである\code{set\-/car!}と\code{set\-/cdr!}は注意深く利用せねばなりません。
データオブジェクトがどのように共有されているかを良く理解しなければ変更は予期しない結果を引き起します。\footnote{
ミュータブルなデータオブジェクトの共有の取扱の微妙な部分は\link{Section 3.1.3}で取り上げられた``等価性''と``変更''の
根底に横たわる問題を反映しています。そこでは私達の言語に変更を許すことは複合データがそれを構成する部分から何かが
異なるという``自己同一性''を持たねばならないことを述べました。
Lispではこの``自己同一性''を\code{eq?}にてテストされる性質だと考えます。即ち、ポインタの等価性です。
多くのLisp実装ではポインタが本質的にはメモリアドレスですので、オブジェクトの自己同一性を定義することの
``問題の解決''はデータオブジェクト``それ自身''がいくつかの特定の計算機内のメモリ上の場所の集合に格納された
情報であることを要求することにより解決します。これは単純なLispプログラムには十分ですが、
計算モデルの``同一性''の問題を解決する一般的な方法ではありません。}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.15}Exercise 3.15:} 
上記の構造\code{z1}と\code{z2}上での\code{set\-/to\-/wow!}の効果を説明する箱とポインタの図を描け。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.16}Exercise 3.16:} 
Ben Bitdiddleは任意のリスト構造内のペアの数を数える手続を書くことに決めた。``簡単だよね''と彼は思った。
``任意の構造内のペアの数は\code{car}の中の数と\code{cdr}の中の数の和に現在のペアを数えるために1を足した物''。
だからBenは以下の手続を書いた。

\begin{scheme}
(define (count-pairs x)
  (if (not (pair? x))
      0
      (+ (count-pairs (car x))
         (count-pairs (cdr x))
         1)))
\end{scheme}



この手続が正しくないことを示せ。具体的にはきっちり3つのペアにより作られBenの手続が3, 4, 7を返すだろう、
またBenの手続が絶対に終了しないリスト構造を表現する箱とポインタの図を描け。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.17}Exercise 3.17:} 
\link{Exercise 3.16}の\code{count\-/pairs}手続の正しい版を考案せよ。これは任意の構造の
中の固有のペアの数を返す。(ヒント：構造を横断しながらどのペアが既に数えられたかを
追跡するために使用する補助的なデータ構造を保存する)。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.18}Exercise 3.18:}
リストを検査しそれが循環を持つかどうか判断せよ。つまりリストの最後を見つけようとした
プログラムが連続して\code{cdr}を取ることで無限ループに入るかどうかを判定せよ。
\link{Exercise 3.13}にてそのようなリストを構築した。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.19}Exercise 3.19:} Redo \link{Exercise 3.18} using an
algorithm that takes only a constant amount of space.  (This requires a very
clever idea.)

\link{Exercise 3.18}を一定の容量のメモリのみを用いるアルゴリズムを用いて再度行え。
(これはとても巧妙なアイデアを必要とする)。
\end{quote}

\subsubsection*{変更とは代入のこと}



複合データを紹介した時、\link{Section 2.1.3}にてペアが手続をのみを利用することで表現できることを観察しました。

\begin{scheme}
(define (cons x y)
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          (else (error "Undefined operation: CONS" m))))
  dispatch)
(define (car z) (z 'car))
(define (cdr z) (z 'cdr))
\end{scheme}

\noindent
同じ観察結果がミュータブルなデータに対しても正しいと言えます。ミュータブル(可変)な
データオブジェクトを代入と局所状態を用いることで手続として実装可能です。
例として上のペアの実装を拡張し、\link{Section 3.1.1}で\code{make\-/account}を用いて銀行口座を
実装した方法とある程度類似して、\code{set\-/car!}と\code{set\-/cdr!}を扱うことができます。

\begin{scheme}
(define (cons x y)
  (define (set-x! v) (set! x v))
  (define (set-y! v) (set! y v))
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          ((eq? m 'set-car!) set-x!)
          ((eq? m 'set-cdr!) set-y!)
          (else 
           (error "Undefined operation: CONS" m))))
  dispatch)
(define (car z) (z 'car))
(define (cdr z) (z 'cdr))
(define (set-car! z new-value) 
  ((z 'set-car!) new-value) z)
(define (set-/cdr! z new-value)
  ((z 'set-cdr!) new-value) z)
\end{scheme}

\noindent
代入が可変データの振舞を説明するために論理上必要な物全てです。
私達の言語に\code{set!}を認めると直ぐに、代入の問題のみでなく、一般的な可変データの全ての問題を
引き起しました。\footnote{
一方で、実装上の視点からは代入は環境を変更することを必要とし、環境はそれ自身が可変な
データ構造です。従って代入と変更は等位です。つまり一方は他方を用いることで実装可能です。}
\begin{quote}
\heading{\phantomsection\label{Exercise 3.20}Exercise 3.20:} 
以下の連続した式の評価を説明する環境の図を描け。

\begin{scheme}
(define x (cons 1 2))
(define z (cons x x))
(set-car! (cdr z) 17)
(car x)
~\textit{17}~
\end{scheme}

\noindent
上で与えられた手続型の実装を用いよ。(\link{Exercise 3.11}と比較せよ)。
\end{quote}

\subsection{キューの表現}
\label{Section 3.3.2}



ミューテータの\code{set\-/car!}と\code{set\-/cdr!}はペアを用いて\code{cons}, \code{car}, \code{cdr}のみでは
不可能なデータ構造を構築可能です。この節ではキューと呼ばれるデータ構造を表現するために
どのようにペアを用いるかについて示します。\link{Section 3.3.3}ではテーブル(表)と呼ばれるデータ構造
の表現方法について学びます。


\newterm{queue}(\jnewterm{キュー})はアイテムが一方の端(キューの\newterm{rear}(リア、\jnewterm{終端}))に挿入され、
他方の端(\newterm{front}(フロント、\jnewterm{先端}))から削除される列です。
\link{Figure 3.18}は初期化時に空のキューにアイテム\code{a}と\code{b}が挿入された状態を示しています。
次に\code{a}が削除され、\code{c}と\code{d}が挿入され、\code{b}が削除されます。
アイテムは常に挿入順に削除されるためキューは時々\newterm{FIFO}(first in, first out)(\jnewterm{先入れ先出し})バッファ
と呼ばれます。

\begin{figure}[tb]
\phantomsection\label{Figure 3.18}
\centering
\begin{comment}
\heading{Figure 3.18:} Queue operations.

\begin{example}
Operation                Resulting Queue
(define q (make-queue))
(insert-queue! q 'a)     a
(insert-queue! q 'b)     a b
(delete-queue! q)        b
(insert-queue! q 'c)     b c
(insert-queue! q 'd)     b c d
(delete-queue! q)        c d
\end{example}
\end{comment}
\includegraphics[width=70mm]{fig/chap3/Fig3.18a.pdf}
\par\bigskip
\noindent
\heading{Figure 3.18:} キュー命令
\end{figure}

\noindent
データ抽象化の観点ではキューを以下の操作の集合であると見做すことができます。

\begin{itemize}

\item
コンストラクタ：\code{(make\-/queue)}は空のキュー(アイテムを全く持たないキュー)を返す

\item
2つのセレクタ：

\begin{scheme}
(empty-queue? ~\( \dark \langle \)~~\var{\dark queue}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
キューが空であるかテストする

\begin{scheme}
(front-queue ~\( \dark \langle \)~~\var{\dark queue}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
キューの先頭のオブジェクトを返す。もしキューが空ならエラーを発す。キューを変更しない。

\item
2つのミューテータ：

\begin{scheme}
(insert-queue! ~\( \dark \langle \)~~\var{\dark queue}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark item}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
キューの最後尾にアイテムを挿入し、変更されたキューをその値として返す。

\begin{scheme}
(delete-queue! ~\( \dark \langle \)~~\var{\dark queue}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
キューの先頭のアイテムを削除し、その値として変更されたキューを返す。もしキューが削除前に空であればエラーを発す。

\end{itemize}

\noindent
キューはアイテムの列であるため確かに順序有りリストであると表現できます。キューの先頭はリストの\code{car}であり、
キューにアイテムを挿入するのは新しい要素をリストの最後に追加することで、キューからのアイテムの削除は
ただリストの\code{cdr}を得ることと言えるでしょう。しかしこの表現は非効率です。
なぜならアイテムを挿入するためにはリストを終端まで走査しなければなりません。
リストの走査のための手段は\code{cdr}命令を連続して用いるしかなく、この走査は\( n \)アイテムのリストに対し
\( \Theta(n) \)ステップを必要とします。
リスト表現に対する簡単な変更がこの欠点を克服し\( \Theta \)(1)ステップを必要とするキュー命令の実装を可能にします。
これはつまり必要なステップ数がキューの長さから独立するということです。



リスト表現による困難はリストの終端を見つけるための走査が必要である点から生じています。
走査が必要な理由はリストをペアの鎖として表現する標準的な方法が、事前にリストの先頭への
ポインタを提供するのに対し、終端を指す簡単にアクセス可能なポインタを提供しないためです。
欠点を避けるための変更としてキューをリストとしながらリストの最終ペアを示す追加のポインタ
をも用いて表現します。この方法ではアイテムを挿入する場合に終端ポインタを調べることで
リストの走査を避けることができます。



するとキューはポインタのペア、\code{front\-/ptr}と\code{rear\-/ptr}として表現されます。
それぞれが通常のリストの先頭と最後のペアを指します。キューを識別可能なオブジェクトにするために
2つのポインタを接続するのに\code{cons}を用います。従ってキューそれ自身が2つのポインタの\code{cons}に
なります。\link{Figure 3.19}はこの表現を図示します。

\begin{figure}[tb]
\phantomsection\label{Figure 3.19}
\centering
\begin{comment}
\begin{quote}
\heading{Figure 3.19:} Implementation of a queue as a list with front and rear pointers.

\begin{example}
       +---+---+
  q -->| * | *-+-------------------+
       +-|-+---+                   |
         |                         |
         | front-ptr               | rear-ptr
         V                         V
     +---+---+    +---+---+    +---+---+
     | * | *-+--->| * | *-+--->| * | / |
     +-|-+---+    +-|-+---+    +-|-+---+
       V            V            V
     +---+        +---+        +---+
     | a |        | b |        | c |
     +---+        +---+        +---+
\end{example}
\end{quote}
\end{comment}
\includegraphics[width=69mm]{fig/chap3/Fig3.19b.pdf}
\begin{quote}
\heading{Figure 3.19:} 先端と終端のポインタを持つリストとしてのキューの実装
\end{quote}
\end{figure}


\noindent
キューの命令を定義するために以下の手続を用います。これはキューの先端と終端のポインタの選択、変更を
可能にします。

\begin{scheme}
(define (front-ptr queue) (car queue))
(define (rear-ptr queue) (cdr queue))
(define (set-front-ptr! queue item) (set-car! queue item))
(define (set-rear-ptr! queue item) (set-cdr! queue item))
\end{scheme}

\noindent
これで実際のキューの命令を実装できます。もし先端のポインタが空リストならばキューは空であると
考えることにします。

\begin{scheme}
(define (empty-queue? queue) (null? (front-ptr queue)))
\end{scheme}

\noindent
\code{make\-/queue}コンストラクタは初期値として空キューを意味する\code{car}と\code{cdr}の両方が空リストの
ペアを返します。

\begin{scheme}
(define (make-queue) (cons '() '()))
\end{scheme}

\noindent
キューの頭のアイテムを選択するために先端ポインタが指すペアの\code{car}を返します。

\begin{scheme}
(define (front-queue queue)
  (if (empty-queue? queue)
      (error "FRONT called with an empty queue" queue)
      (car (front-ptr queue))))
\end{scheme}

\noindent
キューにアイテムを挿入するために、\link{Figure 3.20}が示す結果を成す手法に従います。
最初に\code{car}が挿入するアイテムであり\code{cdr}が空リストである新しいペアを作成します。
もしキューが空であるならキューの先端と終端のポインタにこの新しいペアを設定します。
そうでなければキューの最終ペアを新しいペアを指すように変更し、また終端ポインタを新しい
ペアを指すようにします。

\begin{scheme}
(define (insert-queue! queue item)
  (let ((new-pair (cons item '())))
    (cond ((empty-queue? queue)
           (set-front-ptr! queue new-pair)
           (set-rear-ptr! queue new-pair)
           queue)
          (else
           (set-cdr! (rear-ptr queue) new-pair)
           (set-rear-ptr! queue new-pair)
           queue))))
\end{scheme}

\begin{figure}[tb]
\phantomsection\label{Figure 3.20}
\centering
\begin{comment}
\heading{Figure 3.20:} Result of using \code{(insert\-/queue! q 'd)} on the queue of \link{Figure 3.19}.

\begin{example}
       +---+---+
  q -->| * | *-+--------------------------------+
       +-|-+---+                                |
         |                                      |
         | front-ptr                            | rear-ptr
         V                                      V
     +---+---+    +---+---+    +---+---+    +---+---+
     | * | *-+--->| * | *-+--->| * | *-+--->| * | / |
     +-|-+---+    +-|-+---+    +-|-+---+    +-|-+---+
       V            V            V            V
     +---+        +---+        +---+        +---+
     | a |        | b |        | c |        | d |
     +---+        +---+        +---+        +---+
\end{example}
\end{comment}
\includegraphics[width=88mm]{fig/chap3/Fig3.20b.pdf}
\begin{quote}
\heading{Figure 3.20:} \link{Figure 3.19}のキューに\code{(insert\-/queue! q 'd)}を用いた結果 
\end{quote}
\end{figure}

\noindent
キューの頭のアイテムを削除するために、ただ単に先端ポインタを変更しキューの二つ目のアイテムを
指すようにします。これは最初のアイテムの\code{cdr}ポインタに従うだけで見つけられます。(\link{Figure 3.21}参照)\footnote{
もし最初のアイテムがキューの最終アイテムでもある場合、先端ポインタは削除後に空リストになるでしょう。
これはキューを空の状態にします。終端ポインタの更新を心配する必要はありません。これは依然として
削除されたアイテムを指しますが、\code{empty\-/queue?}は先端ポインタしか見ません。}

\begin{scheme}
(define (delete-queue! queue)
  (cond ((empty-queue? queue)
         (error "DELETE! called with an empty queue" queue))
        (else (set-front-ptr! queue (cdr (front-ptr queue)))
              queue)))
\end{scheme}

\begin{figure}[tb]
\phantomsection\label{Figure 3.21}
\centering
\begin{comment}
\heading{Figure 3.21:} Result of using \code{(delete\-/queue!  q)} on the queue of \link{Figure 3.20}.

\begin{example}
       +---+---+
  q -->| * | *-+--------------------------------+
       +-|-+---+                                |
         +------------+                         |
            front-ptr |                         | rear-ptr
                      V                         V
     +---+---+    +---+---+    +---+---+    +---+---+
     | * | *-+--->| * | *-+--->| * | *-+--->| * | / |
     +-|-+---+    +-|-+---+    +-|-+---+    +-|-+---+
       V            V            V            V
     +---+        +---+        +---+        +---+
     | a |        | b |        | c |        | d |
     +---+        +---+        +---+        +---+
\end{example}
\end{comment}
\includegraphics[width=88mm]{fig/chap3/Fig3.21b.pdf}
\begin{quote}
\heading{Figure 3.21:} \link{Figure 3.20}のキューに\code{(delete\-/queue!  q)}を用いた結果
\end{quote}
\end{figure}


\begin{quote}
\heading{\phantomsection\label{Exercise 3.21}Exercise 3.21:} 
Ben Bitdiddleは上で説明されたキューの実装をテストすることに決めた。
彼はLispインタプリタに対し手続を入力し、続いて以下のように試行を行った。

\begin{scheme}
(define q1 (make-queue))
\end{scheme}

\begin{scheme}
(insert-queue! q1 'a)
~\textit{((a) a)}~
\end{scheme}

\begin{scheme}
(insert-queue! q1 'b)
~\textit{((a b) b)}~
\end{scheme}

\begin{scheme}
(delete-queue! q1)
~\textit{((b) b)}~
\end{scheme}

\begin{scheme}
(delete-queue! q1)
~\textit{(() b)}~
\end{scheme}




``間違っている！''と彼は文句を言った。``インタプリタの応答は最後のアイテムがキューに二回挿入されている
ことを示している。そして僕が両方のアイテムを消しても二つ目の\code{b}がまだそこにある。だからキューは
空になるべきなのにそうならない''。Eva Lu AtorはBenが何が起こったのか間違って理解していると示唆した。
``アイテムはキューに二回入ってはいないわ''と彼女は説明した。
``Lisp標準の応答がキュー表現の意味をどのように理解するのか知らないだけ。もしあなたがキューが正しく
表示されるのを見たいなら自分でキューを表示する手続を定義する必要があるわ''。
Eva Luが話していることを説明せよ。具体的にはなぜBenの例がそのような表示の結果になるのか示せ。
キューを入力に取りキュー内のアイテムの列を表示する手続\code{print\-/queue}を定義せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.22}Exercise 3.22:} 
キューをポインタのペアとして表現する代わりに、キューを局所状態を持つ手続として構築することができる。
局所状態は通常のリストの先端と終端へのポインタから成る。従って\code{make\-/queue}手続は以下の形式となる。

\begin{scheme}
(define (make-queue)
  (let ((front-ptr ~\( \dots \)~ )
        (rear-ptr ~\( \dots \)~ ))
    ~\( \dark \langle \)~~\var{\dark definitions of internal procedures}~~\( \dark \rangle \)~
    (define (dispatch m) ~\( \dots \)~)
    dispatch))
\end{scheme}

\code{make\-/queue}の定義を完成させ、この表現を用いたキューの命令を実装せよ。
\end{quote}



\begin{quote}
\heading{\phantomsection\label{Exercise 3.23}Exercise 3.23:} 
\newterm{deque}(``double\-/ended queue''、\jnewterm{両頭キュー})はアイテムの挿入と消去が先端と終端の
両方に対して行える列である。deque上の命令はコンストラクタ\code{make\-/deque}、述語\code{empty\-/deque?}、
セレクタ\code{front\-/deque}と\code{rear\-/deque}、ミューテータ\code{front\-/insert\-/deque!},
\code{rear\-/insert\-/deque!}, \code{front\-/delete\-/deque!}, \code{rear\-/delete\-/deque!}である。
ペアを用いてどのようにdequeを表現するか示せ。また命令の実装を提供せよ。\footnote{
インタプリタに循環を含む構造を表示させないように注意せよ。(\link{Exercise 3.13}参照)。}
全ての命令は\( \Theta \)(1)ステップで達成すること。
\end{quote}

\subsection{テーブルの表現}
\label{Section 3.3.3}



\link{Chapter 2}で種々の集合の表現について学んだ時、\link{Section 2.3.3}にてキーで同定する
索引を持つレコードの表を保存する作業について述べました。\link{Section 2.4.3}での
データ適従プログラミングの実装において二次元テーブルの広範な使用を行い、情報は
2つのキーを用いて格納と取り出しされました。ここではどのように表をミュータブルなリスト構造として
構築するかについて学びます。

\begin{figure}[tb]
\phantomsection\label{Figure 3.22}
\centering
\begin{comment}
\heading{Figure 3.22:} A table represented as a headed list.

\begin{example}
 +---+---+    +---+---+    +---+---+    +---+---+
 | * | *-+--->| * | *-+--->| * | *-+--->| * | / |
 +-|-+---+    +-|-+---+    +-|-+---+    +-|-+---+
   |            |            |            |
   V            V            V            V
+---------+   +---+---+   +---+---+   +---+---+
| *table* |   | * | * |   | * | * |   | * | * |
+---------+   +-|-+-|-+   +-|-+-|-+   +-|-+-|-+
                |   |       |   |       |   |
                V   V       V   V       V   V
             +---+ +---+ +---+ +---+ +---+ +---+
             | a | | 1 | | b | | 2 | | c | | 3 |
             +---+ +---+ +---+ +---+ +---+ +---+
\end{example}
\end{comment}
\includegraphics[width=81mm]{fig/chap3/Fig3.22c.pdf}
\par\bigskip
\noindent
\heading{Figure 3.22:} 頭出しリストとして表現されたテーブル
\end{figure}

\noindent
最初は一次元の表について考えます。各値が単一のキーの下に格納されます。
テーブルをレコードのリストとして実装し、各レコードははキーと関連する値から成るペアとして実装します。
レコードは\code{car}が次のレコードを指すペアによりリストを形成する様に連結されます。
これらの連結されたペアは表の\newterm{backbone}(\jnewterm{バックボーン}、基幹)と呼ばれます。
テーブルに新しいレコードを追加する時に変更可能な場所を得るために、テーブルを
\newterm{headed list}(\jnewterm{頭出しリスト})として構築します。頭出しリストは特別なバックボーンペアを
最初に持ちます。これはダミーの``レコード''---今回の場合、自由裁量で選択したシンボル\code{*table*}---
を持っています。\link{Figure 3.22}は以下のテーブルの箱とポインタの図を示しています。

\begin{scheme}
a:  1
b:  2
c:  3
\end{scheme}

\noindent
テーブルから情報を抽出するには鍵を引数として取り相対する値(またはそのキーの下に
値が格納されていない場合にはfalse)を返す\code{lookup}手続を用います。
\code{lookup}はキーとレコードのリストを引数として期待する\code{assoc}命令を用いて定義します。
\code{assoc}がダミーレコードを絶対に参照しないことに注意して下さい。\code{assoc}は与えられた
キーを\code{car}として持つレコードを返します。\footnote{\code{assoc}が\code{equal?}を用いるため、
シンボル、数値、リスト構造であるキーを認識可能です。}
すると\code{lookup}は\code{assoc}が返した結果のレコードがfalseでないかチェックし、そのレコードの
値(\code{cdr})を返します。

\begin{scheme}
(define (lookup key table)
  (let ((record (assoc key (cdr table))))
    (if record
        (cdr record)
        false)))
(define (assoc key records)
  (cond ((null? records) false)
        ((equal? key (caar records)) (car records))
        (else (assoc key (cdr records)))))
\end{scheme}

\noindent
値をテーブルに指定したキーの下に挿入するために、最初に\code{assoc}を用いて既にテーブルの中に
このキーを持つレコードが存在しないか確認します。もし無ければ鍵と値を\code{cons}することで
新しいレコードを作成しこれをテーブルのレコードリストの先頭のダミーレコードの後ろに挿入します。
もし既にこのキーのレコードが存在する場合にはそのレコードの\code{cdr}に新しい値を設定します。
テーブルのヘッダは新しいレコードを挿入するために変更する固定位置を与えます。\footnote{従って
最初のバックボーンペアはテーブル``それ自身''を表現するオブジェクトです。テーブルを指す
ポインタはこのペアを指すポインタです。この同じバックボーンペアが常にテーブルを始めます。
もしこのようにしなければ\code{insert!}は新しいレコードを追加した時にテーブルの新しい開始地点を
返さなければならなくなるでしょう。}

\begin{scheme}
(define (insert! key value table)
  (let ((record (assoc key (cdr table))))
    (if record
        (set-cdr! record value)
        (set-cdr! table
                  (cons (cons key value)
                        (cdr table)))))
  'ok)
\end{scheme}

\noindent
新しいテーブルを構築するためには単純にシンボル\code{*table*}を持つリストを作成します。

\begin{scheme}
(define (make-table)
  (list '*table*))
\end{scheme}

\subsubsection*{二次元テーブル}

\noindent
二次元テーブルでは各値は2つのキーにより索引付けられます。そのようなテーブルを
各キーが部分テーブルを特定する1次元テーブルとして構築することができます。
\link{Figure 3.23}は以下のテーブルを箱とポインタの図で示しています。

\begin{example}
math:    +:  43        letters:    a:  97
         -:  45                    b:  98
         *:  42
\end{example}

\noindent
これは2つ部分テーブルを持ちます。(部分テーブルは特別なヘッダシンボルを必要としません。
部分テーブルを特定するキーがこの目的を果たすためです)。



アイテムを探す時、最初のキーを用いて正しい部分テーブルを特定します。
次に二つ目のキーを用いて部分テーブル中のレコードを特定します。

\begin{scheme}
(define (lookup key-1 key-2 table)
  (let ((subtable 
         (assoc key-1 (cdr table))))
    (if subtable
        (let ((record 
               (assoc key-2 (cdr subtable))))
          (if record
              (cdr record)
              false))
        false)))
\end{scheme}

\begin{figure}[tb]
\phantomsection\label{Figure 3.23}
\centering
\begin{comment}
\heading{Figure 3.23:} A two-dimensional table.

\begin{example}
table
  |
  V
+---+---+   +---+---+   +---+---+
| * | *-+-->| * | *-+-->| * | / |
+-|-+---+   +-|-+---+   +-|-+---+
  V           |           V
+-------+     |         +---+---+   +---+---+   +---+---+
|*table*|     |         | * | *-+-->| * | *-+-->| * | / |
+-------+     |         +-|-+---+   +-|-+---+   +-|-+---+
              |           V           V           V
              |       +-------+     +---+---+   +---+---+
              |       |letters|     | * | * |   | * | * |
              |       +-------+     +-|-+-|-+   +-|-+-|-+
              |                       V   V       V   V
              |                    +---+ +---+ +---+ +---+
              |                    | a | | 97| | b | | 98|
              |                    +---+ +---+ +---+ +---+
              V
            +---+---+   +---+---+   +---+---+   +---+---+
            | * | *-+-->| * | *-+-->| * | *-+-->| * | / |
            +-|-+---+   +-|-+---+   +-|-+---+   +-|-+---+
              V           V           V           V
          +------+      +---+---+   +---+---+   +---+---+
          | math |      | * | * |   | * | * |   | * | * |
          +------+      +-|-+-|-+   +-|-+-|-+   +-|-+-|-+
                          V   V       V   V       V   V
                       +---+ +---+ +---+ +---+ +---+ +---+
                       | + | | 43| | - | | 45| | * | | 42|
                       +---+ +---+ +---+ +---+ +---+ +---+
\end{example}
\end{comment}
\includegraphics[width=103mm]{fig/chap3/Fig3.23a.pdf}
\par\bigskip
\noindent
\heading{Figure 3.23:} 二次元テーブル
\end{figure}

\noindent
キーのペアの下に新しいアイテムを挿入するには\code{assoc}を用いて最初のキーの下に
部分テーブルが存在するかどうかを確認します。もし無ければ単一のレコード(\code{key\-/2}, \code{value})を含む
新しい部分テーブルを構築し、それを最初のキーの下にテーブルに挿入します。
もし最初のキーに対する部分テーブルが既に存在する場合新しいレコードをこの部分テーブルに先に説明した
一次元テーブルに対する挿入方法を用いて挿入します。

\begin{scheme}
(define (insert! key-1 key-2 value table)
  (let ((subtable (assoc key-1 (cdr table))))
    (if subtable
        (let ((record (assoc key-2 (cdr subtable))))
          (if record
              (set-cdr! record value)
              (set-cdr! subtable
                        (cons (cons key-2 value)
                              (cdr subtable)))))
        (set-cdr! table
                  (cons (list key-1
                              (cons key-2 value))
                        (cdr table)))))
  'ok)
\end{scheme}

\subsubsection*{ローカルなテーブルの作成}



上で定義された\code{lookup}と\code{insert!}命令はテーブルを引数として取ります。
これが複数のテーブルにアクセスするプログラムを許可します。
複数のテーブルを扱う他の方法には各テーブルに対し分離された\code{lookup}と\code{insert!}手続を
持つ方法があります。これはテーブルを手続的に、その局所状態の一部に内部テーブルを持つ
オブジェクトとして表現することにより可能となります。
適切なメッセージを送った時に、この``テーブルオブジェクト''は内部テーブルを操作する手続を
提供します。以下にこの様式で表現された二次元テーブルのためのジェネレータ(生成器)を示します。

\begin{scheme}
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable 
             (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record 
                   (assoc key-2 (cdr subtable))))
              (if record (cdr record) false))
            false)))
    (define (insert! key-1 key-2 value)
      (let ((subtable 
             (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record 
                   (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1 (cons key-2 value))
                            (cdr local-table)))))
      'ok)
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation: TABLE" m))))
    dispatch))
\end{scheme}

\noindent
\code{make\-/table}を用いることで\link{Section 2.4.3}で用いたデータ適従プログラミングのための
\code{get}と\code{put}を以下のように実装することができます。

\begin{scheme}
(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
\end{scheme}

\noindent
\code{get}は引数として2つのキーを取り、\code{put}は引数として2つのキーと値を取ります。
両方の命令共に同じ局所テーブルをアクセスします。局所テーブルは\code{make\-/table}の
呼出により作成されたオブジェクトの中にカブセル化されます。

\begin{quote}
\heading{\phantomsection\label{Exercise 3.24}Exercise 3.24:} 
上記のテーブル実装において、キーは\code{equal?}を用いて等価試験を行う。
(\code{assoc}により呼び出される)。これは常に適切な試験ではない。
例として数値キーを用いるテーブルを用いる場合に、検索時に
厳密に等しい必要が無く、ある許容範囲で数値を探したいかもしれない。
キーの``等価性''を試験するのに用いられる\code{same\-/key?}手続を引数として取る
テーブルコンストラクタ\code{make\-/table}を定義せよ。
\code{make\-/table}は内部テーブルに対して適切な手続\code{lookup}と\code{insert!}に
アクセスするのに使用可能な\code{dispatch}手続を返さねばならない。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.25}Exercise 3.25:} 
1次元と二次元のテーブルを一般化せよ。任意の数のキーの下で値を格納し、異なる値を
異なる数のキーの下格納できるテーブルをどのように実装するか示せ。
\code{lookup}と\code{insert!}手続は入力としてキーのリストを取りテーブルにアクセスする。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.26}Exercise 3.26:} 
上で実装されたテーブルを検索するにはレコードのリストを走査しなければならない。
これは基本的に\link{Section 2.3.3}の順序無しリスト表現である。大きなテーブルに対しては
異なる様式でテーブルを構造化するほうが効率が良い。(キー, 値)のレコードが二分木を用いて
体系化されるテーブルの実装を説明せよ。キーは何らかの方法にて順序付可能であると
想定する。(\link{Chapter 2}の\link{Exercise 2.66}と比較せよ)。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.27}Exercise 3.27:} 
\newterm{memoization}(\jnewterm{メモ化})(\newterm{tabulation}(\jnewterm{表形式化})とも呼ばれる)とは
手続の局所テーブルに事前に計算した値を記録することを可能するテクニックである。
このテクニックはプログラムのパフォーマンスに大幅な違いを与えることができる。
メモ化された手続は以前の呼出の値がその値を生成した引数をキーとして格納する
テーブルを持つ。メモ化された手続が値を計算するよう命じられた時、最初に値が既に
テーブルにないかチェックを行い、もし存在すれば単にその値を返す。そうでなければ
新しい値を通常の方法で計算しテーブルに保存する。メモ化の例として\link{Section 1.2.2}から
フィボナッチ数を演算するための指数関数処理を思い出せ。

\begin{scheme}
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1)) (fib (- n 2))))))
\end{scheme}

同じ手続のメモ化版は以下である。

\begin{scheme}
(define memo-fib
  (memoize
   (lambda (n)
     (cond ((= n 0) 0)
           ((= n 1) 1)
           (else (+ (memo-fib (- n 1))
                    (memo-fib (- n 2))))))))
\end{scheme}

\noindent
この時、memoizeは以下の様に定義される。

\begin{scheme}
(define (memoize f)
  (let ((table (make-table)))
    (lambda (x)
      (let ((previously-computed-result 
             (lookup x table)))
        (or previously-computed-result
            (let ((result (f x)))
              (insert! x result table)
              result))))))
\end{scheme}

\code{(memo\-/fib 3)}の演算を分析するための環境図を描け。なぜ\code{memo\-/fib}が\( n \)番目のフィボナッチ数
を\( n \)に比例するステップ数で演算するのか説明せよ。単に\code{memo\-/fib}を\code{(memoize fib)}と定義した
場合にもSchemeは正しく処理できるだろうか?
\end{quote}

\subsection{デジタル回路のシミュレータ}
\label{Section 3.3.4}

コンピュータのような複雑なデジタルシステムの設計は重要な工学の活動領域です。
デジタルシステムは簡単な要素を相互接続することで構築されます。これらの個々の要素の
振舞は単純ですが、それらのネットワークはとても複雑な振舞をします。
提案された回路設計のコンピュータシミュレーションはデジタルシステムエンジニアにより使用される
重要なツールです。この節ではデジタル論理シミュレーションを実行するためのシステムを
設計します。このシステムは\newterm{event-driven simulation}(\jnewterm{イベント駆動シミュレーション})
と呼ばれる種類の典型であり、その行動(``イベント'')は後に起こるさらなるイベントを
引き起こし、順により多くのイベントを引き起します。



私達の回路の計算モデルは回路を構築する基本となるコンポーネントに対応するオブジェクトに
より成ります。\newterm{digital signals}(\jnewterm{デジタル信号})を運ぶ\newterm{wires}(\jnewterm{回路})が存在します。
デジタル信号は任意の瞬間に可能な2つの値、0と1の内1つを取ります。また多様なタイプのデジタル
\newterm{function boxes}(\jnewterm{関数箱})が存在し、入力信号を運ぶ回路と別の出力回路を接続します。
そのような箱は入力信号から計算された信号を出力します。出力信号は関数箱のタイプにより時間的に
遅れを生じさせます。例えば\newterm{inverter}(\jnewterm{逆変換器})は入力を反転するプリミティブな関数箱です。
もし逆変換器への入力信号が0に変化したなら、ある逆変換器による遅延の後、逆変換器はその出力信号を
1に変更します。もし逆変換器への入力信号が1に変化したならば、ある逆変換器による遅延の後、
逆変換器は出力信号を0にします。逆変換器を記号として\link{Figure 3.24}に示すように描きます。
\link{Figure 3.24}に示される\newterm{and\-/gate}(\jnewterm{ANDゲート})も2つの入力と1つの出力を持つプリミティブな関数箱です。
入力の\newterm{logical and}(\jnewterm{論理積})の値にその出力の値を駆動します。言い替えれば、もし入力信号の
両方が1になればあるANDゲートによる遅延の後にANDゲートはその出力信号を1にします。そうでなければ
出力は0です。\newterm{or\-/gate}(\jnewterm{ORゲート})も同様の2つの入力を持つプリミティブな関数箱であり
その出力信号は入力に対する\newterm{logical or}(\jnewterm{論理和})の値になります。言い替えれば出力はもし少くとも
1つの入力信号が1であれば1になり、そうでなければ出力は0になります。

\begin{figure}[tb]
\phantomsection\label{Figure 3.24}
\centering
\begin{comment}
\heading{Figure 3.24:} Primitive functions in the digital logic simulator.

\begin{example}
               __          ___
  |\        --|  \       --\  \
--| >o--      |   )--       )  >--
  |/        --|__/       --/__/

Inverter    And-gate     Or-gate
\end{example}
\end{comment}
\includegraphics[width=74mm]{fig/chap3/Fig3.24b.pdf}
\par\bigskip
\noindent
\heading{Figure 3.24:} デジタル論理回路シミュレータにおけるプリミティブな関数
\end{figure}

\noindent
プリミティブな関数を一緒に接続してより複雑な関数を構築できます。これを達成するために
ある関数箱の出力から他の関数箱の入力へと回路を引きます。例えば\link{Figure 3.25}に示す
\newterm{half\-/adder}(\jnewterm{半加算器})はORゲート、2つのANDゲート、逆変換器から成り立ちます。
これは2つの入力信号、AとBを取り2つの出力信号SとCがあります。Sは正確にAとBの内1つが1で
あるならば1になり、CはAとBの両方が1の場合に1になります。遅延が生じるため出力が異なる
時刻に生成されることが図から見てわかります。デジタル回路設計の困難の多くはこの事実から
生じます。

\begin{figure}[tb]
\phantomsection\label{Figure 3.25}
\centering
\begin{comment}
\heading{Figure 3.25:} A half-adder circuit.

\begin{example}
    +--------------------------------------+
    |         ____                         |
A --------*---\   \ D               ___    |
    |     |    >   >---------------|   \   |
    |  +--|---/___/                |    )----- S
    |  |  |              |\  E  +--|___/   |
    |  |  |           +--| >o---+          |
    |  |  |    ___    |  |/                |
    |  |  +---|   \   |                    |
    |  |      |    )--*----------------------- C
B -----*------|___/                        |
    |                                      |
    +--------------------------------------+
\end{example}
\end{comment}
\includegraphics[width=72mm]{fig/chap3/Fig3.25c.pdf}
\par\bigskip
\noindent
\heading{Figure 3.25:} 半加算器回路
\end{figure}

\noindent
今から私達が学習を望むデジタル論理回路をモデル化するためのプログラムを構築します。
プログラムは回路をモデル化する計算モデルを構築します。これは信号を``保持''します。
関数箱は信号間の正しい関係を強制する手続によりモデル化されます。

私達のシミュレーションの基本的要素の1つは手続\code{make\-/wire}であり回路を構築します。
例として6つの回路を以下のように構築できます。

\begin{scheme}
(define a (make-wire))
(define b (make-wire))
(define c (make-wire))
(define d (make-wire))
(define e (make-wire))
(define s (make-wire))
\end{scheme}

\noindent
ある関数箱を回路の集合に対してその種類の箱を構築する手続を呼ぶことにより取り付けることができます。
コンストラクタ手続への引数は箱に取り付けられる回路です。例えばANDゲート、ORゲート、逆変換器を構築
できる場合、\link{Figure 3.25}に示す半加算器を配線することができます。

\begin{scheme}
(or-gate a b d)
~\textit{ok}~
(and-gate a b c)
~\textit{ok}~
(inverter c e)
~\textit{ok}~
(and-gate d e s)
~\textit{ok}~
\end{scheme}

\noindent
もっと良いことには、半加算器に取り付けられる4つの外部回路を与えられた時、
この回路を構築する手続\code{half\-/adder}を定義することでこの操作に明示的に名前を
付けることができます。

\begin{scheme}
(define (half-adder a b s c)
  (let ((d (make-wire)) (e (make-wire)))
    (or-gate a b d)
    (and-gate a b c)
    (inverter c e)
    (and-gate d e s)
    'ok))
\end{scheme}

\noindent
この定義を作ることの利点は\code{half\-/adder}それ自身をより複雑な回路を作成する時に
建築用ブロックとして使用することができることです。例えば\link{Figure 3.26}は
2つの半加算器と1つのORゲートより組み立てられる\newterm{full\-/adder}(\jnewterm{全加算器})を
示しています。\footnote{全加算器は2つの二進数の加算に用いられる基本的な回路要素です。
ここでAとBは加算される2つの数の対応する位置のビットで、\( \rm C_{in} \)は
1つ右の加算からのキャリービット(桁上げビット)です。この回路は対応する位置の合計の
ビットであるSUMと左に伝播されるキャリービットである\( \rm C_{out} \)を算出します。}
全加算器を以下のように構築できます。

\begin{scheme}
(define (full-adder a b c-in sum c-out)
  (let ((s (make-wire)) (c1 (make-wire)) (c2 (make-wire)))
    (half-adder b c-in s c1)
    (half-adder a s sum c2)
    (or-gate c1 c2 c-out)
    'ok))
\end{scheme}

\begin{figure}[tb]
\phantomsection\label{Figure 3.26}
\centering
\begin{comment}
\heading{Figure 3.26:} A full-adder circuit.

\begin{example}
    +----------------------------------+
    |              +-------+           |
A -----------------+ half- +-------------- SUM
    |  +-------+   | adder |   ____    |
B -----+ half- +---+       +---\   \   |
    |  | adder |   +-------+    >or >----- Cout
C -----+       +---------------/___/   |
    |  +-------+                       |
    +----------------------------------+
\end{example}
\end{comment}
\includegraphics[width=74mm]{fig/chap3/Fig3.26a.pdf}
\par\bigskip
\noindent
\heading{Figure 3.26:} 全加算器回路
\end{figure}

\noindent
手続として定義された\code{full\-/adder}を持つことでさらにより複雑な回路を作成するための
建築ブロックとして利用することが可能です。(例えば\link{Exercise 3.30}を参照)。


実質的に、私達のシミュレーターは回路の言語を構築するツールを提供します。
もし\link{Section 1.1}におけるLispの学習への取り組みに用いた言語上の一般的な観点を受け入れれば、
プリミティブな関数箱はプリミティブな言語の要素を形成し、箱の間に回路を引くことは組み合わせの
手段を提供し、手続として回線を引くパターンを指定することは抽象化の手段としての
役割を果たすということが言えます。

\subsubsection*{プリミティブな関数箱}




プリミティブな関数箱はある回路上の信号の変化が他の配線上の信号に影響を与える``力''を実装します。
関数箱を構築するため以下の回路上の命令を用います。

\begin{itemize}

\item \code{(get\-/signal}\( \;\;\langle\kern0.06em\hbox{\ttfamily\slshape wire}\kern0.08em\rangle \)\code{)}

\noindent
回線上の信号の現在地を返す

\item \code{(set\-/signal!}\( \;\;\langle\kern0.08em\hbox{\ttfamily\slshape wire}\kern0.08em\rangle\;\;\langle\kern0.08em\hbox{\ttfamily\slshape new value}\kern0.08em\rangle \)\code{)}

\noindent
回路上の信号の値を新しい値に変更する

\item \code{(add\-/action!}\( \;\;\langle\kern0.08em\hbox{\ttfamily\slshape wire}\kern0.08em\rangle\;\;\langle\kern0.08em\hbox{\ttfamily\slshape procedure of no arguments}\kern0.02em\rangle \)\code{)}

\noindent
指定された手続が回路上の信号が値を変化した場合常に実行される様に宣言する。
そのような手続は、回路上の信号の値の変化が他の回路と通信を行うための伝達手段である。
\end{itemize}

\noindent
さらに手続\code{after\-/delay}を使用し遅延時間と実行される手続を取得し、与えられた手続を遅延時間後に
実行します。


これらの手続を用いてプリミティブなデジタル論理関数を定義できます。
入力を逆変換器を通して出力に接続するために\code{add\-/action!}を用いて入力回路と入力回路上
の信号が値を変化する度に実行される手続を関連付けます。その手続は入力信号の
\code{logical\-/not}(論理否定)を計算し、そして\code{inverter\-/delay}後に出力信号に
この新しい値を設定します。

\begin{scheme}
(define (inverter input output)
  (define (invert-input)
    (let ((new-value (logical-not (get-signal input))))
      (after-delay inverter-delay
                   (lambda ()
                     (set-signal! output new-value)))))
  (add-action! input invert-input) 'ok)
(define (logical-not s)
  (cond ((= s 0) 1)
        ((= s 1) 0)
        (else (error "Invalid signal" s))))
\end{scheme}

\noindent
ANDゲートはより少しだけ複雑です。アクション手続はゲートへの入力のどちらかが
変化した場合に実行されねばなりません。それが入力回路上の信号の値の\code{logical\-/and}(論理積)を
(\code{logical\-/not}と類似の手続を用いて)求め、出力回路上に起こる新しい値への変更を
\code{and\-/gate\-/delay}後に設定します。

\begin{scheme}
(define (and-gate a1 a2 output)
  (define (and-action-procedure)
    (let ((new-value
           (logical-and (get-signal a1) (get-signal a2))))
      (after-delay 
       and-gate-delay
       (lambda () (set-signal! output new-value)))))
  (add-action! a1 and-action-procedure)
  (add-action! a2 and-action-procedure)
  'ok)
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.28}Exercise 3.28:} 
ORゲートをプリミティブな関数箱として定義せよ。あなたの\code{or\-/gate}コンストラクタは
\code{and\-/gate}と同様でなければならない。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.29}Exercise 3.29:} 
ORゲートを構築する別の方法は複合デジタル論理デバイスとしてANDゲートと逆変換器から
構築するものである。これを達成する手続\code{or\-/gate}を定義せよ。\code{and\-/gate\-/delay}と
\code{inverter\-/delay}を用いた遅延時間はどのようになるか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.30}Exercise 3.30:} 
\link{Figure 3.27}は\( n \)個の全加算器を繋げた\newterm{ripple-carry adder}(\jnewterm{桁上げ伝播加算器})を示している。
これは2つの\( n \)ビット二進数を足すための最も簡単な形式の並列加算器である。
入力\( A_1 \), \( A_2 \), \( A_3 \), \( \dots \), \( A_n \)と\( B_1 \), \( B_2 \), \( B_3 \), \( \dots \), \( B_n \)
は足すべき2つの二進数(各\( A_k \)と\( B_k \)は0か1)である。
回路は\( S_1 \), \( S_2 \), \( S_3 \), \( \dots \), \( S_n \)の\( n \)ビットの和と、
和算の桁上がりである\( C \)を生成する。
この回路を生成する手続\code{ripple\-/carry\-/adder}を書け。この手続は引数としてそれぞれ
\( n \)個の配線を持つ3つのリスト---\( A_k \), \( B_k \), \( S_k \)---と別の配線\( C \)を取る。
桁上げ伝播加算器の主な欠点はキャリー信号の伝播を待つ必要があることである。\( n \)ビットの桁上げ伝播加算器
における完全な出力を得るのに必要な遅延時間はいくらか? ANDゲート、ORゲート、逆変換器の遅延時間から表現せよ。
\end{quote}

\begin{figure}[tb]
\phantomsection\label{Figure 3.27}
\centering
\begin{comment}
\heading{Figure 3.27:} A ripple-carry adder for \( n \)-bit numbers.

\begin{example}
   :                                              :   :
   : A_1 B_1   C_1   A_2 B_2   C_2   A_3 B_3   C_3:   : A_n B_n C_n=0
   :  |   |   +---+   |   |   +---+   |   |   +-----  :  |   |   +-
   |  |   |   |   |   |   |   |   |   |   |   |   :   :  |   |   | 
   : ++---+---++  |  ++---+---++  |  ++---+---++  :   : ++---+---++
   : |   FA    |  |  |   FA    |  |  |   FA    |  :   : |   FA    |
   : +--+---+--+  |  +--+---+--+  |  +--+---+--+  :   : +--+---+--+
   :    |   |     |     |   |     |     |   |     :   :    |   |   
C ------+   |     +-----+   |     +-----+   |     :  ------+   |   
   :        |       C_1     |       C_2     |     :   :C_(n-1) |   
   :        |               |               |     :   :        |   
           S_1             S_2             S_3                S_n
\end{example}
\end{comment}
\includegraphics[width=96mm]{fig/chap3/Fig3.27a.pdf}
\par\bigskip
\noindent
\heading{Figure 3.27:} \( n \)-bit数の桁上げ伝播加算器
\end{figure}

\subsubsection*{回路の表現}



私達のシミュレーションにおけるワイヤ(wire、配線、回路)は2つのローカルな状態変数を持つ
計算オブジェクトになります。その2つは\code{signal\-/value}(信号値)(初期値は0)と信号が値を変えた時に実行される
\code{action\-/procedures}(行動手続)の集合です。
メッセージパッシングスタイルを用いてワイヤを局所手続の集合として適切な局所命令を選択する手続\code{dispatch}と
共に実装します。\link{Section 3.1.1}での簡単な銀行口座オブジェクトと同様に行います。

\begin{scheme}
(define (make-wire)
  (let ((signal-value 0) (action-procedures '()))
    (define (set-my-signal! new-value)
      (if (not (= signal-value new-value))
          (begin (set! signal-value new-value)
                 (call-each action-procedures))
          'done))
    (define (accept-action-procedure! proc)
      (set! action-procedures 
            (cons proc action-procedures))
      (proc))
    (define (dispatch m)
      (cond ((eq? m 'get-signal) signal-value)
            ((eq? m 'set-signal!) set-my-signal!)
            ((eq? m 'add-action!) accept-action-procedure!)
            (else (error "Unknown operation: WIRE" m))))
    dispatch))
\end{scheme}

\noindent
局所手続\code{set\-/my\-/signal!}は新しい信号値が配線上の信号を変えるかチェックします。
もしそうであれば全ての行動手続を以下の手続\code{call\-/each}を用いて実行します。
\code{call\-/each}は引数無し手続のリスト内の全てのアイテムを呼び出します。

\begin{scheme}
(define (call-each procedures)
  (if (null? procedures)
      'done
      (begin ((car procedures))
             (call-each (cdr procedures)))))
\end{scheme}

\noindent
局所手続\code{accept\-/action\-/procedure!}は与えられた手続を実行対象手続リストに追加します。
次に新しい手続を一度実行します。(\link{Exercise 3.31}参照)



ローカルの\code{dispatch}手続が指定通りに設定されていることから、以下の手続を与えて
配線上の局所命令にアクセスすることができます。\footnote{\label{Footnote 27}これらの
手続は単純にオブジェクトの局所手続にアクセスするために通常の手続的な文法を使用する
ことを許可する糖衣構文に過ぎません。``手続''と``データ''の役割をそのような簡単な方法で
交換できることは印象的です。例えばもし\code{(wire 'get\-/signal)}と書いた場合、私達は
\code{wire}をメッセージ\code{get\-/signal}を入力として呼び出される手続だと考えるでしょう。
その代わりに\code{(get\-/signal wire)}と書くことは私達に\code{wire}を手続\code{get\-/signal}に対する
入力としてのデータオブジェクトだと考えることを促します。この問題の真実は私達が手続を
オブジェクトとして扱う言語には``手続''と``データ''の間に基本的な違いが存在せず、
私達はどんなスタイルを選択してもプログラミングを可能にする糖衣構文を選択することができる
ということです。}

\begin{scheme}
(define (get-signal wire) (wire 'get-signal))
(define (set-signal! wire new-value)
  ((wire 'set-signal!) new-value))
(define (add-action! wire action-procedure)
  ((wire 'add-action!) action-procedure))
\end{scheme}

\noindent
時間的に変化する信号を持ち付加的に装置に取り付けられる配線はミュータブルなオブジェクトの
特性を良く示しています。私達はそれを代入により変化するローカル状態変数を持つ手続として
モデル化しました。新しい配線が作成された時、新しい状態変数の信号は(\code{make\-/wire}中の\code{let}式により)
確保され、新しい\code{dispatch}手続が構築され返され、新しい状態変数を持つ環境が確保されます。



配線は様々なデバイスの間で共有され、それらに対して接続されます。従ってあるデバイスとの応答により
起こった変化はその配線に取り付けられた全ての他のデバイスに影響を与えます。配線は
接続が開設された時に提供された行動手続を呼ぶことによりその近傍に対し変化を通知します。

\subsubsection*{予定表}



シミュレータを完成させるために必要な物は\code{after\-/delay}のみです。ここでのアイデアは
\newterm{agenda}(\jnewterm{予定表})と呼ばれるデータ構造を保持し、それに行うべき予定を保存します。
以下の命令は予定表のために定義されます。

\begin{itemize}

\item
\code{(make\-/agenda)}は新しい空の予定表を返す。

\item
\code{(empty\-/agenda?}\( \;\;\langle\kern0.08em\hbox{\ttfamily\slshape agenda}\kern0.06em\rangle\hbox{\tt)} \)は
指定した予定表が空であるなら真である。

\item
\code{(first\-/agenda\-/item}\( \;\;\langle\kern0.08em\hbox{\ttfamily\slshape agenda}\kern0.06em\rangle\hbox{\tt)} \)は
予定表の最初のアイテムを返す。

\item
\code{(remove\-/first\-/agenda\-/item!}\( \;\langle\kern0.08em\hbox{\ttfamily\slshape agenda}\kern0.06em\rangle\hbox{\tt)} \) は
予定表から最初のアイテムを削除する。

\item
\code{(add\-/to\-/agenda!}\( \;\;\langle\kern0.03em\hbox{\ttfamily\slshape time}\kern0.06em\rangle\;\;\langle\kern0.08em\hbox{\ttfamily\slshape action}\kern0.06em\rangle\;\;\langle\kern0.08em\hbox{\ttfamily\slshape agenda}\kern0.06em\rangle\hbox{\tt)} \)は指定された時間後に実行される行動手続を追加する。

\item
\code{(current\-/time}\( \;\;\langle\kern0.08em\hbox{\ttfamily\slshape agenda}\kern0.04em\rangle\hbox{\tt)} \)は現在のシミュレーション時間を返す。
\end{itemize}

\noindent
使用する予定表は\code{the\-/agenda}により指定されます。手続\code{after\-/delay}は
新しい要素を\code{the\-/agenda}に追加します。

\begin{scheme}
(define (after-delay delay action)
  (add-to-agenda! (+ delay (current-time the-agenda))
                  action
                  the-agenda))
\end{scheme}

\noindent
シミュレーションは手続\code{propagate}(伝播)により駆動され、\code{the\-/agenda}上で操作を行い、
予定表上の各手続を順に実行します。一般的にシミュレータが実行されるにつれ、新しいアイテムが
予定表に追加され、\code{propagate}はシミュレーションを予定表にアイテムが存在する間は続けます。

\begin{scheme}
(define (propagate)
  (if (empty-agenda? the-agenda)
      'done
      (let ((first-item (first-agenda-item the-agenda)))
        (first-item)
        (remove-first-agenda-item! the-agenda)
        (propagate))))
\end{scheme}

\subsubsection*{サンプルシミュレーション}



回路上に``probe''(プローブ、探針)を置く以下の手続は実行中のシミュレータを表示します。
プローブは配線に対し信号値が変わる度に新しい信号値を現在に時刻と配線を識別する名前を一緒に表示せよと命じます。

\begin{scheme}
(define (probe name wire)
  (add-action! wire
               (lambda ()
                 (newline)
                 (display name)
                 (display " ")
                 (display (current-time the-agenda))
                 (display "  New-value = ")
                 (display (get-signal wire)))))
\end{scheme}

\noindent
予定表の初期化とプリミティブな関数箱に対し遅延時間を指定することから始めます。

\begin{scheme}
(define the-agenda (make-agenda))
(define inverter-delay 2)
(define and-gate-delay 3)
(define or-gate-delay 5)
\end{scheme}

\noindent
ここで4つの配線を定義し、その内2つにプローブを仕込みます。

\begin{scheme}
(define input-1 (make-wire))
(define input-2 (make-wire))
(define sum (make-wire))
(define carry (make-wire))

(probe 'sum sum)
~\textit{sum 0  New-value = 0}~
(probe 'carry carry)
~\textit{carry 0  New-value = 0}~
\end{scheme}

\noindent
次に配線を(\link{Figure 3.25}の様に)半加算器回路に接続し、\code{input\-/1}上の信号を
1に設定し、シミュレーションを実行します。

\begin{scheme}
(half-adder input-1 input-2 sum carry)
~\textit{ok}~
\end{scheme}

\begin{scheme}
(set-signal! input-1 1)
~\textit{done}~
\end{scheme}

\begin{scheme}
(propagate)
~\textit{sum 8  New-value = 1}~
~\textit{done}~
\end{scheme}

\noindent
\code{sum}の進行は時刻8において1に変化しました。シミュレーションの開始から8単位時間が経過しました。
この時点で\code{input\-/2}上の信号を1に設定し値の伝播を許可します。

\begin{scheme}
(set-signal! input-2 1)
~\textit{done}~
\end{scheme}

\begin{scheme}
(propagate)
~\textit{carry 11  New-value = 1}~
~\textit{sum 16  New-value = 0}~
~\textit{done}~
\end{scheme}

\noindent
\code{carry}は時刻11にて1に変化し、\code{sum}は時刻16において0に変化しました。

\begin{quote}
\heading{\phantomsection\label{Exercise 3.31}Exercise 3.31:} 
\code{make\-/wire}内で定義された内部手続\code{accept\-/action\-/procedure!}は新しい行動手続が配線に
追加された時に、その手続が即座に実行された。この初期化がなぜ必要であるのか説明せよ。
具体的には、上の段落の半加算器の例をトレースし、システムの応答が、\code{accept\-/action\-/procedure!}が
以下のように定義されていた場合にどのように異なるかについて述べよ。

\begin{scheme}
(define (accept-action-procedure! proc)
  (set! action-procedures 
        (cons proc action-procedures)))
\end{scheme}
\end{quote}

\subsubsection*{予定表の実装}



最後に将来に実行される予定の手続を保存する予定表データ構造の詳細について説明します。


予定表は\newterm{time segments}(\jnewterm{タイムセグメント}、時間区分)により構成されています。
各タイムセグメントは数値(時刻)と、
そのタイムセグメントの間に実行されるよう予定された手続を持つキュー (\link{Exercise 3.32}参照)から
成るペアです。

\begin{scheme}
(define (make-time-segment time queue)
  (cons time queue))
(define (segment-time s) (car s))
(define (segment-queue s) (cdr s))
\end{scheme}

\noindent
タイムセグメントのキューは\link{Section 3.3.2}.で説明したキューの命令を用いて操作します。



予定表自身は1次元のタイムセグメントの表です。\link{Section 3.3.3}で説明された表との違いは
セグメントが時間の増す順にソートされることです。加えて\newterm{current time}(\jnewterm{現在時刻})
(言い換えると最後に処理された行動の時刻)を予定表の頭に保存します。新しく構築された予定表は
タイムセグメントを持っておらず現在時刻として0を持ちます。\footnote{予定表は\link{Section 3.3.3}のような
頭出しリストですが、このリストは時刻による頭出しですので追加のダミーヘッダ(テーブルにて
用いられた\code{*table*}シンボルのような物)を必要としません。}

\begin{scheme}
(define (make-agenda) (list 0))
(define (current-time agenda) (car agenda))
(define (set-current-time! agenda time)
  (set-car! agenda time))
(define (segments agenda) (cdr agenda))
(define (set-segments! agenda segments)
  (set-cdr! agenda segments))
(define (first-segment agenda) 
  (car (segments agenda)))
(define (rest-segments agenda) 
  (cdr (segments agenda)))
\end{scheme}

\noindent
予定表はタイムセグメントを持っていなければ空です。

\begin{scheme}
(define (empty-agenda? agenda)
  (null? (segments agenda)))
\end{scheme}

\noindent
予定表に行動(アクション)を追加するために、最初に予定表が空であるか確認します。
もしそうならばアクションのためのタイムセグメントを作成し、それを予定表にインストールします。
そうでなければ予定表を走査し、各セグメントの時刻を調べます。もし指定時刻が存在するならば
対応するキューにアクションを追加します。もし指定時刻よりも後の時間に辿り着いたならば、
新しいタイムセグメントを予定表のその時間の前に挿入します。もし予定表の最後まで辿り着いたならば
新しいタイムセグメントを最後に作らねばなりません。

\begin{scheme}
(define (add-to-agenda! time action agenda)
  (define (belongs-before? segments)
    (or (null? segments)
        (< time (segment-time (car segments)))))
  (define (make-new-time-segment time action)
    (let ((q (make-queue)))
      (insert-queue! q action)
      (make-time-segment time q)))
  (define (add-to-segments! segments)
    (if (= (segment-time (car segments)) time)
        (insert-queue! (segment-queue (car segments))
                       action)
        (let ((rest (cdr segments)))
          (if (belongs-before? rest)
              (set-cdr!
               segments
               (cons (make-new-time-segment time action)
                     (cdr segments)))
              (add-to-segments! rest)))))
  (let ((segments (segments agenda)))
    (if (belongs-before? segments)
        (set-segments!
         agenda
         (cons (make-new-time-segment time action)
               segments))
        (add-to-segments! segments))))
\end{scheme}

\noindent
予定表から最初のアイテムを削除する手続は最初のタイムセグメント中のキューの先頭の
アイテムを削除します。もしこの削除がタイムセグメントを空にするのであれば、
セグメントのリストからそれを削除します。\footnote{この手続の中の\code{if}式が
\( \langle \)\var{alternative}\( \kern0.08em\rangle \)式を持っていないことに
注意して下さい。このような``片腕の\code{if}文''は2つの式の間から選択するのではなく
何かをするかどうかを決定するのに使用されます。\code{if}式は述語が偽になった場合に
未定義の値を返し、\( \langle \)\var{alternative}\( \kern0.08em\rangle \)は有りません。}

\begin{scheme}
(define (remove-first-agenda-item! agenda)
  (let ((q (segment-queue (first-segment agenda))))
    (delete-queue! q)
    (if (empty-queue? q)
        (set-segments! agenda (rest-segments agenda)))))
\end{scheme}

\noindent
最初の予定表のアイテムは最初のタイムセグメントのキューの頭に見つかります。
アイテムを抽出する度に現在時刻の更新も行います。\footnote{このようにして、
現在時刻は常に最も最近に処理されたアクションの時刻になります。この時刻を
予定表の頭に格納することで例え関連するタイムセグメントが削除されても依然として
有効であることを確約します。}

\begin{scheme}
(define (first-agenda-item agenda)
  (if (empty-agenda? agenda)
      (error "Agenda is empty: FIRST-AGENDA-ITEM")
      (let ((first-seg (first-segment agenda)))
        (set-current-time! agenda 
                           (segment-time first-seg))
        (front-queue (segment-queue first-seg)))))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.32}Exercise 3.32:} 
予定表の各タイムセグメントの間に実行される手続はキューに保存される。従って各セグメントの
手続は予定表に追加された順に呼び出される(FIFO)。なぜこの順が使用されるべきか説明せよ。
具体的には入力が0,1から1,0に同じセグメントにて変化した時のANDゲートの振舞をトレースし、
もしセグメントの手続を通常の順に格納し、手続の追加と削除を先頭でのみ行った場合(LIFO)に
振舞がどのように異なるかについて述べよ。
\end{quote}


\subsection{制約伝播}
\label{Section 3.3.5}



コンピュータプログラムは伝統的に一方向の演算として体系化されます。
これは事前に指定した引数上で命令を実行し、望んだ出力を生成します。
一方で私達は時折、量の間の関係を用いてシステムをモデル化します。
例えば機械構造の数理的モデルは金属棒の偏差\( d \)が棒上の力\( F \)、棒の長さ\( L \)、
断面積\( A \)、弾性率\( E \)に方程式を通して関連するという情報を含むでしょう。

\begin{comment}

\begin{example}
dAE = FL
\end{example}

\end{comment}
\begin{displaymath}
 dAE = FL. 
\end{displaymath}


そのような方程式は一方向ではありません。任意の4つの量を与えられることで、5つ目を
計算することができます。けれども方程式を伝統的なコンピュータ言語へと翻訳することは
1つの量を選択し他の4つを用いて求めることを私達は強制されます。従って断面積\( A \)を
求める手続は偏差\( d \)を求めることには、例え\( A \)と\( d \)の演算が同じ方程式から
起こっても使用できません。\footnote{制約伝播は最初に信じられない程先進的であった
Ivan \link{Sutherland (1963)}による\acronym{SKETCHPAD}システムに現れました。
Smalltalkをベースにした美しい制約伝播システムはAlan \link{Borning (1977)}により
Xeroxパロアルト研究センタにて開発されました。Sussman, Stallman, Steeleの3人は
制約伝播を電子回路分析に応用しました(\link{Sussman and Stallman 1975}; \link{Sussman and Steele 1980})。
TK!Solver(\link{Konopasek and Jayaraman 1984})は制約をベースにした大規模モデリング環境です。}



この節では関係性自身を用いて働くことが可能な言語の設計を描きます。言語のプリミティブな要素は
\newterm{primitive constraints}(\jnewterm{プリミティブ制約})であり、幾らかの関係性が数量の間に保存される
ことを示します。例えば\( c \)は方程式\( a + b = c \)から参照されねばならず、\code{(multiplier x y z)}
は制約\( xy = z \)を表し、\code{(constant 3.14 x)}は\( x \)の値が3.14に違いないと述べています。



私達の言語はプリミティブ制約をより複雑な関係を表明するために接続する手段を提供します。
制約を\newterm{constraint networks}(\jnewterm{制約ネットワーク})を構築することで接続し、
その中で制約は\newterm{connectors}(\jnewterm{コネクタ})を用いて結合されます。コネクタは値を持つ
オブジェクトであり、1つ以上の制約に加わります。例えば華氏と摂氏の気温の間の関係が
以下であることを知っています。
\begin{comment}

\begin{example}
9C = 5(F - 32)
\end{example}

\end{comment}
\begin{displaymath}
 9C = 5(F - 32). 
\end{displaymath}

そのような制約はプリミティブな加算器、乗算器、不変制約(\link{Figure 3.28})より成り立つ
ネットワークとして考えることができます。図の中で左手に\( m \)1, \( m \)2, \( p \)の
3つの端子を持つ乗算の箱を見ることができます。これらは乗算器を以下のネットワークの残りに
接続します。\( m \)1端子は摂氏の気温を保持するコネクタ\( C \)にリンクされます。\( m \)2端子も
9を持つ整数箱にリンクされます。乗算器の箱が\( m \)1と\( m \)2の積に制約を行う\( p \)端子は
別の乗算器の箱の\( p \)端子に接続され、その箱の\( m \)2は整数5に、\( m \)1は合計の1つの
端子に接続されます。

\begin{figure}[tb]
\phantomsection\label{Figure 3.28}
\centering
\begin{comment}
\begin{quote}
\heading{Figure 3.28:} The relation \( 9C = 5(F - 32) \) expressed as a constraint network.

\begin{example}
       +---------+     +---------+   v   +---------+
C -----+ m1      |  u  |      m1 +-------+ a1      |
       |    *  p +-----+ p  *    |       |    *  s +---- F
    +--+ m2      |     |      m2 +--+ +--+ a2      |
    |  +---------+     +---------+  | |  +---------+
  w |                              x| |y
    |    +-----+        +-----+     | |     +-----+
    +----+  9  |        |  5  +-----+ +-----+  32 |
         +-----+        +-----+             +-----+
\end{example}
\end{quote}
\end{comment}
\includegraphics[width=87mm]{fig/chap3/Fig3.28.pdf}
\begin{quote}
\heading{Figure 3.28:} 制約ネットワークとして表した関係\\
\( 9C = 5(F - 32) \)
\end{quote}
\end{figure}

\noindent
このようなネットワークによる計算は以下の様に進行されます。コネクタに値が(ユーザ、またはリンクされた制約箱により)
与えられた時、その関連する制約全てを(それを起こした制約を除いて)起こし、それらに値を得たことを伝えます。
起きた制約箱は全て次にコネクタに対しコネクタの値を決定するのに十分な情報が存在するかを調査(poll)します。
もしそうであれば、制約箱はコネクタに値を設定し、コネクタはすると関係する制約を全て起こします。これが
繰り返されます。例として摂氏と華氏の間の換算では\( w \), \( x \), \( y \)は整数箱9, 5, 32それぞれにより
直ぐに設定されます。コネクタは乗算器と加算器を起動し、それらは続行に必要な情報が十分ではないことを判断します。
もしユーザ(またはネットワークの何らかの他の部分が)\( C \)に値(例えば25)を設定すると最も左の乗算器が起動され、
\( u \)に\( 25 \cdot 9 = 225 \)を設定します。すると\( u \)が2つ目の乗算器を起動し、それが\( v \)に
45を設定します。そして\( v \)が加算器を起動し、加算器は\( f \)を77に設定します。

\subsubsection*{制約システムの利用}



制約システムを用いて上で説明された気温の計算を実行するには最初に2つのコネクタ、\code{C}と\code{F}を
コンストラクタ\code{make\-/connector}を呼ぶことで作成し、\code{C}と\code{F}をあるべきネットワークにリンクします。

\begin{scheme}
(define C (make-connector))
(define F (make-connector))
(celsius-fahrenheit-converter C F)
~\textit{ok}~
\end{scheme}

\noindent
ネットワークを作成する手続は以下のように定義されます。

\begin{scheme}
(define (celsius-fahrenheit-converter c f)
  (let ((u (make-connector))
        (v (make-connector))
        (w (make-connector))
        (x (make-connector))
        (y (make-connector)))
    (multiplier c w u)
    (multiplier v x u)
    (adder v y f)
    (constant 9 w)
    (constant 5 x)
    (constant 32 y)
    'ok))
\end{scheme}

\noindent
この手続は内部コネクタ\code{u}, \code{v}, \code{w}, \code{x}, \code{y}を作成し、それらを\link{Figure 3.28}
に示されるようにプリミティブな制約コンストラクタ\code{adder}, \code{multiplier}, \code{constant}を
用いてリンクします。



実行中のネットワークを見るために、コネクタ\code{C}と\code{F}にプローブ(探針)を\link{Section 3.3.4}で配線の監視に
用いた物と同様な\code{probe}手続を用いて設置します。プローブのコネクタ上への設置はコネクタに値が
与えられる度にメッセージが表示されるようにします。

\begin{scheme}
(probe "Celsius temp" C)
(probe "Fahrenheit temp" F)
\end{scheme}

\noindent
次に\code{C}の値を25に設定します。(\code{set\-/value!}への3つ目の引数は\code{C}にこの指示が\code{user}による物
であることを伝えています)。

\begin{scheme}
(set-value! C 25 'user)
~\textit{Probe: Celsius temp = 25}~
~\textit{Probe: Fahrenheit temp = 77}~
~\textit{done}~
\end{scheme}

\noindent
\code{C}上のプローブが起動され値を報告します。\code{C}はまたその値を上で説明されたネットワークを通して
伝播させます。これが\code{F}に77を設定し、\code{F}上のプローブにより報告されます。


ここで\code{F}に新しい値、例えば212を設定してみましょう。

\begin{scheme}
(set-value! F 212 'user)
~\textit{Error! Contradiction (77 212)}~
\end{scheme}

\noindent
コネクタが矛盾に気付いたと訴えています。その値は77の時、誰かが212を設定しようとしているのです。
もし本当にネットワークを新しい値にて再利用したいのであれば\code{C}に古い値を忘れるように指示できます。

\begin{scheme}
(forget-value! C 'user)
~\textit{Probe: Celsius temp = ?}~
~\textit{Probe: Fahrenheit temp = ?}~
~\textit{done}~
\end{scheme}

\noindent
\code{C}は元の値を設定した\code{user}が今撤回しているのに気付き、\code{C}はその値をなくすことに
プローブが示すように同意し、ネットワークの残りにこの結果について伝えます。
この情報が結果的に\code{F}に伝播し、\code{F}は今となってはそれ自身の値が77であると信じ続けるための
理由が無いことに気付きます。従って\code{F}もまたその値を諦めプローブにより表示されます。


これで\code{F}は値を持たず、私達は\code{F}に212を設定できます。

\begin{scheme}
(set-value! F 212 'user)
~\textit{Probe: Fahrenheit temp = 212}~
~\textit{Probe: Celsius temp = 100}~
~\textit{done}~
\end{scheme}

\noindent
この新しい値がネットワーク中に伝播された時、\code{C}に100の値を持つことを強制し、
\code{C}上のプローブによりこのことが表されます。全く同じネットワークが\code{F}を
与えて\code{C}を計算するのと、\code{C}を与えて\code{F}を計算することに用いられている
ことに注意して下さい。この方向性の無い演算が制約ベースシステムの特徴的な
機能です。

\subsubsection*{制約システムの実装}



制約システムは局所状態を持つ手続き型のオブジェクトにより、\link{Section 3.3.4}のデジタル回路シミュレータに
良く似た作法で実装されます。制約システムのプリミティブなオブジェクトはいくらかより複雑ではあるものの、
システム全体は予定表や論理遅延時間についての考慮が不要な分、よりシンプルです。


コネクタ上の基本的な命令は次のとおりです。

\begin{itemize}

\item
\code{(has\-/value? <\var{connector}>)}はコネクタが値を持つかどうか判断する

\item
\code{(get\-/value <\var{connector}>)}はコネクタの現在地を返す

\item
\code{(set\-/value! <\var{connector}> <\var{new\-/value}> <\var{informant}>)}は
情報がコネクタに対しその値を新しい値に設定するよう要求することを示す

\item
\code{(forget\-/value! <\var{connector}> <\var{retractor}>)}はコネクタに対し撤回を望む者が値を忘れることを
要求していると伝える

\item
\code{(connect <\var{connector}> <\var{new\-/constraint}>)}はコネクタに対し新しい制約への参加を指示する

\end{itemize}

\noindent
コネクタは与えられた制約にコネクタが値を持っていると伝える手続\code{inform\-/about\-/value}と
制約にコネクタが値を失ったと伝える手続\code{inform\-/about\-/no\-/value}を用いて制約と通信を行います。


\code{adder}は加数コネクタ\code{a1}と\code{a2}と\code{sum}コネクタの間に加算器制約を構築するコンストラクタです。
加算器は局所状態を持つ手続(下記の手続\code{me})として実装されます。

\begin{scheme}
(define (adder a1 a2 sum)
  (define (process-new-value)
    (cond ((and (has-value? a1) (has-value? a2))
           (set-value! sum
                       (+ (get-value a1) (get-value a2))
                       me))
          ((and (has-value? a1) (has-value? sum))
           (set-value! a2
                       (- (get-value sum) (get-value a1))
                       me))
          ((and (has-value? a2) (has-value? sum))
           (set-value! a1
                       (- (get-value sum) (get-value a2))
                       me))))
  (define (process-forget-value)
    (forget-value! sum me)
    (forget-value! a1 me)
    (forget-value! a2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else (error "Unknown request: ADDER" request))))
  (connect a1 me)
  (connect a2 me)
  (connect sum me)
  me)
\end{scheme}

\noindent
\code{adder}は新しい加算器を指定されたコネクタに接続し自身をその値として返します。
手続\code{me}は加算器を表現し、ローカル手続を起動する者の役割を果たします。

\begin{scheme}
(define (inform-about-value constraint)
  (constraint 'I-have-a-value))
(define (inform-about-no-value constraint)
  (constraint 'I-lost-my-value))
\end{scheme}

\noindent
加算器のローカル手続\code{process\-/new\-/value}はその加算器が繋るコネクタの内1つが値を得た事を報された時に
呼び出されます。加算器は最初に\code{a1}と\code{a2}の両方が値を持っているか確認します。
もしそうならば\code{sum}に2つの加数の和をその値として設定するように指示します。
\code{set\-/value!}の\code{informant}(情報提供者)引数は加算器オブジェクト自身である\code{me}です。
もし\code{a1}と\code{a2}の両方が値を持っていない場合、加算器はひょっとしたら\code{a1}と\code{sum}が
値を持っていないか確認します。もしそうならば\code{a2}にその2つの差を設定します。最後に
\code{a2}と\code{sum}が値を持っているのならば加算器に\code{a1}を接待させるために十分な情報を
持っていることになります。もし加算器がコネクタの1つが値を失なったと報された場合、全ての
コネクタに対しその値を捨てるよう指示します。(この加算器により設定された値のみが
実際には失なわれます)。次に加算器は\code{process\-/new\-/value}を実行します。この理由は
1つ、またはそれ以上のコネクタが依然として値を持っている可能性があり(つまり、コネクタが
元々その加算器により設定されたのではない値を持っている)、これらの値は加算器を通して
伝播し返す必要があります。


乗算器は加算器にとても良く似ています。因数のどちらかが0なら例え他方の値がわからなくても
\code{product}を0にします。

\begin{scheme}
(define (multiplier m1 m2 product)
  (define (process-new-value)
    (cond ((or (and (has-value? m1) (= (get-value m1) 0))
               (and (has-value? m2) (= (get-value m2) 0)))
           (set-value! product 0 me))
          ((and (has-value? m1) (has-value? m2))
           (set-value! product
                       (* (get-value m1) (get-value m2))
                       me))
          ((and (has-value? product) (has-value? m1))
           (set-value! m2
                       (/ (get-value product) 
                          (get-value m1))
                       me))
          ((and (has-value? product) (has-value? m2))
           (set-value! m1
                       (/ (get-value product) 
                          (get-value m2))
                       me))))
  (define (process-forget-value)
    (forget-value! product me)
    (forget-value! m1 me)
    (forget-value! m2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else (error "Unknown request: 
                        MULTIPLIER" request))))
  (connect m1 me)
  (connect m2 me)
  (connect product me)
  me)
\end{scheme}

\noindent
\code{constant}コンストラクタは単純に指定されたコネクタの値を設定します。
\code{I\-/have\-/a\-/value}と\code{I\-/lost\-/my\-/value}のどちらのメッセージが定数箱に送られてもエラーを発します。

\begin{scheme}
(define (constant value connector)
  (define (me request)
    (error "Unknown request: CONSTANT" request))
  (connect connector me)
  (set-value! connector value me)
  me)
\end{scheme}

\noindent
最後にプローブは指定されたコネクタの設定、設定解除のメッセージを表示します。

\begin{scheme}
(define (probe name connector)
  (define (print-probe value)
    (newline) (display "Probe: ") (display name)
    (display " = ") (display value))
  (define (process-new-value)
    (print-probe (get-value connector)))
  (define (process-forget-value) (print-probe "?"))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else (error "Unknown request: PROBE" request))))
  (connect connector me)
  me)
\end{scheme}

\subsubsection*{コネクタの表現}


コネクタは局所状態変数を持つ手続型のオブジェクトとして表現され、
\code{value}はコネクタの現在地、\code{informant}はコネクタの値を設定したオブジェクト、
そして\code{constraints}はコネクタが参加する制約のリストです。


\begin{scheme}
(define (make-connector)
  (let ((value false) (informant false) (constraints '()))
    (define (set-my-value newval setter)
      (cond ((not (has-value? me))
             (set! value newval)
             (set! informant setter)
             (for-each-except setter
                              inform-about-value
                              constraints))
            ((not (= value newval))
             (error "Contradiction" (list value newval)))
            (else 'ignored)))
    (define (forget-my-value retractor)
      (if (eq? retractor informant)
          (begin (set! informant false)
                 (for-each-except retractor
                                  inform-about-no-value
                                  constraints))
          'ignored))
    (define (connect new-constraint)
      (if (not (memq new-constraint constraints))
          (set! constraints
                (cons new-constraint constraints)))
      (if (has-value? me)
          (inform-about-value new-constraint))
      'done)
    (define (me request)
      (cond ((eq? request 'has-value?)
             (if informant true false))
            ((eq? request 'value) value)
            ((eq? request 'set-value!) set-my-value)
            ((eq? request 'forget) forget-my-value)
            ((eq? request 'connect) connect)
            (else (error "Unknown operation: CONNECTOR"
                         request))))
    me))
\end{scheme}

\noindent
コネクタの局所手続\code{set\-/my\-/value}はコネクタの値を設定する要求が存在した時に呼ばれます。
もしコネクタが現在値を持っていない場合、その値を設定し、値の設定を要求した制約を\code{informant}として
記憶します。\footnote{\code{setter}は制約ではないかもしれません。気温の例では\code{user}を
\code{setter}として使用しました。}次にコネクタは参加している制約全てに対し値の設定を要求した
制約を除いて通知します。これは以下のiterator(イテレータ、繰り返す者)を用いて達成されます。
イテレータは指定された手続を与えられた1つを除いたリスト中の全てのアイテムに対して適用します。

\begin{scheme}
(define (for-each-except exception procedure list)
  (define (loop items)
    (cond ((null? items) 'done)
          ((eq? (car items) exception) (loop (cdr items)))
          (else (procedure (car items))
                (loop (cdr items)))))
  (loop list))
\end{scheme}

\noindent
もしコネクタがその値を忘れるよう指示されたなら、局所手続\code{forget\-/my\-/value}を
実行し、最初に要求が元々値を設定した同じオブジェクトからであるかを確認します。
もしそうならばコネクタは関連する制約に値の喪失について伝えます。



局所手続\code{connect}は指定された新しい制約を制約リストに、既に存在しない場合には追加します。
次にもしコネクタが値を持っているのならば、新しい制約にその事実を伝えます。



コネクタの手続\code{me}は他の内部手続を実行する役割を果たし、またコネクタをオブジェクトとして
表現します。以下の手続は起動のための文法上のインターフェイスを提供します。

\begin{scheme}
(define (has-value? connector) (connector 'has-value?))
(define (get-value connector) (connector 'value))
(define (set-value! connector new-value informant)
  ((connector 'set-value!) new-value informant))
(define (forget-value! connector retractor)
  ((connector 'forget) retractor))
(define (connect connector new-constraint)
  ((connector 'connect) new-constraint))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.33}Exercise 3.33:} 
プリミティブな乗算器、加算器、定数の制約を用いて、3つのコネクタ\code{a}, \code{b}, \code{c}を
入力として取り、\code{c}の値が\code{a}と\code{b}の値の平均を見出す手続\code{averager}を定義せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.34}Exercise 3.34:} 
Louis Reasonerは2つの端子を持ち、2つ目の端子上のコネクタ\code{b}が常に1つ目の端子上の値\code{a}
の二乗である制約端末squarerを構築したいと考えた。彼は以下の簡単な乗算から作られた
端末を提案した。

\begin{scheme}
(define (squarer a b) (multiplier a a b))
\end{scheme}



このアイデアには致命的な問題がある。説明せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.35}Exercise 3.35:} 
Ben BitdiddleはLouisに\link{Exercise 3.34}の問題を避ける1つの方法としてsquarerを
新しいプリミティブな制約として定義することを伝えた。Benの新しい制約の輪郭の欠けて
いる部分を埋めそのような文脈での実装を行え。

\begin{scheme}
(define (squarer a b)
  (define (process-new-value)
    (if (has-value? b)
        (if (< (get-value b) 0)
            (error "square less than 0: SQUARER" 
                   (get-value b))
            ~\( \dark \langle \)~~\var{\dark alternative1}~~\( \dark \rangle \)~)
        ~\( \dark \langle \)~~\var{\dark alternative2}~~\( \dark \rangle \)~))
  (define (process-forget-value) ~\( \dark \langle \)~~\var{\dark body1}~~\( \dark \rangle \)~)
  (define (me request) ~\( \dark \langle \)~~\var{\dark body2}~~\( \dark \rangle \)~)
  ~\( \dark \langle \)~~\var{\dark rest of definition}~~\( \dark \rangle \)~
  me)
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.36}Exercise 3.36:} 
以下のグローバル環境内の式の列を評価したとする。

\begin{scheme}
(define a (make-connector))
(define b (make-connector))
(set-value! a 10 'user)
\end{scheme}



\code{set\-/value!}の評価の間のある時点で、コネクタのローカル手続から以下の式が評価される。

\begin{scheme}
(for-each-except 
  setter inform-about-value constraints)
\end{scheme}



上の式が評価される環境を示す環境の図を描け。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.37}Exercise 3.37:} 
\code{celsius\-/fahrenheit\-/converter}(摂氏華氏変換器)手続は以下のような式指向なスタイルと比べた時に
煩わしい。

\begin{scheme}
(define (celsius-fahrenheit-converter x)
  (c+ (c* (c/ (cv 9) (cv 5))
          x)
      (cv 32)))
(define C (make-connector))
(define F (celsius-fahrenheit-converter C))
\end{scheme}



ここで\code{c+}, \code{c*}等は数値演算命令の``制約''版である。例えば\code{c+}は
2つのコネクタを引数として取り、これらに関係するコネクタを加算器制約にて
返す。

\begin{scheme}
(define (c+ x y)
  (let ((z (make-connector)))
    (adder x y z)
    z))
\end{scheme}


同様の手続\code{c\-/}, \code{c*}, \code{c/}, \code{cv}(定数)を定義し、複合制約を上記の変換器の
例の様に定義できるようにせよ。\footnote｛
式指向形式は便利です。それは演算の中間式に
名前を付ける必要性を回避できるためです。私達の元々の制約言語の形式は多くの言語が複合データを
取り扱う場合と同様に面倒でした。例として、変数がベクトルを表現する場合に
積\( (a + b) \cdot (c + d) \)を求めたい時、``命令型スタイル''で指定されたベクトルの
値を設定するけれどもそれ自身はベクトルを値として返さない手続を用いて行うことは可能です。

\begin{smallscheme}
(v-sum a b temp1)
(v-sum c d temp2)
(v-prod temp1 temp2 answer)
\end{smallscheme}



代替法として、ベクトルを値として返す手続を用いて式を用いて行うことも可能です。
その場合、明示的に\code{temp1}と\code{temp2}を記述する必要を避けることができます。

\begin{smallscheme}
(define answer (v-prod (v-sum a b) (v-sum c d)))
\end{smallscheme}



Lispは手続の値として複合オブジェクトを返すことができるため、命令型スタイル制約言語を
式指向スタイルに課題で示されたように変形することができます。複合データの扱いが乏しい
言語、例えばAlgol、Basic、Pascal(明示的にPascalのポインタ変数を用いる場合は除く)では
通常複合オブジェクトを操作する場合に命令型スタイルに行き詰まります。式指向形式の利点を
与えられるとある人はシステムを私達がこの節で行ったように命令型スタイルで実装することに
何らかの意味があるのかと尋ねるかもしれません。1つの理由は非式指向の制約言語は
制約オブジェクト上に、コネクタオブジェクト上と同様にハンドルを提供します(例えば\code{adder}手続の値)。
これはもし我々がシステムをコネクタ上の命令を通して間接的に通信するだけでなく、
制約と直接通信する新しい命令を用いてシステムを拡張したい場合にはとても便利です。
式指向スタイルを命令型の実装を用いて実装するのは簡単ですが、逆はとても難しいのです。}
\end{quote}

\section{並行性: 時間が本質}
\label{Section 3.4}



私達はここまで局所状態をモデリングのためのツールとして持つ計算オブジェクトの力を学びました。
それにもかかわらず、\link{Section 3.1.3}で警告したように、この力にはコストが伴います。
参照等価性を失なうことは等価性と変更に関する問題のチケットを増加し、評価の置換モデルを
断念し、より何回な環境モデルの支持を必要とします。


状態、等価性、変更の複雑さの下に潜んでいる中心的課題は、代入を導入することにより
私達は計算モデルの中に\newterm{time}(\jnewterm{時間})の存在を認めることを強制されることです。
代入の導入前は私達のプログラム全ては値を持つ任意の式が常に同じ値を持つという意味に
おいて恒久的でした。対照的に、\link{Section 3.1.1}で紹介した銀行口座からの引き出しと差引残高の返却
のモデル化の例を思い出して下さい。

\begin{scheme}
(withdraw 25)
~\textit{75}~
(withdraw 25)
~\textit{50}~
\end{scheme}

\noindent
ここでは同じ式の一連の評価が異なる値を生じています。この振舞は代入文の実行
(この場合では変数\code{balance}への代入)が値が変化した\newterm{moments in time}(\jnewterm{時間の瞬間})
を描いています。式の評価の結果は式自身だけではなく、これらの瞬間の前か後に評価が
行われたかにも依存します。局所状態を持つ計算モデルを用いたモデルの構築は私達に
プログラミングにおける本質的な概念としての時間に直面することを強います。



計算モデルの構造化において物理世界の私達の認知を一致させることをより進めることは可能です。
世界の中のオブジェクトは一時に1つが順に変わることはありません。そうではなく、
私達はそれらが\newterm{concurrently}(\jnewterm{並行})に---同時に---行動することを知覚します。
そのためシステムを並行に実行する計算処理の集合であるとモデル化することは多くにおいて自然です。
分離された局所状態を持つオブジェクトを用いてモデルを体系化することにより
私達のプログラムをモジュラー化するのと同様に、計算モデルを別々に、並行に発展する部分に
分割することは多くの場合に適切です。例えプログラムが逐次的な計算機により実行される
としてもプログラムを並行に実行される前提で書くことを練習することはプログラマに
不必要な制約を防ぐことを強いるため、プログラムをよりモジュール式にします。



プログラムをよりモジュール式にするのに加えて、並行演算は逐次的演算に対し速度上の
利点を与えることが可能です。逐次的演算は一時に1つの命令のみを実行するためタスクの
実行にかかる時間量は実行される命令の総量に比例します。\footnote{本物のCPUの
多くは実際にはいくつかの命令を同時に、\newterm{pipelining}(\jnewterm{パイプライン})と
呼ばれる戦略に従い実行します。このテクニックは大きくハードウェアの実行効率を
改善しますが、これは一連の命令ストリームの実行を、逐次的プログラムの振舞を保ち
ながら高速化するためのみに利用されます。}
しかしもし問題を相対的に独立した部分に分割することが可能で、稀にしか通信を行う必要が無ければ、
それらの部分を異なる計算機に配置し、存在する計算機の数に比例した速さの利点を生じることが
可能となるでしょう。



残念なことに、代入により持ち込まれた複雑性は並行性の出現により、より一層難しくなります。
並行実行の結果は世界が並列に作動するためか計算機がそれを行うためかによらず、
私達の時間の理解にさらなる複雑性をもたらします。



\subsection{並行システム内の時間の性質}
\label{Section 3.4.1}



表面上は時間は簡単に見えます。時間はイベントに課される順序付けです。\footnote{ケンブリッジの
ビルの壁上のある落書きを引用すれば``時間とは全てが同時に起こることを防ぐために発明された仕掛けだ''}
任意のイベント\( A \)と\( B \)に対し、\( A \)が\( B \)の前に起こるか、\( A \)と\( B \)が同時か、
\( A \)が\( B \)の後に起こるかです。例えば、銀行口座の例に戻れば、最初に\$100を持つ連結口座から
Peterが\$10を引き出し、Paulが\$25を引き出した場合、口座には\$65が残ります。二人の引き出し順により、
口座の残高の列は\( \,\$100 \to \$90 \to \$65\, \)か\( \,\$100 \to \$75 \to \$65\, \)です。
銀行システムの計算機実装においてこの口座の列の変化は連続した変数\code{balance}への代入として
モデル化できます。


複雑な状況ではしかし、そのような見方は問題となりえます。PeterとPaulに加えて他の人々が
同じ銀行口座に世界中に分散された現金自動預け払い機のネットワークを通してアクセスすると
します。実際の口座の残高の列は大きく、アクセスタイミングの詳細と機械の間の通信の詳細に
依存します。


このイベント順の非決定性は並行システムの設計において深刻な問題を提起します。
例えばPeterとPaulの引き出しが共通の変数\code{balance}を共有する2つの分離した処理
だとします。各処理は\link{Section 3.1.1}にて与えられた手続により指定されます。

\begin{scheme}
(define (withdraw amount)
  (if (>= balance amount)
      (begin
        (set! balance (- balance amount)) balance)
      "Insufficient funds"))
\end{scheme}

\noindent
もし2つの処理が独立に動作するなら、Peterは残高を確認し、正当な額面を
引き出そうとします。しかしPaulがPeterが残高を確認した時点とPeterが引き出しを
完了する時点の間にいくらかの資金を引き出すかもしれません。従ってPeterの
確認を無効にするかもしれません。



さらに悪くなりえます。以下の式について考えてみましょう。

\begin{scheme}
(set! balance (- balance amount))
\end{scheme}

\noindent
この式は各引き出し処理の部分として実行されます。これは3つのステップから成り立ちます。
(1) 変数\code{balance}の値にアクセスする。(2) 新しい残高を計算する。(3) \code{balance}に
新しい値を設定する。もしPeterとPaulの引き出しがこの命令を並行に実行した場合、
二人の引き出しは\code{balance}にアクセスし、それに新しい値を設定する順を交互に配置
するかもしれません。



\link{Figure 3.29}のタイミング図は\code{balance}が100で開始し、Peterが10を引き出し、Paulが
25を引き出し、それでも\code{balance}の最終の値が75である場合のイベントの順を描写しています。
図に示されるとおり、この異例の理由はPaulの\code{balance}への75の代入が減算されるべき\code{balance}
の値が100であるという前提の下で行われているためです。しかしこの前提はPeterが\code{balance}を
90に変更した時に無効になります。これは銀行システムにとって最悪な失敗です。なぜなら
システム中のお金の総量が保存されていません。取引前にお金の総額は100でした。その後、Peterは
\$10を持ち、Paulは\$25を持ち、銀行は\$75を持っています。\footnote{このシステムでより悪い失敗が
2つの\code{set!}命令が残高を同時に変更しようとした場合に起こり得ます。このような場合には
メモリ中に現れる実際のデータは2つの処理により書かれる情報の不作為な組み合わせに最後には
なるかもしれません。多くのコンピュータはプリミティブなメモリライト命令上に内部ロックを持つため、
そのような同時アクセスを防ぎます。しかし、この見たところ簡単な種類のプロテクトでさえ
マルチプロセスのコンピュータの設計においては実装上の課題を提起します。
多様なプロセッサが、データが異なるプロセッサの間でメモリアクセスのスピードを向上するために
レプリケート(``キャッシュとして保存'')が行われるかもしれないという事実に係らず、
静的なメモリ内容の見かけを得ることを保証するには、複雑な\newterm{cache\-/coherence}(\jnewterm{キャッシュ一貫性})
プロトコルが必要となります。}

\begin{figure}[tp]
\phantomsection\label{Figure 3.29}
\centering
\begin{comment}
\heading{Figure 3.29:} Timing diagram showing how interleaving the order of events 
in two banking withdrawals can lead to an incorrect final balance.

\begin{example}
 |           Peter              Bank              Paul
 |                              ____
 |                             /    \
 |             .--------------| \$100 |-------------.
 |             |               \____/              |
 |             V                                   V
 |  .----------------------.            .----------------------.           
 |  | Access balance: \$100 |            | Access balance: \$100 |
 |  `----------+-----------'            `----------+-----------'
 |             V                                   V
 |  .----------------------.            .----------------------.           
 |  | new value: 100-10=90 |            | new value: 100-25=75 |
 |  `----------+-----------'            `----------+-----------'
 |             V                                   |
 |  .----------------------.                       |
 |  | set! balance to \$90  |                       |
 |  `----------+-----------'    ____               |
 |             |               /    \              |
 |             `------------->| \$ 90 |             V
 |                             \____/   .----------------------.
 |                                      | new value: 100-25=75 |
 |                              ____    `----------+-----------'
 |                             /    \              |
 |                            | \$ 90 |<------------'
 V                             \____/
time
\end{example}
\end{comment}
\includegraphics[width=109mm]{fig/chap3/Fig3.29b.pdf}
\begin{quote}
\heading{Figure 3.29:} 2回の引き出しのイベント順の相互配置が不正確な最終残高へどのように導くかを
示したタイミング図
\end{quote}
\end{figure}

\noindent
ここに描かれた一般的な現象は、いくつかのプロセスが共通な状態変数を共有していることです。
このことを複雑にしているのは複数のプロセスが共有された状態を同時に操作しようと
試みていることです。銀行口座の例では、各取引の間に、各顧客は他の顧客が存在しないかのように
行動できなければなりません。顧客が口座を残高に依存した形で更新する時、その顧客は、変更の
瞬間の前に、残高が依然として彼が考えた状態であることを前提とできなければなりません。

\subsubsection*{並行プログラムの正しい振舞}



先の例は並行プログラムに潜みがちな微妙なバグの類型です。この複雑性の根本は
異なるプロセスの間で共有される変数への代入に横たわっています。
私達は既に\code{set!}を用いるプログラムを書く場合には気をつけねばならないことを
知っています。計算の結果が代入の起こる順に依存するためです。\footnote{\link{Section 3.1.3}に
おける指数プログラムはこのことを単一の逐次処理にて説明しました。}並行プロセスでは
特に代入に気をつけねばなりません。異なるプロセスにより作られる代入の順を
コントロールできないかもしれないためです。もしいくつかのそのような変更が
(二人の預金者が連結口座にアクセスするように)並行に行われるのであれば私達のシステムの
振舞が正しいことを確認するための何らかの方法を必要とします。例えば、連結口座からの
引き出しの場合、お金が保管されていることを確認しなければなりません。並行プログラムの
振舞を正しくするために、並行実行に何らかの制限を置かねばなりません。



並行性への可能な1つの制限は、任意の共有状態変数を変更するどの2つの命令もどうじ には起こり
得ないことです。これはとても厳しい制限です。分散銀行システムではシステム設計に対し
ただ1つの取引だけが一時に手続できることを保証することを要求します。これは非効率であり、
かつ過度に保守的です。\link{Figure 3.30}はPeterとPaulが銀行口座を共有し、Paulはまたプライベートな
口座を持っていることを示しています。共有口座からの2つの引き出し(1つはPeterによる、もう1つはPaul
によるもの)とPaulのプライベート口座への預金を図示しています。\footnote{列はPeterの財布、
(Bank1内の)共有口座、Paulの財布、(Bank2内の)Paulのプライベート口座の中身を各引き出し(W)と
預金(D)の前後にて示しています。Peterは\$10をBank1から引き出し、Paulは\$5をBank2に預金し、
次にBank1から\$25を引き出しています。}共有口座からの2つの引き出しは並行であってはなりません
(両方が同じ口座にアクセスと更新を行うため)。またPaulの預金と引き出しは並行であってはなりません
(両方がPaulの財布にアクセスと更新を行うため)。しかしPaulによる彼のプライベート口座への預金を
Peterの共有アカウントからの引き出しと並行に進行することを許すことは何の問題も起こさないはずです。


\begin{figure}[tb]
\phantomsection\label{Figure 3.30}
\centering
\begin{comment}
\heading{Figure 3.30:} Concurrent deposits and withdrawals from a joint account 
in Bank1 and a private account in Bank2.

\begin{example}
 |    Peter          Bank1          Paul           Bank2
 |    ____           ____           ____           ____  
 |   /    \         /    \         /    \         /    \ 
 |  |  \$7  |--. .--| \$100 |       |  \$5  |--. .--| \$300 |
 |   \____/   V V   \____/         \____/   V V   \____/ 
 |           +---+                         +---+         
 |           | W |                         | D |         
 |    ____   ++-++   ____           ____   ++-++   ____  
 |   /    \   | |   /    \         /    \   | |   /    \ 
 |  | \$17  |<-' `->| \$90  |--. .--|  \$0  |<-' `->| \$305 |
 |   \____/         \____/   V V   \____/         \____/ 
 |                          +---+
 |                          | W |
 |    ____           ____   ++-++   ____           ____  
 |   /    \         /    \   | |   /    \         /    \ 
 |  | \$17  |       | \$65  |<-' `->| \$25  |       | \$305 |
 |   \____/         \____/         \____/         \____/ 
 V
time
\end{example}
\end{comment}
\includegraphics[width=94mm]{fig/chap3/Fig3.30b.pdf}
\begin{quote}
\heading{Figure 3.30:} 銀行1の連結口座と銀行2の個人口座への並行な預け入れと引き出し
\end{quote}
\end{figure}

\noindent
並行性上の比較的厳しくない制限は並行システムがまるでプロセスが同じ
順に逐次的に実行されたかのように同じ結果を生成することを保証します。
2つの重要な側面がこの制限にはあります。第一にプロセスに対し実際に
逐次的に実行することを要求はしませんが、\emph{あたかも}逐次的に実行された
場合と同じ結果を生成することを要求します。\link{Figure 3.30}の例に対して
銀行口座システムの設計者は安全にPaulの預金とPeterの引き出しを並行に起こす
ことを許可できます。なぜなら2つの命令が逐次的に起こったのと最終結果が同じに
なるためです。第二に、複数の可能な``正しい''結果が並行プログラムにより生成
されるでしょう。なぜなら結果が\emph{ある}逐次的順序と同じ結果であることのみを
要求しているためです。例えばPeterとPaulの連結口座に\$100が初めにあるとし、
Peterが\$40を預金し、Paulが並行に口座の半分のお金を引き出したとします。
すると逐次的実行の口座残高は\$70か\$90のどちらかになります
(\link{Exercise 3.38}参照)。\footnote{\label{Footnote 39}この考えをより形式的に
表す方法は、並行プログラムは本質的に\newterm{nondeterministic}(\jnewterm{非決定的})である
と述べることです。つまり、それらは単一の値を持つ関数ではなく、結果が起こり得る値の
集合となる関数により説明されます。\link{Section 4.3}では非決定的演算について学びます。}



並行プログラムの正しい実行のためのより弱い要件はまだ有ります。拡散のシミュレーションの
プログラム(例えば物質内の熱の流れ)は巨大な数のプロセスから成り、各プロセスは
小容量の空間を表し、その値を並行に更新します。各プロセスはその値を、その値と近傍の値
の平均へと繰り返し変更します。このアルゴリズムは命令が行われる順から独立して正しい
答に収束します。共有値の並行な使用上にどんな制限も必要としません。

\begin{quote}
\heading{\phantomsection\label{Exercise 3.38}Exercise 3.38:} 
Peter, Paul, Maryが初めに\$100を持つ連結銀行口座を共有すると仮定する。。
並行に、Peterが\$10の預金、Paulが\$20の引き出し、Maryは口座の半分のお金の引き出しを
以下のコマンドにより実行した。

\begin{example}
Peter: (set! balance (+ balance 10))
Paul:  (set! balance (- balance 20))
Mary:  (set! balance (- balance (/ balance 2)))
\end{example}

\begin{enumerate}[a]

\item
これらの3つの取引が完了した後に、全ての異なる\code{balance}の起こり得る値を並べよ。
ただし銀行システムはこの3つのプロセスが何らかの順にて逐次的に実行する前提とする。

\item
もしシステムがプロセスにインターリーブ(相互配置)を認めた場合に生成される他の値は何か?
\link{Figure 3.29}の様なタイミング図を描きこれらの値がどのように起こり得るのか説明せよ。
\end{enumerate}
\end{quote}

\subsection{並行性制御のための仕組み}
\label{Section 3.4.2}


並行プロセスの取扱における困難は異なるプロセスのイベント順の交互配置について考える
必要性に原因があることを学びました。例えば2つのプロセスがあり1つは3つの順序付けられた
イベント\( (a, b, c) \)で、もう1つは3つの順序付けられたイベント\( (x, y, z) \)で
あるとします。もし2つのプロセスが、それらの実行がどのように相互配置されるのかについて
制約無しで並行に実行された時、2つのプロセスの個々の順は変わらないとしても、
20の異なる起こり得るイベントの順が存在します。

\begin{example}
(a,b,c,x,y,z)  (a,x,b,y,c,z)  (x,a,b,c,y,z)  (x,a,y,z,b,c)
(a,b,x,c,y,z)  (a,x,b,y,z,c)  (x,a,b,y,c,z)  (x,y,a,b,c,z)
(a,b,x,y,c,z)  (a,x,y,b,c,z)  (x,a,b,y,z,c)  (x,y,a,b,z,c)
(a,b,x,y,z,c)  (a,x,y,b,z,c)  (x,a,y,b,c,z)  (x,y,a,z,b,c)
(a,x,b,c,y,z)  (a,x,y,z,b,c)  (x,a,y,b,z,c)  (x,y,z,a,b,c)
\end{example}

\noindent
プログラマがこのシステムを設計するにつれ、これらの20種の順序のそれぞれの結果について
考慮して、各振舞が受け入れられるか確認する必要があるでしょう。そのような取り組み方は
プロセスとイベントの数が増加するにつれ、急速に手に負えない物となるでしょう。


並行システムの設計に対するより現実的なアプローチは
プログラムの振舞が正しいことを確認できるよう並行プロセスのインターリーブを制約できる
一般的な仕組みを工夫することです。
多くの仕組みがこの目的のため開発されてきました。この節ではそれらの1つ、
\newterm{serializer}(\jnewterm{シリアライザ}、並列直列変換器)について学びます。

\subsubsection*{共有状態へのアクセスの直列化}



直列化(serialization)は次の考えを実装します。プロセスは並行に実行します。しかし幾つかの手続の
集合が存在し、それらは並行には実行できません。もっと正確に言えば直列化は
各直列化された集合内のただ1つの手続の実行が一時に許されるような複数の区別された
手続の集合を作成します。もし1つの集合内のいくつかの手続が実行されるなら、
集合内の任意の手続を実行しようとするプロセスは最初の実行が完了するまで待つことを
強制されます。



直列化を用いて共有変数へのアクセスをコントロールできます。例えばもし共有変数を
その変数の前の値に応じて変更したい時、同じ手続内でその変数の以前の値にアクセスし、
その変数に新しい値を代入します。それからその変数に代入するどの他の手続もこの
手続とは並行には実行でなきないことを、同じシリアライザを持つこれらの手続の全てを
直列化することにより確実にします。これはその変数の値がアクセスとそれに対応する代入の
間に変更されることができないことを保証します。

\subsubsection*{Schemeのシリアライザ}


上記の仕組みをより確実に行うために、\code{parallel\-/execute}(並列実行)と呼ばれる手続を含む
拡張Schemeを持っていると仮定しましょう。

\begin{scheme}
(parallel-execute ~\( \dark \langle \)~~\( \dark p_1 \)~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark p_2 \)~~\( \dark \rangle \)~ ~\( \dots \)~ ~\( \dark \langle \)~~\( \dark p_k \)~~\( \dark \rangle \)~)
\end{scheme}

\noindent
各\( \langle \)\( p \)\( \kern0.08em\rangle \)は引数無しの手続でなければなりません。
\code{parallel\-/execute}は分離されたプロセスを各\( \langle \)\( p \)\( \kern0.08em\rangle \)に対し作り、
それらのプロセスは\( \langle \)\( p \)\( \kern0.08em\rangle \)を(引数無しで)適用します。
これらのプロセスは全て並行に実行されます。\footnote{\code{parallel\-/execute}は標準Schemeの一部ではありません。
しかし\acronym{MIT} Schemeで実装することが可能です。私達の実装においては新しい並行プロセスはまた
オリジナルのSchemeプロセスと共に並行に実行できます。また私達の実装では\code{parallel\-/execute}により
返される値は特別なコントロールオブジェクトであり新しく作成されたプロセスを停止させるために使用できます。}



これがどのように利用されるかの例として、以下について考えてみて下さい。

\begin{scheme}
(define x 10)
(parallel-execute
 (lambda () (set! x (* x x)))
 (lambda () (set! x (+ x 1))))
\end{scheme}

\noindent
これ2つの並行プロセス---\code{x}に\code{x}かける\code{x}を設定する\( P_1 \)と、\code{x}に1を足す
\( P_2 \)を作成します。実行完了後に、\( P_1 \)と\( P_2 \)の
イベントのインターリーブに依存するため、\code{x}は5つの起こり得る値の内1つに成ります。

\begin{scheme}
101: ~\textrm{\( P_1 \)が\code{x}に100を設定し、次に\( P_2 \)が\code{x}を101に増やす}~
121: ~\textrm{\( P_2 \)が\code{x}を11に増やし、次に\( P_1 \)が\code{x}を\code{x} \code{*} \code{x}に設定}~
110: ~\textrm{\( P_2 \)が\code{x}を10から11に以下の2度のアクセスの間に変化させる} ~
     ~\textrm{\( P_1 \)が\code{x}の値に\code{(* x x)}の評価の間にアクセスする}~
 11: ~\textrm{\( P_2 \)が\code{x}にアクセスし, 次に\( P_1 \)が\code{x}に100を設定し、\( P_2 \)が\code{x}を設定}~
100: ~\textrm{\( P_1 \)が\code{x}に(二度)アクセスし、次に\( P_2 \)が\code{x}を11に設定、次に\( P_1 \)が\code{x}を設定}~
\end{scheme}

\noindent
並行性を\newterm{serializers}(\jnewterm{シリアライザ})により作成された直列化された手続を用いることで抑制
することができます。シリアライザは\code{make\-/serializer}により構築され、この実装は後程与えられます。
シリアライザは手続を引数として取り、元の手続の様に振る舞うserialized(被直列化)手続を返します。
与えられたシリアライザへの全ての呼出は同じ集合に属する被直列化手続を返します。


従って上の例とは異なり、以下の実行は

\begin{scheme}
(define x 10)
(define s (make-serializer))
(parallel-execute
 (s (lambda () (set! x (* x x))))
 (s (lambda () (set! x (+ x 1)))))
\end{scheme}

\noindent
\code{x}に対しただ2つの起こり得る値、101と121を返します。他の可能性は\( P_1 \)と\( P_2 \)の
実行がインターリーブ(相互配置)されないため排除されました。


以下に\link{Section 3.1.1}の\code{make\-/account}手続を預け入れと引き出しが直列化された版を示します。

\begin{scheme}
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((protected (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (protected withdraw))
            ((eq? m 'deposit) (protected deposit))
            ((eq? m 'balance) balance)
            (else (error "Unknown request: MAKE-ACCOUNT"
                         m))))
    dispatch))
\end{scheme}

\noindent
この実装により、2つのプロセスは単一の口座に並行に預け入れと引き出しを行うことはできなく
なりました。これにより\link{Figure 3.29}で図示されたエラーの原因、
Paulの新しい値を求めるための残高へのアクセスと、Paulが実際に代入を行う時の間に、
Peterが口座残高を変更する場合は排除されます。
一方で、各口座はそれ自身のシリアライザを持つので、異なる口座への預金と引き出しは並行
に行うことができます。

\begin{quote}
\heading{\phantomsection\label{Exercise 3.39}Exercise 3.39:} 
上で示された並行実行における5つの可能性の内、もし変わりに以下のような実行を起こなった
場合にどれが残るか?

\begin{scheme}
(define x 10)
(define s (make-serializer))
(parallel-execute 
 (lambda () (set! x ((s (lambda () (* x x))))))
 (s (lambda () (set! x (+ x 1)))))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.40}Exercise 3.40:}
以下を実行した場合に\code{x}の起こり得る値の全てを上げよ。

\begin{scheme}
(define x 10)
(parallel-execute (lambda () (set! x (* x x)))
                  (lambda () (set! x (* x x x))))
\end{scheme}

これらの内もし代わりに以下の直列化手続を用いた場合どれが残るか?

\begin{scheme}
(define x 10)
(define s (make-serializer))
(parallel-execute (s (lambda () (set! x (* x x))))
                  (s (lambda () (set! x (* x x x)))))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.41}Exercise 3.41:} 
Ben Bitdiddleは以下のように銀行口座を実行すればより良くなるのではないかと心配している。
(コメントの有る行が変更されている)。

\begin{scheme}
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance 
                     (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((protected (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (protected withdraw))
            ((eq? m 'deposit) (protected deposit))
            ((eq? m 'balance)
             ((protected 
               (lambda () balance)))) ~\textrm{; serialized}~
            (else
             (error "Unknown request: MAKE-ACCOUNT"
                    m))))
    dispatch))
\end{scheme}

\noindent
心配の理由は非直列化アクセスを銀行口座に許すと得意な振舞が起こり得るためだ。
同意するか? Benの懸念を実演するシナリオは存在するか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.42}Exercise 3.42:} 
Ben Bitdiddleは全ての\code{withdraw}と\code{deposit}メッセージに対して新しい被直列化手続を
作成することは時間の無駄であると提案した。彼は\code{protected}への呼出が
\code{dispatch}手続の外で行われるよう\code{make\-/account}を変更することができると述べた。
つまりwithdrawal手続が呼ばれる度に、口座が(口座が作成されたと同時に作成された)同じ
被直列化手続を返すことになるだろう。

\begin{scheme}
(define (make-account balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((protected (make-serializer)))
    (let ((protected-withdraw (protected withdraw))
          (protected-deposit (protected deposit)))
      (define (dispatch m)
        (cond ((eq? m 'withdraw) protected-withdraw)
              ((eq? m 'deposit) protected-deposit)
              ((eq? m 'balance) balance)
              (else 
               (error "Unknown request: MAKE-ACCOUNT"
                      m))))
      dispatch)))
\end{scheme}



これは行うことが安全な変更だろうか? 具体的には、これらの2つの版の\code{make\-/account}により
許される並行性に違いは存在するだろうか?
\end{quote}

\subsubsection*{複数共有リソース使用の複雑さ}



シリアライザは並行プログラムの複雑性の分離を手助けすることで、注意深く(願わくは)正しく
取り扱えるようにする強力な抽象化を与えます。しかしシリアライザの使用は
(単一の銀行口座のような)ただ単一の共有リソースが存在する場合には相対的に簡単ですが、
並行プログラミングは複数の共有リソースがある場合に、裏切るかのように難しくなります。



提起できる困難さの内1つを説明するために、2つの銀行口座の残高を交換したいと
考えます。各口座にアクセスし残高を見つけ、残高間の差を計算し、一方の口座から
この差を引き出し、もう一方の口座へ預け入れます。これを以下のように実装することが
できます。\footnote{\code{deposit}メッセージが負の額面を受け入れるという事実を利用する
ことで\code{exchange}を簡略化しました。(これは私達の銀行システムの深刻なバグです！)}

\begin{scheme}
(define (exchange account1 account2)
  (let ((difference (- (account1 'balance)
                       (account2 'balance))))
    ((account1 'withdraw) difference)
    ((account2 'deposit) difference)))
\end{scheme}

\noindent
この手続は単一のプロセスのみが交換を試みる場合にはうまく働きます。しかしPeterとPaulが
二人共口座\( a \)1, \( a \)2, \( a \)3にアクセスし、そしてPeterが\( a \)1と\( a \)2を
交換している間にPaulが並行に\( a \)1と\( a \)3を交換している場合を考えてみて下さい。
例え口座の預け入れと引き出しが個別の口座に対して(この節の上で示された\code{make\-/account}手続の
ように)直列化されたとしても、\code{exchange}は依然として不正確な結果を生じることができます。
例えばPeterが\( a \)1と\( a \)2の残高の差を求める時、PaulがPeterが交換を完了する前に
\( a \)1の残高を変更するかもしれません。\footnote{もし口座残高が\$10, \$20, \$30で始めた
場合、任意の回数の交換の後に、残高は何らかの順にて依然として\$10, \$20, \$30にならねばなりません。
個別の口座への預け入れの直列化はこれを保証するのに十分ではありません。\link{Exercise 3.43}を
参照して下さい。}正しい振舞のためには、\code{exchange}手続を、交換の全体の時間の間、口座への
どの他の並行アクセスもロックアウト(締め出し)するように準備をしなければなりません。


これを達成する1つの方法は両方の口座のシリアライザを用いて\code{exchange}手続全体を
直列化します。これを行うためには、口座のシリアライザへのアクセスに準備を行います。
シリアライザを露出することで、銀行口座オブジェクトのモジュール化を意図的に破っている
ことに注意して下さい。\code{make\-/account}の以下の版は\link{Section 3.1.1}で与えられた元の版と
シリアライザがbalance変数を守るため提供されていることを除けば同じです。そして
シリアライザはメッセージパッシングを通して転送されます。

\begin{scheme}
(define (make-account-and-serializer balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((balance-serializer (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) withdraw)
            ((eq? m 'deposit) deposit)
            ((eq? m 'balance) balance)
            ((eq? m 'serializer) balance-serializer)
            (else 
             (error "Unknown request: MAKE-ACCOUNT"
                    m))))
    dispatch))
\end{scheme}

\noindent
これを用いて直列化された預け入れと引き出しを行うことができます。しかし最初の直列化された
口座とは異なり、直列化を明示的に管理することは銀行口座オブジェクトの各ユーザの責任です。
例えば以下の様にです。\footnote{\link{Exercise 3.45}にてなぜ預け入れと引き出しがもはや
自動的に口座により直列化されないのかについて調査します。}

\begin{scheme}
(define (deposit account amount)
  (let ((s (account 'serializer))
        (d (account 'deposit)))
    ((s d) amount)))
\end{scheme}

\noindent
シリアライザをこの方法で外出しすることは私達に直列化された交換プログラムを実装するのに
十分な柔軟性を与えます。単純に元の\code{exchange}手続を両方の口座のシリアライザにて
直列化します。

\begin{scheme}
(define (serialized-exchange account1 account2)
  (let ((serializer1 (account1 'serializer))
        (serializer2 (account2 'serializer)))
    ((serializer1 (serializer2 exchange))
     account1
     account2)))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.43}Exercise 3.43:} 
3つの口座の残高が\$10, \$20, \$30で始まり、複数のプロセスが実行され口座の残高を
交換すると考える。プロセスが逐次的に実行されるなら、任意の数の並行な交換の後に、
口座残高がある順序において\$10, \$20, \$30になると主張する。\link{Figure 3.29}の
ようなタイミング図を描き、交換がこの節のaccount-exchangeの最初の版を
用いて実装された場合にこの前提がどのように破られるかについて示せ。一方で、
例えこの\code{exchange}プログラムを用いても口座の残高の合計は保存されると主張する。
タイミング図を描き、個別の口座上の取引を直列化しない場合には
例えこの前提でもどのように破られるかについて示せ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.44}Exercise 3.44:} 
ある口座から別の口座への振込の問題について考える。Ben Bitdiddleは
例え複数の人々が並行にお金を複数の口座間にて転送をしても、以下の手続を用いることで、
預金と引き出しの取引を直列化する任意の口座の仕組み、例えば上のテキストの\code{make\-/account}の版を
用いながら振込を達成できると主張する。

\begin{scheme}
(define (transfer from-account to-account amount)
  ((from-account 'withdraw) amount)
  ((to-account 'deposit) amount))
\end{scheme}



Louis Reasonerはここにも問題があると主張した。交換問題を取り扱うのに必要とされた様な
より洗練された手法が必要であるとも述べた。Louisは正しいだろうか? もし正しくないのならば
振込問題と交換問題の間の本質的な違いは何か? (\code{from\-/account}の残高は少くとも\code{amount}で
あると考えること)。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.45}Exercise 3.45:} 
Louis Reasonerは私達の銀行口座システムは不必要に複雑、かつエラーを起こしやすく、
預け入れと引き出しも自動的に直列化されないと考えた。彼は
\code{make\-/account}が行ったように口座と預け入れを直列化するためにそれを用いることに加えて
(その代わりにではなく)
\code{make\-/account\-/and\-/serializer}はシリアライザを(\code{serialized\-/exchange}のような
手続にて利用するために)露出させるべきだったと主張した。
彼は口座を以下のように再定義することを提案した。

\begin{smallscheme}
(define (make-account-and-serializer balance)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount)) balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount)) balance)
  (let ((balance-serializer (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (balance-serializer withdraw))
            ((eq? m 'deposit) (balance-serializer deposit))
            ((eq? m 'balance) balance)
            ((eq? m 'serializer) balance-serializer)
            (else (error "Unknown request: MAKE-ACCOUNT" m))))
    dispatch))
\end{smallscheme}



するとdeposit(預け入れ)は元々の\code{make\-/account}で用いたように扱われる。

\begin{scheme}
(define (deposit account amount)
  ((account 'deposit) amount))
\end{scheme}


Louisの推論の何が間違っているか説明せよ。具体的には\code{serialized\-/exchange}が
呼ばれた時に何が起こるかについて考えよ。
\end{quote}

\subsubsection*{シリアライザの実装}



私達はシリアライザを\newterm{mutex}(\jnewterm{ミューテックス}、相互排除)と呼ばれるよりプリミティブな
同期の仕組みを用いて実装します。mutexは2つの命令をサポートするオブジェクトです。1つはmutex
が\newterm{acquired}(\jnewterm{獲得})でき、もう1つはmutexが\newterm{released}(\jnewterm{解放})できます。
一度mutexが獲得されれば、他のそのmutexに対する獲得命令はそのmutexが解放されるまで
続行することができません。\footnote{``mutex''という用語は\newterm{mutual exclusion}(\jnewterm{相互排除})
の省略形です。並行処理が安全に資源を共有することを可能にする仕組みの準備における一般的な問題は
相互排除問題と呼ばれます。私達のmutexは\newterm{semaphore}(\jnewterm{セマフォ})という仕組みの簡単な改良型
です。(\link{Exercise 3.47}参照)。これはアイントホーフェン技術大学にて開発された
``THE'' Multiprogramming system(訳注: THEは究極のとかこれぞとか唯一の等の意味になる)
にて導入され、大学のオランダ語でのイニシャルから名付けられました(\link{Dijkstra 1968a})。
acquireとreleaseの命令は元々はオランダ語の単語\emph{passeren}(渡す)と\emph{vrijgeven}(解放する)から
PとVと呼ばれ、鉄道システムにて用いられたsemaphores(信号装置)を参照しています。
Dijkstra(ダイクストラ)の古典的解説(\link{Dijkstra 1968b})は明確に並行コントロールの問題を表した最も初期の
1つであり、多様な並行問題をどのようにセマフォを用いて扱うかについて示しました。}
私たちの実装では、各シリアライザは関連付けられたmutexを持ちます。手続\code{p}を与えられた場合、
シリアライザはmutexを獲得する手続を返し、\code{p}を実行し、それからmutexを解放します。
これがシリアライザにより生成された手続の1つのみが一度に実行できることを保証します。これが
まさに私たちが保証する必要のある、直列化の特性です。

\begin{scheme}
(define (make-serializer)
  (let ((mutex (make-mutex)))
    (lambda (p)
      (define (serialized-p . args)
        (mutex 'acquire)
        (let ((val (apply p args)))
          (mutex 'release)
          val))
      serialized-p)))
\end{scheme}

\noindent
mutexはミュータブルなオブジェクト(ここで私達は1要素のリストを使用し、\newterm{cell}(\jnewterm{セル})
と参照します。)であり、trueかfalseの値を保持します。値がfalseの時、mutexは獲得可能です。
値がtrueの時、mutexは使用不可であり、このmutexを獲得しようと試みるプロセスは待たなければ
いけません。



私達のmutexコンストラクタ\code{make-mutex}はセルの中身をfalseに初期化することから始めます。
mutexを獲得するためにはセルを確認します。もしmutexが使用可能であれば、セルの中身をtrueに
して続行します。そうでなければループの中で待ち、mutexが使用可能になるまで何度も獲得を
試みます。\footnote{多くの時分割OSではmutexでブロックされるプロセスは上記のように
``busy-waiting''(占有待ち)にて時間を無駄にはしません。その代わりにシステムは他のプロセスを
最初のプロセスが待っている間に実行するようにスケジュールし、ブロックされたプロセスはmutexが使用可能に
なると起こされます。}mutexを解放するためにはセルの中身にfalseを設定します。

\begin{scheme}
(define (make-mutex)
  (let ((cell (list false)))
    (define (the-mutex m)
      (cond ((eq? m 'acquire)
             (if (test-and-set! cell)
                 (the-mutex 'acquire))) ~\textrm{; retry}~
            ((eq? m 'release) (clear! cell))))
    the-mutex))
(define (clear! cell) (set-car! cell false))
\end{scheme}

\noindent
\code{test\-/and\-/set!}はセルをテストし、テストの結果を返します。さらに、もしテストが
falseであれば\code{test\-/and\-/set!}はセルの中身にfalseを返す前にtrueを設定します。
この振舞は以下の手続のように表現できます。

\begin{scheme}
(define (test-and-set! cell)
  (if (car cell) true (begin (set-car! cell true) false)))
\end{scheme}

\noindent
しかし、この\code{test\-/and\-/set!}の実装は現状では十分ではありません。
致命的な機微がここに存在し、ここが並行性コントロールがシステムに入る
本質的な場所です。\code{test\-/and\-/set!}命令は\newterm{atomically}(不可分に、\jnewterm{アトミック}に)
実行されなければなりません。つまり、一度プロセスがセルをテストしfalseであると
知ったならば、セルの中身が実際にセルをテストできるどの他のプロセスよりも先に
trueと設定されることを保証せねばなりません。もしこの保証をしなければmutexは
\link{Figure 3.29}における銀行口座の失敗と似た失敗をします。(\link{Exercise 3.46}参照)。



\code{test\-/and\-/set!}の実際の実装は私達のシステムが並行プロセスをどのように実行するかの
詳細に依存します。例えば私達は並行プロセスを逐次的なプロセッサ上に時分割のメカニズムを
用いて複数のプロセスを循環させることで実行するかもしれません。各プロセスに少ない時間の
間割り込みが発生するまで実行することを許し次のプロセスを開始します。このような場合には
\code{test\-/and\-/set!}はテストと設定の間は時分割を停止することでうまく行きます。\footnote{
シングルプロセッサ向けの\acronym{MIT} Schemeは時分割モデルを使うので\code{test\-/and\-/set!}は以下の様に
実装できます。

\begin{smallscheme}
(define (test-and-set! cell)
  (without-interrupts
   (lambda ()
     (if (car cell)
         true
         (begin (set-car! cell true)
                false)))))
\end{smallscheme}

\noindent
\code{without\-/interrupts}は時分割割り込みをその引数である手続が実行されている間、無効にします。
}
代替法として、マルチプロセスのコンピュータはアトミックな命令を直接ハードウェアにて
サポートします。\footnote{そのような命令にはtest\-/and-set,
test-and-clear, swap, compare-and-exchange, load-reserve, store-conditional等
様々なものが存在し、その設計は注意深くマシンのプロセッサ-メモリ間インターフェイスに
合わせなければいけません。ここで起こる1つの問題にはそのような命令を用いて
完全に同時に同じリソースを2つのプロセスが獲得しようと試みた場合に何が起こるかを
決定することです。これはどのプロセスがコントロールを握るのかについて決定する
ための何らかの仕組みを要求します。そのような仕組みは\newterm{arbiter}(\jnewterm{アービタ}、調停者)
と呼ばれます。アービタは通常ある種のハードウェアデバイスにまとめられます。
残念なことに、アービタに対し自由裁量の長さの時間を決定を行うのに許さない限り
100\%の時間を働く公平なアービタを構築することは物理的に不可能であることが証明できます。
ここでの根本的な現象は元々14世紀のフランス人哲学者Jean Buridan(ジャン ビュリダン)により
Aristotle(アリストテレス)の\textit{De caelo}(天体論)への注釈において観察されています。
ビュリダンは2つの等しく魅力的な食事の情報源の間に置かれた完全に理性的な犬は
飢えて死ぬと主張しました。最初にどちらに行くのか決めることが不可能なためです。
}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.46}Exercise 3.46:} 
\code{test\-/and\-/set!}をテキストに示される通常の手続を用い、命令をアトミックにする試み無しで
実装すると仮定する。\link{Figure 3.29}の様なタイミング図を描き、2つのプロセスが同時に
mutexを獲得するのを許可した場合にmutexの実装がどのように失敗するのか説明せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.47}Exercise 3.47:} 
(サイズ\( n \)の)セマフォはmutexの一般化である。mutexのように、セマフォはacquireと
release命令をサポートするが、最大\( n \)プロセスまでが並行に獲得できることでは
より一般的である。セマフォを獲得しようとする追加のプロセスは解放命令を待たなければ
ならない。セマフォの実装を以下の条件で行え。

\begin{enumerate}[a]

\item
mutexを用いる

\item
アトミックな\code{test\-/and\-/set!}命令を用いる

\end{enumerate}
\end{quote}

\subsubsection*{デッドロック}



シリアライザをどのように実装するべきかについて学習したため、
例え上記の\code{serialized\-/exchange}を用いても口座の交換が依然として
問題を持つことを理解することができます。Peterが\( a \)1と\( a \)2を交換しようとした時、
Paulが並行に\( a \)2を\( a \)1と交換しようと試みていると想像してみて下さい。
Peterのプロセスが\( a \)1を守る直列化された手続に入った時点に届いたとします。
その直後に、Paulのプロセスが\( a \)2を守る直列化された手続に入りました。
さてPeterは(\( a \)2を守っている直列化された手続に入ること)を進めることはPaulが
\( a \)2を守る直列化された手続から抜けるまでできません。同様に、Paulもまた
Peterが\( a \)1を守る直列化された手続を抜けるまで進めることができません。
この状況は\newterm{deadlock}(\jnewterm{デッドロック})と呼ばれます。デッドロックは並行なアクセスを
複数の共有リソースに対し提供するシステムでは常に存在する危険性です。



この状況におけるデッドロックを防ぐ1つの方法は各口座に固有の識別番号を与え、
\code{serialized\-/exchange}を書き換えることでプロセスが常に最も小さな番号の
口座を守る手続を最初に入るよう試みるようにします。この方法は交換問題に対して
うまく行きますが、より洗練されたデッドロック防止技術を必要とする他の状況が
存在します。またはデッドロックが全く防げない状況も存在します。(\link{Exercise 3.48} 
と\link{Exercise 3.49}を参照)\footnote{デッドロックを共有リソースに番号を付け、順に
獲得する一般的なテクニックは\link{Havender (1968)}によります。デッドロックが防げない
状況では\newterm{deadlock\-/recovery}(\jnewterm{デッドロックリカバリ}(復帰))手法を必要とし、それはプロセスに
デッドロック状態の``back out''(取消)と再試行を引き起します。デッドロックリカバリの
仕組みは広くデータベース管理システムにて使用され、\link{Gray and Reuter 1993}に
詳細が取り上げられています。}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.48}Exercise 3.48:} 
なぜ上で説明されたデッドロック防止手法(即ち口座に番号を付け各プロセスが最も小さな
番号の口座を最初に獲得する)が交換問題のデッドロックを防ぐのか詳細に説明せよ。
\code{serialized\-/exchange}をこの考えを組込むように書き直せ。(\code{make\-/account}も
変更する必要があり、そうすることで各口座が番号と共に作られ、その番号が適切な
メッセージを送ることによりアクセスできるようにしなければならない。)
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.49}Exercise 3.49:} 
上で説明されたデッドロック防止の仕組みがうまく行かない場合のシナリオを示せ。

\end{quote}

\subsubsection*{並行性、時間と通信}



並行システムのプログラミングが異なるプロセスが共有状態にアクセスする時に
イベントの順序をコントロールすることをどうして必要とするかについて学びました。
そして賢明なシリアライザの使用を通してこのコントロールをどのように達成する
かについても学びました。しかし根本的な視点から、常に``共有状態''が
何を意味するのかが明らかでないために、並行性の問題はそれよりも深く位置します。



\code{test\-/and\-/set!}のような仕組みはプロセスに対し任意の時間にグローバルな共有フラグ
の試験を要求します。これは解決が難しく、現在の高速なCPUにおいて実装するのに非効率的です。
パイプラインやキャッシュメモリの様な最適化の仕組みのためメモリの中身は各瞬間において
静的な状態にはありません。現代のマルチプロセスシステムにおいては、従ってシリアライザの
パラダイムは並行性コントロールの新しい取り組みにより取って代わられてきています。\footnote{そのような
直列化の代替法の1つは\newterm{barrier synchronization}(\jnewterm{バリア同期})と呼ばれます。
プログラマは並行プロセスにそれらが気に入るように実行することを許可します。しかし
どのプロセスも全てのプロセスがバリアに着くまでは先に進むことができないいくつかの
同期点(``バリア'')を設置します。現代のプロセッサはプログラマに一貫性が要求される場所に
同期点を設置することを可能にする機械語命令を提供します。例えば\acronym{PowerPC}は
この目的のため\acronym{SYNC}(同期)と
\acronym{EIEIO}(Enforced In\-/order Execution of Input/Output, I/Oの強制順序実行)と
呼ばれる2つの命令を含んでいます。}



共有状態の問題となる側面は巨大な分散システムにおいても生じます。例として、
分散銀行システムを想像して下さい。個別の銀行支店は銀行残高のローカル値を保持し
繰り返しそれらを他の支店により保存されている値と比較します。そのようなシステムにおいては
``口座残高''は同期直後を除いて不確定になるでしょう。もしPeterがお金をPaulと連結する
口座に預け入れした時に、いつ口座残高が変更されたと言うべきか\-/\-/\-/地元の支店が残高を変更した
時か、または同期の後までは言えないのか? そしてもしPaulが異なる支店から口座にアクセスした場合、
振舞が``正しい''銀行システム上に設置する妥当な制約とは何か? 正確性に対し問題となるものは
PeterとPaulが独立して観察する振舞と同期直後の口座の``状態''のみでしょう。``本当の''口座残高に
関わる質問や同期の間のイベントの順は準用ではないか、意味がないでしょう。\footnote{これは
おかしな見方のように見えるかもしれません。しかしこのように動くシステムは存在します。
例えばクレジットカードの口座への国際課金は通常国毎の拠点上で精算され異なる国での
課金は繰り返し消し込みされます。従って口座残高は異なる国では異なります。}



ここでの基本的な現象は異なるプロセスの同期、共有状態の設置、またはイベントの順を
強いることはプロセス間通信を必要とします。本質的に、並行性コントロールにおける
任意の時間の概念は緊密に通信に結びつけられねばなりません。\footnote{分散システムに
対するこの視点は\link{Lamport (1978)}により追求されました。彼は
分散システムにおいてイベントの順序付けを成立させるのに使用できる``グローバルな時計''
を設立するためにどのように通信を用いるかについて示しました。}
面白いことに似たような時間と通信の間の繋がりが相対論にも生じています。光速(イベントの
同期に使用可能な最も高速な信号)は基本的に時間と空間に関連して一定です。
私達の計算モデルの時間と状態を取り扱うために遭遇した複雑性は実際に物理的宇宙の
根本的な複雑性を映しているのかもしれません。

\section{ストリーム}
\label{Section 3.5}


モデリングにおけるツールとしての代入について、また代入が生じる複雑な問題の認識に
ついても良い理解を得ることができました。次は我々が行ってきたことを異なる方法で
行えたのか、そうすることでこれらの問題を回避できたのかについて尋ねる番です。
この節では状態をモデル化する代替となる取り組み方について、\newterm{streams}(\jnewterm{ストリーム})
と呼ばれるデータ構造を基にして探求します。私達が学ぶにつれて、ストリームは状態の
モデル化の複雑性のいくらかを和らげることができます。



一旦戻って、この複雑性がどこから来たのか再検討してみましょう。実際の世界の現象を
モデル化する試みにおいて、私達は幾らかの恐らく適切な決定をしました。私達は
実際の世界のオブジェクトを局所状態を用いて、ローカル変数を持つ計算オブジェクトによって
モデル化しました。私達はコンピュータ内の時間変化により実際の世界の時間変化を
判断しました。私達はコンピュータ内のモデルオブジェクトの状態の時系列変化をモデル
オブジェクトのローカル変数への代入を用いて実装しました。



他に取り組み方があるでしょうか? コンピュータ内の時間をモデル化された世界の時間を用いて
判断することを避けられるでしょうか? 変わり行く世界の事象をモデル化するために
モデルを時間と共に変化させなければならないのでしょうか?
問題を数学の関数を用いて考えましょう。数量\( x \)の時間的に変化する振舞を時間の関数
\( x(t) \)として説明できます。もし瞬間毎に\( x \)に集中すれば変化する数量だと考え
ることができます。けれどももし値の歴史全体の時間集中すれば私達は変化を重要視しません。
関数それ自体は変化しません。\footnote{物理学者は時折粒子の``world lines''(世界線)を
運動に関する推測のための手段として導入することでこの見方を受け入れます。私達もまた既に
(\link{Section 2.2.3})においてこれが信号処理システムについて考える自然な方法であると説明しました。
\link{Section 3.5.3}にて信号処理に対するストリームの適用について探求します。}


もし時間が不連続なステップにより測られるのであれば、(無限に成りうる)列として時間関数を
モデル化できます。この節では変化をモデル化されたシステムの時刻歴(time history)を表す
列を用いてどのように変化をモデル化するかについて学びます。
これを達成するために、\newterm{streams}(\jnewterm{ストリーム})と呼ばれる新しいデータ構造を導入します。
抽象的な視点からはストリームは単に列です。しかし私達はストリームの(\link{Section 2.2.1}にあるような)
リストによる簡単な実装はストリーム処理の力を完全に明かすことができないことを知るでしょう。
代替法として、\newterm{delayed evaluation}(\jnewterm{遅延評価})のテクニックを導入します。
遅延評価は巨大な(例え無限でも)列をストリームして表現することを可能にします。



ストリーム処理は状態を持つシステムを代入やミュータブルなデータを用いずにモデル化することを
可能にします。これは重要な意味合いを倫理的、物理的両方で持ちます。なぜなら代入の導入による
固有の欠陥を防ぐモデルを構築できるためです。一方で、ストリームフレームワークはそれ自身の
困難を持ちます。そしてどのモデリングテクニックがよりモジュラでより簡単にシステムを保守できるか
の疑問が残ります。



\subsection{ストリームとは遅延化リスト}
\label{Section 3.5.1}



\link{Section 2.2.3}で学んだように、列はプログラムモジュールを組み合わせるための標準的な
インターフェイスの役割を果たすことができます。列を操作するための強力な抽象化を
形式化しました。例えば\code{map}, \code{filter}, \code{accumulate}であり、簡潔であり、かつ
洗練された作法にて広範囲の操作を獲得します。



残念なことに、列をリストとして表現するとこの洗練さは演算により必要とされる時間と記憶域に関する
深刻な非効率性を犠牲にして得ることになります。列上の操作をリストの変形として表現した時、
私達のプログラムは(大きくなりえる)データ構造を処理の各ステップにおいて構築とコピーをせねば
なりません。


なぜこれが正しいのか知るために、ある区間の全ての素数の和を求めるための2つのプログラムを
比較してみましょう。最初のプログラムは標準的な繰り返しのスタイルを用います。\footnote{素数性を
テストする(\link{Section 1.2.6}のような)述語\code{prime?}を持っていると仮定します。}

\begin{scheme}
(define (sum-primes a b)
  (define (iter count accum)
    (cond ((> count b) accum)
          ((prime? count) 
             (iter (+ count 1) (+ count accum)))
          (else (iter (+ count 1) accum))))
  (iter a 0))
\end{scheme}

\noindent
2つ目のプログラムは同じ演算を\link{Section 2.2.3}の列命令を用いて実行します。

\begin{scheme}
(define (sum-primes a b)
  (accumulate +
              0
              (filter prime? 
                      (enumerate-interval a b))))
\end{scheme}

\noindent
演算の実行において、最初のプログラムは蓄積される合計のみを格納する必要があります。
逆に、2つ目のプログラムのフィルタは\code{enumerate\-/interval}が区間の数の完全なリスト
を構築するまで一度もテストを行うことができません。フィルタは別のリストを生成し、
合計を形成するため畳み込まれる前に順に\code{accumulate}に渡されます。そのような大きな
中間ストレージは最初のプログラムでは必要ありません。最初のプログラムは区間を昇順に
列挙し、各素数が生成されるにつれ合計に足していくと考えることができます。



リスト使用における非効率性は、以下の式を評価して10,000から1,000,000の区間にて
2つ目の素数を求めるのに列パラダイムを用いると、悲痛な程、明らかです。

\begin{scheme}
(car (cdr (filter prime?
                  (enumerate-interval 10000 1000000))))
\end{scheme}

\noindent
この式は2つ目の素数を確かに見つけました。しかし計算上のコストは酷過ぎます。
ほとんど百万の整数のリストを構築し、このリストを各要素の素数性をテストすることで
選別し、ほとんど全ての結果を無視します。より伝統的なプログラミングスタイルにおいては
列挙とフィルタリングを交互に配置し、2つ目の素数を見つけたら停止します。



ストリームは列をリストとして扱うコストを負担することなく列操作を用いることが可能な
賢明な考えです。ストリームを用いると2つの世界の良い所取りができます。プログラムを
列操作のように優雅に定式化できます。繰り返し演算の効率も獲得できます。
基本的なアイデアはストリームを部分的にのみ構築する準備を行い、部分的な構築物を
ストリームを消費するプログラムに渡します。もし消費プログラムがまだ構築されていない
ストリームの部分にアクセスしようと試みた場合、ストリームは要求された部分を生成するために
自動的にそれ自身の十分な追加を構築します。従ってストリーム全体が存在するという
錯覚を維持することができます。言い替えれば、私達は完全な列を処理するようなプログラムを
書きますが、私達のストリーム実装に自動的に、透過的にストリームの構築とその使用を
相互配置するように設計します。



表面上では、ストリームはそれを操作するための異なった名前を持つただのリストです。
コンストラクタ\code{cons\-/stream}と以下の制約を満たす2つのセレクタ\code{stream\-/car}と\code{stream\-/cdr}
が存在します。

\begin{example}
(stream-car (cons-stream x y)) = x
(stream-cdr (cons-stream x y)) = y
\end{example}

\noindent
判別可能なオブジェクト\code{the\-/empty\-/stream}が存在し、これはどんな\code{cons\-/stream}命令の
結果にはなりえず、述語\code{stream\-/null?}にて識別できます。\footnote{\acronym{MIT}の実装では
\code{the\-/empty\-/stream}は空のリスト\code{'()}と同じで、\code{stream\-/null?}は\code{null?}と同じです。}
従ってストリームを作成し、使用して、リストの作成と使用と同様に、準備された列のデータの
集約を表現することができます。具体的には、\link{Chapter 2}からストリーム用のリスト命令の類似手続、
例えば\code{list\-/ref}, \code{map}, \code{for\-/each}を構築できます。\footnote{これはあなたを困惑させ
るでしょう。そのような似た手続をストリームとリストに定義するという事実は、私達がその根底にある
抽象を見逃していることを示します。残念なことに、この抽象を利用するためには、現在可能なものより
より細かな評価過程に対するコントロールを行使する必要があります。この点については\link{Section 3.5.4}の
終わりにてより詳細に議論します。\link{Section 4.2}ではリストとストリームを統合するフレームワークを
開発します。}

\begin{scheme}
(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))
(define (stream-map proc s)
  (if (stream-null? s)
      the-empty-stream
      (cons-stream (proc (stream-car s))
                   (stream-map proc (stream-cdr s)))))
(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))
\end{scheme}

\noindent
\code{stream\-/for\-/each}はストリームを見るのに便利です。

\begin{scheme}
(define (display-stream s) 
  (stream-for-each display-line s))
(define (display-line x) (newline) (display x))
\end{scheme}

\noindent
ストリームの実装に自動的、かつ透過的にストリームの構築とその使用を相互配置させる
ためには、ストリームの\code{cdr}が、ストリームが\code{cons\-/stream}により構築された時でなく、
\code{stream\-/cdr}手続によりアクセスされた時に評価されるように手筈を整えます。
この実装の選択は\link{Section 2.1.2}での分数の議論を思い出させます。その場合は分子と分母の
最小の項への約分を構築時または選択時に実行されるよう実装を選択できることを
学びました。2つの分数実装は同じデータ抽象化を生成しますが、選択が効率に影響を与えました。
似た関係がストリームと通常のリストの間にも存在します。データ抽象化としては、ストリームは
リストと同じです。違いは要素が評価されるタイミングです。通常のリストでは\code{car}と\code{cdr}の両方は
構築時に評価されます。ストリームでは\code{cdr}は選択時に評価されます。


私達のストリームの実装は\code{delay}(遅延)と呼ばれる特殊形式を基にします。
\code{(delay <\var{exp}>)}の評価は式\( \langle \)\var{exp}\( \kern0.08em\rangle \)を評価しません。
しかしその代わりに所謂\newterm{delayed object}(\jnewterm{遅延オブジェクト})を返します。これは
ある将来の時点で\( \langle \)\var{exp}\( \kern0.08em\rangle \)を評価する``promise''(プロミス、約束)として
考えることができます。\code{delay}の相方として\code{force}(強いる)と呼ばれる手続が存在し、
遅延オブジェクトを引数として取り、評価を実行します。実際に\code{delay}にその約束を果たさせる
ことを強要します。以下で\code{delay}と\code{force}がどのように実装できるかについて学びますが、
最初にこれらを用いてストリームを構築しましょう。


\noindent
\code{cons\-/stream}は特殊形式で、

\begin{scheme}
(cons-stream ~\( \dark \langle \)~~\var{\dark a}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark b}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
上が以下と同じになるよう設計されています。

\begin{scheme}
(cons ~\( \dark \langle \)~~\var{\dark a}~~\( \dark \rangle \)~ (delay ~\( \dark \langle \)~~\var{\dark b}~~\( \dark \rangle \)~))
\end{scheme}

\noindent
これの意味する所は、私達はペアを用いてストリームを構築します。しかし、ペアの
\code{cdr}にストリームの残りの値を置くのではなく、そこにプロミスを置き要求された
時点で残りを計算します。これで\code{stream\-/car}と\code{stream\-/cdr}が手続として定義できます。

\begin{scheme}
(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))
\end{scheme}

\noindent
\code{stream\-/car}はペアの\code{car}を選択します。\code{stream\-/cdr}はペアの\code{cdr}を選択し、
そこに見つかった遅延表現を評価し、ストリームの残りを得ます。\footnote{\code{stream\-/car}と
\code{stream\-/cdr}が手続として定義できるにも係わらず、\code{cons\-/stream}は特殊形式で
なければなりません。もし\code{cons\-/stream}が手続であるのならば、私達の評価モデルに従い、
\code{(cons\-/stream <\var{a}> <\var{b}>)}の評価は自動的に\( \langle \)\var{b}\( \kern0.08em\rangle \)の
評価を起こします。これは明らかに私たちにとって起こって欲しくないことです。
同じ理由から\code{delay}も特殊形式でなければなりません。しかし\code{force}は
通常の手続になります。}

\subsubsection*{ストリーム実装の実践}



この実装がどのように振る舞うのかを見るために、先に見た``法外な''素数演算をストリームを
用いて再定式化したものを分析してみましょう。

\begin{scheme}
(stream-car
 (stream-cdr
  (stream-filter prime? 
                 (stream-enumerate-interval 
                  10000 1000000))))
\end{scheme}

\noindent
これが本当に効率的に働くことを見るでしょう。


\code{stream\-/enumerate\-/interval}を引数10,000と1,000,000と共に呼び出すことから始めます。
\code{Stream\-/enumerate\-/interval}は\code{enumerate\-/interval} (\link{Section 2.2.3})の
ストリーム版同等品です。

\begin{scheme}
(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))
\end{scheme}

\noindent
従って\code{stream\-/enumerate\-/interval}で返される結果は以下のようになります。
\code{cons\-/stream}で形成された\footnote{ここで示されている数値は遅延オブジェクトの
中には実際には現れません。実際に現れるのは元の式であり、環境の中で変数は適切な
数値に束縛されています。例えば\code{low}が10,000に束縛されながら\code{(+ low 1)}が
\code{10001}が表示されている場所に現れます。}

\begin{scheme}
(cons 10000
      (delay (stream-enumerate-interval 10001 1000000)))
\end{scheme}

\noindent
つまり\code{stream\-/enumerate\-/interval}はペアとして表現されたストリームを返しその\code{car}は
10,000で、その\code{cdr}はプロミスでありもし要求されれば区間のより多くを列挙します。
このストリームはここでフィルタをかけ素数を残します。
\code{filter}手続(\link{Section 2.2.3})のストリーム版同等品を用います。

\begin{scheme}
(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter 
                       pred
                       (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))
\end{scheme}

\noindent
\code{stream\-/filter}はストリームの\code{stream\-/car}(ペアの\code{car}であり10,000)を
テストします。これは素数ではないので\code{stream\-/filter}は入力ストリームの\code{stream\-/cdr}を
調査します。\code{stream\-/cdr}の呼出は遅延化された\code{stream\-/enumerate\-/interval}の
評価を強制します。これは今、以下を返します。

\begin{scheme}
(cons 10001
      (delay (stream-enumerate-interval 10002 1000000)))
\end{scheme}

\noindent
\code{stream\-/filter}は今このストリームの\code{stream\-/car}である10,001を見て、
これもまた素数ではないことを確認し、もう一度\code{stream\-/cdr}を強制します。
これを\code{stream\-/enumerate\-/interval}が素数10,007を生じるまで繰り返し、すると
直ぐに\code{stream\-/filter}はその定義に従い以下を返します。

\begin{scheme}
(cons-stream (stream-car stream)
             (stream-filter pred (stream-cdr stream)))
\end{scheme}

\noindent
これはこの場合以下のようになります。

\begin{scheme}
(cons 10007
      (delay (stream-filter
              prime?
              (cons 10008
                    (delay (stream-enumerate-interval
                            10009
                            1000000))))))
\end{scheme}

\noindent
これでこの結果は元の式の\code{stream\-/cdr}に渡されます。これにより遅延された
\code{stream\-/filter}が強制され、それが順に遅延された\code{stream\-/enumerate\-/interval}を
次の素数、10,009を見つけるまで強制します。最終的に、結果が私達の元の式の
\code{stream\-/car}に渡された物が以下です。

\begin{scheme}
(cons 10009
      (delay (stream-filter
              prime?
              (cons 10010
                    (delay (stream-enumerate-interval
                            10011
                            1000000))))))
\end{scheme}

\noindent
\code{stream\-/car}が10,009を返し計算が完了します。2つ目の素数を見つけるのに必要なだけの
整数が素数性のテストを受け、区間は素数フィルタに入力するのに必要なだけ列挙されました。



一般的に、遅延評価は``demand-driven''(要求駆動)プログラミングだと考えることができ、
ストリーム処理の各ステージは次のステージを満たすのに十分な場合にのみ稼動されます。
私達がここで行ったことは手続の見掛け上の構造から実際のイベントの順を分断することです。
手続をストリームが``一度に揃って''存在するかのように書くが、実際には演算は漸増的に
伝統的なプログラミングスタイルのように実行されます。


\subsubsection*{\code{delay}と\code{force}の実装}


\code{delay}と\code{force}はミステリアスな命令に見えるかもしれませんが、それらの実装は
本当にとても簡単です。\code{delay}は式を梱包して要求に応じて評価できるようにせねば
なりません。私達はこれを手続のボディのように式を扱うことで簡単に達成できます。
\code{delay}は以下のような特殊形式です。

\begin{scheme}
(delay ~\( \dark \langle \)~~\var{\dark exp}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
これは以下の糖衣構文になります。

\begin{scheme}
(lambda () ~\( \dark \langle \)~~\var{\dark exp}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
\code{force}は単純に\code{delay}により生成された(引数無しの)手続を呼び出します。
従って\code{force}は手続として実装可能です。

\begin{scheme}
(define (force delayed-object) (delayed-object))
\end{scheme}

\noindent
この実装は\code{delay}と\code{force}が期待通りに動く程度には十分です。しかし導入可能な
重要な最適化が存在します。多くのアプリケーションにおいては同じ遅延オブジェクトを
何度も強制することになります。これがストリームを利用する再帰プログラムにおいて深刻な
非効率の原因となります(\link{Exercise 3.57}参照)。解決方法は遅延オブジェクトが初めて
強制された時に計算された値を保存するように遅延オブジェクトを構築します。
続く強制は格納された値の計算を繰り返さずに、単純に格納された値を返します。
言い替えれば、\code{delay}を特別な目的のメモ化手続として\link{Exercise 3.27}にて説明された
物と同様に実装します。これを達成する1つの方法は以下の手続を用います。これは引数として
(引数の無い)手続を取りその手続のメモ化された版を返します。メモ化された手続が最初に
実行される時、計算結果を格納します。以降の評価では単純に結果を返します。

\begin{scheme}
(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))
\end{scheme}

\noindent
\code{delay}はすると\code{(delay <\var{exp}>)}が以下と等価になるように定義されます。

\begin{scheme}
(memo-proc (lambda () ~\( \dark \langle \)~~\var{\dark exp}~~\( \dark \rangle \)~))
\end{scheme}

\noindent
そして\code{force}は以前の定義と同じです。\footnote{この節で説明された物以外にも
多くのストリームの実装が存在します。遅延評価はストリームを現実的にする鍵ですが、
Algol 60の\newterm{call\-/by\-/name}(\jnewterm{コールバイネーム}、名前による呼出)パラメタパッシング法
固有の物でした。ストリームの実装にこの仕組みを使用することは最初に\link{Landin (1965)}により
説明されました。ストリームに対する遅延評価は\link{Friedman and Wise (1976)}により
Lispに導入されました。彼等の実装では\code{cons}は常にその引数の評価を遅延するので、
リストは自動的にストリームとして振舞いました。メモ化最適化は\newterm{call\-/by\-/need}
(\jnewterm{コールバイニード}、必要による呼出)
としても知られています。Alogolコミュニティは私達の元の遅延オブジェクトを
\newterm{call\-/by\-/name thunks}(\jnewterm{コールバイネーム サンク})と呼び最適化された版を
\newterm{call\-/by\-/need thunks}(\jnewterm{コールバイニード サンク})と呼ぶでしょう。}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.50}Exercise 3.50:} 
以下の定義を完成させよ。これは\code{stream\-/map}を複数の引数を取ることができる
ようにする\link{Section 2.2.1}の\code{map}, \link{Footnote 12}の同等品である

\begin{scheme}
(define (stream-map proc . argstreams)
  (if (~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ (car argstreams))
      the-empty-stream
      (~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~
       (apply proc (map ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ argstreams))
       (apply stream-map
              (cons proc (map ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ argstreams))))))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.51}Exercise 3.51:} 
遅延評価のより詳細を見るために、単純に引数を表示した後に引数を返すだけの以下の手続を使用する。

\begin{scheme}
(define (show x)
  (display-line x)
  x)
\end{scheme}



インタプリタが以下の一連の式のそれぞれを評価した時に何を
表示するだろうか?\footnote{\link{Exercise 3.51}や\link{Exercise 3.52}のような課題は
\code{delay}がどのように働くかについての私達の理解を試すために価値有るものです。
一方で、遅延評価を表示---そしてさらに悪いことに代入と---混ぜることは大きな
混乱要因であり、コンピュータ言語の授業のインストラクタ達はこの節にあるような
試験問題で学生達を苦しめてきました。言うまでもありませんが、そのような微妙さ
に依存するプログラムを書くことは醜悪なプログラミングスタイルです。ストリーム処理の
力の一部は私達にイベントが実際にプログラムの中で起こる順について忘れさせてくれる
ことです。残念なことにこれは明らかに代入が存在する場合にはできない事です。
代入は私達に時間と変更に関して心配することを強いるのです。}

\begin{scheme}
(define x 
  (stream-map show 
              (stream-enumerate-interval 0 10)))
(stream-ref x 5)
(stream-ref x 7)
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.52}Exercise 3.52:} 
以下の一連の式について考える。

\begin{scheme}
(define sum 0)
(define (accum x) (set! sum (+ x sum)) sum)
(define seq 
  (stream-map accum
              (stream-enumerate-interval 1 20)))
(define y (stream-filter even? seq))
(define z 
  (stream-filter (lambda (x) (= (remainder x 5) 0))
                 seq))
(stream-ref y 7)
(display-stream z)
\end{scheme}



上記の各式が評価された後の\code{sum}の値はいくつか? 式\code{stream\-/ref}と\code{display\-/stream}を
評価した時表示される応答は何か? これらの応答はもし\code{(delay <\var{exp}>)}を単純に
\code{(lambda () <\var{exp}>)}と実装し\code{memo\-/proc}により提供される最適化を使用しな
かった場合に異なるだろうか? 説明せよ。
\end{quote}

\subsection{無限ストリーム}
\label{Section 3.5.2}



実際にはアクセスに必要な分のストリームしか計算していないのに
ストリームを完全な要素の集合として扱うイリュージョンをどのようにサポートするのかについて
学びました。このテクニックを利用して例え列が実際にはとても長くても列を効率的にストリーム
として表現することができます。より印象的なことに、ストリームを無限に長い列を表現するために
使用することができます。例として以下の正の整数のストリームの定義について考えてみましょう。
\begin{scheme}
(define (integers-starting-from n)
  (cons-stream n (integers-starting-from (+ n 1))))
(define integers (integers-starting-from 1))
\end{scheme}

\noindent
\code{integers}が\code{car}が1で\code{cdr}が2で始まる整数を生成するプロミスになるため
これは理にかなっています。これは無限に長いストリームです。しかし任意の与えれた
時間にはその有限な一部しか検討することはできません。従って私達のプログラムは
無限のストリーム全体がそこにあることを知ることはできません。



\code{integers}を用いて他の無限のストリームを定義できます。例えば7で割ることのできない
整数のストリームです。

\begin{scheme}
(define (divisible? x y) (= (remainder x y) 0))
(define no-sevens
  (stream-filter (lambda (x) (not (divisible? x 7)))
                 integers))
\end{scheme}

\noindent
すると7で割り切れない整数をこのストリームの要素にアクセスするだけで見つけることができます。

\begin{scheme}
(stream-ref no-sevens 100)
~\textit{117}~
\end{scheme}

\noindent
\code{integers}と同様に、フィボナッチ数の無限ストリームも定義できます。

\begin{scheme}
(define (fibgen a b) (cons-stream a (fibgen b (+ a b))))
(define fibs (fibgen 0 1))
\end{scheme}

\noindent
\code{fibs}はその\code{car}が0で、その\code{cdr}は\code{(fibgen 1 1)}を評価するプロミスであるペアです。
この遅延化した\code{(fibgen 1 1)}を評価すると、\code{car}が1で\code{cdr}が
\code{(fibgen 1 2)}を評価するプロミスであるペアを生成します。以下、その繰り返しです。



より刺激的な無限ストリームの調査のために、\code{no\-/sevens}の例を一般化し、素数の
無限ストリームを\newterm{sieve of Eratosthenes}(\jnewterm{エラトステネスの篩})として
知られる手法を用いて構築します。\footnote{エラトステネスは紀元前3世紀の
アレキサンドリア学派のギリシャ人哲学者で、地球の外周を最初に正しく推測した
として有名です。彼は夏至の日の正午の影を観察することでこれを求めました。
エラトステネスの篩は古典ですが、特殊用途のハードウェア``篩''の基礎をなしており、
最近まで巨大な素数を突き止める最も強力なツールでした。しかし70年代からこれらの
手法は\link{Section 1.2.6}で議論された確率的な技術の成長により取って代わられました。}
私達は整数を最初の素数である2で始めます。残りの素数を得るために、整数の残りから
2の倍数をフィルタリングすることから始めます。これは3で始まるストリームを残し、
3は次の素数です。ここで3の倍数をこのストリームの残りからフィルタリングします。
これは5で始まるストリームを残し、5は次の素数です。以下これを繰り返します。
言い換えれば、素数を次の様に説明する篩にかける処理により構築します。まずストリーム\code{S}に
篩をかけるために、最初の要素が\code{S}の最初の要素であり、残りは\code{S}の残りから\code{S}の
最初の要素の倍数をフィルタリングすることで得られるストリームを形成します。
そして結果をさらに篩にかけます。この処理は容易にストリーム命令を用いて記述できます。

\begin{scheme}
(define (sieve stream)
  (cons-stream
   (stream-car stream)
   (sieve (stream-filter
           (lambda (x)
             (not (divisible? x (stream-car stream))))
           (stream-cdr stream)))))
(define primes (sieve (integers-starting-from 2)))
\end{scheme}

\noindent
これで特定の素数を見つけるのには以下のように尋ねるだけです。

\begin{scheme}
(stream-ref primes 50)
~\textit{233}~
\end{scheme}

\noindent
\link{Figure 3.31}の``ヘンダーソン図''に示されるように\code{sieve}により設定
された信号処理システムを熟考することは面白いです。\footnote{私達はこれらの図をPeter Henderson
にちなんで名付けました。彼はこの種の図をストリーム処理について考える方法として示した最初の
人物です。各実線は送信される値のストリームを表しています。\code{car}から\code{cons}と\code{filter}への点線は
これがストリームではなく単一の値であることを示します。}
入力ストリームは``un\code{cons}er''に流し込まれ、ストリームの最初の要素をストリームの残りから分離します。
最初の要素は可分性フィルタを構築するのに用いられ、残りはそれに渡され通ります。フィルタの出力は
もう1つの篩の箱に流し込まれます。次に元の最初の用途は内側の篩の出力上に\code{cons}され出力ストリーム
を形成します。従ってストリームのみが無限ではなく、信号処理器もまた無限です。
なぜなら篩がその中に篩を持っているからです。

\begin{figure}[tb]
\phantomsection\label{Figure 3.31}
\centering
\begin{comment}
\heading{Figure 3.31:} The prime sieve viewed as a signal-processing system.

\begin{example}
  +---------------------------------------------------------------+
  | sieve                                                         |
  |                                                               |
  |        __/|                                        |\__       |
  |     __/car|........................................|   \__    |
  |   _/      |           :                            |      \_  |
----><_       |           V                            |  cons _>---->
  |    \__    |    +------------+    +------------+    |    __/   |
  |       \cdr|--->| filter:    |    | sieve      |--->| __/      |
  |          \|    |            |--->|            |    |/         |
  |                | not        |    |            |               |
  |                | divisible? |    |            |               |
  |                +------------+    +------------+               |
  +---------------------------------------------------------------+
\end{example}
\end{comment}
\includegraphics[width=111mm]{fig/chap3/Fig3.31.pdf}
\begin{quote}
\heading{Figure 3.31:} 信号処理システムとして見た素数の篩
\end{quote}
\end{figure}

\subsubsection*{暗黙的ストリーム定義}


上記の\code{integers}と\code{fibs}のストリームは明示的にストリーム要素を1つづつ計算する
``生成''手続を指定することにより定義されました。ストリームを指定する代替法として
遅延評価の利点を用いて暗黙的にストリームを定義することが上げられます。
例えば以下の式はストリーム\code{ones}を1の無限ストリームとして定義します。

\begin{scheme}
(define ones (cons-stream 1 ones))
\end{scheme}

\noindent
これは再帰手続の定義そっくりに動きます。\code{ones}はペアでその\code{car}は1でその\code{cdr}は
\code{ones}を評価するプロミスです。\code{cdr}の評価は再び1と\code{ones}を評価するプロミスを
与えます。以下、繰り返しです。



より面白いこととしてストリームを\code{add\-/streams}のような命令で操作することができます。
\code{add\-/streams}は2つの与えらえたストリームのエレメント同士の和を生成します。

\begin{scheme}
(define (add-streams s1 s2) (stream-map + s1 s2))
\end{scheme}

\noindent
これで整数を以下のように定義できます。

\begin{scheme}
(define integers 
  (cons-stream 1 (add-streams ones integers)))
\end{scheme}

\noindent
これは\code{integers}が最初の要素は1で残りは\code{ones}と\code{integers}の和になります。
従って\code{integers}の2つ目の要素は1 足す \code{integers}の最初の要素、つまり2になります。
\code{integers}の3つ目の要素は1 足す \code{integers}の2つ目の要素、つまり3です。以下繰り返しです。
この定義は任意の時点で十分な\code{integers}ストリームが生成されているので次の整数を生成する
ために定義にフィードバックすることができるためうまく行くのです。


フィボナッチ数も同じスタイルで定義できます。

\begin{scheme}
(define fibs 
  (cons-stream
   0
   (cons-stream 1 (add-streams (stream-cdr fibs) fibs))))
\end{scheme}

\noindent
この定義は\code{fibs}は0と1で始まるストリームであり、残りのストリームは\code{fibs}を
自身に1つずらして足すことで生成することができると述べています。

\begin{scheme}
      1  1  2  3  5  8   13  21  ~\( \dots \)~  =  ~\code{(stream\-/cdr fibs)}~
      0  1  1  2  3  5   8   13  ~\( \dots \)~  =  ~\code{fibs}~
0  1  1  2  3  5  8  13  21  34  ~\( \dots \)~  =  ~\code{fibs}~
\end{scheme}

\noindent
\code{scale\-/stream}はまた別の、そのようなストリーム定義を形成するのに便利な手続です。
これはストリームの各要素に与えられた定数を掛けます。

\begin{scheme}
(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor))
              stream))
\end{scheme}

\noindent
例として

\begin{scheme}
(define double (cons-stream 1 (scale-stream double 2)))
\end{scheme}

\noindent
は2の冪乗のストリームを生成します：1, 2, 4, 8, 16, 32, \( \dots \)



素数ストリームの代替定義は整数で始まり、それらの素数性をテストすることでフィルタリング
することでも与えられます。最初の素数、2を開始に必要とします。

\begin{scheme}
(define primes
  (cons-stream
   2
   (stream-filter prime? (integers-starting-from 3))))
\end{scheme}

\noindent
この定義はあまり見かけほど簡単ではありません。\( n \)が(任意の整数でなく)\( \sqrt{n} \)以下の
素数で割り切れるかどうかをチェックすることにより数\( n \)が素数であるかを決めるためです。

\begin{scheme}
(define (prime? n)
  (define (iter ps)
    (cond ((> (square (stream-car ps)) n) true)
          ((divisible? n (stream-car ps)) false)
          (else (iter (stream-cdr ps)))))
  (iter primes))
\end{scheme}

\noindent
これは再帰定義であり、\code{primes}が\code{primes}を用いる\code{prime?}述語を用いて定義されています。
この手続がうまく行く理由は、任意の時点で、十分な\code{primes}ストリームが生成されており、
次にチェックするのに必要な数の素数性をテストできるからです。全ての\( n \)に対して素数性を
テストします。例え\( n \)が素数でなくても(この場合、それを割り切れる素数が既に生成されています。),
例え\( n \)が素数(この場合、素数が既に生成されています---言い換えれば、\( \sqrt{n} \)より大きく\( n \)未満の
素数)であってもです。\footnote{この最後の点はとても微妙で\( p_{n+1} \le p_n^2 \)という事実に依存して
います。(ここで\( p_k \)は\( k \)番目の素数を示します)。このような予測を立証するのはとても難しいです。
ユークリッドによる太古の証明による、ある素数が無限に存在することが\( p_{n+1} \le p_1 p_2 \ldots p_n + 1 \)を
示しています。そして実質的にはより良い結果が証明されることは1851年までありませんでした。
この年、ロシア人の数学者P. L. Chebyshev(パフヌティ・チェビシェフ)は全ての\( n \)に対し\( p_{n+1} \le 2p_n \)で
あることを証明しました。最初に1845年に予想されたこの結果は\newterm{Bertrand's hypothesis}(\jnewterm{ベルトランの
仮説})として知られています。証明は\link{Hardy and Wright 1960}の節22.3に見つかります。}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.53}Exercise 3.53:} 
プログラムを実行すること無しに以下により定義されたストリームの要素について
説明せよ。

\begin{scheme}
(define s (cons-stream 1 (add-streams s s)))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.54}Exercise 3.54:} 
\code{add\-/streams}と類似の手続\code{mul\-/streams}を定義せよ。これは2つの入力ストリームの
要素同士の積を生成する。また、以下を\code{integers}ストリームと共に用いて以下のストリームの
定義を完成させよ。これの\( n \)番目の要素(0で開始)は\( n + 1 \)の階乗である。

% \begin{scheme}
~%~ (define factorials (cons\-/stream 1 (mul\-/streams ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~)))
~%~ \end{scheme}
\noindent
\code{(define factorials (cons\-/stream 1 (mul\-/streams}\( \kern0.7ex\langle \)\code{?}\( \rangle \)\( \kern0.7ex\langle \)\code{?}\( \rangle \)\code{)))}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.55}Exercise 3.55:} 
手続\code{partial\-/sums}を定義せよ。これはストリーム\( S \)を引数として取り、要素が
\( S_0 \), \( S_0 + S_1 \), \( S_0 + S_1 + S_2, \dots \)であるストリームを返す。
例えば\code{(partial\-/sums integers)}は1, 3, 6, 10, 15, \( \dots \)のストリームにならねば
ならない。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.56}Exercise 3.56:} 
R. Hamming(リチャード ハミング)により取り上げられた有名な問題に、昇順に、重複無く、
2, 3, 5以外の素因数を持たない正の整数を列挙せよというものがある。これを行う
1つの明らかな方法は単純に各整数を順に2, 3, 5以外の素因数を持つかどうかテストする
方法です。しかしこれはとても非効率です。整数が大きくなる程に要求に合う数はより
少なくなるためです。代替法として、要求された数のストリームを\code{S}と呼び、以下の
事実について注目してみましょう。

\begin{itemize}

\item
\code{S}は1で始まる。

\item
\code{(scale\-/stream S 2)}の要素もまた\code{S}の要素である。

\item
同じことが\code{(scale\-/stream S 3)}と\code{(scale\-/stream 5 S)}に対しても真である。

\item
これらは全て\code{S}の要素である。

\end{itemize}

さて私達が行わなければならないこと全てはこれらの情報から要素を結合することである。
このために2つの順序有りストリームを重複を省き1つの順序付けられた結果のストリームに結合する
手続\code{merge}を定義する。

\begin{scheme}
(define (merge s1 s2)
  (cond ((stream-null? s1) s2)
        ((stream-null? s2) s1)
        (else
         (let ((s1car (stream-car s1))
               (s2car (stream-car s2)))
           (cond ((< s1car s2car)
                  (cons-stream 
                   s1car 
                   (merge (stream-cdr s1) s2)))
                 ((> s1car s2car)
                  (cons-stream 
                   s2car 
                   (merge s1 (stream-cdr s2))))
                 (else
                  (cons-stream 
                   s1car
                   (merge (stream-cdr s1)
                          (stream-cdr s2)))))))))
\end{scheme}

次に要求されたストリームが\code{merge}を用いて以下のよう構築されるだろう。

\begin{scheme}
(define S (cons-stream 1 (merge ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~)))
\end{scheme}

上で\( \langle \)\var{??}\( \kern0.08em\rangle \)とマークされた箇所の欠けた式を埋めよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.57}Exercise 3.57:} 
\( n \)番目のフィボナッチ数を\code{add\-/streams}手続を基にした\code{fibs}の定義を用いて
計算した場合に加算は何回実行されるか? 加算回数が\code{(delay <\var{exp}>)}を単純に
\link{Section 3.5.1}で説明した\code{memo\-/proc}手続により提供される最適化を用いずに、
\code{(lambda () <\var{exp}>)}として実装した場合に指数関数的に増加することを示せ。\footnote{この課題は
call\-/by\-/needが\link{Exercise 3.27}で説明された通常のメモ化に密接に関係していることを示します。
その課題では代入を明示的にローカルの表の構築に用いました。私達のcall-by-needストリームの
最適化は効果的にそのようなテーブルを自動的に構築し、ストリームの以前に強制された部分の値を
格納します。}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.58}Exercise 3.58:} 
以下の手続により計算されるストリームの解説を与えよ。

\begin{scheme}
(define (expand num den radix)
  (cons-stream
   (quotient (* num radix) den)
   (expand (remainder (* num radix) den) den radix)))
\end{scheme}


(\code{quotient}はプリミティブであり、2つの整数の、整数の商を返す)。
\code{(expand 1 7 10)}により生成される一連の要素は何か?
\code{(expand 3 8 10)}では何が生成されるか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.59}Exercise 3.59:} 
\link{Section 2.5.3}にて多項式を項のリストとして表現する多項式数値演算システムをどのように
実装するかについて学んだ。同様な方法で以下のような\newterm{power series}(\jnewterm{べき級数})に
ついても扱うことができる。
\begin{comment}

\begin{example}
               x^2     x^3       x^4
e^x = 1 + x + ----- + ----- + --------- + ...
                2     3 * 2   4 * 3 * 2

             x^2       x^4
cos x = 1 - ----- + --------- - ...
              2     4 * 3 * 2

             x^3         x^5
sin x = x - ----- + ------------- - ...
            3 * 2   5 * 4 * 3 * 2
\end{example}

\end{comment}
\begin{displaymath}
e^x = 1 + x + \displaystyle\frac{x^2}{2} + \displaystyle\frac{x^3}{3 \cdot 2} + \displaystyle\frac{x^4}{4 \cdot 3 \cdot 2} + \dots, 
\end{displaymath}
\begin{displaymath}
\cos x = 1 - \displaystyle\frac{x^2}{2} + \displaystyle\frac{x^4}{4 \cdot 3 \cdot 2} - \dots, 
\end{displaymath}
\begin{displaymath}
\sin x = x - \displaystyle\frac{x^3}{3 \cdot 2} + \displaystyle\frac{x^5}{5 \cdot 4 \cdot 3 \cdot 2} - \dots 
\end{displaymath}
\noindent
これらは無限ストリームとして表現されている。数列\( a_0 +
a_1 x + a_2 x^2 + a_3 x^3 + \dots \)を要素が係数\( a_0 \), \( a_1 \), \( a_2 \), \( a_3 \), \( \dots \)
のストリームとして表すことにする。

\begin{enumerate}[a]

\item
級数\( a_0 + a_1 x + a_2 x^2 + a_3 x^3 + \dots \)の積分は次の級数になる。
\begin{comment}

\begin{example}
             1             1             1
c + a_0 x + --- a_1 x^2 + --- a_2 x^3 + --- a_3 x^4 + ...
             2             3             4
\end{example}

\end{comment}
\begin{displaymath}
 c + a_0 x + {1\over2} a_1 x^2 + {1\over3} a_2 x^3 + {1\over4} a_3 x^4 + \dots, 
\end{displaymath}
\noindent
ここで\( c \)は任意の定数である。羃級数を表すストリーム\( a_0 \), \( a_1 \), \( a_2 \), \( \dots \)を
入力として取り、その級数の積分の非定数項の係数のストリーム\( a_0 \), \( {1\over2}a_1 \), \( {1\over3}a_2 \), \( \dots \)を
返す手続\code{integrate\-/series}を定義せよ。(結果が定数項を持たないため、それは羃級数では無い。
\code{integrate\-/series}を使う時、後で適切な定数を\code{cons}する。)

\item
関数\( x \mapsto e^x \)はそれ自身が導関数である。これは\( e^x \)と\( e^x \)の不定積分が
定数項を除いて同じ級数になることを意味する。定数項は\( e^0 = 1 \)である。結果的に、
\( e^x \)の級数を次のように生成できる。

\begin{scheme}
(define exp-series
  (cons-stream 1 (integrate-series exp-series)))
\end{scheme}



sinとcosの級数をどのように生成するか示せ。sinの導関数がcosであり、cosの導関数が
負のsinであることから始めよ。

\begin{scheme}
(define cosine-series (cons-stream 1 ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~))
(define sine-series (cons-stream 0 ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~))
\end{scheme}
\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.60}Exercise 3.60:}
\link{Exercise 3.59}における係数ストリームとして表現された羃級数を用いて、級数の加算
は\code{add\-/streams}により実装される。級数を乗算するための以下の手続の定義を完成させよ。

\begin{scheme}
(define (mul-series s1 s2)
  (cons-stream ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ (add-streams ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~)))
\end{scheme}



手続ができたら\link{Exercise 3.59}の級数を用いて\( \sin^2 x +
\cos^2 x = 1 \)を確認せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.61}Exercise 3.61:}
\( S \)が定数項が1の羃級数(\link{Exercise 3.59})であるとする。
羃級数\( 1 / S \)を見つけたいとする。つまり\( SX = 1 \)となるような級数\( X \)である。
\( S_R \)が\( S \)の定数項の後の部分である場合に\( S = 1 + S_R \)を書け。
そうすれば\( X \)を以下のようにして求めることができる。
\begin{comment}

\begin{example}
        S * X = 1
(1 + S_R) * X = 1
  X + S_R * X = 1
            X = 1 - S_R * X
\end{example}

\end{comment}
\begin{displaymath}
%  \eqalign{
% 	        S \cdot X 	&= 1, \cr
% 	(1 + S_R) \cdot X 	&= 1, \cr
% 	  X + S_R \cdot X 	&= 1, \cr
% 	            	X 	&= 1 - S_R \cdot X. \cr
% } 
\begin{array}{r@{{}={}}l}
	        S \cdot X 	& 1, \\
	(1 + S_R) \cdot X 	& 1, \\
	  X + S_R \cdot X 	& 1, \\
	            	X 	& 1 - S_R \cdot X. 
\end{array}
\end{displaymath}


言い換えれば、\( X \)は定数項が1であり高次項が負の\( S_R \)と\( X \)の積により与え
られる羃級数である。この考えを用いて定数項1を持つ羃級数\( S \)に対する
\( 1 / S \)を求める手続\code{invert\-/unit\-/series}を書け。\link{Exercise 3.60}の
\code{mul\-/series}を用いる必要がある。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.62}Exercise 3.62:} 
\link{Exercise 3.60}と\link{Exercise 3.61}の結果を用いて2つの羃級数を割る
手続\code{div\-/series}を定義せよ。\code{div\-/series}は任意の2つの級数に対して利用できねば
ならず分母の級数は非ゼロな定数項で始まらねばならない。(もし分母がゼロの定数項を
持つならば\code{div\-/series}はエラーを発すこと)。\code{div\-/series}を\link{Exercise 3.59}の
結果と一緒にどのように用いてtanの羃級数を生成するか示せ。
\end{quote}

\subsection{ストリームパラダイムの利用}
\label{Section 3.5.3}


遅延評価を伴なうストリームは強力なモデリングツールにすることができ、局所状態と
代入の利点の多くを提供する。さらにプログラミング言語への代入の導入に伴う、
いくつかの理論的な混乱を防ぎます。



ストリームのアプローチは私達に、状態変数への代入の周りに体系化されたシステムよりも、
異なるモジュール境界を伴なうシステムを構築することを可能にするため、啓発的です。
例えば私達は個別の瞬間における状態変数の値としてではなく、
時系列(または信号)全体を興味の中心として考えることができます。
このことが異なる瞬間の状態のコンポーネントの比較と接続を行うのにより便利にします。

\subsubsection*{反復をストリームプロセスとして定式化する}



\link{Section 1.2.1}において、反復プロセスを紹介しました。これは状態変数を更新することで
進行されます。私達は今、状態を更新される変数の集合としてではなく、
``永遠''の値のストリームとして表すことができます。\link{Section 1.1.7}の平方根手続への
再訪問にこの視点を導入しましょう。考え方は推測値を改善する手続を何度も適用することで
\( x \)の平方根の推測値をより良い値の列を生成するということを思い出して下さい。

\begin{scheme}
(define (sqrt-improve guess x)
  (average guess (/ x guess)))
\end{scheme}

\noindent
私達の元の\code{sqrt}手続では、これらの推測値を状態変数の一連の値にしました。
代わりに推測値の無限ストリームを作ることができます。推測値の初期値は1で
始めます。\footnote{\code{let}をローカル変数\code{guesses}を束縛するのに使うことは
できません。\code{guesses}の値は\code{guesses}自身に依存するためです。
\link{Exercise 3.63}はなぜここで局所変数を欲しがるのかを扱います。}

\begin{scheme}
(define (sqrt-stream x)
  (define guesses
    (cons-stream
     1.0
     (stream-map (lambda (guess) (sqrt-improve guess x))
                 guesses)))
  guesses)

(display-stream (sqrt-stream 2))
~\textit{1.}~
~\textit{1.5}~
~\textit{1.4166666666666665}~
~\textit{1.4142156862745097}~
~\textit{1.4142135623746899}~
~\( \dots \)~
\end{scheme}

\noindent
より多くのストリームの項を生成することでより良い推測値を得ることができます。
もし望むなら、解答が十分に良くなるまで項の生成を続ける手続を書くことも可能です。
(\link{Exercise 3.64}参照)。


同じ方法で扱えるもう1つの反復は\( \pi \)の近似値を\link{Section 1.3.1}で見た
交項級数(交代級数)を基にして生成することが可能です。
\begin{comment}

\begin{example}
[pi]        1     1     1
-\-/\-/- = 1 - -\-/- + -\-/- - -\-/- + ...
  4         3     5     7
\end{example}

\end{comment}
\begin{displaymath}
 {\pi\over4} = 1 - {1\over3} + {1\over5} - {1\over7} + \dots. 
\end{displaymath}

最初に級数の加数(符号が交互に代わる奇数の逆数)のストリームを生成します。次に
(\link{Exercise 3.55}の\code{partial\-/sums}手続を用いてより多くの項の
和のストリームを取り、結果を4倍します。

\begin{scheme}
(define (pi-summands n)
  (cons-stream (/ 1.0 n)
               (stream-map - (pi-summands (+ n 2)))))
(define pi-stream
  (scale-stream (partial-sums (pi-summands 1)) 4))

(display-stream pi-stream)
~\textit{4.}~
~\textit{2.666666666666667}~
~\textit{3.466666666666667}~
~\textit{2.8952380952380956}~
~\textit{3.3396825396825403}~
~\textit{2.9760461760461765}~
~\textit{3.2837384837384844}~
~\textit{3.017071817071818}~
~\( \dots \)~
\end{scheme}

\noindent
これはより良い\( \pi \)の近似値のストリームを提供します。しかし、近似値の
収束はとても遅いです。列の8個の項は\( \pi \)の値を3.284から3.017の間に
束縛されます。


今の所、状態のストリームを使用する取り組みは状態変数を更新する物から大きくは
異なりません。しかしストリームはある面白いトリックを行う機会を提供します。
例えば、近似値の列を同じ値に、ただし、より速く収束する列に変換する
\newterm{sequence accelerator}(\jnewterm{列アクセラレータ})を用いてストリームを
変換することができます。


18世紀のスイスの数学者Leonhard Euler(レオンハルト オイラー)によるそのようなアクセラレータの1つは、
交項級数(符号を互い違いにする項の列)の部分和である列にうまく働きます。
オイラーの手法においては、もし\( S_n \)が元の和の列の\( n \)番目の項であるなら、
加速された列は以下の項を持ちます。
\begin{comment}

\begin{example}
             (S_(n+1) - S_n)^2
S_(n+1) - ------------------------
          S_(n-1) - 2S_n + S_(n+1)
\end{example}

\end{comment}
\begin{displaymath}
 S_{n+1} - {(S_{n+1} - S_n)^2 \over S_{n-1} - 2S_n + S_{n+1}}\,. 
\end{displaymath}
従って元の列が値のストリームとして表現されるならば、変換された列は以下により与えられる。

\begin{scheme}
(define (euler-transform s)
  (let ((s0 (stream-ref s 0))     ~\textrm{; \( S_{n-1} \)}~
        (s1 (stream-ref s 1))     ~\textrm{; \( S_n \)}~
        (s2 (stream-ref s 2)))    ~\textrm{; \( S_{n+1} \)}~
    (cons-stream (- s2 (/ (square (- s2 s1))
                          (+ s0 (* -2 s1) s2)))
                 (euler-transform (stream-cdr s)))))
\end{scheme}

\noindent
オイラーによる加速を私達の\( \pi \)の近似値の列を用いて実演できます。

\begin{scheme}
(display-stream (euler-transform pi-stream))
~\textit{3.166666666666667}~
~\textit{3.1333333333333337}~
~\textit{3.1452380952380956}~
~\textit{3.13968253968254}~
~\textit{3.1427128427128435}~
~\textit{3.1408813408813416}~
~\textit{3.142071817071818}~
~\textit{3.1412548236077655}~
~\( \dots \)~
\end{scheme}

\noindent
さらに良くなるよう、加速された列を加速でき、そして再帰的にそれの加速を繰り返すことが可能です。
すなわち、ストリームのストリーム(\newterm{tableau}(\jnewterm{タブロー})と呼ぶ構造)を作り、
その中では各ストリームは1つ前の変換です。

\begin{scheme}
(define (make-tableau transform s)
  (cons-stream s (make-tableau transform (transform s))))
\end{scheme}

\noindent
タブローは以下の形を取ります。
\begin{comment}

\begin{example}
s_00   s_01   s_02   s_03   s_04   ...
       s_10   s_11   s_12   s_13   ...
              s_20   s_21   s_22   ...
                            ...
\end{example}

\end{comment}
\begin{displaymath}
 \vbox{
\offinterlineskip
\halign{
\strut 	\hfil \  #\  \hfil & 
	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil \cr

$ s_{00} $ 	&  $ s_{01} $ 	&  $ s_{02} $ 	&  $ s_{03} $ 	&  $ s_{04} $ 	&  $ \dots $ \cr
		&  $ s_{10} $ 	&  $ s_{11} $ 	&  $ s_{12} $ 	&  $ s_{13} $ 	&  $ \dots $ \cr
		& 		&  $ s_{20} $ 	&  $ s_{21} $ 	&  $ s_{22} $ 	&  $ \dots $ \cr
		& 		& 		&  $ \dots $ 	& 		&  \cr }
} 
\end{displaymath}


最後にタブローの各行の最初の項を取ることで列を形成します。

\begin{scheme}
(define (accelerated-sequence transform s)
  (stream-map stream-car (make-tableau transform s)))
\end{scheme}

\noindent
\( \pi \)の列のこの種の``超加速''を実演することができます。

\begin{scheme}
(display-stream
 (accelerated-sequence euler-transform pi-stream))
~\textit{4.}~
~\textit{3.166666666666667}~
~\textit{3.142105263157895}~
~\textit{3.141599357319005}~
~\textit{3.1415927140337785}~
~\textit{3.1415926539752927}~
~\textit{3.1415926535911765}~
~\textit{3.141592653589778}~
~\( \dots \)~
\end{scheme}

\noindent
結果は感動的です。列の8つの項を得ることで\( \pi \)の小数点以下14桁の正しい値が
もたらせられます。もし元の\( \pi \)の列のみを使用したなら、\( 10^{13} \)のオーダーの
演算をする必要が(すなわち列の個々の項が\( 10^{-13} \)よりも小さくなるまで十分に長く
展開する必要が)同じ程度の正確さを得るためには必要です！



これらの加速テクニックをストリームを用いずに実装することもできました。
しかしストリームによる定式化はとりわけエレガントで便利です。状態の列全体が
統一された命令の集合により操作可能なデータ構造として使用できるからです。

\begin{quote}
\heading{\phantomsection\label{Exercise 3.63}Exercise 3.63:} 
Louis Reasonerはなぜ\code{sqrt\-/stream}手続が以下のより簡単な方法で、局所変数
\code{guesses}無しで実装されていないのか尋ねた。

\begin{scheme}
(define (sqrt-stream x)
  (cons-stream 1.0 (stream-map
                    (lambda (guess)
                      (sqrt-improve guess x))
                    (sqrt-stream x))))
\end{scheme}



Alyssa P. Hackerが問題の手続のこの版は冗長な演算を行うため、かなり非効率であるからと答えた。
Alyssaの答を説明せよ。もし\code{delay}の実装が\code{memo\-/proc} (\link{Section 3.5.1})で提供された最適化を
用いずに\code{(lambda () <\var{exp}>)}のみを使用したならば2つの版の間に依然として効率上の
違いは存在するだろうか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.64}Exercise 3.64:} 
引数としてストリームと許容値の数値を取る手続\code{stream\-/limit}を書け。
差の絶対値が許容値未満である2つの連続する要素を見つけるまでストリームを検査し、
その2つの要素の2番目を返す。これを用いて与えられた許容誤差以内の平方根を求める
ことができるだろう。

\begin{scheme}
(define (sqrt x tolerance)
  (stream-limit (sqrt-stream x) tolerance))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.65}Exercise 3.65:} 
以下の級数を用いて、
\begin{comment}

\begin{example}
            1     1     1
ln 2 = 1 - --- + --- - --- + ...
            2     3     4
\end{example}

\end{comment}
\begin{displaymath}
 \ln 2 = 1 - {1\over2} + {1\over3} - {1\over4} + \dots 
\end{displaymath}
\noindent
\( \pi \)に対して上で行ったのと同様に、2の自然対数の近似値を3種の近似値の列を
求めよ。これらの列はどれだけ早く収束するか?

\end{quote}

\subsubsection*{ペアの無限ストリーム}


\link{Section 2.2.3}において列パラダイムがどのように伝統的な入れ子ループをペアの列上に
定義された手続として扱うかについて学びました。もしこのテクニックを無限ストリームに
対しても一般化すれば簡単には繰り返しとしては表現されないプログラムを書くことが
できます。なぜなら``ループ''を無限集合の範囲にも渡らせなければなりません。



例えば\link{Section 2.2.3}の\code{prime\-/sum\-/pairs}手続を一般化して、整数\emph{全て}の
ペア\( (i, j) \)、但し\( i \le j \)で\( i + j \)が素数である場合の
ストリームを生成します。もし\code{int\-/pairs}が\( i \le j \)における全ての整数のペア
\( (i, j) \)の列であるのならば、私達が必要とするストリームは単純に以下のように
定義されます。\footnote{\link{Section 2.2.3}にもある通り、私達は整数のペアをLispのペアでは
なく、リストにて表現します。}

\begin{scheme}
(stream-filter
 (lambda (pair) (prime? (+ (car pair) (cadr pair))))
 int-pairs)
\end{scheme}

\noindent
すると問題は\code{int\-/pairs}ストリームを生成することになります。より一般的には、
2つのストリーム、\( S = (S_i) \)と\( T = (T_j) \)を持っているとした場合に、
無限の長方形の配列を想像してみて下さい。
\begin{comment}

\begin{example}
(S_0, T_0)  (S_0, T_1)  (S_0, T_2)  ...
(S_1, T_0)  (S_1, T_1)  (S_1, T_2)  ...
(S_2, T_0)  (S_2, T_1)  (S_2, T_2)  ...
   ...
\end{example}

\end{comment}
\begin{displaymath}
 \vbox{
\offinterlineskip
\halign{
\strut 	\hfil \  #\  \hfil & 
	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil \cr

	$ (S_0, T_0) $ & $ (S_0, T_1) $ & $ (S_0, T_2) $ & $ \dots $ \cr
	$ (S_1, T_0) $ & $ (S_1, T_1) $ & $ (S_1, T_2) $ & $ \dots $ \cr
	$ (S_2, T_0) $ & $ (S_2, T_1) $ & $ (S_2, T_2) $ & $ \dots $ \cr
	$ \dots $ & & & \cr }
} 
\end{displaymath}
配列内の、対角線上かその上部の全てのペアを含むストリームを生成したいと考えます。
つまり、以下のペアです。
\begin{comment}

\begin{example}
(S_0, T_0)  (S_0, T_1)  (S_0, T_2)  ...
            (S_1, T_1)  (S_1, T_2)  ...
                        (S_2, T_2)  ...
                                    ...
\end{example}

\end{comment}
\begin{displaymath}
 \vbox{
\offinterlineskip
\halign{
\strut 	\hfil \  #\  \hfil & 
	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil \cr

$ (S_0, T_0) $ 	& $ (S_0, T_1) $ 	& $ (S_0, T_2) $ 	& $ \dots $ \cr
		& $ (S_1, T_1) $ 	& $ (S_1, T_2) $ 	& $ \dots $ \cr
		& 			& $ (S_2, T_2) $ 	& $ \dots $ \cr
		& 			& 			& $ \dots $ \cr }
} 
\end{displaymath}
\noindent
(もし\( S \)と\( T \)の両方を整数のストリームとして取るなら、これが望んだストリーム\code{int\-/pairs}です。)


一般的なペアのストリームを\code{(pairs S T)}と呼び、それが3つの部分から組み立てられていると考えます。
ペア\( (S_0, T_0) \)、最初の行の残りのペア、残りのペアです。\footnote{なぜ私達が分解を選ぶのかについての
見識については\link{Exercise 3.68}を参照して下さい。}
\begin{comment}

\begin{example}
(S_0, T_0) | (S_0, T_1)  (S_0, T_2)  ...
-----------+-----------------------------
           | (S_1, T_1)  (S_1, T_2)  ...
           |             (S_2, T_2)  ...
           |                         ...
\end{example}

\end{comment}
\begin{displaymath}
 \vbox{
\offinterlineskip
\halign{
\strut 	\hfil \  #\  \hfil & \vrule
	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil &
	\hfil \  #\  \hfil \cr

$ (S_0, T_0) $ 	& $ (S_0, T_1) $ 	& $ (S_0, T_2) $ 	& $ \dots $ \cr
\noalign{\hrule}
		& $ (S_1, T_1) $ 	& $ (S_1, T_2) $ 	& $ \dots $ \cr
		& 			& $ (S_2, T_2) $ 	& $ \dots $ \cr
		& 			& 			& $ \dots $ \cr }
} 
\end{displaymath}

この分解の3つ目の断片(最初の行にないペア)は(再帰的に)\code{(stream\-/cdr S)}と\code{(stream\-/cdr T)}から
形成されることに注意して下さい。また2番目の断片(最初の行の残り)は以下により求められます。

\begin{scheme}
(stream-map (lambda (x) (list (stream-car s) x))
            (stream-cdr t))
\end{scheme}

\noindent
従って私達のペアのストリームは以下により形成できます。

\begin{scheme}
(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (~\( \dark \langle \)~~\var{\dark combine-in-some-way}~~\( \dark \rangle \)~
     (stream-map (lambda (x) (list (stream-car s) x))
                 (stream-cdr t))
     (pairs (stream-cdr s) (stream-cdr t)))))
\end{scheme}

\noindent
手続を完成させるためには、2つの内部ストリームを接続する何らかの方法を選択せねばなりません。
アイデアの1つは\link{Section 2.2.1}の\code{append}手続の類似ストリームを用いる方法です。

\begin{scheme}
(define (stream-append s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (stream-append (stream-cdr s1) s2))))
\end{scheme}

\noindent
しかし、これは無限ストリームには不適切です。なぜならばこれは最初のストリームからの
要素を全て、2つ目のストリームとの合併前に取ります。具体的には、もし全ての正の整数
のペアを以下のようにして生成しようとすると、

\begin{scheme}
(pairs integers integers)
\end{scheme}

\noindent
結果のストリームは最初に1番目の整数が1の場合の全てのペアを通して実行しようとします。
そしてそれ故に1番目の整数が他の値のペアを全く生成することができません。


無限ストリームを扱うためには、プログラムを十分に長く実行したならば全ての要素がいつかは
得られることを保証する組み合わせの順を工夫する必要があります。これを達成する洗練された
方法は以下の\code{interleave}(相互配置)手続を用います。\footnote{組み合わせの順に要求された属性
を正しく上げると次にようになります。2つの引数を取る関数が必須であり、最初のストリームの要素
\( i \)と2つ目のストリームの要素\( j \)に対応するペアは出力ストリームの\( f(i, j) \)番目として
現れます。\code{interleave}を用いてこれを達成するトリックは、KRC言語にこれを採用したDavid Turnerにより
示されました。(\link{Turner 1981})}

\begin{scheme}
(define (interleave s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (interleave s2 (stream-cdr s1)))))
\end{scheme}

\noindent
\code{interleave}は2つのストリームから交代に要素を得るため、2つ目のストリームの各要素が
いつかは相互配置ストリームへ入ることが、例え最初のストリームが無限でもわかります。



従って要求されたペアのストリームを以下のように生成できます。

\begin{scheme}
(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (pairs (stream-cdr s) (stream-cdr t)))))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.66}Exercise 3.66:} 
ストリーム\code{(pairs integers integers)}を試験せよ。pairsがストリーム内に配置する順に
ついて全体的なコメントを行え。例えばペア(1, 100)の前にはおよそどれだけの数のペアが
先行するか? (99, 100)と(100, 100)の場合についても答えよ。(もし正確な数学上の説明が
できるなら、なおさら良い。しかし行き詰まったと感じるのならばより程度的な回答を
気楽に上げて欲しい。)
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.67}Exercise 3.67:} 
\code{pairs}手続を変更し、\code{(pairs integers integers)}が\emph{全て}の整数のペア\( (i, j) \)を
(\( i \le j \)という条件無しで)生成するようにせよ。ヒント：追加のストリームを混ぜ合わせる
必要がある。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.68}Exercise 3.68:} 
Louis Reasonerは3つの部分からペアストリームを構築することは不必要に複雑なのではないかと
考えた。最初の行のペア\( (S_0, T_0) \)を残りのペアから分離する代わりに、以下のように
最初の行全体を用いて行うことを提案した。

\begin{scheme}
(define (pairs s t)
  (interleave
   (stream-map (lambda (x) (list (stream-car s) x))
               t)
   (pairs (stream-cdr s) (stream-cdr t))))
\end{scheme}


これはうまく行くだろうか?  \code{(pairs integers integers)}をLouisの\code{pairs}の
定義を用いて評価した場合に何が起こるか考えよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.69}Exercise 3.69:}
3つの無限ストリーム、\( S \), \( T \), \( U \)を取り、三つ組\( (S_i, T_j, U_k) \)の
ストリームを生成する手続\code{triples}を書け。但し\( i \le j \le k \)とする。
\code{triples}を用いて全ての正の整数のピタゴラス数の3つ組のストリームを生成せよ。
すなわち三つ組\( (i, j, k) \)は\( i \le j \)、かつ\( i^2 + j^2 = k^2 \)である。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.70}Exercise 3.70:} 
\emph{アドホック}(その場その場)な相互配置処理の結果の順ではなく、
ペアが何らかの便利な順で現れるストリームを生成できれば便利だろう。
もし整数の1つのペアが別のペアよりも``小さい''と言える方法を定義できるならば
\link{Exercise 3.56}の\code{merge}手続に似たテクニックを用いることができる。
これを行う1つの方法は``重み関数''\( W(i, j) \)を定義し
\( W(i_1, j_1) < W(i_2, j_2) \)であるなら
\( (i_1, j_1) \)は\( (i_2, j_2) \)未満であると取り決める。
\code{merge}に似た手続\code{merge\-/weighted}を書け。ただし\code{merge\-/weighted}は追加の引数
\code{weight}を取り、\code{weight}はペアの重みを計る手続でありマージされた結果のストリームの中で
どの要素が現れるべきかの順を決定するのに利用される。\footnote{ペアの重みがペアの配列の中で
行に沿って外へ動くか、列に沿って下った場合に増えるように重み関数に対して要求するだろう。}
重み関数を計算する手続と一緒にこれを用いて、
\code{pairs}を2つのストリームを取る手続\code{weighted\-/pairs}に一般化し、
重みに従った順のペアのストリームを生成する。
作成した手続を用いて以下を生成せよ。

\begin{enumerate}[a]

\item
全ての正の整数のペア\( (i, j) \)のストリームを\( i \le j \)の条件で、和\( i + j \)に
従った順で生成する

\item
全ての正の整数のペア\( (i, j) \)のストリームを\( i \le j \)かつ\( i \)とmath{j}が
どちらも2, 3, 5で割り切れない条件で、和\( 2i + 3j + 5i\!j \)に従う順序で生成する

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.71}Exercise 3.71:} 
2つの立方数の和で表す方法が複数ある数は時折\newterm{Ramanujan numbers}(\jnewterm{ラマヌジャン数})と
呼ばれる。これは数学者Srinivasa Ramanujan(シュリニヴァーサ・ラマヌジャン)に敬意を表して
いる。\footnote{G. H. Hardy(ゴッドフレイ・ハロルド・ハーディ)によるラマヌジャンの
死亡告知(\link{Hardy 1921})から引用すれば、``Mr. Littlewoodこそが`全ての自然数が彼の友達であった'と
述べられた(私が信じる)人だ。私は彼がPutneyで病気で倒れた
時に1度会いに行った。その時私は車番1729のタクシーに乗ったのでとてもつまらない数に見えたと
告げ、それが良くない前触れでないことを祈ると伝えた。`いいえ'と彼が答えた。`それはとても
面白い数です。それは2つの立方数の和により表現する方法が2つ有る最小の数です'''
ラマヌジャン数を生成する重み付けられたペアのトリックはCharles Leisersonにより私達に
示されました。}
ペアの順序有りストリームはこれらの数を計算する問題に対し洗練された解法を提供する。
2つの立方数の和として表現する方法が2つある数を見付けるためには、\( i^3 + j^3 \)の和に従い
重み付けられた整数のペア\( (i, j) \)のストリームを生成し(\link{Exercise 3.70}参照)、次に
ストリームから同じ重みを持つ連続したペアを探すだけで良い。ラマヌジャン数を生成する
手続を書け。そのような最初の数は1,729である。次の5つは何か?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.72}Exercise 3.72:} 
\link{Exercise 3.71}と同様な方法で2つの平方数の和として3つの異なる方法で書ける全ての数の
ストリームを生成せよ。(それらがどのようにして、そう書けるのか示せ)。
\end{quote}

\subsubsection*{信号としてのストリーム}



ストリームの議論を信号処理システムにおける``信号''の計算可能な同類であると説明する
ことから始めました。実際に、ストリームを用いて信号処理システムをとても直接的な方法で
モデル化することができ、連続する時間区間の信号の値をストリームの連続する要素として
表現します。例えば\newterm{integrator}(\jnewterm{積分器})、つまり\newterm{summer}(\jnewterm{アナログ加算器})を実装し、
入力ストリーム\( x = (x_i) \)と初期値\( C \)、小さな増分\( dt \)に対し、以下の
合計を累算し、
\begin{comment}

\begin{example}
           i
          ---
S_i = C + >   x_j dt
          ---
          j=1
\end{example}

\end{comment}
\begin{displaymath}
 S_i = C + \sum_{j=1}^i x_j dt 
\end{displaymath}
\noindent
値\( S = (S_i) \)のストリームを返します。以下の\code{integral}手続は(\link{Section 3.5.2})の
整数ストリームの``暗黙的なスタイル''の定義を思い出させます。

\begin{scheme}
(define (integral integrand initial-value dt)
  (define int
    (cons-stream initial-value
                 (add-streams (scale-stream integrand dt)
                              int)))
  int)
\end{scheme}

\noindent
\link{Figure 3.32}は\code{integral}手続に相当する信号処理システムの絵です。入力ストリームは
\( dt \)によりスケール(拡大)され加算器を通して渡され、その出力は同じ加算器に
戻されます。\code{int}の定義内の自己参照が図では加算器の出力が入力の1つに接続される
フィードバックループにより反映されています。

\begin{figure}[tb]
\phantomsection\label{Figure 3.32}
\centering
\begin{comment}
\heading{Figure 3.32:} The \code{integral} procedure viewed as a signal-processing system.

\begin{example}
                             initial-value
                                  |
       +-----------+              |   |\__
input  |           |      |\__    +-->|   \_  integral
------>| scale: dt +----->|   \_      |cons_>--*------->
       |           |      | add_>---->| __/    |
       +-----------+  +-->| __/       |/       |
                      |   |/                   |
                      |                        |
                      +------------------------+
\end{example}
\end{comment}
\includegraphics[width=102mm]{fig/chap3/Fig3.32.pdf}
\begin{quote}
\heading{Figure 3.32:} 信号処理システムとして見た\code{integral}手続
\end{quote}
\end{figure}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.73}Exercise 3.73:} 
電子回路をストリームを用いて一連の時間の時系列電流や電圧の値を表すことでモデル化できる。
例えば、抵抗値\( R \)の抵抗と静電容量\( C \)のコンデンサから成る\newterm{RC circuit}(\jnewterm{RC回路})を
連続して持っているとする。入力された電流\( i \)に対する回路の電圧レスポンス\( v \)は
\link{Figure 3.33}の式により決定し、その構造は添付の信号フロー図により示される。

\clearpage
\begin{figure}[tb]
\phantomsection\label{Figure 3.33}
\centering
\begin{comment}
\heading{Figure 3.33:} An RC circuit and the associated signal-flow diagram.

\begin{example}
  +        v        -

 ->----'\/\/\,---| |---
  i       R         C


                  / t
               1  |
 v  =  v   +  --- |  i dt  +  R i
        0      C  |
                  / 0

         +--------------+
     +-->|   scale: R   |---------------------+   |\_
     |   +--------------+                     |   |  \_
     |                                        +-->|    \   v
  i  |   +--------------+     +------------+      | add >--->
 ----+-->|  scale: 1/C  |---->|  integral  |----->|   _/
         +--------------+     +------------+      | _/
                                    |             |/
				   v
				    0
\end{example}
\end{comment}
\includegraphics[width=94mm]{fig/chap3/Fig3.33.pdf}
\par\bigskip
\noindent
\heading{Figure 3.33:} RC回路と対応する信号処理図
\end{figure}



この回路をモデル化する手続\code{RC}を書け。\code{RC}は入力として\( R \), \( C \), \( dt \)を
取り、手続を返さねばならない。返り値の手続は入力として電流\( i \)を表すストリームと
コンデンサの初期電圧\( v_0 \)を取り、出力として電圧\( v \)のストリームを生成する。
例えば\code{RC}を用いて\( R \)が5[Ω]、\( C \)が1[F]、タイムステップが0.5秒のRC回路を
\code{(define RC1 (RC 5 1 0.5))}を評価することでモデル化できなければならない。
これは\code{RC1}を電流の時系列を表すストリームとコンデンサの初期電圧を取り電圧の出力ストリーム
を生成する。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.74}Exercise 3.74:} 
Alyssa P. Hackerは物理センサから来る信号を処理するシステムを設計している。
彼女が作りたい重要な機能は入力信号の\newterm{zero crossings}(\jnewterm{ゼロ交差})を記録する信号である。
結果の信号は入力信号が負から正に変わった時に\( +1 \)、正から負に変わった時に\( -1 \)、
その他の場合は0である。(入力が0の場合の符号は正とする)。例えば典型的な入力信号とその関連する
ゼロ交差信号は以下のようになる。

\begin{scheme}
~\( \dots \)~ 1 2 1.5 1 0.5 -0.1 -2 -3 -2 -0.5 0.2 3 4 ~\( \dots \)~
~\( \dots \)~ 0 0  0  0  0   -1   0  0  0   0   1  0 0 ~\( \dots \)~
\end{scheme}

% \begin{smallscheme}
~%~ ~\( \dots \)~1  2  1.5  1  0.5  -0.1  -2  -3  -2  -0.5  0.2  3  4~\( \dots \)~
~%~ ~\( \dots \)~0  0   0   0   0    -1    0   0   0    0    1   0  0~\( \dots \)~
~%~ \end{smallscheme}


Alyssaのシステムではセンサからの信号はストリーム\code{sense\-/data}で表され、
ストリーム\code{zero\-/crossings}が関連するゼロ交差のストリームである。
Alyssaは最初に手続\code{sign\-/change\-/detector}を書いた。これは2つの値を引数として
取り値の符号を比べ値に対応した0, 1, -1を生成する。次にゼロ交差ストリームを以下の
ように構築した。

\begin{scheme}
(define (make-zero-crossings 
         input-stream last-value)
  (cons-stream
   (sign-change-detector
    (stream-car input-stream) 
    last-value)
   (make-zero-crossings
    (stream-cdr input-stream)
    (stream-car input-stream))))
(define zero-crossings
  (make-zero-crossings sense-data 0))
\end{scheme}


Alyssaの上司、Eva Lu Atorが歩み寄り、このプログラムは以下の、\link{Exercise 3.50}の
\code{stream-map}を一般化した版を使用した物とほぼ同じであると提案した。

\begin{scheme}
(define zero-crossings
  (stream-map sign-change-detector
              sense-data
              ~\( \dark \langle \)~~\var{\dark expression}~~\( \dark \rangle \)~))
\end{scheme}



\( \langle \)\var{expression}\( \rangle \)で示された部分を与えてプログラムを完成させよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.75}Exercise 3.75:} 
残念なことに、\link{Exercise 3.74}のAlyssaのゼロ交差判別器は十分でないことが証明された。
センサからのノイズの多い信号が誤ったゼロ交差へと導くためである。ハードウェアのスペシャリスト、
Lem E. TweakitはAlyssaにゼロ交差を試験する前にノイズを排除するために信号を滑らかに
することを提案した。Alyssaは彼のアドバイスを受け入れ、センサのデータの各値を前の値との
平均を取ることで構築された信号からゼロ交差を抽出することを決めた。彼女は問題を彼女の
アシスタント、Louis Reasonerに伝えた。彼はその考えを実装しようと試み、Alyssaのプログラムを
以下のように変更した。

\begin{scheme}
(define (make-zero-crossings
         input-stream last-value)
  (let ((avpt (/ (+ (stream-car input-stream) 
                    last-value) 
                 2)))
    (cons-stream
     (sign-change-detector avpt last-value)
     (make-zero-crossings 
      (stream-cdr input-stream) avpt))))
\end{scheme}



これはAlyssaの計画を正しく実装していない。Louisが入れてしまったバグを見つけ
プログラムの構造を変更せずに直せ。(ヒント：\code{make\-/zero\-/crossings}の引数の数を
増やす必要がある。)
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.76}Exercise 3.76:} 
Eva Lu Atorは\link{Exercise 3.75}におけるLouisの取り組み方を批判した。彼が書いた
プログラムはモジュラ化されていない。滑らかにする操作とゼロ交差抽出が混ざってしまって
いるためである。例えば抽出器はAlyssaが入力信号を調整するより良い手段を見つければ
変更する必要が無かった。Louisを手助けし、入力としてストリームを取り、2つの連続する
入力ストリームの要素の平均を要素とするストリームを生成する手続\code{smooth}を書け。
次に\code{smooth}をゼロ交差判定機を実装するためのコンポーネントとしてよりモジュラー化
スタイルにて用いよ。
\end{quote}

\subsection{ストリームと遅延評価}
\label{Section 3.5.4}



先の節の終わりの\code{integral}手続はどのようにストリームを用いてフィードバックループを
持つ信号処理システムをモデル化できるかを示しています。\link{Figure 3.32}に示される加算器の
フィードバックループは\code{integral}の内部ストリーム\code{int}がそれ自身を用いて定義されている
事実によりモデル化されています。

\begin{scheme}
(define int
  (cons-stream
   initial-value
   (add-streams (scale-stream integrand dt)
                int)))
\end{scheme}

\noindent
暗黙的定義のような物を扱うインタプリタの能力は\code{cons\-/stream}に組込まれている
\code{delay}に依存している。この\code{delay}無しではインタプリタは、\code{int}が既に定義されている
ことを要件とする\code{cons\-/stream}への引数両方を評価する前には\code{int}を構築することができませんでした。
一般的に、\code{delay}はストリームを用いてループを含む信号処理システムをモデル化するのに不可欠です。
\code{delay}無しでは任意の信号処理コンポーネントへの入力が、出力を生成する前に
完全に評価されるように、私達のモデルが定式化されなければなりません。

\begin{figure}[tb]
\phantomsection\label{Figure 3.34}
\centering
\begin{comment}
\heading{Figure 3.34:} An ``analog computer circuit'' that solves the equation \( dy / dt = f(y) \).

\begin{example}
                            y_0
                             |
                             V
    +----------+  dy   +----------+     y
+-->|  map: f  +------>| integral +--*----->
|   +----------+       +----------+  |
|                                    |
+------------------------------------+
\end{example}
\end{comment}
\includegraphics[width=67mm]{fig/chap3/Fig3.34.pdf}
\begin{quote}
\heading{Figure 3.34:} 方程式\( dy / dt = f(y) \)を解く``アナログ演算回路''
\end{quote}
\end{figure}

\noindent
残念なことに、ループを伴うシステムのストリームモデルは\code{cons\-/stream}により提供される
``隠れた''\code{delay}を越えて、\code{delay}の使用を要求します。例えば\link{Figure 3.34}は
\( f \)が与えられた関数である場合に微分方程式信号\( dy / dt = f(y) \)を
解く処理システムを示しています。図は\( f \)をその入力信号に適用するマッピング
コンポーネント(map)を示しています。mapはフィードバックループの中に積分器へ向けて
実際にそのような方程式を解くために利用されているアナログ計算機回路にとても似た作法で
接続されています。



\( y \)に対し初期値\( y_0 \)を与えられたとした時、このシステムを以下の手続を用いて
モデル化を試みることができるでしょう。

\begin{scheme}
(define (solve f y0 dt)
  (define y (integral dy y0 dt))
  (define dy (stream-map f y))
  y)
\end{scheme}

\noindent
この手続はうまく行きません。\code{solve}の最初の行にて\code{integral}の呼出は
入力\code{dy}が定義されてることを要求します。これは\code{solve}の二行目までは
起こり得ません。


一方で、私達の定義の意図もつじつまが合いません。原理上は、\code{y}ストリームを
\code{dy}を知らずに生成し始めることができます。再に\code{integral}や他の多くのストリーム
命令は\code{cons\-/stream}に、引数に関する部分的な情報を与えられただけで応答の部分を
生成できるという点で似た性質を持っています。\code{integral}では出力ストリームの
最初の要素は\code{initial\-/value}で与えられます。従って出力ストリームの最初の要素を
被積分関数\code{dy}を評価せずに生成することができます。一度\code{y}の最初の要素を知る
ことができれば、\code{solve}の2行目の\code{stream\-/map}は\code{dy}の最初の要素を生成する
仕事を開始できます。これにより\code{y}の次の要素を生成することもでき、以下繰り返し
となります。


この考えの利点を得るために、\code{integral}を再定義し、被積分関数ストリームが
\newterm{delayed argument}(\jnewterm{遅延引数})を要求するようにします。\code{Integral}は
出力ストリームの最初の要素より多くを生成することを要求された時のみ、被積分関数を
\code{force}し評価させます。

\begin{scheme}
(define (integral delayed-integrand initial-value dt)
  (define int
    (cons-stream
     initial-value
     (let ((integrand (force delayed-integrand)))
       (add-streams (scale-stream integrand dt)
                    int))))
  int)
\end{scheme}

\noindent
これで\code{solve}手続の実装が、\code{y}の定義内で\code{dy}を遅延させればできます。\footnote{この
手続は全てのScheme実装で動くことが保証されていません。とはいえ、任意の実装に対して簡単な
変更で動作します。問題はScheme実装の内部定義の扱い方に関係があります。(\link{Section 4.1.6}参照)}

\begin{scheme}
(define (solve f y0 dt)
  (define y (integral (delay dy) y0 dt))
  (define dy (stream-map f y))
  y)
\end{scheme}

\noindent
全体的に、\code{integral}を呼び出す者は今では被積分関数を\code{delay}しなければなりません。
\( e \approx 2.718 \)の近似値を微分方程式\( dy / dt = y \)に対する
解が\( y = 1 \)の場合の値を初期条件\( y(0) = 1 \)で求めることで\code{solve}手続が
うまく働くことを実演できます。

\begin{scheme}
(stream-ref (solve (lambda (y) y) 1 0.001) 1000)
~\textit{2.716924}~
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.77}Exercise 3.77:} 
上で使用された\code{integral}手続は\link{Section 3.5.2}の整数無限ストリームの``暗示的''定義に
似ている。代替的に、より\code{integers\-/starting\-/from}に似た\code{integral}の定義を
与えることができない。(これも\link{Section 3.5.2}参照)

\begin{smallscheme}
(define (integral integrand initial-value dt)
  (cons-stream
   initial-value
   (if (stream-null? integrand)
       the-empty-stream
       (integral (stream-cdr integrand)
                 (+ (* dt (stream-car integrand))
                    initial-value)
                 dt))))
\end{smallscheme}


ループを持つシステム内で利用された場合、この手続は\code{integral}の元の版が抱えた
問題と同じ問題を持つ。手続を変更して\code{integrand}に対し遅延された引数を要求する
ようにし、それ故に上で示されたように\code{solve}手続で利用できるようにせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.78}Exercise 3.78:} 
単項二次線形微分方程式を学ぶための信号処理システムの設計問題について考えよ。
\begin{comment}

\begin{example}
d^2 y        d y
-----  -  a -----  -  by  =  0
d t^2        d t
\end{example}

\end{comment}
\begin{displaymath}
 {d^2y \over dt^2} - a {dy \over dt} - by = 0. 
\end{displaymath}



\( y \)をモデル化する出力ストリームはループを含むネットワークにより生成される。
これは\( d^2y / dt^2 \)の値が\( y \)と\( dy / dt \)の値に依存し、
これらの両方が\( d^2y / dt^2 \)を積分することにより決定されるからである。
\link{Figure 3.35}に示される図の符号化を行いたい。定数\( a \), \( b \), \( dt \)と
初期値、\( y \)に対する\( y_0 \)と\( dy_0 \)を引数として取り、\( y \)の一連の値の
ストリームを生成する手続\code{solve-2nd}を書け。
\end{quote}

\begin{figure}[tb]
\phantomsection\label{Figure 3.35}
\centering
\begin{comment}
\heading{Figure 3.35:} Signal-flow diagram for the solution to a second-order linear differential equation.

\begin{example}
               dy_0                y_0
                |                   |
                V                   V
   ddy     +----------+    dy  +----------+    y
+--------->| integral +-----*--+ integral +--*--->
|          +----------+     |  +----------+  |
|                           |                |
|            +----------+   |                |
|     __/|<--+ scale: a |<--+                |
|   _/   |   +----------+                    |
+--<_add |                                   |
     \__ |   +----------+                    |
        \|<--+ scale: b |<-------------------+
             +----------+
\end{example}
\end{comment}
\includegraphics[width=91mm]{fig/chap3/Fig3.35a.pdf}
\begin{quote}
\heading{Figure 3.35:} 二次線形微分方程式の解のための信号フロー図
\end{quote}
\end{figure}


\begin{quote}
\heading{\phantomsection\label{Exercise 3.79}Exercise 3.79:} 
\link{Exercise 3.78}の\code{solve\-/2nd}手続を一般化し、一般的な二次微分方程式\( d^2y / dt^2 =
f(dy / dt, y) \)を解くのに使用できるようにせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.80}Exercise 3.80:} 
\newterm{series RLC circuit}(\jnewterm{連続RLC回路})は抵抗、コンデンサ、インダクタンスが\link{Figure 3.36}に
示されるように連結されている。\( R \), \( L \), \( C \)が抵抗、インダクタンス、コンデンサである
場合、3つのコンポーネントに対する電圧(\( v \))と電流(\( i \))の間の関係は以下の方程式により
説明される。
\begin{comment}

\begin{example}
v_R = i_R R

         d i_L
v_L = L -------
          d t

         d v_C
i_C = C -------
          d t
\end{example}

\end{comment}
\begin{displaymath}
 	v_R 	= 	i_R R, \qquad\quad
	v_L 	= 	L {di_L \over dt}\,, \qquad\quad
	i_C 	= 	C {dv_C \over dt}\,, 
\end{displaymath}

そして回路の接続が以下の関係を決定する。
\begin{comment}

\begin{example}
i_R = i_L = -i_C

v_C = v_L + v_R
\end{example}

\end{comment}
\begin{displaymath}
 	i_R 	= 	i_L = -i_C\,, \qquad\quad
	v_C 	= 	v_L +  v_R\,.  
\end{displaymath}


これらの方程式の組み合わせは(コンデンサに渡る電圧\( v_C \)とインダクタンスの
電流\( i_L \)にてまとめれば)回路の状態が以下の微分方程式のペアで説明されることを
示している。
\begin{comment}

\begin{example}
d v_C        i_L
-----  =  -  ---
 d t          C

d i_L      1           R
-----  =  --- v_C  -  --- i_L
 d t       L           L
\end{example}

\end{comment}
\begin{displaymath}
  {dv_C \over dt}  =  -{i_L \over C}\,, \qquad\quad
    {di_L \over dt}  =   {1   \over L} v_C - {R \over L} i_L\,. 
\end{displaymath}

この微分方程式のシステムを表す信号フロー図は\link{Figure 3.37}に示される。
\end{quote}

\begin{figure}[tb]
\phantomsection\label{Figure 3.36}
\centering
\begin{comment}
\heading{Figure 3.36:} A series RLC circuit.

\begin{example}
              + v_R -
        i_R
     +--->----'\/\/\,--------+
     |                       |  i_L
    \|/          R          \|/
  +  |  i_C                  |_   +
    -+-                       _)
v_C -+- C                     _)  v_L
     |                        _)
  -  |                       |    -
     +-----------------------+
\end{example}
\end{comment}
\includegraphics[width=60mm]{fig/chap3/Fig3.36.pdf}
\par\bigskip
\noindent
\heading{Figure 3.36:} 連続RLC回路
\end{figure}

\begin{quote}
引数として回路のパラメタ\( R \), \( L \), \( C \)と時間の増分\( dt \)を取る
手続\code{RLC}を書け。ある意味では\link{Exercise 3.73}の\code{RC}手続のそれに似ているが、
\code{RLC}は状態変数の初期値\( v_{C_0} \)と\( i_{L_0} \)を取り、(\code{cons}を用いて)
\( v_C \)と\( i_L \)の状態のストリームのペアを生成する手続を生成せねばならない。
\code{RLC}を用いて、連結RLC回路の振舞をモデル化するストリームのペアを生成せよ。
ただし\( R \) = 1[Ω], \( C \) = 0.2[F], \( L \) = 1 henry, \( dt \)
= 0.1[s], soreni初期値 \( i_{L_0} \) = 0[A], \( v_{C_0} \) = 10[V]とする。
\end{quote}

\begin{figure}[tb]
\phantomsection\label{Figure 3.37}
\centering
\begin{comment}
\heading{Figure 3.37:} A signal-flow diagram for the solution to a series RLC circuit.

\begin{example}
                 +-------------+
+----------------+  scale: l/L |<--+
|                +-------------+   |
|                                  |
|                +-------------+   |  v_C
|       dv_C +-->|   integral  +---*------>
|            |   +-------------+
|            |        ^
|            |        | v_(C_0)
|            |
|            |   +-------------+
|            +---+ scale: -l/C |<--+
|                +-------------+   |
|  |\__                            |
+->|   \_  di_L  +-------------+   |  i_L
   | add_>------>|   integral  +---*------>
+->| __/         +-------------+   |
|  |/                 ^            |
|                     | i_(L_0)    |
|                                  |
|                +-------------+   |
+----------------+ scale: -R/L |<--+
                 +-------------+
\end{example}
\end{comment}
\includegraphics[width=68mm]{fig/chap3/Fig3.37a.pdf}
\begin{quote}
\heading{Figure 3.37:} 連続RLC回路の解のための信号フロー図
\end{quote}
\end{figure}

\subsubsection*{正規順評価}

この節の例は明示的な\code{delay}と\code{force}の使用がどのようにして大きなプログラミングの
柔軟性を与えるかについて説明します。しかし同じ例がまたこのことがどのようにして私達の
プログラムをより複雑にするかについても示します。例として私達の新しい\code{integral}手続は
ループを伴うシステムをモデル化するための力を与えます。しかし今では\code{integral}が
遅延化された被積分関数と共に呼び出されなければならないことを忘れてはならなくなりました。
そして\code{integral}を使用する全ての手続はこのことについて注意しなければなりません。
実際には、手続の2つの組を作りました。通常の手続と遅延化された引数を取る手続です。
一般的に、分離された手続の組を作ることは私達に分離された高階手続の組もまた作ることを
強います。\footnote{これはPascalの様な旧来の強い方の言語が高階手続をこなす場合に持つ
困難さの(Lispにとっては)小さな反射です。そのような言語ではプログラマは必ず各手続の引数と
結果のデータ型を指定せねばなりません。数値、論理値、配列、等です。その結果として
``与えられた手続\code{proc}を列の全ての要素にmapする''ような抽象化を\code{stream\-/map}のような
単一の高階手続にて表すことができませんでした。それどころか\code{proc}に
対して指定されるかもしれない異なる引数と結果のデータ型の組み合わせ全てに対して
異なるマッピング手続を必要としました。高階手続の存在における``データ型''の実用的な
概念を維持することは多くの困難な問題を提起しました。この問題を処理する1つの方法は
言語ML(\link{Gordon et al. 1979})により説明され、その``多層データ型''はデータ型間の
高階変換のためのテンプレートを含んでいます。さらにMLのほとんどの手続データ型は
明示的にプログラマにより宣言されることはありません。その代わりにMLは
\newterm{type\-/inferencing}(\jnewterm{型推論})メカニズムを含み、環境の情報を用いて新しく定義された
手続のデータ型を推論します。}


2つの異なる手続の組の必要性を防ぐ1つの方法は全ての手続に対し遅延引数を取らせることです。
手続に対する全ての引数が自動的に遅延化され、引数が実際に必要とされる時(例えばプリミティブ
命令に要求された時)強制される評価のモデルを受け入れることができるでしょう。これは
私達の言語を正規順評価を用いるように変形します。これは私達が\link{Section 1.1.5}の評価の置換
モデルを紹介した時、最初に説明しました。正規順評価への変換は統一、洗練された方法で
遅延評価の利用を簡易化します。そしてこれはストリーム処理のみについて考慮するのならば
受け入れるべき自然な戦略です。\link{Section 4.2}では評価機を学んだ後に、私達の言語をどのように
してこのように変形するのかについて学びます。残念なことに手続呼出に遅延を導入することは
イベント順に依存するプログラムを設計する能力に混乱をもたらします。例えば代入を利用する、
データを変更する、入出力を実行するプログラムです。例え1つの\code{cons\-/stream}内の\code{delay}でも
\link{Exercise 3.51}や\link{Exercise 3.52}で説明された大きな混乱を招きます。誰もが知っている
ように、変更可能性と遅延評価はプログラミング言語の中でうまく混ざりません。
そしてこれらの両方を一度に取り扱う方法の発明は活発な研究領域です。

\subsection{関数型プログラムのモジュール化とオブジェクトのモジュール化}
\label{Section 3.5.5}


\link{Section 3.1.2}で学んだように、代入の導入の主な利点の1つは巨大システムの状態の一部を
ローカル変数の中にカプセル化、または``隠す''ことによりシステムのモジュール化の
容易性を増すことができます。ストリームモジュールは同等なモジュールの容易性を
代入の使用成しに提供可能です。例として\( \pi \)のモンテカルロ推定を再実装して
みましょう。\link{Section 3.1.2}にてこれをストリーム処理の視点から試しました。



モジュール化容易性の鍵となる問題は、乱数生成器の内部状態を乱数を使用するプログラムから
隠したいと願ったことです。手続\code{rand\-/update}から始めました。これの連続する値が
私達の乱数を供給し、そしてこれを乱数生成器を作り出すのに使用しました。

\begin{scheme}
(define rand
  (let ((x random-init))
    (lambda ()
      (set! x (rand-update x))
      x)))
\end{scheme}

\noindent
ストリームの定式化においては乱数生成器が単体では存在しません。乱数のストリームがただ
\code{rand\-/update}を連続して呼ぶことで生成されます。

\begin{scheme}
(define random-numbers
  (cons-stream random-init
               (stream-map rand-update random-numbers)))
\end{scheme}

\noindent
これを用いて乱数ストリームにおける連続したペア上で行われたCes\`aro(チェザロ)の実験
の結果のストリームを構築します。

\begin{scheme}
(define cesaro-stream
  (map-successive-pairs
   (lambda (r1 r2) (= (gcd r1 r2) 1))
   random-numbers))
(define (map-successive-pairs f s)
  (cons-stream
   (f (stream-car s) (stream-car (stream-cdr s)))
   (map-successive-pairs f (stream-cdr (stream-cdr s)))))
\end{scheme}

\noindent
\code{cesaro\-/stream}が次に\code{monte\-/carlo}手続に与えられます。これは確率の推測のストリームを
生成します。するとその結果は\( \pi \)の推測値のストリームへと変換されます。
このプログラムのこの版は何回試行を行うかのパラメタが必要ありません。より良い\( \pi \)の
推測値(より多くの試行からの)はより多くの\code{pi}ストリームを見ることで得られます。

\begin{scheme}
(define (monte-carlo experiment-stream passed failed)
  (define (next passed failed)
    (cons-stream
     (/ passed (+ passed failed))
     (monte-carlo
      (stream-cdr experiment-stream) passed failed)))
  (if (stream-car experiment-stream)
      (next (+ passed 1) failed)
      (next passed (+ failed 1))))
(define pi
  (stream-map
   (lambda (p) (sqrt (/ 6 p)))
   (monte-carlo cesaro-stream 0 0)))
\end{scheme}

\noindent
考慮すべきモジュール化容易性がこの取り組み方には存在します。なぜなら依然として
任意の実験を取り扱うことが可能な一般的な\code{monte\-/carlo}手続を定式化できるためです。
その上、代入やローカル変数が存在しません。

\begin{quote}
\heading{\phantomsection\label{Exercise 3.81}Exercise 3.81:} 
\link{Exercise 3.6}は乱数生成器に乱数列のリセットを許可することで``ランダム''な
数の列を繰り返し生成させる一般化について議論した。
入力ストリームの要求に従い操作する これと同じ生成器のストリーム定式化を実現せよ
ストリームの要素が\code{generate}なら新しい乱数を生成し、また\code{reset}なら指定された値に列をリセットすることで
希望の乱数列を生成する。
代入は使用しないこと。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 3.82}Exercise 3.82:} 
\link{Exercise 3.5}のモンテカルロ積分をストリームを用いて再度行え。
ストリーム版の\code{estimate\-/integral}は何度試行を行うのか伝える引数は持たない。
その代わり連続するより多くの試行を基に推測値のストリームを生成する。
\end{quote}

\subsubsection*{時間の関数型プログラミング的視点}


さて、この章の始めに提起されたオブジェクトと状態の問題に戻り新しい光の下で調査
しましょう。私達は代入とミュータブルオブジェクトを導入し状態を持つシステムのモデル化
を行うプログラムのモジュラー方式の構築のための仕組みを提供しました。ローカル状態変数
を持つ計算オブジェクトを構築し、代入を用いてこれらの変数を変更しました。
世界のオブジェクトの一時的な振舞を相当する計算オブジェクトの一時的な振舞により
モデル化しました。



今までストリームが局所状態を持つオブジェクトのモデル化する代替法を提供することを学んで
きました。何らかのオブジェクトの局所状態のような変化する数量を、連続する状態の時刻歴を
表現するストリームを用いてモデル化できます。
本質的に、私達はストリームを用いることで時間を明示的に表現しています。そうすることで
私達のシミュレートされた世界の時間を評価の間に現れる一連のイベントから分断しています。
実際に、\code{delay}の存在のため、モデルのシミュレートされた時間と評価中のイベントの順の
間には何の関係も無いでしょう。



これらの2つのモデル化の取り組み方を対比するために、``銀行の引き出し機''の実装について
再考してみましょう。これは銀行口座の残高を監視します。\link{Section 3.1.3}ではそのような処理機
の単純化された版を実装しました。

\begin{scheme}
(define (make-simplified-withdraw balance)
  (lambda (amount)
    (set! balance (- balance amount))
    balance))
\end{scheme}

\noindent
\code{make\-/simplified\-/withdraw}への呼出は計算オブジェクトを生成します。各計算
オブジェクトは局所状態変数\code{balance}を個別に持ち、そのオブジェクトを続けて呼ぶと
\code{balance}は減少します。銀行口座のユーザが連続したそのようなオブジェクトに対する
入力を打ち、ディスプレイの画面に表われる一連の返り値を観察するのを想像できます。


代替的に、引き出し処理機を入力として残高と引き出す金額のストリームを取り口座の一連の
残高のストリームを生成する手続としてモデル化することが可能です。

\begin{scheme}
(define (stream-withdraw balance amount-stream)
  (cons-stream
   balance
   (stream-withdraw (- balance (stream-car amount-stream))
                    (stream-cdr amount-stream))))
\end{scheme}

\noindent
\code{stream\-/withdraw}は明確な数学上の関数を実装し、関数の出力はその入力のみにより
完全に決定します。しかし入力\code{amount\-/stream}がユーザにより打鍵された一連の値の
ストリームであり結果の残高ストリームが表示されたと考えてみて下さい。すると、
値を入力し結果を見ているユーザの視点からはストリーム処理が\code{make\-/simplified\-/withdraw}に
より作成されたかのように、同じ振舞をしています。
しかしストリーム版では代入が無く、局所状態変数が無く、それ故に\link{Section 3.1.3}で遭遇した
論理的な困難に存在しません。それにもかかわらずシステムは状態を持っています！



これは本当に驚くべきことです。\code{stream\-/withdraw}は明確な数学上の関数を実装し
その振舞は代わらないのに、ここでのユーザの知覚はシステムとの相互作用の1つであり変化
する状態を持ちます。このパラドックスを解決する1つの方法はユーザの一時的な存在が
システムに状態を与えていると認識することです。もしユーザが相互作用から一歩離れて
個々の取引でなく、残高のストリームに関して考えれば、システムはステートレス(状態が
無く)として現われるでしょう。\footnote{物理でも同様に、私達が移動点を観察する時、
点の位置(状態)は変化していると言えます。しかし、移動点の時空の世界線の視点からは
何の変化も起こってはいません。}



複雑な処理のある部分の視点からは、他の部分は時間と共に変化するように見えます。
それらは隠された時間と伴に変化する局所状態を持ちます。もし私達がこの種の自然な
分解を私達の世界において(世界の一部である私達の視点から見たままに)計算機内の
モデル化したプログラムを計算機内の構造を用いて書きたいのならば、関数型でない
計算オブジェクトを作成します。それらは時間と共に変化します。状態を局所状態変数で
モデル化し、そして状態の変化をそれらの変数への代入を用いてモデル化します。
これを行うことにより計算の実行時間を、私達がその一部である世界の時間のモデルと
し、従って私達は``オブジェクト''を計算機の中に得ることになります。



オブジェクトを用いるモデリングは強力、かつ直感的です。その理由の多くはこれが
私達がその一部である世界との相互作用の視点に合うためです。
しかしこの章を通して繰り返し学んできた様に、これらのモデルは悩ましい
イベント順の制約とと複数の処理間の同期の問題を提起します。
これらの問題を防ぐ可能性から\newterm{functional programming languages}(\jnewterm{関数型プログラミング言語})の
開発が促進されてきました。これは代入や変更可能なデータを提供しません。そのような言語では
全ての手続は引数の明確な数学の関数を実装し、その振舞は変化しません。関数型の取り組み方は
並行システムを扱うのにとても魅力的です。\footnote{Fortranの開発者であるJohn Backusは
1978年に\acronym{ACM}のチューリング賞を授与された時に関数型プログラミングに高い知名度を
与えました。彼の受賞スピーチ(\link{Backus 1978})は関数型のアプローチを強く支持しました。
関数型プログラミングの良い概観は\link{Henderson 1980}と\link{Darlington et al. 1982}で
与えられます。}


一方で、もしきっちりと見てみれば時間に関係する問題が関数型のモデルにも潜んでいることが見えます。
ある特に厄介な領域がインタラクティブシステム(応答システム)を設計したい時に、特に独立した要素の間で相互作用を
行うシステムにおいて提起されます。例として、もう1度連結銀行口座を許可する銀行システムについて
考えてみましょう。代入とオブジェクトを用いる保守的なシステムでは、PeterとPaulが口座を共有している
という事実をモデル化します。共有は\link{Section 3.1.3}で見たように、PeterとPaulの両者が彼等の取引要求を
同じ銀行口座オブジェクトに送ることにより行われます。ストリームの視点からは、``オブジェクト''それ自身は
無いため、銀行口座を取引要求の操作を行う処理としてモデル化し、応答のストリームを生成できる
ことが既に示されています。従って、PeterとPaulが連結銀行口座を持つことが、\link{Figure 3.38}で示すように
Peterの取引要求ストリームとPaulの取引要求リクエストをマージし、その結果を銀行口座ストリーム処理へ渡すと
いう事実をモデル化することができるでしょう。

\begin{figure}[tb]
\phantomsection\label{Figure 3.38}
\centering
\begin{comment}
\heading{Figure 3.38:} A joint bank account, modeled by merging two streams of transaction requests.

\begin{example}
Peter's requests   +---------+     +---------+
------------------>|         |     |         |
Paul's requests    |  merge  |---->| bank    |---->
------------------>|         |     | account |
                   +---------+     +---------+
\end{example}
\end{comment}
\includegraphics[width=88mm]{fig/chap3/Fig3.38.pdf}
\begin{quote}
\heading{Figure 3.38:} 取引要求リクエストの2つのストリームをマージすることでモデル化した連結銀行口座
\end{quote}
\end{figure}

\noindent
この定式化に伴う問題は\newterm{merge}(\jnewterm{マージ})という概念にあります。これは2つの
ストリームを単純に交互にPeterの要求を1つ、Paulの要求を1つと取りマージすることは
しません。Paulが口座にとても稀にしかアクセスしないと考えてみましょう。
Peterに対し、彼が2つ目の取引を発行できる前にPaulが口座にアクセスするのを待つよう
強いることはできません。しかしそのようなマージが実装された場合、
PeterとPaulにより知覚される``実時間''に制約された何らかの方法で2つの取引ストリームを
相互配置しなければなりません。何らかの方法とはもしPeterとPaulが会えば、いくつかの取引が会う
前に処理され、他の取引が会った後に処理されることに合意できるという意味でです。\footnote{任意の
2つのストリームに対し一般的に複数の受け入れ可能な相互配置の順が存在することに
注意して下さい。従って技術的には``マージ''は関数ではなく関係です。その答は
入力の決定的な関数ではありません。私達は既に(\link{Footnote 39})で非決定論が
並行の扱いの本質であると述べました。マージの関係は同じ本質的な非決定論を関数型の
視点から説明します。\link{Section 4.3}では非決定論をまた別の視点から見ることになります。}
これは正確に、\link{Section 3.4.1}で扱わねばならなかったのと同じ制約です。そこでは状態を
持つオブジェクトの並行処理におけるイベントの``正しい''順を保証する明示的な同期の
導入の必要性が見つかりました。従って、関数型のスタイルをサポートする取り組みにおいて、
異なる要因からの入力のマージの必要性は関数型のスタイルが排除するはずだった同じ問題
を再び導入します。


私達はこの章を、私達がモデル化しようとする実際の世界の私達の視点に合う構造を持つ
計算モデルの構築をゴールとして始めました。
世界を分離した、時間制約のある、相互応答する、状態を持つオブジェクトでモデル化できます。
または世界を単一の、時間制約のない、状態の無い、個体によりモデル化できます。
それぞれの視点が強力な利点を持ちますが、どちらの視点も単独では十分ではありません。
大統一は未だ現われてはいません。\footnote{オブジェクトモデルは世界を分割し分離した
部分にすることで近似します。関数型モデルはオブジェクト境界に従ってモジュラ化はしません。
オブジェクトモデルは``オブジェクト''の非共有下の状態が共有されている状態よりも
とても大きい場合に便利です。オブジェクトの視点が失敗する場合の例は量子力学です。
そこでは物を個別の点として考えることは逆説と混乱を招きます。オブジェクトの視点を
関数型の視点と統一することはプログラミングとはあまり関係が無いかもしれません。
しかしより根本的な認識論の問題と関係するのです。}
