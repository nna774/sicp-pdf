\chapter{手続を用いた抽象化の構築}
\label{Chapter 1}

\begin{quote}
心がその中で、その力を単純な考えの上に発揮する``心の働き''は、主としてこれら3つです。1. いくつかの
簡単な考えを1つの複合物に組み合わせます。全ての複雑な考えはこのようにして作られます。
2. 2つの考えをそれが簡単であるか複雑であるかに係らず一緒にもたらし、お互いに
合わせることでそれらを統合することは無しに、全ての関係性の考えを得ることで、一度に
それらを見渡します。3. 考えをそれらの実在に付随する全ての他の考えから分離します。
これは抽象化と呼ばれ、このようにして全てのその一般的な考えは作られます。

---John Locke, \emph{An Essay Concerning Human Understanding} (1690)
\end{quote}

\vspace{1.0em}

\noindent
私達は\newterm{computational process}(\jnewterm{演算プロセス})について学びます。演算プロセスとは抽象的な存在で
コンピュータ
の中に複数が住んでいます。それらが進化するとプロセスは\newterm{data}(\jnewterm{データ})と呼ばれる
また別の抽象的な物を扱います。プロセスの進化は\newterm{program}(\jnewterm{プログラム})と呼ばれるルールの
パターン(型、類型)により命じられます。人はプログラムを作成してプロセスに命ずるのです。
つまり私達はコンピュータの精霊に私達の呪文で魔法をかけるのです。

演算プロセスは本当に魔法使いの精霊の考えに似ています。それは見たり触れたりは
できません。物理的な物では構成されていません。しかしとてもリアルな存在です。
知的な仕事を行います。質問にも答えます。銀行でお金を払ったり、工場でロボットの
腕をコントロールすることで世界に影響を与えることも可能です。私達が利用する
プロセスに魔法をかけるプログラムとは魔法使いの呪文のような物です。難解な秘伝の
\newterm{programming languages}(\jnewterm{プログラミング言語})の中で記号的表現にて慎重に組み立てられプロセスに
実行してほしいタスク(仕事、任務)を指示します。



演算プロセスは、正しく動くコンピュータでは、精密に正しくプログラムを実行します。
従って魔法使いの見習いのように、初心者のプログラマは魔法の結果について理解し、
予測することを学ばねばなりません。例えプログラムの小さなエラー
（通常は\newterm{bugs}(\jnewterm{バグ})、または\newterm{glitches}(\jnewterm{グリッチ}、誤作動)と呼ばれます）でも
複雑で予測不可能な結果をもたらす場合もあるのです。



幸運なことに、プログラムを学ぶことは魔法を学ぶことより少しも危険ではありません。
私達が相手にする精霊は都合良く安全な方法で封じ込まれています。
しかし、実際の世界でのプログラミングには注意力、専門知識、堅実さを必要とします。
例えばCAD(計算機による設計支援)プログラムの小さなバグが飛行機や
ダムの最悪な崩壊に繋ったり、工業ロボットの自己破壊を起こしたりします。



ソフトウェアエンジニアのマスター達は最終的にプロセスが望まれたタスクを実行する
ことに自信を持てるだけの技能を、プログラムの構築に対して持っています。
彼らは前もってシステムの行いを図で説明することができます。予測不可能な問題が
最悪な結果をもたらさぬようプログラムをどのように構造化を行うのか知っています。
そして問題が発生した時にはプログラムの \newterm{debug}(\jnewterm{デバッグ}、バグ取り)を行えます。
良い設計のコンピュータシステムは、良い設計の自動車や原子炉のように
モジュール方式で設計されており、パーツは個別に組み立て、置き換え、デバッグが
可能です。

\subsubsection*{Lispプログラミング}



私達はプロセスを記述するのに適切な言語を必要とします。この目的に対しプログラミング
言語Lispを利用します。私達の日々の考えが通常、自然言語（例えば英語やフランス語、
日本語）で表されるように、定量的な現象が数学の記号で表されるように、手続的な
思考はLispで表現されます。Lispは1950年代後半に\newterm{recursion equations}(\jnewterm{再帰方程式})
と呼ばれるある種の論理表現に関する推論のための形式化として開発されました。
この言語はJohn McCarthyにより着想され、彼の論文``記号式の再帰方程式とそれらの機械による演算''
(\link{McCarthy 1960})を基にしています。



数学上の形式主義としての始まりにも関わらず、Lispは実用的なプログラミング言語
です。Lisp\newterm{interpreter}(\jnewterm{インタプリタ}、逐次翻訳処理器)はLisp言語にて記述されたプロセスを実行する
機械です。最初のLispインタプリタはMcCarthyと\acronym{MIT}研究所の人工知能部門の
同僚、学生による手助けにて実装されました。\footnote{
\textit{Lisp 1 Programmer's Manual}は1960年に初出し、
\textit{Lisp 1.5 Programmer's Manual} (\link{McCarthy et al. 1965})は1962年に出版
されました。Lispの初期の歴史は\link{McCarthy 1978}にて説明されています。}
Lispはその名前をLIst Processing(リスト処理)の頭文字から取っており、
記号微分や代数式の積分の様なプログラミング上の問題に着手するための
記号操作能力を提供するために設計されました。この目的のためにアトムとリストとして
知られる新しいデータオブジェクトを含みます。これはその時代の他の全ての言語から
著しく際立たせる物でした。



Lispは計画的な設計の取り組みから生まれた製品ではありませんでした。そうではなく、
非公式に試験的なやり方で、ユーザの要求と実利的な実装上の考慮への対応として発展しました。
Lispの非公式な進化は何年も続き、Lispユーザのコミュニティは伝統的に言語の``公式な''
どんな定義の公表に対しても抵抗しました。この進化は初期構想の柔軟性と洗練さと共に、今日
世界中で広く使用される言語で2番目に古い(Fortranのみがより古い)言語として、Lispに継続的に
最新のプログラム設計についての考えを受け入れることを可能にしてきました。
従ってLispは今では複数の方言の系統が存在し、それらはオリジナルの機能の多くを共有しながらも、
お互いに大きな違いを持ちます。この本で使用されるLispの方言はSchemeと呼ばれます。\footnote{
1970年代に最もメジャーなLispプログラムの記述に用いられた2つの方言は\acronym{MIT}のプロジェクト
\acronym{MAC}で開発されたMacLisp (\link{Moon 1978}; \link{Pitman 1983})と
Bolt Beranek and Newman Inc.とXerox Palo Alto研究センターににて開発された
Interlisp (\link{Teitelman 1974})でした。Portable Standard Lisp (\link{Hearn 1969}; \link{Griss 1981})
は簡単に、異なるマシンの間で移植可能にするよう設計されたLisp方言です。MacLispは
カリフォルニア大学バークレー校により開発されたFranz Lispや\acronym{MIT}人工知能研究所が
Lispをとても効率良く実行するために設計した特定目的プロセッサ(処理機)をベースにした
Zetalisp (\link{Moon and Weinreb 1981})といったいくつかの下位方言を生みました。
この本で使用するLisp方言はSheme (\link{Steele and Sussman 1975})と呼ばれ、1975年に
\acronym{MIT}人工知能研究所のGuy Lewis Steele Jr.とGerald Jay Sussmanにより開発され、
後に\acronym{MIT}にて教育目的のために再実装されました。
Common Lisp (\link{Steele 1982}, \link{Steele 1990})はLispコミュニティにより初期のLisp方言の
機能を集約し、Lispの業界標準を作成するために開発されました。Common Lispは1994年に
\acronym{ANSI}標準(\link{ANSI 1994})になりました。
}



実験的であるという特徴と記号操作の重要性のため、Lispは初期においては数値演算に対し
少くともFortranとの比較にてとても非効率でした。しかし年を追って、プログラムを
機械語に変換し、数値演算を適度に効率良く実行可能なLispコンパイラが開発されました。
特別なアプリケーションに対してはLispは最高の効果を発揮しています。\footnote{
そのような特別なアプリケーションの1つは自然科学上の重大な計算、太陽系の動きの統合
におけるブレイクスルーでした。これは以前の結果より二桁も良く、太陽系の活動が混沌
であることを実演しました。この計算は全てLispで書かれたソフトウェアツールの手助け
により実装された新しい統合アルゴリズム、特定目的のコンパイラ、特定目的の計算機に
より可能となりました。(\link{Abelson et al. 1992}; \link{Sussman and Wisdom 1992})}
Lispは今でもどうしようもなく非効率であるという古い評判を乗り越えられてはいませんが、
Lispは今では多くのアプリケーションにて、効率が問題の中心ではない場合において
利用されています。例えばLispはOSのシェル言語やエディタの拡張言語、CADシステム等に
おいて選択言語となっています。



もしLispがメインストリームの言語でなければなぜ私達はプログラミングの議論のための
フレームワークとしてそれを用いるのでしょうか? なぜならこの言語は
重要なプログラミング構成概念とデータ構造を学ぶため、またそれらをサポートする
言語上の機能にそれらを関連付けするために、言語自身を洗練された媒体と成す個有の機能
を持っているためです。
これらの機能で最も著しい物は、Lispによる\newterm{procedures}(\jnewterm{手続})と
呼ばれるプロセスの記述が、それ自身がLispのデータとして表現され、また操作されることが可能
であるという事実です。これの重要性は、伝統的な``受動的な''データと``能動的な''
プロセスとの間の区別をぼかす能力に依存する、強力なプログラム設計のテクニックが存在する
ということです。私達がそれを発見するにつれ、手続をデータとして扱うLispの柔軟性は
Lispをこれらのテクニックを探求するのに、既存で最も便利な言語の1つとします。
手続をデータとして表現する能力はまた、Lispを他のプログラムをデータとして操作しなければ
ならないプログラムを書く目的に対し洗練された言語にします。例えばコンピュータ言語に
対応するインタプリタやコンパイラのようなプログラムです。これらの考慮点に加えて、
Lispによるプログラミングはとても楽しいのです。



\section{プログラミングの要素}
\label{Section 1.1}



強力なプログラミング言語はコンピュータにタスクの実行を指示するだけではありません。
そのような言語は私達がプロセスについての自らの考えを体系化するフレームワークとして
の役目を担います。従って言語を記述する時、簡単なアイデアを組み合わせてより複雑な
アイデアを形成するという手段をその言語が提供することには特に注意を払わねばなりません。
強力な言語全てがこれを達成するために３つのメカニズムを持っています。

\begin{itemize}

\item \textbf{プリミティブな式},
言語に関わる最も単純な要素を表現する

\item \textbf{合成化の手段},
これにより、より単純なものより複合要素が構築される

\item \textbf{抽象化の手段},
これにより複合要素は名前を付けて個体として扱える

\end{itemize}

\noindent
プログラミングにおいては２つの種類の要素を扱います。手続(procedure)とデータです。
（後でそれらはあまりはっきりとは区別できないことを明かします。）
簡単に説明するとデータは操作対象の``物''で手続はデータの操作のためのルールの
記述です。従って強力なプログラミング言語はどれもプリミティブ(原始的な、最低レベルの、組込の)なデータと
プリミティブな手続を記述可能でなければならず、また手続とデータを
合成化、抽象化する手法を持たなければなりません。

この章では単純な数値データのみを扱うことにより、手続構築のためのルールに
集中します。\footnote{数値を``単純なデータ''と特徴付けるのは公然なウソです。
実際に数値の扱いは任意のプログラミング言語において最も油断ならない、混乱を招く
要素です。いくつかの典型的な問題は次のものです。いくつかのコンピュータシステムは
2のような\newterm{integers}(\jnewterm{整数})と2.71のような\newterm{real numbers}(\jnewterm{実数})の区別をします。実数2.00は
整数2とは異なるでしょうか？ 整数に用いられる算術演算は実数に対する物と同じでしょ
うか？ 6を2で割ったら3? それとも3.0? どれだけ大きな数値を表示できますか? 精度は
小数何桁まで正しく表わされますか? 整数の範囲は実数の範囲と同じですか? もちろん
これらの質問の他にも丸めと切り捨てに関する誤差の問題の蓄積といった数値解析の科学全体が
存在します。この本のフォーカスは大規模なプログラム設計であり数値演算向けの
テクニックではないのでこれらの問題は無視することにします。この章の数値演算の
例では非整数演算において精度上正確な桁数に制限を持つ算術演算を用いる場合に
一般的な丸めの方法を示します。}後の章では同じこれらのルールにより複合データも
また構築できることを学びます。




\subsection{式}
\label{Section 1.1.1}

プログラミングを始める１つの簡単な方法はいくつかの典型的な対話を
Lispの方言であるSchemeのインタプリタを用いて試してみることです。コンピュータ
の端末の前に座っていると想像してみてください。あなたが\newterm{expression}(\jnewterm{式})を
入力するとインタプリタはその式の\newterm{evaluation}(\jnewterm{評価})の結果を表示することで
応答します。

あなたが入力するプリミティブな式の一種として数値があります。(より正確には
あなたが入力する式は10進数の数値を表す数字から成り立ちます。)
もし数値をLispに与えた場合、

\begin{scheme}
486
\end{scheme}

\noindent
インタプリタは以下を表示することで応答します。\footnote{この本を通して、ユーザの入力
とインタプリタが表示した応答を区別したい場合、傾いた文字で表します。}

\begin{scheme}
~\textit{486}~
\end{scheme}

\noindent
数値を表す式はプリミティブな手続を表す式(例えば\code{+} や \code{*})
と接続することで複合式を形成し、それら数値に対し手続を適用することを表現します。
例えば:

\begin{scheme}
(+ 137 349)
~\textit{486}~
\end{scheme}

\begin{scheme}
(- 1000 334)
~\textit{666}~
\end{scheme}

\begin{scheme}
(* 5 99)
~\textit{495}~
\end{scheme}

\begin{scheme}
(/ 10 5)
~\textit{2}~
\end{scheme}

\begin{scheme}
(+ 2.7 10)
~\textit{12.7}~
\end{scheme}

\noindent
これらのような式は括弧の中の式のリストを区切ることにより形成され手続の適用を示し、
\newterm{combinations}(\jnewterm{組み合わせ})と呼ばれます。リストの最も左の要素は\newterm{operator}(\jnewterm{オペレータ}、\jnewterm{演算子})と呼ばれ、
他の要素は\newterm{operand}(\jnewterm{オペランド}、被演算数)と呼ばれます。組み合わせの値はオペレータにより
与えられた手続をオペランドの値である\newterm{arguments}(\jnewterm{引数})に適用することで得られます。


オペレータをオペランドの左に置く決まりは\newterm{prefix notation}(\jnewterm{前置表記法})として
知られています。最初の内は数学の決まりから明らかに逸脱するので混乱するかもしれません。
しかし、前置表記法にはいくつかの利点が存在します。その1つは以下の例のように、
任意の数の引数を取る手続に適応できることです。

\begin{scheme}
(+ 21 35 12 7)
~\textit{75}~
\end{scheme}

\begin{scheme}
(* 25 4 12)
~\textit{1200}~
\end{scheme}

\noindent
曖昧さが全くありません。オペレータが常に最も左の要素であり、合成全体
は括弧で区切られているためです。



前置表記法の2つ目の利点は直接的な方法にて組み合わせを\textit{nested}(ネスト、入れ子)にすることが可能です。
つまり、組み合わせの要素それ自体が組み合わせである場合です。

\begin{scheme}
(+ (* 3 5) (- 10 6))
~\textit{19}~
\end{scheme}

\noindent
原理的にはそのようなネストの深さとLispインタプリタが評価可能な式全体の複雑さには
制限がありません。しかし私達人間は以下のような比較的単純な式でも混乱してしまいます。

\begin{scheme}
(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))
\end{scheme}

\noindent
インタプリタは直ちに57だと評価するでしょう。このような式を次のような形式で
記述することで私達自身を助けることが可能です。

\begin{scheme}
(+ (* 3
      (+ (* 2 4)
         (+ 3 5)))
   (+ (- 10 7)
      6))
\end{scheme}

\noindent
\newterm{pretty-printing}(\jnewterm{プリティプリント}、整形)として知られるフォーマットの決まりに個々の
長いオペランドを従わせることで、オペランドが垂直方向で位置合わせされます。
結果的に式の構造が明確にインデント(字下げ)されることになります。\footnote{典型的な
Lispシステムは式を整形しユーザを手助けするための機能を提供します。特に便利な
2つの機能において、1つは新しい行がどこで始まろうとも自動的に正しい整形位置に
インデントします。もう1つは右括弧が入力された時に対応する左括弧がハイライト
されます。}



例え複雑な式でもインタプリタは常に同じ基本的なサイクルにて処理を行います。
式を端末から読み、その式を評価し、結果を表示します。この操作モードはしばしば
インタプリタが\newterm{read-eval-print loop}(REPL:\jnewterm{レプル})で実行されていると
呼ばれます。特に明示的にインタプリタに式の値を表示しろと命令する必要がないこと
に注意して下さい。\footnote{Lispは各式が値を持つという決まりに従います。Lispが
非効率な言語であるという古い噂と共に、この決まりがAlan PerilsによるOscar Wilde
をもじった皮肉のネタ元になっています。曰く``Lispプログラマは全ての値を知っている
がそのコストはどれについても知らない''}


\subsection{名前付けと環境}
\label{Section 1.1.2}
プログラミング言語の重要な特徴は演算対象を参照するための名前を利用するために
それが提供する手段です。名前は\newterm{value}(\jnewterm{値})としてオブジェクトを持つ\newterm{variable}(\jnewterm{変数})を
識別します。


Lispの方言Schemeでは対象に\code{define}(定義)を用いて名前を付けます。
以下のように入力すると

\begin{scheme}
(define size 2)
\end{scheme}

\noindent
インタプリタは名前\code{size}と値2を関連付けます。\footnote{この本ではインタプリタの
定義に対する評価の応答を表示しません。とても実装依存であるためです。}
一度名前\code{size}が数値2に関連付けられれば値2を名前で参照することが可能です。

\begin{scheme}
size
~\textit{2}~
\end{scheme}

\begin{scheme}
(* 5 size)
~\textit{10}~
\end{scheme}

\noindent
より多くの\code{define}の使用例を見ましょう。

\begin{scheme}
(define pi 3.14159)
(define radius 10)
(* pi (* radius radius))
~\textit{314.159}~
(define circumference (* 2 pi radius))
circumference
~\textit{62.8318}~
\end{scheme}

\noindent
\code{define}は言語の最も単純な抽象化の手段です。簡単な名前を使用して合成命令の
結果を参照することを可能にします。例えば上の例で計算した\code{circumference}(円周)
です。一般的に演算対象はとても複雑な構造を持ち、それを覚えて使用時に詳細を
繰り返し記述することはとても面倒です。実際に、複雑なプログラムは少しづつ
複雑さを増していく演算対象を1つづつ構築して組み立てられます。インタプリタは
このプログラム組立の各ステップに特に便利です。なぜなら名前とオブジェクトの
関連性が連続した対話を通して少しづつ作成可能なためです。この機能は
漸進的開発とプログラムのテストを促進し、Lispプログラムが通常数多くの比較的
単純な手続により構成される理由です。



値に記号を関連付け、後にそれらを取り出すことがあるのは、インタプリタが名前と
オブジェクトのペアを追跡するためのある種のメモリを持たなければいけないことを
意味することは明白でしょう。このメモリは\newterm{environment}(\jnewterm{環境})と呼ばれます。(より正確
には\newterm{global environment}(\jnewterm{グローバル環境}、大域環境)、演算には複数の異なる環境が利用され
ることを後に学ぶため)\footnote{\link{Chapter 3}にてこの環境という
概念がインタプリタがどのように働くか、またどのようにインタプリタを実装するかに
おいて重要であることを示します。}


\subsection{組み合わせの評価}
\label{Section 1.1.3}
この章の目標の1つは手続的な思考上の問題を分離することです。
代表例として、組み合わせの評価においてインタプリタはそれ自身が手続に従うことを
考えてみましょう。

\begin{quote}
組み合わせを評価するため、以下を行います

\begin{enumerate}

\item
組み合わせの部分式を評価する

\item
最も左の部分式(オペレータ)の値である手続を他の部分式の値である引数(オペランド)
に対し適用する

\end{enumerate}
\end{quote}

\noindent
この単純なルールでさえ、一般的な過程におけるいくつかの重要な点を示します。
最初に第一のステップが組み合わせの評価過程を達成すためには先に組み合わせの各要素の
評価過程の実行を行う必要があります。従って評価ルールは事実上
\newterm{recursive}(\jnewterm{再帰})的です。つまり評価ルールの1ステップとしてそれ自身を
実行する必要性があります。\footnote{評価ルールが第一のステップの部分として
組み合わせの最も左の要素を評価しなければいけないというのは奇妙に写るかもしれませ
ん。この時点ではそれは\code{+}や\code{*}が表す足し算やかけ算のような組込の
プリミティブな手続でしかないためです。後に組み合わせのオペレータそのものが組み合わせ
である場合を扱えることが便利であることを学びます。}



再帰の考えがいかに簡潔に、深くネストした複合式を表現できるかに注目してください。
再帰でなければとても複雑な経過に見えてしまうでしょう。例えば以下の式を評価して
みます。

\begin{scheme}
(* (+ 2 (* 4 6))
   (+ 3 5 7))
\end{scheme}

\noindent
この式は評価ルールが4つの異なる組み合わせに適用される必要があります。この過程を
式の組立を木形式にて表現することで図解することが可能です。\link{Figure 1.1}を
ご覧下さい。各組み合わせは枝の付いたノードで表され、枝にはオペレータと別の組み合わせ
への茎となるオペランドが付いています。終端ノード(他のノードへのと続く枝の無い物)
はオペレータか数値を表しています。評価を木の用語で表すと、オペランドの値は
上へと流れていくことが想像できます。終端ノードから始まり上のレベル、さらに上のレベルにて
合成されます。一般的に、再帰は階層的な木のような対象を扱うのにとても強力な技術
です。実際に評価ルールの``値を情報に流す''形式は\newterm{tree accumulation}
(\jnewterm{集積木})として知られます。


\begin{figure}[tb]
\phantomsection\label{Figure 1.1}
\centering
\begin{comment}
\heading{Figure 1.1:} Tree representation, showing the value of each subcombination.

\begin{example}
   390
   /|\____________
  / |             \
 *  26            15
    /|\           /|\
   / | \         // \\
  +  2  24      / | | \
        /|\    +  3 5  7
       / | \
      *  4  6
\end{example}
\end{comment}
\includegraphics[width=31mm]{fig/chap1/Fig1.1g.pdf}
\begin{quote}
\heading{Figure 1.1:} 部分的組合せの値を示す木表現
\end{quote}
\end{figure}

\noindent
次に第一ステップの適用の繰り返しが、組み合わせでなく、プリミティブ
な式、例えば数値や組込オペレータ、その他の名前を評価することが必要となる点へと
導くことに注目して下さい。
以下を規定することにより、プリミティブな場合を取り扱います。

\begin{itemize}

\item
数字の値はそれが意味する値です

\item
組込オペレータの値は機械語の列であり対応する操作を実行します。

\item
その他の名前の値は現在の環境にてその名前に対応するオブジェクトです。

\end{itemize}

\noindent
2つ目のルールは
\code{+}と\code{*}のような記号もまたグローバル(大域)環境に含まれており、それらの``値''として
一連の機械語命令に関係付けられていると規定することにより、3番目のルールの特別な場合
であると見做すことができます。
注意すべき
鍵となる点は式の中の記号の意味の決定に環境が果たす役割です。Lispのような
インタラクティブな言語では\code{(+ x 1)}のような式の値について記号\code{x}
(またはの\code{+}のような記号についてさえ)意味を与える環境の説明無しに話すことは
無意味です。\link{Chapter 3}にて学びますが、評価が行われる文脈を提供する環境の
一般的概念は我々がプログラムの実行を理解する上で重要な役割を果たします。

上で与えられた評価ルールが定義を扱わないことにも注意して下さい。
例えば\code{(define x 3)}の評価は\code{define}を2つの引数、シンボル\code{x}の値と3に
適用しません。\code{define}の目的はまさに\code{x}に対する値の関連付けだからです。
(つまり\code{(define x 3)}は合成式ではありません。)

そのような一般的な評価ルールに対する例外は\jnewterm{特殊形式}と呼ばれます。
\code{define}は特殊形式の一例に過ぎません。すぐに他の例に出会うことになります。
特殊形式は全てそれ自身の評価ルールを持ちます。色々な種類の式(それぞれが
関連する評価ルールを持つ)はプログラミング言語の構文を構成します。
他の多くのプログラミング言語と比較してLispはとても簡単な構文を持ちます。
式の評価ルールは簡単な一般ルールと少しの特殊形式にて説明可能です。
\footnote{事物をより統一的な方法で表記可能な、簡単で便利な代替的表面構造である
特別な構文形式を、Peter Landinの作成した語句ですが、\newterm{syntactic sugar}
(シンタックスシュガー、\jnewterm{糖衣構文})と呼ぶ場合があります。他言語のユーザと比較して
Lispプログラマは一般に構文上の問題に気をつかいません。(Pascalのマニュアルを調査
するとどれだけ多くのページが構文の記述に割り当てられているのかに気付くのとは逆
です。)この構文の軽視はLispの柔軟性の理由の一部になります。Lispの柔軟性
は表面上の構文の変更を簡単にします。また多くの``便利な''構文の構築を見かける
理由にも繋ります。それらの構文は言語をあまり統一的でないものにし、プログラムが
巨大で複雑になるにつれ元の価値よりも多くの問題を起こすことになります。Alan Peril
曰く、``糖衣構文はセミコロンの癌を引き起こす''}



\subsection{複合手続}
\label{Section 1.1.4}
他の強力なプログラミング言語に必ず存在する要素をいくつかLispでも確認しました。

\begin{itemize}

\item
数値と算術命令はプリミティブなデータと手続です。

\item
組み合わせのネストは演算の結合手法を提供します。

\item
名前と値を関連付けする定義は抽象化の限定された手法を与えます。

\end{itemize}

\noindent
ここでは\newterm{procedure definitions}(\jnewterm{手続の定義})を学びます。より強力な抽象化のテクニックであり
組み立てられた操作に名前を与え、1つの単位としてアクセス可能にします。


``二乗の値''をどのように表現するかから始めましょう。``二乗の値を求めるためには
その値をその値自身にかける''と言えるでしょう。

\begin{scheme}
(define (square x) (* x x))
\end{scheme}

\noindent
これを以下のように理解することが可能です。

\begin{example}
(define (square    x)         (*      x         x))
  |        |       |           |      |         |
 定義    二乗する  xを       かける  xを       xで.
\end{example}

\noindent
ここで\code{square}と名付けられた\newterm{compound procedure}(\jnewterm{複合手続})が出てきました。この手続はある数値を
それ自身にてかけ算することを表しています。かけられる数には\code{x}という名前が
付けられており代名詞が自然言語にて果たすのと同じ役割を果たします。
この定義の評価はこの複合手続を作成し、私達はそれに\code{square}という名前を
与えています。\footnote{ここでは次の2つを区別できるようになることが本当に重要だと言え
ます。1つは手続を名前を付けずに作成すること、もう1つは既に作成された手続に
名前を付けることです。どのように行うかについては\link{Section 1.3.2}にて学びます。}


一般的な手続の定義形式は以下の通りです。

\begin{scheme}
(define (~\( \dark \langle\kern0.08em \)~~\var{\dark name}~~\( \dark \kern0.03em\rangle \)~ ~\( \dark \langle \)~~\var{\dark formal parameters}~~\( \dark \kern0.02em\rangle \)~) 
  ~\( \dark \langle\kern0.08em \)~~\var{\dark body}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
\( \langle\hbox{\sl name}\kern0.08em\rangle \)はその環境における手続定義に関連付けられる記号です。
\footnote{この本では一般的な式の構文をかぎ括弧にて閉じたイタリックの記号
---例えば、 \( \langle \)\var{name}\( \kern0.08em\rangle \)---を用いて実際に
式が利用される時に埋められるべき式中の``枠''を示します。}
\( \langle\hbox{\sl formal parameters}\kern0.08em\rangle \)は手続の中で
利用される名前で手続の関連する引数を参照します。
\( \langle\hbox{\sl body}\kern0.08em\rangle \)は形式上のパラメータが、
適用される手続の実際の引数に置換される時、手続適用の値を返す式です。
\footnote{より実際には、手続のボディは連続する式です。この場合インタプリタは
連続する各式を順に評価し最後の式の値を手続適用全体の値として返します。}
\( \langle \)\var{name}\( \kern0.08em\rangle \)と
\( \langle \)\var{formal parameters}\( \kern0.08em\rangle \)は括弧を用いて
グループ化され、実際の手続呼出しのように定義されます。


\code{square}を定義したので使ってみましょう。

\begin{scheme}
(square 21)
~\textit{441}~
(square (+ 2 5))
~\textit{49}~
(square (square 3))
~\textit{81}~
\end{scheme}

\noindent
\code{square}を構築要素として他の手続の構築に用いることも可能です。
例えば、 \( x^2 + y^2 \)は次のように表現できます。

\begin{scheme}
(+ (square x) (square y))
\end{scheme}

\noindent
2つの数値を引数として取りそれらの二乗の和を求める\code{sum\-/of\-/squares}を定義する
ことも簡単です。

\begin{scheme}
(define (sum-of-squares x y)
  (+ (square x) (square y)))
(sum-of-squares 3 4)
~\textit{25}~
\end{scheme}

\noindent
\code{sum\-/of\-/squares}をさらに別の手続構築に利用することもできます。

\begin{scheme}
(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))
(f 5)
~\textit{136}~
\end{scheme}

\noindent
複合手続はプリミティブな手続と全く同じように利用可能です。
実際に上の\code{sum\-/of\-/squares}の定義を見ても\code{square}が\code{+} や \code{*}のように
インタプリタに組込まれているのか、複合手続として定義されているのか見分けがつか
ないでしょう。


\subsection{手続適用の置換モデル}
\label{Section 1.1.5}
オペレータの名前が合成式を示す組合せを評価する時、 インタプリタは
\link{Section 1.1.3}で説明した組合せのオペレータがプリミティブである場合と
ほぼ同じ手順を追います。インタプリタは合成の各要素を評価し、
(組合せのオペレータの値である)手続を(組合せのオペランドである)
引数に対して適用します。




プリミティブな手続を引数に対して適用するメカニズムはインタプリタに組込まれている
ことが想像できます。複合手続に対しては適用プロセスは以下のようになります。

\begin{quote}
複合手続を引数に適用するために、手続のボディを、各形式パラメタを対応する引数にて
置換してから評価します。
\end{quote}


\noindent
過程を説明するために以下のコンビネーションを評価してみましょう。

\begin{scheme}
(f 5)
\end{scheme}

\noindent
\code{f}は\link{Section 1.1.4}にて定義された手続です。 \code{f}のボディを取得することから始めます。

\begin{scheme}
(sum-of-squares (+ a 1) (* a 2))
\end{scheme}

\noindent
次に形式パラメタの\code{a}を引数5で置き換えます。

\begin{scheme}
(sum-of-squares (+ 5 1) (* 5 2))
\end{scheme}

\noindent
従って問題は2つのオペランドとオペレータ\code{sum\-/of\-/squares}に換算されます。
この組み合わせの評価は3つの部分問題に分かれます。まずオペレータを
評価して適用する手続を得て、オペランドを評価して引数を得る必要があります。
さて\code{(+ 5 1)}は6になり、\code{(* 5 2)}は10になりますので\code{sum\-/of\-/squares}手続
を6と10に適用しなければなりません。これらの値は\code{sum\-/of\-/squares}のボディの
パラメタ\code{x}と\code{y}を置き換え、式は以下のように置換されます。

\begin{scheme}
(+ (square 6) (square 10))
\end{scheme}

\noindent
\code{square}の定義を用いるとこれはさらに以下のように置換されます。

\begin{scheme}
(+ (* 6 6) (* 10 10))
\end{scheme}

\noindent
乗算を置換することで以下になります。

\begin{scheme}
(+ 36 100)
\end{scheme}

\noindent
最終的には次のとおりです。

\begin{scheme}
136
\end{scheme}

\noindent
ここまで説明したプロセスは手続適用の\newterm{substitution model}(\jnewterm{置換モデル}、代入モデル)
と呼ばれます。この章にて扱われた手続の過程においては、
手続適用の``意味''を決定するモデルとして捉えることができます。
しかし、強調すべき2つの事があります。

\begin{itemize}

\item
置換の目的は私達が手続適用について考えることを手助けすることであり、
インタプリタが実際にどのように働くかの説明を与えることではありません。
典型的なインタプリタは形式パラメータのための値を置き換えるために手続のテキストを
操作することで、手続適用を評価することはしません。実際には``置換''は形式パラメタに
ローカルの環境を用いることで行われます。このことについてはより完全に\link{Chapter 3}
と\link{Chapter 4}にてインタプリタの実装の詳細について調査する時に議論します。

\item
この本のコース全体ではインタプリタがどのように働くかについて、一連の徐々に
精巧なモデルを紹介して行きます。最終的にはインタプリタとコンパイラの完全な実装
を\link{Chapter 5}で見せます。置換モデルはこれらのモデル
の最初---評価手続について正式な考え得るための始まりに過ぎません。
一般的に科学とエンジニアリングについての事象をモデリングする場合、単純化した
不完全なモデルから始めます。より詳細な調査を行うにつれ、これらの単純なモデルは
不適切になり、より正確なモデルにて置き換えられます。置換モデルもまた例外ではあり
ません。実際に \link{Chapter 3}で示しますが手続を``mutable(変わりやすい)データ''
と共に扱う場合に置換モデルは破綻し、より複雑な手続適用のモデルにより置き換えなけ
ればならなくなります。
\footnote{置換のアイデアの簡明性にもかかわらず、置換処理の厳密な数学上の定義を
与えることは驚くほど複雑になることが知られています。問題は手続の形式パラメタの名前と
手続が適用される式で利用されている(同じである可能性のある)名前の間の混乱の可能性から生じます。
実際に論理とプログラミング意味論の文献における\jnewterm{置換}の間違った定義には
長い歴史があります。\link{Stoy 1977}の置換に関する注意深い議論を参照下さい。}

\end{itemize}

\subsubsection*{適用順~対~正規順}
\link{Section 1.1.3}で与えられた評価の記述に従えば、インタプリタは最初にオペレータとオペランド
を評価し、次に結果の手続を結果の引数に適用します。評価の仕方はこれだけでは
ありません。代替としての評価モデルはオペランドをそれらの値が必要になるまで
評価しません。その代わりに最初はオペランドの式にそれがプリミティブなオペレータ
のみ持つまでパラメタで置換します。それから評価を実行します。この手法を用いた
場合、\code{(f 5)}の評価は展開の流れに従って進行します。

\begin{scheme}
(sum-of-squares (+ 5 1) (* 5 2))
(+   (square (+ 5 1))      (square (* 5 2))  )
(+   (* (+ 5 1) (+ 5 1))   (* (* 5 2) (* 5 2)))
\end{scheme}

\noindent
簡約が続きます。


\begin{scheme}
(+      (* 6 6)      (* 10 10))
(+         36           100)
                136
\end{scheme}

\noindent
今回も前回の評価モデルと同じ答になりました。しかし経過が異なります。
具体的には\code{(+ 5 1)}と\code{(* 5 2)}がここではそれぞれ二回づつ実行されます。
式\code{(* x x)}における\code{x}がそれぞれ \code{(+ 5 1)}と\code{(* 5 2)}に置き換えることで
換算されているのに相当していています。




この代替である``完全に展開してから簡約する''評価方法は\jnewterm{正規順序評価}
として知られています。一方、``引数を評価してから適用''する方法はインタプリタ
が実際に利用するもので\jnewterm{適用順序評価}と呼ばれます。、
(この本の最初の2つの章の手続全てを含めて)置換を使用してモデリング可能、かつ正当な値を生む手続適用において
正規順序と適用順序の評価は同じ値を生むことが見てとれるでしょう。
(正規順序と適用順序の評価が同じ値を返さない``不当な''値の例は\link{Exercise 1.5}をご覧下さい)




Lispは適用順序評価を用いています。理由の一部は上の\code{(+ 5 1)} と \code{(* 5 2)}で
示されたような式の複数回評価を避けることで付加的な効率を得るためです。
そしてより重要な理由は正規順序評価は置換によりモデル化可能な手続の範囲を離れる時の
取扱がとても複雑なためです。一方で、正規順序評価はとても価値のあるツールです。
その意味のいくらかを\link{Chapter 3} と \link{Chapter 4}にて調査します。
\footnote{\link{Chapter 3}では\code{stream processing}(ストリーム処理)を紹介します。これは
一見して``無限''のデータ構造を正規順評価の制約形式に立脚して取り扱う手法です。
\link{Section 4.2}ではSchemeインタプリタを変更しSchemeの正規順異種を作成します。}


\subsection{条件式と述語}
\label{Section 1.1.6}

この時点で私達が定義可能な種類の手続の表現力はとても限られています。テストを作成し、
テストの結果により異なる命令を実行する方法が無いためです。例えば数値の絶対値を
演算する手続を定義できません。数値が正、負、零であるかテストを行いルールに従い
異なる場合に対し異なる行動をしなければなりません。

\begin{comment}

\begin{example}
      /
      |   x  if x > 0
|x| = <   0  if x = 0
      |  -x  if x < 0
      \
\end{example}

\end{comment}
\begin{displaymath}
 |x| = \left\{ \begin{array}{r@{\quad \mathrm{if} \quad}l}	 	 
        x  &  x > 0, \\
	0  &  x = 0, \\
  \!\! -x  &  x < 0. \end{array} \right. 
\end{displaymath}

この考えは\newterm{case analysis}(ケース分析、\jnewterm{事例分析})と呼びLispにはそのようなケース分析の
ための特殊形式が存在します。\code{cond}(``conditional''(条件文)を表わす)と呼ばれ、
以下のように利用されます。

\begin{scheme}
(define (abs x)
  (cond ((> x 0) x)
        ((= x 0) 0)
        ((< x 0) (- x))))
\end{scheme}

\noindent
条件式の一般的な形式は以下のとおりです。

\begin{scheme}
(cond (~\( \dark \langle{p_1}\kern0.08em\rangle \)~ ~\( \dark \langle{e_1}\kern0.08em\rangle \)~)
      (~\( \dark \langle{p_2}\kern0.08em\rangle \)~ ~\( \dark \langle{e_2}\kern0.08em\rangle \)~)
      ~\( \dots \)~
      (~\( \dark \langle{p_n}\kern0.08em\rangle \)~ ~\( \dark \langle{e_n}\kern0.08em\rangle \)~))
\end{scheme}

\noindent
記号\code{cond}から構成され、続く括弧で括った複数の式のペア

\begin{scheme}
(~\( \dark \langle{p}\kern0.08em\rangle \)~ ~\( \dark \langle{e}\kern0.08em\rangle \)~)
\end{scheme}

\noindent
\newterm{clauses}(\jnewterm{クローズ}、節)と呼ばれます。各ペアの最初の式は\newterm{predicate}(\jnewterm{述語})
---値が真か偽になる式です。
\footnote{``真か偽のどちかに解釈される''とは次を意味します。Schemeでは2つの区別される
値が存在し、それらは \code{\#t} と \code{\#f}の定数で示されます。インタプリタが述語の値をチェック
する時、\code{\#f}を偽と訳します。それ以外の任意の値は全て真だと扱われます。(従って
\code{\#t}を与えることは論理的には必要ありません。しかしそのほうが便利です。)
この本では\code{true} と \code{false}という名前を用います。それらは\code{\#t} と \code{\#f}という値に
それぞれ関連付けられます。}


条件式は次のように評価されます。まず述語\( \langle{p_1}\kern0.08em\rangle \)が最初に評価されます。
もしその値が偽であれば次に\( \langle{p_2}\kern0.08em\rangle \)が評価されます。もし\( \langle{p_2}\kern0.08em\rangle \)
の値もまた偽であるならば、その次は\( \langle{p_3}\kern0.08em\rangle \)が評価されます。
この過程は値が真となる述語が見つかるまで続きます。その場合インタプリタは対応するクローズの
\newterm{consequent expression}(\jnewterm{結果式}) \( \langle{e}\kern0.08em\rangle \)の値が条件式の値として返されます。
もし真となる\( \langle{p}\kern0.08em\rangle \)が見つからない場合には\code{cond}の値は未定義です。



述語という単語は真か偽を返す手続に利用されます。真か偽と評価される式にも用いられます。
絶対値の手続\code{abs}はプリミティブな述語\code{>}, \code{<}, \code{=}を利用します。
\footnote{\code{abs}はまた``マイナス''演算子\code{-}を使用します。
\code{(- x)}のように単一のオペランドに利用された時、符号の反転を示します。}

これらは2つの数値を引数として取り最初の数が2つ目の数に対し式の順に、より大きい、より小さい、等しい
かどうかテストを行い適宜に真か偽を返します。


絶対値の手続を書くもう1つの方法が次です。

\begin{scheme}
(define (abs x)
  (cond ((< x 0) (- x))
        (else x)))
\end{scheme}

\noindent
これは日本語で``もし\( x \)が零より小さい場合\( -x \)を返す。そうでなければ\( x \)を返す''と
表現できます。\code{else}は特別なシンボルで\code{cond}の最後の節(クローズ)の\( \langle{p}\kern0.08em\rangle \)
の場所にて利用可能です。こうすることで\code{cond}がその値として対応する\( \langle{e}\kern0.08em\rangle \)
の値をそれ以前のクローズ全てが回避された場合に返すことが可能です。
本当の所はここで\( \langle{p}\kern0.08em\rangle \)に常に値が真となる任意の式を使用することも可能です。


次はさらにもう1つ別の絶対値手続の書き方です。

\begin{scheme}
(define (abs x)
  (if (< x 0)
      (- x)
      x))
\end{scheme}

\noindent
これは特殊形式の\code{if}という制約のある条件の型を使用しており、ケース分析にて正確に2つのケースが存在する場合に用います。
\code{if}式の一般的な形式は以下のとおりです。



\begin{scheme}
(if ~\( \dark \langle\kern0.07em \)~~\var{\dark predicate}~~\( \dark \kern0.06em\rangle \)~ ~\( \dark \langle\kern0.07em \)~~\var{\dark consequent}~~\( \dark \kern0.05em\rangle \)~ ~\( \dark \langle\kern0.06em \)~~\var{\dark alternative}~~\( \dark \kern0.06em\rangle \)~)
\end{scheme}

\noindent
\code{if}式を評価するためにインタプリタは式の\( \langle \)\var{predicate}\( \kern0.08em\rangle \)の部分を評価すること
から始めます。もし\( \langle \)\var{predicate}\( \kern0.08em\rangle \)の評価が真値になる場合、インタプリタは次に
\( \langle \)\var{consequent}\( \kern0.08em\rangle \)を評価しその値を返します。そうでなければ
\( \langle \)\var{alternative}\( \kern0.08em\rangle \)を評価しその値を返します。
\footnote{\code{if} と \code{cond}の小さな違いは\code{cond}の各クローズの\( \langle{e}\kern0.08em\rangle \)は連続する式になっても
良いことです。もし対応する\( \langle{p}\kern0.08em\rangle \)が真になる場合、\( \langle{e}\kern0.08em\rangle \)内の式は
順に評価され連なりの最後の式の値が\code{cond}の値として返されます。しかし\code{if}式の中では
\( \langle \)\var{consequent}\( \kern0.08em\rangle \)と\( \langle \)\var{alternative}\( \kern0.08em\rangle \)
は単一の式でなければなりません}



\code{<}や\code{=}, \code{>}のようなプリミティブな述語に追加して論理複合命令が存在し、複合述語を構築することを可能にします。
最も良く利用される3つは以下の物です。

\begin{itemize}

\item
\( \hbox{\tt(and }\langle{e_1}\rangle\;\;\dots\;\;\langle{e_n}\rangle\hbox{\tt)} \)

インタプリタは式\( \langle{e}\kern0.08em\rangle \)を左から右へ1つずつ評価します。もし\( \langle{e}\kern0.08em\rangle \)の
どれかが偽と評価された場合\code{and}式の値は偽となり、残りの\( \langle{e}\kern0.08em\rangle \)は評価されません。
もし全ての\( \langle{e}\kern0.08em\rangle \)の評価が真となれば\code{and}式の値は最後の値になります。

\item
\( \hbox{\tt(or }\langle{e_1}\rangle\;\;\dots\;\;\langle{e_n}\rangle\hbox{\tt)} \)

インタプリタは式 \( \langle{e}\kern0.08em\rangle \)を1つずつ左から右へ評価します。
もし\( \langle{e}\kern0.08em\rangle \)のどれかが真と評価されればその値が\code{or}式の値として返され、
\( \langle{e}\kern0.08em\rangle \)の残りは評価されません。
もし全ての\( \langle{e}\kern0.08em\rangle \)が偽と評価された場合、\code{or}の値は偽となります。

\item
\( \hbox{\tt(not }\langle{e}\rangle\hbox{\tt)} \)

\code{not}式の値は式\( \langle{e}\kern0.08em\rangle \)が偽と評価される時は真であり、そうでなければ偽となります。

\end{itemize}

\noindent
\code{and}と\code{or}が特殊形式であり手続ではないことに注意して下さい。
部分式が全て評価される必要が無いためです。
\code{not}は通常の手続です。

これらがどのように利用されるかの例として、数値\( x \)が\( 5 < x < 10 \)の値域に存在するかという条件は
次のように表現されます。

\begin{scheme}
(and (> x 5) (< x 10))
\end{scheme}

\noindent
別の例として、ある数値が別の数値に対し等しいかより大きいかを示す述語は以下の通りです。

\begin{scheme}
(define (>= x y) (or (> x y) (= x y)))
\end{scheme}

\noindent
または代替法として

\begin{scheme}
(define (>= x y) (not (< x y)))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.1}Exercise 1.1:} 以下の一連の式について、
各式に対するインタプリタの応答としての表示結果は何か?
式の列は下記に表示された順で評価されるものと考えよ。

\begin{scheme}
10
(+ 5 3 4)
(- 9 1)
(/ 6 2)
(+ (* 2 4) (- 4 6))
(define a 3)
(define b (+ a 1))
(+ a b (* a b))
(= a b)
(if (and (> b a) (< b (* a b)))
    b
    a)
\end{scheme}

\begin{scheme}
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
\end{scheme}

\begin{scheme}
(+ 2 (if (> b a) b a))
\end{scheme}

\begin{scheme}
(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
   (+ a 1))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.2}Exercise 1.2:} 以下の式を接頭辞形式にて翻訳せよ
\begin{comment}

\begin{example}
5 + 4 + (2 - (3 - (6 + 4/5)))
-----------------------------
       3(6 - 2)(2 - 7)
\end{example}

\end{comment}
\begin{displaymath}
{5 + 4 + (2 - (3 - (6 + {4\over5})))\over3(6 - 2)(2 - 7)}\,.
\end{displaymath}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.3}Exercise 1.3:} 3つの数値を引数として取り、
内2つの大きな数値の二乗の和を返す手続を定義せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.4}Exercise 1.4:} 我々の評価モデルが
オペレータが複合式である組み合わせを可能にすることを観察せよ。
この観察結果を用いて次の手続の挙動を説明せよ:


\begin{scheme}
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.5}Exercise 1.5:} Ben Bitdiddleは自分が
直面するインタプリタが適用順評価と正規順評価のどちらを用いるか
決定するテストを開発した。まず以下の2つの手続を定義する。

\begin{scheme}
(define (p) (p))
(define (test x y)
  (if (= x 0) 0 y))
\end{scheme}



次に以下の式を評価する。

\begin{scheme}
(test 0 (p))
\end{scheme}



Benは適用順評価を用いるインタプリタではどのような挙動を観察するだろうか?
Benは正規順評価を用いるインタプリタではどのような挙動を観察するだろうか?
あなたの回答を説明せよ。(特殊形式の\code{if}はインタプリタが適用順評価でも正規順評価でも
同じ挙動を行うと仮定せよ: 述語式が最初に評価され、結果がconsequentとalternativeのどちらを評価するか決定する)


\end{quote}

\subsection{例: ニュートン法による平方根}
\label{Section 1.1.7}


ここまでで説明された通り、手続は普通の数学の関数にとても似ています。
手続は1つ以上のパラメタにより決定される値を特定します。しかし数学の関数と計算機の
手続の間には重要な違いが存在します。手続は効果的である必要があります。



その一例として、平方根の演算問題について考えましょう。
square-root関数を以下のように定義できます。

\begin{comment}

\begin{example}
sqrt(x) = the y such that y >= 0 and y^2 = x
\end{example}

\end{comment}
\begin{displaymath}
\sqrt{x}\;\; = {\rm\;\; the\;\;} y 
{\rm\;\; such\;\; that\;\;} y \ge 0 {\rm\;\; and\;\;} y^2 = x.
\end{displaymath}


これは完全に正しい数学の関数です。これを用いてある数値が他の数値の平方根であるか
分かりますし、平方根の一般的な事実を導出可能です。しかし一方でこの定義は手続の
記述ではありません。与えられた数値から実際どのようにして平方根を求めるのか、
これはほとんど何も教えてくれません。この定義を疑似Lispにて言い換えようとも
問題の何の手助けにもなりません。

\begin{scheme}
(define (sqrt x)
  (the y (and (>= y 0) 
              (= (square y) x))))
\end{scheme}

\noindent
これはただ問題を提起するだけです。



関数と手続の間の対称性は事物の属性の説明と行いの説明との間の一般的区別に関する
反映です。または時には宣言的知識と手続的知識の間の区別だと参照できるでしょう。
数学では通常宣言的(what is)記述を用い、コンピュータサイエンスでは通常手続的
(how to)記述を用います。\footnote{宣言的、手続的記述は数学とコンピュータサイエンスの
ように実際に深く関わっています。例えばプログラムの生成した答が``正しい''という
ことはプログラムについて宣言的な文を作成することです。プログラムが正しいことを
証明するための立証技術を目的とした非常に多くの研究が存在します。この問題の技術的
難度の多くは(プログラムが構築される)手続的文と(事象を推論するのに用いられる)
宣言的文との間の移行に関連します。関連領域において、プログラミング言語の設計に
おける現在の重要な領域は超高水準言語と呼ばれる物の調査です。それは実際に
プログラムを宣言的文の用語にて作成します。その意図はインタプリタを十分に洗練する
ことでプログラマより与えられた``what is''の知識より``how to''の知識を自動的に
生成可能とします。これは一般的には可能ではありませんが、成果が達成された
重要な領域が存在します。この考え方については\link{Chapter 4}にて再度触れることに
致します。}



人はどのようにして平方根を求めることができるのでしょうか? 最も一般的な方法は
ニュートンの漸次接近法を用いる方法です。ニュートン法はある数値\( x \)の平方根
の推定値として\( y \)を持つ場合に、より良い推定値(実際の平方根により近い値)を
求めるために\( y \)と\( x / y \)の平均を取るという簡単な操作を実行します。
\footnote{この平方根アルゴリズムは実際にはニュートン法の特別なケースです。
ニュートン法は方程式の根を求める一般的な技法です。平方根アルゴリズム自体は
アレキサンドリアのHeronにより\acronym{A.D.}1世紀に開発されました。一般的な
ニュートン法をLispの手続によりどのように表わすかについては\link{Section 1.3.4}にて
学びます。}
例として、2の平方根は以下のようにして求められます。
推定値の初期値を1とします:

\begin{smallexample}
推定値    商                     平均
1         (2/1) = 2              ((2 + 1)/2) = 1.5
1.5       (2/1.5) = 1.3333       ((1.3333 + 1.5)/2) = 1.4167
1.4167    (2/1.4167) = 1.4118    ((1.4167 + 1.4118)/2) = 1.4142
1.4142    ...                    ...
\end{smallexample}

\noindent
この過程を繰り返すことにより平方根のより良い近似値を得られます。



では手続の表現にてこの過程を形式化してみましょう。radicand(被開法数: 根号の中身。平方根を求める値)と
guess(推定値)を用います。もし推定値の品質が十分であれば終了します。そうでなければ
処理をより良い推定値にて繰り返さなければなりません。この基本的戦略を手続として
以下のように記述しました。

\begin{scheme}
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))
\end{scheme}

\noindent
推定値は旧推定値と商の平均を取ることで改善されます。

\begin{scheme}
(define (improve guess x)
  (average guess (/ x guess)))
\end{scheme}

\noindent
averageの定義は以下です。

\begin{scheme}
(define (average x y)
  (/ (+ x y) 2))
\end{scheme}

\noindent
``十分に良い''の定義を決めねばなりません。以下に説明しますが、これは本当はあまり良い
テストではありません。(\link{Exercise 1.7}をご覧下さい)
考え方は回答を十分に近い値にするために、その二乗と被開法数の差が事前に決定した
許容誤差(ここでは0.001)より小さくなるまで改善します。
\footnote{通常は述語にはクエスチョンマークで終わる名前を与えます。そうすることで
それが述語だと理解できるようにです。これは単にスタイル上の慣例です。インタプリタの
受け取り方に関する限り、クエスチョンマークは通常の文字でしかありません。}


\begin{scheme}
(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))
\end{scheme}

\noindent
最後にどのように始めるかが必要です。例えば任意の数値の平方根の推定値を常に1とすることも
可能です。\footnote{推定値の初期値を1ではなく1.0と表現していることに注意して下さい。
これは多くのLispの実装では何の違いもありません。しかし\acronym{MIT} Schemeは
整数と小数の値を厳格に区別します。2つの整数を割ると小数ではなく分数を返します。
例として10を6で割ると5/3を返します。しかし10.0を6.0で割れば1.6666666666666667を返すのです。
(分数の演算の実装法については\link{Section 2.1.1}で学びます。)
もし推定値の初期値をsquare-rootプログラムにおいて1にして開始した場合、\( x \)も
実際に整数である場合には全ての続くsquare-rootの演算により生成される値は小数ではなく分数
になります。分数と小数を混ぜた演算は小数を返します。従って推定値の初期値を1.0にすることで
全ての続く値を小数にすることが可能です。}

\begin{scheme}
(define (sqrt x)
  (sqrt-iter 1.0 x))
\end{scheme}

\noindent
この定義をインタプリタに入力すれば\code{sqrt}を他の手続のように利用可能です。

\begin{scheme}
(sqrt 9)
~\textit{3.00009155413138}~

(sqrt (+ 100 37))
~\textit{11.704699917758145}~

(sqrt (+ (sqrt 2) (sqrt 3)))
~\textit{1.7739279023207892}~

(square (sqrt 1000))
~\textit{1000.000369924366}~
\end{scheme}

\noindent
\code{sqrt}プログラムはまた私達がここまでで紹介した単純な手続き型言語がCやPascalで
記述可能などんな純粋数値演算プログラムを書くのにも十分であることを示しています。
これには驚かれるかもしれません。私達はまだコンピュータに何かを繰り返し繰り返し
行わせるどのような繰り返し(ループ)要素もこの言語には入れていないためです。
一方で\code{Sqrt\-/iter}はどのように繰り返しが特別な記法を全く使わずに通常の手続
呼出能力のみで成し遂げられるかを実演して見せています。
\footnote{反復実装における手続呼出上の効率の問題を気にされている読者の方は
\link{Section 1.2.1}の``末尾再帰''上の備考に注目して下さい}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.6}Exercise 1.6:} Alyssa P. Hackerはなぜ
\code{if}が特殊形式として提供される必要があるのか理解できなかった。
``なぜ\code{cond}を用いた通常手続として定義できないのだろう?''と彼女は訝った。
Alyssaの友達であるEva Lu Atorはこれは実際にできると主張し、\code{if}の新バージョンを
定義した。

\begin{scheme}
(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
\end{scheme}

EvaはAlyssaに対してプログラムのデモを行った。

\begin{scheme}
(new-if (= 2 3) 0 5)
~\textit{5}~
(new-if (= 1 1) 0 5)
~\textit{0}~
\end{scheme}

喜びながらAlyssaは\code{new\-/if}を用いてsquare-rootプログラムを書き直した。

\begin{scheme}
(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x) x)))
\end{scheme}



Alyssaが平方根の計算にこれの使用を試した時に何が起こるだろうか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.7}Exercise 1.7:} 平方根の演算で使用された
\code{good\-/enough?}テストはとても小さい数値の平方根を
見つける場合にはあまり効果的ではないだろう。また実際のコンピュータでは数値演算
命令はほとんど常に精度に制限のある状態で実行される。これが我々のテストをとても
大きな数値に対して不適切にする。ここまでの記述についてテストがどのように小さな値と
大きな値にて失敗するか例を用いて説明せよ。\code{good\-/enough?}実装の代替戦略は
\code{guess}がある試行から次に向けどのように変化するか監視し、変化が推定値の割合に
おいてとても小さい時に止めることである。このような終了テストを用いるsquare-rootを
設計せよ。これは小さな、及び、大きな数値に対してより良く働くだろうか?

\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.8}Exercise 1.8:} 立方根に対する
ニュートン法は\( y \)が\( x \)の立方根である場合において以下の値により
良く近似される。
\begin{comment}

\begin{example}
x/y^2 + 2y
----------
    3
\end{example}

\end{comment}
\begin{displaymath}
{{x / y^2} + 2y\over 3}.
\end{displaymath}
\noindent
この式を用いてsquare-rootに類似したcube-rootを実装せよ。(\link{Section 1.3.4}にてこれらの
square-rootとcube-rootの抽象化としての汎用なニュートン法の実装方法を学習します。)
\end{quote}

\subsection{ブラックボックス抽象化としての手続}
\label{Section 1.1.8}



\code{sqrt}は私達にとり相互に定義された手続の集合により定義されたプロセスの例でした。
\code{sqrt\-/iter}の定義が\newterm{recursive}(\jnewterm{再帰的})であることに注意して下さい。再帰とは
手続がそれ自身の語により定義されていることです。手続をそれ自体の名前を用いて定義する
考え方は不安になるかもしれません。そのような``循環的''な定義がどのようにしてつじつま
を合わせるのか全く不明に見えるかもしれません。コンピュータにより実行するために良く
定義された手続には指定が足りなく見えるかもしれません。これについては\link{Section 1.2}にて
より注意深く触れることにします。最初はしかし\code{sqrt}の例にて説明されたいくつか別の
重要な点について考えましょう。



平方根を演算する問題が自然にいくつかの部分的な問題へ分割されることに注意して下さい。
推定値が十分に良いかどのように判断するか、推定値をどのように改善するか、等です。
これらのタスクの1つ1つは分離された手続により達成されます。\code{sqrt}プログラム全体は
(\link{Figure 1.2}にて表される)手続の群れに見てとることが可能です。この図が問題を
部分問題へと分解することを映し出しています。

\begin{figure}[tb]
\phantomsection\label{Figure 1.2}
\centering
\begin{comment}
\heading{Figure 1.2:} Procedural decomposition of the \code{sqrt} program.
\end{comment}
\begin{example}
                       sqrt
                        |
                    sqrt-iter
                    /       \
            good-enough    improve
              /     \          \
          square    abs      average
\end{example}

\begin{quote}
\heading{Figure 1.2:} \code{sqrt}プログラムの手続分解
\end{quote}
\end{figure}

\noindent
この分解戦略の重要性はプログラムを部分---最初の10行、次の10行、その他へと分割
するような単純なものではありません。そうではなく、各手続が他の手続の定義にて
モジュールとして利用可能な特定のタスクを担うことが不可欠です。例えば\code{good\-/enough?}
手続を\code{square}の語を用いて定義する時、\code{square}手続を``ブラックボックス''として
考えることが可能です。その時、その手続が\emph{どのように}結果を計算するのか気にして
いません。それが二乗を計算するという事実のみです。二乗がどのように計算されるかという
詳細は隠し、後の時点で考慮することが可能です。実際に\code{good\-/enough?}手続について考える
限り、\code{square}は手続では無く手続の抽象に過ぎないのです。\jnewterm{手続の抽象化}と
呼ばれるものです。この抽象化のレベルでは二乗を計算するどんな手続も等しく相応しいのです。



従って返り値のみを考えるため、以下の2つの二乗する手続は区別不可能となります。
それぞれが数値の引数を取りその数値の二乗を値として生成します。
\footnote{これら手続のどちらがより効率的な実装であるかは全く明確ではありません。
これは実行環境依存です。``明白な''実装が効率的ではない機械が存在します。
広範な対数と逆対数のテーブルをとても効率の良い方法で持つ機械について考えてみて下さい}

\begin{scheme}
(define (square x) (* x x))
(define (square x) (exp (double (log x))))
(define (double x) (+ x x))
\end{scheme}

\noindent
従って手続定義は詳細を隠すことができなければなりません。手続のユーザはその手続を
彼等自身で書いたとは限りません。しかし他のプログラマからブラックボックスとして
取得したかもしれません。ユーザはその手続がどのように実装されているのかそれを使用
するためには知る必要が無いのです。

\subsubsection*{ローカル名}



手続のユーザにとっては問題とならない手続実装の詳細の1つには手続の形式パラメタに
対する実装者が選択した名前があります。従って以下の異なる手続は区別不可能でなけれ
ばなりません。


\begin{scheme}
(define (square x) (* x x))
(define (square y) (* y y))
\end{scheme}

\noindent
この指針---手続の意味はその作者が使用したパラメタの名前から独立すべきである---は
表面上では自明なことに思えますがそこから導きださえる結論は重要です。最も単純な結論は
手続のパラメタ名はその手続のボディに対してローカルであるべきというものです。
例えば、まずsquare-root手続の中の\code{good\-/enough?}の定義においては\code{square}を使用しました。


\begin{scheme}
(define (good-enough? guess x)
  (< (abs (- (square guess) x))
     0.001))
\end{scheme}

\noindent
\code{good\-/enough?}の作者の意図する所は第一引数の二乗が第二引数にて与えられた
許容差の範囲であるかを決定することです。\code{good\-/enough?}の作者が\code{guess}を
第一引数の参照に用い\code{x}を第二引数に用いたことが見てとれます。\code{square}の
引数は\code{guess}です。もし\code{square}の作者が\code{x}を(上で見たように)使用した場合
\code{good\-/enough?}の\code{x}は\code{square}の\code{x}とは異ならなければならないことが
わかります。手続\code{square}の実行は\code{good\-/enough?}の\code{x}の値に影響を与えては
いけません。なぜならその\code{x}の値は\code{square}が演算を終えた後にも\code{good\-/enough?}
にて必要だからです。



もしパラメタがそれらが関連する手続のボディに対してローカルでない場合、\code{square}の
パラメタ\code{x}は\code{good\-/enough?}のパラメタ\code{x}と混同される可能性があります。
そして\code{good\-/enough?}の挙動はどのバージョンの\code{square}を利用するかに依存するでしょう。
従って\code{square}は私達が望んだブラックボックスではなくなるでしょう。



手続の形式パラメタは手続定義においてとても特別な役割を持ちます。形式パラメタには
どんな名前を用いてもかまわないのです。そのような名前は\newterm{bound variable}
(\jnewterm{束縛変数})と呼ばれます。そして手続定義はその形式パラメタを\newterm{binds}(\jnewterm{束縛}する)と
呼びます。もし束縛変数が静的に定義中においてリネームされても手続定義の意味は変わり
ません。\footnote{静的なリネームのコンセプトは実際には微妙で正式に定義するのは難しい
ことです。有名な論理学者達も恥しい間違いをここで犯してきました}
もし変数が束縛されていなければそれは\newterm{free}(\jnewterm{自由})だと呼びます。
束縛が名前を定義する式の集合はその名前の\newterm{scope}(\jnewterm{スコープ})と呼ばれます。
手続定義においてはその手続の形式パラメタとして宣言された束縛変数はその手続のボディを
そのスコープとします。



上記の\code{good\-/enough?}の定義において、\code{guess}と\code{x}は束縛変数ですが、
\code{<}, \code{-}, \code{abs}, \code{square}は自由変数です。私達が
選んだ\code{guess}と\code{x}の名前が、\code{<}, \code{-}, \code{abs}, \code{square}と異なり区別可能
である限り、\code{good\-/enough?}の意味はそれらの名前から独立せねばなりません。
(もし\code{guess}を\code{abs}にリネームした場合、変数\code{abs}を\newterm{capturing}(\jnewterm{占領})
することで自由変数を束縛変数に変化させるのでバグを持ち込むことになるでしょう。)
しかしながら\code{good\-/enough?}の意味はその自由変数の名前からは独立していません。
記号\code{abs}は(この定義の外部の)数値の絶対値を求める手続に名付けられているという事実に
当然、依存します。もし\code{cos}を\code{abs}にその定義において置き換えれば\code{good\-/enough?}は
異なる関数を計算することでしょう。


\subsubsection*{内部定義とブロック構造}



私達は今の所、一種類の名前の分離について学びました。手続の形式パラメタは手続の
ボディに対してローカルです。square-rootプログラムは我々が望むだろう名前使用を
コントロールする別な方法を示します。

\begin{scheme}
(define (sqrt x)
  (sqrt-iter 1.0 x))
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))
(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))
(define (improve guess x)
  (average guess (/ x guess)))
\end{scheme}

\noindent
このプログラムの問題は\code{sqrt}のユーザにとって重要な手続は\code{sqrt}のみであることです。
他の手続(\code{sqrt\-/iter}, \code{good\-/enough?}, \code{improve})は彼らにとって余計なものです。
ユーザは他に\code{good\-/enough?}という名の手続を、square-rootプログラムと一緒に使用する
他のプログラムの一部として定義することができません。なぜなら\code{sqrt}がそれを必要と
するからです。この問題は多くの異なるプログラマにより巨大システムを構築する場合に特に
深刻な問題となります。例えば数値演算の巨大ライブラリの構築において、多くの数値演算
関数は一連の近似値演算として計算されるため補助的な手続として\code{good\-/enough?}と\code{improve}
と名付けられた手続を持つかもしれません。私達は部分手続を局所化し\code{sqrt}の中に隠し
たいと思うでしょう。そうすれば\code{sqrt}が他の一連の近似値演算と共存し、それぞれが
自身のプライベートな\code{good\-/enough?}手続を持つことができます。これを可能にするために
手続はその手続に対して局所的な内部定義を持つことが可能です。例えばsqaure-rootプログラムは
以下のように書き換えることが可能です。

\begin{scheme}
(define (sqrt x)
  (define (good-enough? guess x)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess x) (average guess (/ x guess)))
  (define (sqrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (sqrt-iter (improve guess x) x)))
  (sqrt-iter 1.0 x))
\end{scheme}

\noindent
このような定義の入れ子は\newterm{block structure}(\jnewterm{ブロック構造})と呼ばれ、最も単純な名前パッケージ
問題解決に基本的に正しい解決方法です。しかしより良いアイデアがここに隠れています。
補助的な手続を内在化させることに加えてそれらを簡潔化することができます。\code{x}は\code{sqrt}に
束縛されているため、\code{sqrt}の内部に定義された手続\code{good\-/enough?}, \code{improve}, \code{sqrt\-/iter}は
\code{x}のスコープ内にあります。従って\code{x}を明示的にこれらの手続それぞれに渡す必要はありません。
その代わりに\code{x}を以下で示すように内部の定義にて自由変数にすることができます。
そして\code{x}は包括する手続\code{sqrt}が呼ばれた時にその値を得ます。このような規律を
\newterm{lexical scoping}(\jnewterm{レキシカルスコープ})と呼びます。\footnote{レキシカルスコープは
手続内の自由変数が包括する手続定義により作られた束縛を参照するため用いられるよう指示します。
それはつまり、手続が定義された環境の中でそれらが探されることを意味します。これがどのように
働くのか、その詳細については第3章にて環境とインタプリタの詳細な挙動について学ぶ時に理解
します。}


\begin{scheme}
(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
\end{scheme}

\noindent
ブロック構造は巨大なプログラムを取扱の簡単な部品に分割するために広範囲にて
利用されます。\footnote{\label{Footnote 28}組込定義は手続本体の最初に来なければなりません。
相互依存の定義と使用を行うプログラムの実行結果についてはこのような管理も
責任を持つことができません}
ブロック構造の考え方はプログラミング言語Algol 60に起源を持ちます。多くの
先進的なプログラミング言語に存在し、巨大プログラム構築の体系化を手助けす
る重要なツールです。


\section{手続とそれが生成するプロセス}
\label{Section 1.2}



私達はプログラミングの要素について考えてきました。プリミティブな算術演算子を用い
これらの演算子を組み合わせ、その合成演算子を複合手続として定義することで抽象化
を行ってきました。しかしそれらは私達がプログラムをどのように書くか知っていると
言えるためには十分ではありません。私達の状況はチェスにおいて各駒がどのように動く
のかルールを覚えたが典型的な序盤や戦術、戦略について何も知らない人に似ています。
チェスの初心者棋士のように、私達はまだこの領域での慣習としての一般的パターンを
知りません。私達はどの手が打つ価値があるのか(どの手続が定義する価値があるのか)の
知識を欠いています。打った手の(手続実行の)結果を予想する経験を欠いています。


熟慮下の行動の結果を思い描く能力はエキスパートプログラマになるために重大です。
それはどんな統合的、かつ創造的な活動についても同じです。熟練の写真家になるには
例えば、景色の見方を学び、各可能な露出と現像条件の組み合わせにおいて各領域が
どれだけ暗く写真に表れるかを知らなければなりません。そうして初めてフレームの計画、
光量、露出、現像を逆向きに推測して望んだ効果を得ることが可能となります。
プログラミングにおいてもまた同じです。プロセスが取り得る行動がどのような進行を
経るのか計画し、プログラムを用いてプロセスをコントロールします。


エキスパートになるためには、数多くの種類の手続により生成されるプロセスを心に
描けられるようにならなければなりません。そのようなスキルを開発した後に初めて
望んだ挙動を示すプログラムを信頼できる形で構築する方法を学ぶことが可能になります。



手続は計算過程の\newterm{local evolution}(\jnewterm{局所展開})のためのパターンです。プロセス
の各ステージが以前のステージの上にどのように構築されるかを指定します。
ここで手続により局所展開が指示されたプロセスの全体的な、または\newterm{global}(\jnewterm{大域的})な
挙動について説明を行えればと思います。しかしこれは一般的にはとても難しいので、最低でも
いくつかのプロセス展開の典型的パターンについて説明することを試してみましょう。



この節では簡単な手続により生成されたプロセスのためのいくつかの共通な``形''について
検討してみます。またこれらのプロセスが時間と記憶域の重要な計算資源をどの程度消費する
かについても調査してみます。ここで考慮する手続はとても簡単なものです。それらの役割は
写真撮影におけるテストパターンにより演じられる様なものです。非常に単純化した原型的な
パターンであり、それら自身の目的に沿った現実的な例ではありません。


\subsection{線形再帰と反復}
\label{Section 1.2.1}


階乗を求める関数を考えることから始めましょう。定義を以下に示します。

\[
n! = n \cdot [(n - 1)  \cdot (n - 2)  \dots 3 \cdot 2 \cdot 1] = n \cdot (n - 1)!
\]


階乗を計算する方法は数多くあります。1つの方法は任意の正の整数 \( n \)において、\( n! \)は
\( n \)と\( (n - 1)! \)の積に等しいという観察結果を利用します。
\begin{comment}

\begin{example}
n! = n * [(n - 1) * (n - 2) ... 3 * 2 * 1] = n * (n - 1)!
\end{example}

\end{comment}
\begin{displaymath}
n! = n \cdot [(n - 1) \dot (n - 2) \dots 3 \cdot 2 \cdot 1] = n \cdot (n - 1)!.
\end{displaymath}

従って\( (n - 1)! \)を演算し、\( n \)を掛けることで\( n! \)を求めることが可能です。
もし1!が1に等しいという規約を追加すればこの観察結果は直接手続に翻訳できます。

\begin{scheme}
(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))
\end{scheme}

\noindent
\link{Section 1.1.5}の置換モデルを用いてこの手続が6!の計算を実行する様子を
\link{Figure 1.3}に示すように観察できます。

\begin{figure}[tb]
\phantomsection\label{Figure 1.3}
\centering
\begin{comment}
\heading{Figure 1.3:} A linear recursive process for computing 6!.

\begin{example}
(factorial 6)        ----------------
(* 6 (factorial 5))                   \
(* 6 (* 5 (factorial 4)))               \
(* 6 (* 5 (* 4 (factorial 3))))           \
(* 6 (* 5 (* 4 (* 3 (factorial 2)))))       \
(* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))  |
(* 6 (* 5 (* 4 (* 3 (* 2 1)))))             /
(* 6 (* 5 (* 4 (* 3 2))))                 /
(* 6 (* 5 (* 4 6)))                     /
(* 6 (* 5 24))                        /
(* 6 120)                           /
720          <---------------------
\end{example}
\end{comment}
\includegraphics[width=82mm]{fig/chap1/Fig1.3c.pdf}
\par\bigskip
\noindent
\heading{Figure 1.3:} 6!を求めるための線形再帰プロセス
\end{figure}

\noindent
では階乗の演算について異なる視点を得てみましょう。\( n! \)を計算するルールを最初に
1を2で掛け、その結果を3に掛け、次に4に掛け\( n \)に辿り着くまで繰り返すと説明する
ことも可能でした。より形式的には、積の実行と、1から\( n \)までカウントするカウンタ
とを一緒に保持します。カウンタと積は同時にあるステップから次へとルールに従い
変更されると言うことでこの演算を説明できます。

\begin{scheme}
product ~\( \dark \gets \)~ counter * product
counter ~\( \dark \gets \)~ counter + 1
\end{scheme}

\noindent
そして\( n! \)とはカウンタが\( n \)を越えた時点での積の値であると規定します。

再び、今までの階乗を求める手続の説明を次のように書き換えられます。
\footnote{実際のプログラムでは恐らく前の節で紹介したブロック構造を\code{fact\-/iter}の
定義を隠すために用いるでしょう。

\begin{smallscheme}
(define (factorial n)
  (define (iter product counter)
    (if (> counter n)
        product
        (iter (* counter product)
              (+ counter 1))))
  (iter 1 1))
\end{smallscheme}

ここでそれを避けたのは一度に考えなければならなことを最小にするためです。}


\begin{scheme}
(define (factorial n)
  (fact-iter 1 1 n))
(define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))
\end{scheme}

\noindent
前回と同じく、置換モデルを用いて6!の演算を\link{Figure 1.4}として示します。



2つのプロセスを比べてみて下さい。1つの見方としては、これらはほとんど同じに見えます。
両者は同じ数学の関数を同じ領域で計算し、それぞれが\( n! \)を求めるのに\( n \)に比例
したステップ数を必要とします。実際に両者のプロセスが全く同じ一連の乗算を実行し、全く
同じ一連の部分的な積を得ます。一方で2つのプロセスの``形''を考えた時、全く異なった展開を
していることに気がつきます。


\begin{figure}[tb]
\phantomsection\label{Figure 1.4}
\centering
\begin{comment}
\heading{Figure 1.4:} A linear iterative process for computing 6!.

\begin{example}
(factorial 6)   -----.
(fact-iter   1 1 6)  |
(fact-iter   1 2 6)  |
(fact-iter   2 3 6)  |
(fact-iter   6 4 6)  |
(fact-iter  24 5 6)  |
(fact-iter 120 6 6)  |
(fact-iter 720 7 6)  V
720
\end{example}
\end{comment}
\includegraphics[width=36mm]{fig/chap1/Fig1.4c.pdf}
\par\bigskip
\noindent
\heading{Figure 1.4:} 6!を求めるための線形反復プロセス
\end{figure}

\noindent
最初のプロセスについて考えます。\link{Figure 1.3}の矢印で示されるように、
置換モデルが展開の後、収縮する状態を明らかにしています。
展開は\newterm{deferred operations}(遅延演算)の連鎖(このケースでは乗算の連なり)を構築するプロセスとして
起こります。収縮は演算が実際に実行されることにより起こります。遅延演算の連鎖として
示されるこのタイプのプロセスは\newterm{recursive process}(再帰プロセス)と呼ばれます。このプロセスの実行には
インタプリタが後の実行ために操作の過程を記録する必要があります。\( n! \)の演算では遅延乗算の連鎖
の長さ、そしてそれに従う追跡の必要な情報の量が、\( n \)に従い線形に(\( n \)に比例して)ステップ数と同様に増加します。
このようなプロセスは\newterm{linear recursive process}(線形再帰プロセス)と呼ばれます。



対照的に、2つ目のプロセスは展開も収縮もしません。各ステップにおいて追跡が必要な物は
どの\( n \)に対しても変数\code{product}, \code{counter}, \code{max\-/count}の現在値です。
これを\newterm{iterative process}(\jnewterm{反復プロセス})と呼びます。
一般的に、反復プロセスは限られた数の\newterm{state variables}(\jnewterm{状態変数})により状態が、
集約されることが可能な物です。
状態変数がプロセスが状態毎にどのように更新されるかという固定ルールと
プロセスが停止する条件を指定する(任意の)終了試験と一緒に用います。
\( n! \)の演算では\( n \)に従い必要なステップ数が線形に増加します。
このようなプロセスは\newterm{linear iterative process}(\jnewterm{線形反復プロセス})と呼ばれます。



2つのプロセスの対称性は他の見方もできます。反復の場合、プログラムの変数は任意の
ポイントにおいてプロセスの状態について完全な描写を提供します。もしステップの間で
計算を停止した場合に、計算の再開を行うのに必要な全てはインタプリタに対し3つの
プログラム変数の値を提供することです。再帰プロセスではそうはいきません。
この場合、いくつかの追加の``隠された''情報が存在し、インタプリタにより保持されており、
プログラムの変数には保存されていません。その情報には遅延命令の連鎖を辿る中での
``プロセスの現在地''が示されています。鎖が長い程、より多くの情報が保持される必要が
あります。\footnote{\link{Chapter 5}にてレジスタマシン上での手続の実装について
議論する時に、任意の反復プロセスが``ハードウェア内にて''固定長のレジスタ集合を持ち、
補助的なメモリは持たない機械であると認識できることを学びます。対照的に、再帰プロセスを
理解するには\newterm{stack}(\jnewterm{スタック})として知られる補助的なデータ構造が必要です。}



反復と再帰の対称性において、再帰\jnewterm{プロセス}の概念と再帰\jnewterm{手続}の
概念を混同しないように注意せねばなりません。私達が手続を再帰だと説明する時、
手続の定義が(直接、または間接的に)その手続自身を参照するという構文上の事実を
参照します。しかし、プロセスがあるパターン、例えば、線形再帰に従うと
説明する時、私達はプロセスがどのように展開するかについて話しており、手続が
どのように書かれているかという構文については話していません。\code{fact\-/iter}のような
再帰手続を反復プロセスの生成として言及することは当惑させるかもしれません。
しかし、そのプロセスは実際に反復的です。その状態は3つの状態変数により完全に補足され、
インタプリタはプロセスを実行するために、ただ3つの変数を追跡することのみが必要です。



プロセスとプロシジャ(手続)の区別が混乱を招き易いのは、(AdaやPascal、C言語を含む)多くの一般的言語
の実装が、例えプロセスが本質的には反復で記述されていても、任意の再帰手続の逐次実行が手続呼出の回数に伴い
多くのメモリ容量を消費するように設計されているためです。結果としてこれらの言語は反復プロセスのみを特別な目的の
``ループ構成概念''である\code{do}, \code{repeat}, \code{until}, \code{for}, \code{while}のような物を用いて
記述します。私達が\link{Chapter 5}にて考えるSchemeの実装はこの短所を共有しません。
例え反復プロセスが再帰手続により記述されていても定量的な記憶域にて実行します。
この属性を持つ実装は\newterm{tail-recursive}(末尾再帰)と呼ばれます。末尾再帰の実装を用いれば
反復は一般的な手続呼出メカニズムを用いて表現可能であり、特別な反復構成概念は糖衣構文としてのみ
実益のあるものとなります。\footnote{末尾再帰は長い間コンパイラの最適化のための裏技として知られ
てきました。末尾再帰の論理的な意味論上の基礎はCarl \link{Hewitt (1977)}により与えられました。
彼はそれを演算の``メッセージパッシング''モデルにて説明しました。\link{Chapter 3}にて議論します。
これに影響を受けて、Gerald Jay SussmanとGuy Lewis Steele Jr. (\link{Steele and Sussman 1975}参照)
はSchemeのための末尾再帰インタプリタを構築しました。Steeleは後に末尾再帰が手続呼出をコンパイルするのに
どれだけ自然な方法の結果であるかを示しました(\link{Steele 1977})。Schemeの\acronym{IEEE}標準仕様は
Schemeの実装が末尾再帰であることを必須要件としています。}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.9}Exercise 1.9:} 次の2つの各手続は
2つの正の整数を加算する手段を定義している。手続\code{inc}は引数を
1増やし、\code{dec}は引数を1減らす。

\begin{scheme}
(define (+ a b)
  (if (= a 0) b (inc (+ (dec a) b))))
(define (+ a b)
  (if (= a 0) b (+ (dec a) (inc b))))
\end{scheme}


置換モデルを用いて各手続が\code{(+ 4 5)}の評価において生成するプロセスを図示せよ。
これらのプロセスは反復であるか、再帰であるか?

\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.10}Exercise 1.10:} 以下の手続は
アッカーマン関数と呼ばれる数学の関数を計算する。

\begin{scheme}
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))
\end{scheme}


以下の式の値はいくつであるか?

\begin{scheme}
(A 1 10)
(A 2 4)
(A 3 3)
\end{scheme}


\code{A}が上で定義された手続である時、以下の手続について考察せよ。

\begin{scheme}
(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))
\end{scheme}


\( n \)が正の整数である場合に手続\code{f}, \code{g}, \code{h}により計算される関数の
数学上の定義について簡明に答えよ。例として\code{(k n)}は\( 5n^2 \)を計算する。

\end{quote}


\subsection{木再帰}
\label{Sec. 1.2.2}
\label{Section 1.2.2}
もう1つの演算の一般的パターンは\newterm{tree recursion}(\jnewterm{木再帰})と呼ばれます。
例として、フィボナッチ数の計算について考えてみましょう。各数値は先行する2つの数の
和となります。

\begin{comment}
0, 1, 1, 2, 3, 5, 8, 13, 21, \( \dots \)
\end{comment}
\begin{displaymath}
 0,\; 1,\; 1,\; 2,\; 3,\; 5,\; 8,\; 13,\; 21,\; \dots. 
\end{displaymath}


一般に、フィボナッチ数は次のルールにて定義可能です。

\begin{comment}

\begin{example}
         /
         |  0                        if n = 0
Fib(n) = <  1                        if n = 1
         |  Fib(n - 1) + Fib(n - 2)  otherwise
         \
\end{example}

\end{comment}
\begin{displaymath}
 {\rm Fib}(n) = 
\begin{cases}	
        \; 0 & {\rm if} \;\; n=0, \\
	\; 1 & {\rm if} \;\; n=1, \\
	\; {\rm Fib}(n-1) + {\rm Fib}(n-2) \quad & {\rm otherwise}. 
\end{cases} 
\end{displaymath}


私達は直ぐにこの定義をフィボナッチ数を計算する再帰手続の定義に翻訳が可能です。

\begin{scheme}
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
\end{scheme}

\noindent
この計算のパターンについて考えてみましょう。\code{(fib 5)}を計算するには
\code{(fib 4)}と\code{(fib 3)}を計算します。\code{(fib 4)}を計算するには\code{(fib 3)}と
\code{(fib 2)}を計算します。一般的に展開されたプロセスは\link{Figure 1.5}で示すように
木のように見えます。枝が各レベル(最下層を除く)にて2つに分かれることに注意して
下さい。これが\code{fib}手続が実行される度に毎回、自身を二回呼び出す事実を反映
しています。



この手続は典型的な木再帰としては有益です。しかしフィボナッチ数を計算するには酷い
方法です。あまりにも冗長な計算を行うためです。\link{Figure 1.5}において\code{(fib 3)}
の計算全体が---ほぼ仕事の半分が---重複していることに注意して下さい。実際には手続が
\code{(fib 1)}や\code{(fib 0)}の演算回数(上記の木全体においての葉の数)が正確にFib(\( n+1 \))
であることを示すのは難しくありません。この方法の酷さを知るために、
Fib(\( n \))の値が\( n \)に対し指数関数的に増加することを示すことができます。
より正確にはFib(\( n \))は以下の条件の場合に\( \varphi^n / \sqrt{5} \)に最も近い
整数になります。(\link{Exercise 1.13}参照)

\begin{comment}

\begin{example}
[phi] = (1 + [sqrt]5)/2 ~= 1.6180
\end{example}

\end{comment}
\begin{displaymath}
\varphi = {1 + \sqrt{5}\over2} \approx 1.6180 
\end{displaymath}
\noindent
\( \varphi \)は\newterm{golden ratio}(\jnewterm{黄金比})であり次の等式を満たします。

\begin{comment}

\begin{example}
[phi]^2 = [phi] + 1
\end{example}

\end{comment}
\begin{displaymath}
\varphi^2 = \varphi + 1. 
\end{displaymath}

\begin{figure}[tb]
\phantomsection\label{Figure 1.5}
\centering
\begin{comment}
\heading{Figure 1.5:} The tree-recursive process generated in computing \code{(fib 5)}.

\begin{example}

                   ..<............ fib5   <.......... 
                ...     ___________/  \___________   .  
             ...       /       . .....            \    . 
           ..       fib4     .        . . . .     fib3  .  
         ..     ____/. \____  ..             .  __/  \__  .  
       ..      /  . .  ..   \    .        ..   /  . .   \   . 
     ..     fib3 .       .  fib2 .        . fib2 .   .  fib1 .
   ..      / . \  .     .   /  \  .      .  /  \ ...  .  |  .
 ..       / . . \   .  .   /  . \   .  .   / .  \   .  . 1 .
.      fib2 . . fib1.  .fib1 .  fib0 . .fib1. . fib0 .  .  .
.      /  \  . . |  .  . |  .  . |   . . |   . . |   .   .>
V     /  . \   . 1  .  . 1  .  . 0  .  . 1  .  . 0  ..
.  fib1 .. fib0..  .   .   .   .   .   V   .   ..  . 
.   |  .  . |  . .>     .>.     . .    ..>.      .>
.   1 .   . 0  .      
 .   .     .  .       
  .>.       ..        

\end{example}
\end{comment}
\includegraphics[width=90mm]{fig/chap1/Fig1.5c.pdf}
\begin{quote}
\heading{Figure 1.5:} \code{(fib 5)}を求める際に生成された木再帰プロセス
\end{quote}
\end{figure}

\noindent
従ってプロセスは入力に伴ない指数関数的に増加するステップ数を要します。一方で
要求される記憶域は入力に対し線形にしか増加しません。なぜなら計算過程の任意のポイントに
おいて、木の中のどのノードが上にあるのかのみ追跡する必要があるためです。一般的に、
木再帰プロセスにおいて必要とされるステップ数は木の中のノードの数に比例します。
必要とされる記憶域は木の最大の深さに対して比例します。


フィボナッチ数の計算を反復プロセスに定式化することも可能です。この考えは\( a \)と\( b \)
の整数のペアを用い、Fib(1) = 1とFib(0) = 0の初期化を行い、以下の変換を同時に行うというものです。


\begin{comment}

\begin{example}
a <- a + b
b <- a
\end{example}

\end{comment}
\begin{displaymath}
% \eqalign{a &\gets a + b, \cr 
% b &\gets a. \cr}
\begin{array}{l@{\quad\gets\quad}l}
  a & a + b, \\ 
  b & a.
\end{array}
\end{displaymath}
\noindent
この変換を\( n \)回行った後に\( a \)と\( b \)がそれぞれFib(\( n+1 \))と
Fib(\( n \))に等しいことを示すのは難しくありません。従ってフィボナッチ数を反復的に
以下の手続を用いて計算可能です。

\begin{scheme}
(define (fib n)
  (fib-iter 1 0 n))
(define (fib-iter a b count)
  (if (= count 0)
      b
      (fib-iter (+ a b) a (- count 1))))
\end{scheme}

\noindent
このFib(\( n \))を計算する2つ目の方法は線形反復です。2つの方法により要求される
ステップ数の差は、一方は\( n \)に対し線形であり、もう一方はFib(\( n \))自身の値の速さで
増加するため、例え入力値が小さくてもその差は非常に大きくなります。



これより木再帰プロセスが役に立たないと結論づけるべきではありません。数値ではなく
階層構造のデータを操作するプロセスを考えた場合、木再帰は自然で強力なツールです。
\footnote{これの例は\link{Section 1.1.3}:インタプリタ自身が木再帰プロセスを用いて式を評価する
ことから暗示されます}しかし、例え数値演算においても木再帰はプログラムの設計と理解を
手助けするのに役立ちます。例えば最初の\code{fib}手続は2つ目に比べてとても非効率ですが、
より直感的でフィボナッチ数列の定義とLisp翻訳の違いは大差がありません。反復アルゴリズム
の定式化を行うためには、計算が3つの状態変数に再定義できることに気付く必要があります。

\subsubsection*{例: 両替方法を数える}



反復的フィボナッチアルゴリズムに至るには多少の知恵が必要です。一方で、次の問題
について考えてみて下さい：\$1.00を両替するにはいくつの方法があるでしょうか?
50セント、25セント、10セント、5セント、1セント硬貨があります。
より一般的に、任意の量の金額に対して両替方法がいくつ存在するか計算する手続を書くこと
ができますか?


この問題には再帰手続としての簡単な答が存在します。利用可能なコインのタイプをある
順序で並べると考えてみましょう。すると以下の関係が成り立ちます。


\( n \)種類の硬貨を用いた場合、金額\( a \)の両替方法の数は

\begin{itemize}

\item
最初の種類の硬貨を除いた残り全てを用いた金額\( a \)の両替方法の数、\\

プラス

\item
\( d \)が最初の種類の硬貨の額面である場合に、\( n \)種類の硬貨全てを用いた
金額\( a - d \)の両替方法の数

\end{itemize}

\noindent
なぜこれが正しいのか考えるためには両替方法が2つのグループに分けられることに注目し
ます。最初の種類の硬貨を用いないものと、用いるものです。従ってある金額に対する
両替方法の数の総数は最初の種類の硬貨を全く使わないその金額に対する両替方法の数と最初の
コインを用いる両替方法の数の和です。しかし後者の数は最初の種類の硬貨を用いた後の
残りの金額に対する両替方法の数に等しくなります。


従って与えられた金額の両替問題から少ない種類の硬貨を用いたより少ない金額の両替問題へと
再帰的に縮小することが可能です。この集約ルールについて注意深く考えてください。そして
自分自身でそのルールを用いて以下の縮退ケースを指定した場合アルゴリズムを記述できるよう
に準備して下さい。\footnote{例えば5セント硬貨と1セント硬貨を用いて10セントの両替を
行う問題に縮退ルールをどのように適用するかについて、詳細に通してやって見て下さい}

\begin{itemize}

\item
もし\( a \)が0である場合、両替方法は1と数える

\item
もし\( a \)が0未満の場合、両替方法は0と数える

\item
もし\( n \)が0の場合、両替方法は0と数える

\end{itemize}

\noindent
この記述は簡単に再帰手続に翻訳できます。

\begin{scheme}
(define (count-change amount) (cc amount 5))
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination 
                         kinds-of-coins))
                     kinds-of-coins)))))
(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
\end{scheme}

\noindent
(\code{first\-/denomination}手続は利用可能な硬貨の種類の数を入力に取り、最初の種類の
硬貨の額面を返します。ここでは硬貨は最大額面から最小への順に並んでいると仮定し
ますが、どのような順でもうまく行きます)これで元々の質問である\$1の両替について
回答ができます。

\begin{scheme}
(count-change 100)
~\textit{292}~
\end{scheme}

\noindent
\code{count\-/change}は\code{fib}の最初の実装と同様に冗長な木再帰プロセスを生成します。
(292が演算されるのに暫く時間がかかるでしょう)
一方で結果を求めるのにより良いアルゴリズムをどのように設計するかは自明ではあり
ません。この問題は読者への宿題とします。木再帰プロセスはとても非効率ですが
多くの場合、指示と理解が簡単であることが人々に対し、ユーザが両者の世界の良い面を
得られる、木再帰手続をより効率的で等価な手続へと変換を行う``賢いコンパイラ''
の設計を提案する方向へと向かわせています。
\footnote{冗長な演算に対処する1つの取り組み方法は演算結果
に従い、自動的に値のテーブルを構築することです。手続をある引数に適用するよう要求される度に、最初にその値が
既にテーブルに存在するかを確認します。その場合、冗長な演算を防ぐことが可能です。
この戦略は\newterm{tabulation}(\jnewterm{表形式化})や\newterm{memoization}(\jnewterm{メモ化})として知られ
直感的な方法で実装が可能です。表形式化は時折、(\code{count\-/change}のような)指数関数的な
ステップ数を要するプロセスを、入力に対し時間と記憶域の要求が線形に増加するプロセスへと
変換するのに利用されます。(\link{Exercise 3.27}参照)}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.11}Exercise 1.11:} 関数\( f \)は
\( n < 3 \)の場合\( f(n) = n \)と\( n \ge 3 \)の場合、\( f(n) = f(n-1) + 2f(n-2) + 3f(n-3) \)
のルールの下に定義される。 \( f \)を演算する手続を再帰プロセスを用いて書け。また\( f \)を演算する手続を
反復プロセスを用いて書け。
\end{quote}

\newpage

\begin{quote}
\heading{\phantomsection\label{Exercise 1.12}Exercise 1.12:} 以下の
数値のパターンは\newterm{Pascal's triangle}(\jnewterm{パスカルの三角形})と呼ばれる。

\begin{example}
        1
      1   1
    1   2   1
  1   3   3   1
1   4   6   4   1
      . . .
\end{example}



三角の端の数値は全て1であり、三角内部の各数値はそれの上2つの数値の和である。
\footnote{パスカルの三角形の各要素は\newterm{binomial coefficients}(二項係数)と
呼ばれます。\( n \)番目の行が\( (x + y)^n \)の展開式における各項の係数であるため
です。係数を計算するこのパターンはBlaise Pascalの1653年の確率理論の独創的な成果
である \textit{Trait\'e du triangle arithm\'etique}に現れました。\link{Knuth (1973)}
によると、1303年に同様のパターンが中国の数学者、朱世傑により出版された\textit{Szu-yuen Y\"u-chien} 
(``The Precious Mirror of the Four Elements'')(四元玉鑑)の中にも記載されています。
また12世紀のペルシャの詩人であり数学者であったOmar Khayyam、同じく12世紀
のインド人数学者Bh\'ascara \'Ach\'aryaについても同様です。}パスカルの三角形の要素を
再帰プロセスを用いて求める手続を書け。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.13}Exercise 1.13:} Fib(\( n \))が
\( \varphi^n / \sqrt{5} \)に最も近い整数であることを証明せよ。
\( \varphi = (1 + \sqrt{5}) / 2 \)とする。
ヒント：\( \psi = (1 - \sqrt{5}) / 2 \)と置く。帰納法とフィボナッチ数の定義
(\link{Section 1.2.2}参照)を用いてFib(\( n \)) = \( (\varphi^n - \psi^n) / \sqrt{5} \)
であることを証明せよ。
\end{quote}

\subsection{増加のオーダー}
\label{Section 1.2.3}



前節の例ではプロセスが消費する計算資源の割合が大幅に異なることを示しました。
この違いを説明する1つの便利な方法には\newterm{order of growth}(\jnewterm{増加のオーダー})の記法を
用いて入力が大きくなるにつれプロセスが要求するリソース(資源)の総体的量の
説明を得ることがあります。



\( n \)が問題サイズを測るパラメータ、\( R(n) \)をサイズ\( n \)の問題に対し
プロセスが要求するリソースの量だとします。前節の例では\( n \)を与えられた
関数が何回計算されるかの数としました。しかし他の可能性もあります。例えば、
もし私達のゴールが数値の平方根の近似値を求めることであれば、\( n \)を必要な
精度の桁数と取ることもありえるでしょう。行列の乗算では\( n \)を行列の行数と
取るかもしれません。一般的に与えられた問題を分析するのに望ましい問題の属性は
いくつもあります。同様に、\( R(n) \)が使用される内部保管レジスタの数を量った
り、実行された基本的機械語命令の数であったり等します。一度に固定数の命令を
実行する計算機においては必要とされる時間は実行される基本的機械語命令の数に
比例します。



もし任意の十分に大きな\( n \)の値に対して正の定数\( k_1 \)と\( k_2 \)が
\( n \)に独立して存在し\( k_1f(n) \le R(n) \le k_2f(n) \)を満たす時、
\( R(n) \)は増加の次数\( \Theta(f(n)) \)を持ち\( R(n) \) = \( \Theta(f(n)) \)
(``シータ\( f(n) \)''と発音する)と記述されます。




例として、\link{Section 1.2.1}で説明した階乗を求める線形再帰プロセスではステップ数は入力
\( n \)に比例します。従ってこのプロセスに必要なステップ数は\( \Theta(n) \)に
従い増加します。必要とされる記憶域もまた\( \Theta(n) \)に従い増加します。反復式階乗では
ステップ数はまだ\( \Theta(n) \)ですが、記憶域は\( \Theta(1) \)---定数です。
\footnote{これらの記述は多くの過度な単純化を隠しています。例えばもし``機械語命令''を
プロセスのステップ数として数えた場合に、一例として、乗算に対し必要な機械語命令の数は乗算される
2つの数に対し独立していると想定するとします。それは数値が十分に大きな場合は
間違いです。同様の見解が記憶域に対する見積に対しても取られます。プロセスの設計と記述
のように、プロセスの分析は抽象化の色々なレベルに対して行えます。}
木再帰フィボナッチ演算は\( \Theta(\varphi^n) \)ステップと記憶域\( \Theta(n) \)を
必要とします。
この時\( \varphi \)は\link{Section 1.2.2}で示したとおりの黄金比です。



増加の次数はプロセスの行いについて概観的な説明のみを与えます。
例えば\( n^2 \)ステップ、\( 1000n^2 \)ステップ、
\( 3n^2 + 10n + 17 \)ステップを必要とするプロセスは全て増加の次数は
\( \Theta(n^2) \)になります。一方で増加の次数は問題のサイズを変更した場合に
どの程度プロセスの挙動が変化するかを推測するのに実用的な指標です。
\( \Theta(n) \)の線形プロセスに対しサイズを2倍にした場合、概ね2倍のリソースを
使用します。指数関数的プロセスに対しては問題サイズを1増やす度、定数因子を
リソース使用率にかけることになります。\link{Section 1.2}の最後にて増加の次数が対数である
2つのアルゴリズムをでは、問題サイズを倍にした時に必要とするリソースが定数量
増えることを調査します。

\begin{quote}
\heading{\phantomsection\label{Exercise 1.14}Exercise 1.14:} \link{Section 1.2.2}の
\code{count\-/change}手続により11セントの両替を求めた場合に生成される
プロセスの木を図示せよ。量が増えるに従いこのプロセスにより使用される記憶域とステップ数
の増加の次数はいくつか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.15}Exercise 1.15:} (ラジアンで指定される)
角度の正弦値は\( x \)が十分に小さい時\( \sin x  \approx x \)
の近似式を用いることで計算できる。そして三角法の恒等式、
\begin{comment}

\begin{example}
               x             x
sin x = 3 sin --- - 4 sin^3 ---
               3             3
\end{example}

\end{comment}
\begin{displaymath}
\sin x = 3\sin {x\over3} - 4\sin^3 {x\over3} 
\end{displaymath}
\noindent
を用いてsinの引数の大きさを縮小することができる。(この課題の目的では``十分に小さい''
とはその大きさが0.1ラジアンよりも大きくないこととする) これらの考えが以下の手続に
組込まれている。

\begin{scheme}
(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
   (if (not (> (abs angle) 0.1))
       angle
       (p (sine (/ angle 3.0)))))
\end{scheme}

\begin{enumerate}[a]

\item
手続\code{p}は\code{(sine 12.15)}を評価した時、何回適用されるか?

\item
\code{(sine a)}が評価された時、\code{sine}手続により生成されたプロセスにより使用
された(\( a \)の関数としての)記憶域とステップ数の増加の次数を求めよ。

\end{enumerate}
\end{quote}


\subsection{指数計算}
\label{Section 1.2.4}



与えられた数値の指数関数を求める問題について考えましょう。基数\( b \)と正の整数
である指数\( n \)を引数に取り\( b^n \)を求める手続にします。再帰定義により
これを行う1つの方法は次の通りです。

\begin{comment}

\begin{example}
b^n = b * b^(n - 1)
b^0 = 1
\end{example}

\end{comment}
\begin{displaymath}
% \eqalign{b^n &= b\cdot b^{n-1}, \cr 
% b^0 &= 1, \cr} 
\begin{array}{l@{{}={}}l}
  b^n & b\cdot b^{n-1}, \\ 
  b^0 & 1,
\end{array}
\end{displaymath}

早速、手続に翻訳します。

\begin{scheme}
(define (expt b n)
  (if (= n 0)
      1
      (* b (expt b (- n 1)))))
\end{scheme}

\noindent
これは線形再帰プロセスであり、\( \Theta(n) \)ステップと記憶域\( \Theta(n) \)を
必要とします。階乗と同様にすぐに等価な線形反復へと定式化可能です。

\begin{scheme}
(define (expt b n)
  (expt-iter b n 1))
(define (expt-iter b counter product)
  (if (= counter 0)
      product
      (expt-iter b
                 (- counter 1)
                 (* b product))))
\end{scheme}

\noindent
このバージョンは\( \Theta(n) \)ステップと記憶域\( \Theta(1) \)を必要とします。


指数関数は二乗を連続して用いることでより少ないステップで計算できます。
例えば、\( b^8 \)を以下のように計算するのではなく、
\begin{comment}

\begin{example}
b * (b * (b * (b * (b * (b * (b * b))))))
\end{example}

\end{comment}
\begin{displaymath}
 b\cdot (b\cdot (b\cdot (b\cdot (b\cdot (b\cdot (b\cdot b))))))\,, 
\end{displaymath}

3回の乗算で求めることが可能です。
\begin{comment}

\begin{example}
b^2 = b * b
b^4 = b^2 * b^2
b^8 = b^4 * b^4
\end{example}

\end{comment}
\begin{displaymath}
% \eqalign{	b^2 &= b\cdot b, \cr
%		b^4 &= b^2\cdot b^2, \cr
%		b^8 &= b^4\cdot b^4. \cr} 
\begin{array}{l@{{}={}}l}
  b^2 & b\cdot b, \\
  b^4 & b^2\cdot b^2, \\
  b^8 & b^4\cdot b^4.
\end{array}
\end{displaymath}

この方法は2の冪乗である指数関数についてはうまく働きます。また連続する二乗の利点を
一般的な指数関数の演算に対し以下のルールに従うことで利用可能です。
\begin{comment}

\begin{example}
b^n = (b^(n/2))^2    if n is even
b^n = b * b^(n - 1)  if n is odd
\end{example}

\end{comment}
\begin{displaymath}
% \eqalign{b^n &= (b^{n / 2})^2 \qquad \;\, {\rm if\;} n {\rm\; is\; even}, \cr
% b^n &= b\cdot b^{n-1} \qquad {\rm if\;} n {\rm\; is\; odd}. \cr} 
\begin{array}{l@{{}={}}lr@{\ n\ }l}
  b^n & (b^{n / 2})^2  \;\; & \mbox{if\,} & \mbox{\,is\, even}, \\
  b^n & b\cdot b^{n-1} \;\; & \mbox{if\,} & \mbox{\,is\, odd}.
\end{array}
\end{displaymath}

この方法を手続として表現します。

\begin{scheme}

(define (fast-expt b n)
  (cond ((= n 0) 1)
        ((even? n) (square (fast-expt b (/ n 2))))
        (else (* b (fast-expt b (- n 1))))))
\end{scheme}

\noindent
整数が偶数であるかテストする述語はプリミティブな手続、\code{remainder}を用い
以下のように定義される。

\begin{scheme}
(define (even? n)
  (= (remainder n 2) 0))
\end{scheme}

\noindent
\code{fast\-/expt}により展開されるプロセスは\( n \)の対数に従い記憶域とステップ数の両者が
増加します。これを理解するために\( b^{2n} \)を\code{fast\-/expt}を用いて演算するのに
\( b^n \)の演算よりただ1度のみ多くの乗算が必要であることに注目して下さい。
従って計算可能な指数のサイズは、可能な新規の乗算の度に(大体)倍になります。
このため\( n \)の指数により必要とされる乗算の数は2を底とする\( n \)の対数と同等の
早さにて増加します。このプロセスは\( \Theta(\log n) \)で増加します。
\footnote{より正確に言えば、必要とされる乗算の数は1から\( n \)の基数2の対数未満と
\( n \)の二進数表現における1の数の和になります。この合計が常に\( n \)の基数2の対数
の2倍よりも小さくなります。オーダ(次数)記法の定義に従う任意の定数 \( k_1 \)と
\( k_2 \)により、対数プロセスに対し、その対数の基数は問題ではないため、そのような
プロセス全ては\( \Theta(\log n) \)と説明されることが示されます}



\( \Theta(\log n) \)の増加と\( \Theta(n) \)の増加の違いは\( n \)が大きくなる程
顕著になります。例えば\( n \) = 1000の時\code{fast\-/expt}は14回しか乗算を必要としません。
\footnote{誰が数値を1000乗まで上げることを気にするのだろうかと思うかもしれません。
\link{Section 1.2.6}を参照して下さい}
連続する二乗の考えを用いて対数ステップ数の指数関数を求める反復アルゴリズムを考案
することも可能です。(\link{Exercise 1.16}参照) しかし反復アルゴリズムでは良くあること
ですが、これは再帰アルゴリズムのように直接的に書下すことができません。
\footnote{この反復アルゴリズムは古代から存在します。紀元前200年以前に\'Ach\'arya Pingala
により書かれた\textit{Chandah-sutra}には現れています}
\link{Knuth 1981}の4.6.3節にてこれと指数関数の他の方法について完全な議論と分析を行って
います。

\begin{quote}
\heading{\phantomsection\label{Exercise 1.16}Exercise 1.16:} 連続二乗と対数ステップ数を
用いる\code{fast\-/expt}のような反復指数関数プロセスを展開する
手続を設計せよ。(ヒント:\( (b^{n / 2})^2 = (b^2)^{n / 2} \)を用い、指数\( n \)、
基数\( b \)と共に追加の状態変数\( a \)を保持し状態変換を積\( ab^n \)が状態間に
おいて一定であるという方法にて定義せよ。
プロセスの最初において\( a \)は1を取り、回答はプロセスの終了時に\( a \)の値として
得られる。一般的に、状態間において一定である\newterm{invariant quantity}(\jnewterm{不変量})を
定義する技法は反復アルゴリズムの設計を考える上で強力な方法である。)
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.17}Exercise 1.17:} この節における
指数演算アルゴリズムは指数関数を乗算の繰り返しを用いて実行することを
基本としている。同様な手段で、整数の乗算を加算の繰り返しを用いて実行することも可能だ。
以下の乗算手続(私達の言語が足し算だけ可能で乗算はできないと仮定する)は\code{expt}手続の
類似である。

\begin{scheme}
(define (* a b)
  (if (= b 0)
      0
      (+ a (* a (- b 1)))))
\end{scheme}



このアルゴリズムは\code{b}に対し線形のステップ数を取る。今、和に加えて整数を
倍にする\code{double}と偶数を2で割る\code{halve}があるとする。これらを用いて
\code{fast\-/expt}に類似して対数ステップ数を持つ乗算手続を設計せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.18}Exercise 1.18:} \link{Exercise 1.16}と
\link{Exercise 1.17}の結果を用いて反復プロセスを生成する2つの
整数を乗算する手続を考案せよ。足し算、double、halveを用い対数ステップ数のアルゴリズム
を使用すること。
\footnote{このアルゴリズムは時折``ロシア農民のかけ算''として知られており、古くから
存在します。その使用例は最も古い数学の書籍の1つ、リンドパピルスにも見られます。これは
紀元前1700年頃にエジプトの筆記者、A'h-moseにより書かれた(そしてより古い書物から写本された)本です。}

\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.19}Exercise 1.19:} フィボナッチ数を
対数ステップ数にて求める巧みなアルゴリズムが存在する。\link{Section 1.2.2}の
\code{fib\-/iter}にて\( a \)と\( b \)状態変数の変換\( a \gets a + b \)と\( b \gets a \)を思い出そう。
この変換を\( T \)と呼び、1と0から始めて\( n \)回繰り返して\( T \)を適用した時に
Fib(\( n+1 \))とFib(\( n \))のペアを算出することに注意せよ。言い換えれば、フィボナッチ数は
変換\( T \)の\( n \)乗である\( T^n \)をペア(1, 0)から始めて適用するということである。
ここで\( T \)は\( p=0 \)、\( q=1 \)である時の変換\( T_{pq} \)の特別な形であると考えてみよう。
この時\( T_{pq} \)は\( (a, b) \)を\( a \gets bq + aq + ap \) and \( b \gets bp + aq \)とする。
もしそのような変換\( T_{pq} \)を二回適用した場合にその効果は同形変換 \( T_{p'q'} \)を一回
適用した場合と同じであることを示せ。また \( p \)と\( q \)に対する\( p' \) and \( q' \)を求めよ。
これは\code{fast\-/expt}手続におけるように、\( T^n \)を連続する平方にて求める。
これらを全て一緒に考慮して次の手続を完成させよ。これは対数ステップ数にて実行される。
\footnote{この課題は\link{Kaldewaij 1990}の例をベースにJoe Stoyにより提案されました}

\begin{scheme}
(define (fib n)
  (fib-iter 1 0 0 1 n))
(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~   ~\textrm{; compute \textit{p}'}~
                   ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~   ~\textrm{; compute \textit{q}'}~
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))
\end{scheme}
\end{quote}

\subsection{最大公約数}
\label{Section 1.2.5}



2つの整数\( a \)と\( b \)のGreatest Common divisor(\acronym{GCD}:最大公約数)とは
\( a \)と\( b \)の両者を余り無しで割り切れる最大の整数だと定義されます。例えば16と28
の\acronym{GCD}は4です。\link{Chapter 2}で分数の計算の実装方法について調査する時に
分数を約分するために\acronym{GCD}を求められるようになる必要が出てきます。
(分数を約分するためには分母と分子をそれらの\acronym{GCD}で割らねばなりません。例えば
16/28は4/7になります) 2つの整数の\acronym{GCD}を求める1つの方法はそれらを因数分解し、
共通因数を求める方法です。しかしより効率的な有名なアルゴリズムが存在します。



そのアルゴリズムの考えはもし\( r \)が\( a \)を \( b \)で割った時の余りである場合に
\( a \)と\( b \)の共通因数は正確に\( b \)と\( r \)の共通な因数であるという結果を基にして
います。従って次の等式を利用可能です。

\begin{example}
GCD(a,b) = GCD(b,r)
\end{example}

\noindent
引き続いて\acronym{GCD}を求める問題からより小さな値の整数のペアの\acronym{GCD}を
求める問題へと縮小していくことができます。例えば、

\begin{example}
GCD(206,40) = GCD(40,6)
            = GCD(6,4)
            = GCD(4,2)
            = GCD(2,0)
            = 2
\end{example}


\noindent
上の例では\acronym{GCD}(206, 40)を\acronym{GCD}(2, 0)へと縮小しています。その答は2です。
任意の2つの正の整数から始めて収縮を繰り返し実行することで常に最終的には2つ目の数値が0である
ペアにすることができます。その時、\acronym{GCD}の値はもう1つの値です。この\acronym{GCD}を
求める方法は\newterm{Euclid's Algorithm}\jnewterm{ユークリッドの互除法})として知られています。
\footnote{ユークリッドの互除法はユークリッドの\textit{Elements}(およそ紀元前300年
の原論第7巻)に載っていたためにそう呼ばれます。\link{Knuth (1973)}によると最も古く良く知られた
重要なアルゴリズムであると考えられるそうです。(\link{Exercise 1.18})の古代のエジプト人の
乗算方法は確かにこれよりも古いのですが、Knuthの説明ではユークリッドのアルゴリズムは最も古く
知られた一般的なアルゴリズムとして紹介されたものであり、説明的な例の集合では無いとのことです}


ユークリッドの互除法を手続として表すのは簡単です。

\begin{scheme}
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
\end{scheme}

\noindent
これが反復プロセスを生成し、そのステップ数は与えられた数値の対数で増加します。


ユークリッドの互除法により必要とされるステップ数が対数増加する事実がフィボナッチ数に
対する興味深い関係を持ちます。

\begin{quote}
\heading{Lam\'eの定理:}もしユークリッドの互除法があるペアの\acronym{GCD}を求めるのに
\( k \)ステップを必要とする場合、必ずペアの小さな値が\( k \)番目のフィボナッチ数より
大きいか等しい。
\footnote{この定理は1845年にフランスの数学者でありかつエンジニアでもあるGabriel Lam\'eにより
証明されました。彼は数理物理学への貢献の第一人者としても有名です。この定理を証明するには
\( a_k \ge b_k \)であるペア(\( a_k, b_k \))がユークリッドの互除法にて\( k \)ステップで停止
するか考えます。証明は\( (a_{k+1}, b_{k+1}) \to (a_k, b_k) \to (a_{k-1}, b_{k-1}) \)が
縮小プロセスにおける連続する3つのペアである場合、必ず\( b_{k+1} \ge b_k + b_{k-1} \)であること
を基にします。この仮定を確認するために縮小ステップの変換定義が\( a_{k-1} = b_k, b_{k-1} =  \)``\( a_k \)を
\( b_k \)で割った余り''であることについて考えます。2つ目の等式はある整数
\( q \)に対し\( a_k = qb_k + b_{k-1} \)が成り立つことを意味します。\( q \)は少なくとも1ですから
\( a_k = qb_k + b_{k-1} \ge b_k + b_{k-1} \)が成り立ちます。しかし以前の収縮ステップより
\( b_{k+1} = a_k \)です。従って\( b_{k+1} = a_k \ge b_k + b_{k-1} \)が成り立ちます。これで先程の
仮定は立証できました。アルゴリズムが停止するのに必要なステップ数を\( k \)とした場合に、これで定理は
\( k \)を用いた数学的帰納法にて証明可能となりました。\( k = 1 \)の時、これは単に\( b \)が
少なくともFib(1) = 1と同じ大きさであることを必要としますので真です。次に\( k \)に等しいかより小さい
整数全てにおいて定理が真であると仮定します。そして\( k + 1 \)でも成立することを証明します。
\( (a_{k+1}, b_{k+1}) \to (a_k, b_k) \to (a_{k-1}, b_{k-1}) \)が縮小プロセスにおける連続するペア
である場合に、数学的帰納法の仮定より、\( b_{k-1} \ge {\rm Fib}(k - 1) \)と
\( b_k \ge {\rm Fib}(k) \)が成り立ちます。ここで先程フィボナッチ数の定義と共に証明した式を
適用すると\( b_{k+1} \ge b_k + b_{k-1} \ge {\rm Fib}(k) + {\rm Fib}(k-1) = {\rm Fib}(k+1) \)
が導出されます。これで定理の証明は終了です。
}

\end{quote}

\noindent
この定理を用いてユークリッドの互除法の増加のオーダーを推測することが可能です。
\( n \)が手続の入力値の小さな値だとします。もしプロセスが\( k \)ステップ必要と
する場合、\( n \ge {\rm Fib}(k) \approx \varphi^k / \sqrt{5} \)が必ず成り立ちます。
従ってステップ数\( k \)は\( n \)の(\( \varphi \)を底とする)対数で増加します。
つまり増加のオーダーは\( \Theta(\log n) \)となります。


\begin{quote}
\heading{\phantomsection\label{Exercise 1.20}Exercise 1.20:} ある手続が
生成するプロセスはもちろんインタプリタにより使用されるルールに依存する。
例として上で説明した反復\code{gcd}手続について考える。この手続を\link{Section 1.1.5}で議論した
正規順評価で解釈、実行したと想定する。(\code{if}に対する正規順評価ルールは\link{Exercise 1.5}
を参照)。置換法を(正規順に)用いて\code{(gcd 206 40)}の評価により生成されるプロセスを
説明せよ。次に実際に実行された\code{remainder}命令を示せ。\code{(gcd 206 40)}の正規順評価に
おいて実際に実行された\code{remainder}命令は何回だろうか? 適用順評価では?
\end{quote}


\subsection{例: 素数判定}
\label{Section 1.2.6}



この節では整数\( n \)が素数であるかをテストする2つの方法について述べます。
1つは増加のオーダーが\( \Theta(\sqrt{n}) \)であり、他は``確率的''な
アルゴリズムで増加のオーダーが\( \Theta(\log n) \)です。
この節の最後の課題ではこれらのアルゴリズムに基づいたプログラミングのプロジェクトを
提案します。

\subsubsection*{約数を探す}



古代の時代から数学者は素数についての問題に魅惑されてきました。多くの人々が数値が素数であるか
の決定法の問題に取り組んできました。数値が素数であるかのテストの1つの方法は数値の約数を
求めることです。次のプログラムは1より大きな最も小さい整因子(約数)を与えられた\( n \)
に対して求めます。このプログラムはそれを直接的な方法、つまり2で始まる一連の整数により割り切れる
かどうかをテストすることにより行います。

\begin{scheme}
(define (smallest-divisor n) (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))
(define (divides? a b) (= (remainder b a) 0))
\end{scheme}

\noindent
数値が素数であるか以下のようにテストします: \( n \)は\( n \)自身が最小の約数である
場合、かつその場合に限り素数である。

\begin{scheme}
(define (prime? n)
  (= n (smallest-divisor n)))
\end{scheme}

\noindent
\code{find\-/divisor}の終了条件はもし\( n \)が素数でないならば\( \sqrt{n} \)より小さいか
または等しい約数を持つという事実に基づいています。
\footnote{もし\( d \)が\( n \)の約数である時、\( n / d \)もまた約数です。
しかし\( d \)と\( n / d \)の両者が共に\( \sqrt{n} \)より大きいことは有りません}
これはこのアルゴリズムが1から\( \sqrt{n} \)までの約数についてのみテストすれば良いことを
示します。結果として、\( n \)が素数であるかを判定するのに必要なステップ数の増加のオーダーは
\( \Theta(\sqrt{n}) \)となります。

\subsubsection*{フェルマーテスト}



\( \Theta(\log n) \)の素数判定はフェルマーの小定理として知られる数論の結果に
基づきます。\footnote{Pierre de Fermat (1601-1665)は現在の整数論の創始者と
考えられています。彼は多くの重要な数論上の事実について発見しました。しかし彼は
通常その結果のみを公表し、証明を与えませんでした。フェルマーの小定理は彼が1640年に
書いた手紙に記録されています。最初に出版された証明は1736年にオイラーにより与え
られました。(それより早く、同様の証明がライプニッツの出版されなかった原稿に
見つかっています)。最も有名なフェルマーの数式は---フェルマーの最終定理として知られ---
1637年に彼の所有した書籍(3世紀のギリシャ人数学者Diophantusによる)\textit{Arithmetic}
に``私は真に驚くべき証明を発見したが、書き残すにはこの余白は狭すぎる''という所感
と共にメモされた物です。フェルマーの最終定理の証明を見つけることは数論において
最も有名な挑戦の1つとなりました。完全な解はついに1995年にプリンストン大学の
Andrew Wilesにより与えられました。}

\begin{quote}
\heading{フェルマーの小定理:} \( n \)が素数かつ\( a \)が\( n \)より小さい任意の正の整数である時、
\( a \)の\( n \)乗は法\( n \)に関して\( a \)と合同である。
\end{quote}

\noindent
(2つの数値はその両方が\( n \)で割った時に同じ余りを持つ場合、\newterm{congruent modulo} \( n \)
(\jnewterm{法\( n \)に関して合同})と
呼ばれます。また\( a \)を\( n \)で割った時の余りは\( a \) \newterm{modulo} \( n \)の\newterm{remainder}(剰余)、
または単純に\( a \) \newterm{modulo} \( n \)と呼ばれます。)


もし\( n \)が素数でなければ一般に\( a < n \)の多くの値は上記の関係を満しません。
これが次の素数判定のアルゴリズムへと導きます: ある値\( n \)が与えられた時、\( a < n \)と
なる乱数を取り\( a^n \) modulo \( n \)の剰余を求めます。もし結果が\( a \)に等しくない時、
\( n \)は確実に素数ではありません。もし\( a \)に等しいならば\( n \)が素数である確率は良いと言えます。
ここで別の乱数\( a \)を取り同じ方法でテストを行います。それもまた等式を満すのであれば\( n \)が
素数である確率はより確からしくなります。より多くの\( a \)について試験を行えば、結果の確からしら
を増すことが可能です。このアルゴリズムはフェルマーテストとして知られています。


フェルマーテストを実装するには(ある数値の指数関数 modulo 別の数値)を求める手続が必要です。

\begin{scheme}
(define (expmod base exp m)
  (cond ((= exp 0) 
         1)
        ((even? exp)
         (remainder 
          (square 
           (expmod base (/ exp 2) m))
          m))
        (else
         (remainder
          (* base 
             (expmod base (- exp 1) m))
          m))))

\end{scheme}

\noindent
これは\link{Section 1.2.4}の\code{fast\-/expt}手続にとても似ています。連続する二乗を用いるため、ステップ数の増加は
"指数"引数の対数になります。
\footnote{指数\( e \)が1より大きい場合の縮小ステップは、任意の整数\( x \),
\( y \), \( m \)に対し\( x \) modulo \( m \)と\( y \) modulo \( m \)を別々に求め、これらを
掛け、その結果の法\( m \)に関する剰余を求めることで(\( x \)と\( y \)の積 modulo \( m \))を求めることが
できるという事実に基づきます。例えば\( e \)が偶数の場合に\( b^{e / 2} \) modulo \( m \)を求め、
その二乗を取り、法\( m \)に関する剰余を得ます。このテクニックはとても役に立ちます。\( m \)より
もはるかに大きな数値を一切扱う必要無しに演算を行うことが可能だからです。
(\link{Exercise 1.25}と比較せよ)}



フェルマーテストは1から\( n-1 \)までの乱数\( a \)を選択し、\( a \)の\( n \)乗のmodulo \( n \)
が\( a \)に等しいかをチェックすることで行います。乱数\( a \)は手続\code{random}を用いて選択しますが、それは
Schemeのプリミティブな手続に存在する前提です。\code{random}は入力の整数よりも少ない非負数な整数
を返します。そのため1から\( n-1 \)の乱数を得るには\code{random}に\( n-1 \)を入力とし、結果に1を足します。

\begin{scheme}
(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))
\end{scheme}

\noindent
以下の手続はパラメータにより与えられた数値の回数分、テストを実行します。
テストが毎回成功すればtrueを、そうでなければfalseを返します。

\begin{scheme}
(define (fast-prime? n times)
  (cond ((= times 0) true)
        ((fermat-test n) (fast-prime? n (- times 1)))
        (else false)))
\end{scheme}


\subsubsection*{確率的手法}


フェルマーテストは正確さが保証された多くの親しみのあるアルゴリズムとは性格が異なっています。
ここでは得られた結果は確率的にのみ正しいと言えます。より正確には、\( n \)が常にフェルマーテストに
失敗するのであれば\( n \)が素数でないことは確実です。しかし\( n \)がテストをパスした
という結果は、とても強い目安ではありますが、\( n \)が素数であることを保証しません。
ここで言いたかったのは任意の数値\( n \)に対し、十分な回数のテストを行い\( n \)が常にテストを
パスする場合、この素数判定が間違いである可能性は思い通りに小さくすることが
可能だということでした。



残念ながらこの主張は完全には正しくありません。実はフェルマーテストを騙してしまう
数値が存在します。\( a < n \)となる全ての整数において、\( n \)が素数ではなく、しかし、
\( a^n \)が\( n \)を法とする\( a \)に合同であるような数値\( n \)。
そのような数値はとても稀です。そのためフェルマーテストは実際にとても信用が高いと言えます。
\footnote{\label{Footnote 1.47} フェルマーテストを騙してしまう数は\newterm{Carmichael numbers}(\jnewterm{カーマイケル数})
と呼ばれとても稀であるということ以外はあまり良くわかっていません。100,000,000未満には255の
カーマイケル数が存在します。最小の物からいくつか上げると561, 1105, 1729,
2465, 2821,  6601です。任意に選ばれたとても巨大な数値の素数性をテストする場合にフェルマーテスト
を騙す数値に当る確率はコンピュータが``正確な''アルゴリズムを実行する際に宇宙放射線がエラーを
引き起す確率よりも低いです。2つ目の理由でなく、最初の理由からアルゴリズムを不適切だと考えることは
数学とエンジニアリングの間の違いを示しています。}



フェルマーテストのバリエーションには騙されない物も複数あります。これらのテストでは
フェルマーテストと同様に、整数\( n \)の素数判定を乱数\( a < n \)を選択し、
\( n \)と\( a \)に依る何らかの条件をチェックします。(そのようなテストの例は
\link{Exercise 1.28}を参照して下さい)。一方でフェルマーテストとは対照的に、任意の
\( n \)に対し\( n \)が素数でなければ\( a < n \)の多くに対し条件が成立しないことを
証明できます。従って\( n \)がいくつかの乱数\( a \)に対してテストが通るのであれば、
\( n \)が素数である可能性は五分五分より高くなります。もし\( n \)が2つの乱数である\( a \)
に対してテストを通れば、\( n \)が素数である確率は4分の3よりも高くなります。テストを
何度も乱数\( a \)を選択しながら実行することでエラーの確率を思い通りに小さくすることが
可能です。



エラーの確率が自由裁量で小さくできることが証明可能なテストの存在はこのタイプの
アルゴリズムへの興味を起こしました。それらは\newterm{probabilistic algorithms}
(\jnewterm{確率的アルゴリズム})と呼ばれます。この領域にはとても多くの研究活動が存在し、
確率的アルゴリズムは多くの現場に効果的に適用されてきました。\footnote{確率的
素数判定法の最も特筆すべき適用例は暗号の領域です。現時点では任意の200桁の数値を
因数分解することは計算能力上不可能ですが、そのような数値の素数判定はフェルマー
テストにより数秒で行うことが可能です。この事実が\link{Rivest et al. (1977)}により
提案された``解読不能な符号''を構築するためのテクニックの基を形成しました。
その結果として\jnewterm{RSAアルゴリズム}は電子通信上のセキュリティを拡張する
テクニックとして広く利用されるようになりました。このことと関連する開発により、
素数の研究は一時は``純粋''数学のトピックの典型例でありその世界自身のために
のみ研究される物だと考えられてきましたが、現在では暗号、電子資産の転送と情報検索に
対する重要で現実的な適用例を持つことが判明しました。}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.21}Exercise 1.21:}\code{smallest\-/divisor}手続を
用いて次の数値の最小の約数を求めよ：199、1999、19999
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.22}Exercise 1.22:} 多くのLisp実装は
\code{runtime}と呼ばれるプリミティブな手続を持っておりそれはシステムが実行
している間の(例えばマイクロ秒で測定された)時間を整数にて返す。次の\code{timed\-/prime\-/test}
手続は整数\( n \)と共に呼んだ時、\( n \)を表示し、\( n \)が素数であるかチェックする。
\( n \)が素数であれば手続は3つのアスタリスクとテスト実行に掛った時間を表示する。

\begin{scheme}
(define (timed-prime-test n)
  (newline) (display n) (start-prime-test n (runtime)))
(define (start-prime-test n start-time)
  (if (prime? n) 
      (report-prime (- (runtime) start-time))))
(define (report-prime elapsed-time)
  (display " *** ") (display elapsed-time))
\end{scheme}

この手続を用いて指定した範囲の連続した奇数について素数判定を行う手続、\code{search\-/for\-/primes}
を書け。その手続を用いて1000、10,000、100,000より大きな素数を3つ見つけよ。
各素数のテストに必要な時間を記録せよ。テストアルゴリズムは10,000辺りの素数を判定する時、
約\( \sqrt{10} \)倍、1000辺りの素数をテストするより時間がかかるはずである。
あなたの結果はこれに従っているか?
100,000や1,000,000のデータに対して\( \Theta(\sqrt{n}) \)の予想は当たっているか?
あなたの結果は演算に必要なステップ数に比例して実行時間が増えるという考えに矛盾していないか?

\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.23}Exercise 1.23:} この節の最初で示された
\code{smallest\-/divisor}手続は必要の無いテストを数多く行っている：
数値が2で割ることができるかチェックした後に、それがより大きな偶数にて割り切れるかチェックを
行う必要は無い。これにより\code{test\-/divisor}の値は2, 3, 4, 5, 6, \( \dots \)ではなく、
2, 3, 5, 7, 9, \( \dots \)であるべきだと提案できる。この変更を実装するために、入力が2であれば3
を返し、それ以外では入力に2を足した値を返す手続\code{next}を定義せよ。\code{smallest\-/divisor}手続を
変更し、\code{(+ test\-/divisor 1)}の代わりに\code{(next test\-/divisor)}を使用せよ。
\code{timed\-/prime\-/test}をこの変更したバージョンの\code{smallest\-/divisor}を用いて
\link{Exercise 1.22}で見つけた12の素数に対しテストを行え。
この変更はテストステップを半分にするため2倍速く実行されることをが予測される。
この予測が確認できるだろうか? もしそうでなければ2つのアルゴリズムのスピードの比率は
どのような値が確認できるか? 2と異なる結果をどのように説明するか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.24}Exercise 1.24:} \link{Exercise 1.22}の
\code{timed\-/prime\-/test}手続を変更し\code{fast\-/prime?}(フェルマー法)を用い、
課題で見つけた12の素数をそれぞれテストせよ。フェルマーテストは\( \Theta(\log n) \)で
増加するが、1000に近い素数をテストするのに必要な時間と比べ1,000,000付近の素数をテストする
のに必要な時間をどれ程と見繕うだろうか? 実際との相違をどのように説明できるか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.25}Exercise 1.25:} Alyssa P. Hackerは
\code{expmod}を書くにあたって多くの余分な仕事を行ったと文句を
言った。結局のところ我々は既に指数演算のやり方を知っているのだから単純に
以下のように書くことができたはずだと彼女は言った。

\begin{scheme}
(define (expmod base exp m)
  (remainder (fast-expt base exp) m))
\end{scheme}

彼女は正しいだろうか? この手続は最初の素数判定と同様にうまく行えるだろうか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.26}Exercise 1.26:} Louis Reasonerは
\link{Exercise 1.24}を行うのに随分と苦労した。彼の\code{fast\-/prime?}
テストは彼の\code{prime?}テストよりも随分遅いようだ。Louisは友達のEva Lu Atorを呼んで
助けを求めた。彼らがLouisのコードを試してみると、Louisが\code{expmod}手続を\code{square}手続を呼ぶのでなく、
明示的に乗算を用いていることを見つけた。

\begin{scheme}
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (* (expmod base (/ exp 2) m)
                       (expmod base (/ exp 2) m))
                    m))
        (else
         (remainder (* base 
                       (expmod base (- exp 1) m))
                    m))))
\end{scheme}



``これがどんな違いを生んでいるのかわからないよ''とLouisは言った。``私にはわかる''と
Evaが言う。``手続をそのように記述することで、\( \Theta(\log n) \)のプロセスを
\( \Theta(n) \)のプロセスに変えてしまったの。''
説明せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.27}Exercise 1.27:} \link{Footnote 1.47}にて
並べられたカーマイケル数が実際にフェルマーテストを騙すか実演せよ。
整数\( n \)を取り\( a^n \)が\( a \)と法\( n \)に関して合同であるか全ての\( a < n \)
に対しテストを行う手続を書き、与えられたカーマイケル数に対してその手続を試せ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.28}Exercise 1.28:} 騙されないフェルマーテストの
1つの変形として\newterm{Miller-Rabin test} (\link{Miller 1976};
\link{Rabin 1980})がある。これはフェルマーの小定理の代替形から始めるが、それは\( n \)
が素数でかつ\( a \)が\( n \)以下の任意の正の整数である時、\( a \)の\( (n-1) \)乗は
法\( n \)に関して1と合同であると定める。Miller-Rabinテストで数値\( n \)の素数判定を行うには
乱数\( a < n \)を選択し、\( a \)の\( (n-1) \)乗の\( n \)を法とする剰余を
\code{expmod}手続を用いて求める。しかし、\code{expmod}手続中で二乗するステップにおいて毎回、
``自明でない法\( n \)に関する1の平方根''を見つけたかチェックを行う。これは1または\( n-1 \)に
等しくない数値でかつ、法\( n \)に関して二乗した値の剰余が1に等しい数値である。そのような
自明でない1の平方根が存在すれば\( n \)が素数ではないことが証明可能である。
またもし\( n \)が素数でない奇数である時、少なくとも\( a < n \)の半分において
このような方法で\( a^{n-1} \)を演算すると自明でない法\( n \)に関する1の平方根が現れることが
証明可能である。(これがなぜMiller-Rabinテストが騙されないかである)。
\code{expmod}手続を変更し自明でない1の平方根を見つけた時合図を送るようにし、それを用いて
\code{fermat\-/test}に似たMiller-Rabinテストを実装せよ。既知の素数、非素数を用いてあなたの手続を
チェックせよ。ヒント：\code{expmod}に合図を送らせる簡単な方法は0を返させることである。

\end{quote}

\vspace{0.5em}
\section{高階手続による抽象の形式化}
\label{Section 1.3}



私達はここまでで手続が事実上、特定の値から独立した数値への複合命令を記述する
抽象化であることを見てきました。例えば、

\begin{scheme}
(define (cube x) (* x x x))
\end{scheme}

\noindent
これは特定の値の立方について述べているのではなく、任意の数値の立方を得るための手法
について述べている訳です。もちろんこの手続を定義することなく常に以下のような式を書くことで
やっていくことも可能です。
\begin{scheme}
(* 3 3 3)
(* x x x)
(* y y y)
\end{scheme}

\noindent
そして明示的に\code{cube}について触れないことも可能でしょう。しかしこれはとても
大きな不便を与えます。高レベルな命令の用語ではなく常に言語内にプリミティブとして
偶然存在するレベルの特定の命令レベルにて働かざるを得なくなります(このケースでは乗算です)。
私達のプログラムは立方を計算可能ですが、私達の言語は立方のコンセプトを表現する能力が
欠けているかもしれません。私達が強力なプログラミング言語から望むべき物の1つは共通の
パターンに対し名前を付けることで抽象を構築し、その後抽象化の用語にて直接働く能力です。
手続はこの能力を与えます。これがなぜ原始的な物を除いた全てのプログラミング言語にて
手続を定義するメカニズムが含まれているかの理由です。



それにも関わらず数値演算ですら、もし手続のパラメータが数値のみであると制約されていれば
抽象化を行うには我々の能力は非常に大きく制限されていると言えるでしょう。
しばしば同じプログラムのパターンがいくつもの異なる手続にて使用されます。そのような
パターンを表現するには引数として手続を受け入れることができるか、手続を値として返すような
手続を構築する必要が出てきます。手続を操作する手続は\newterm{higher-order procedures}(\jnewterm{高階手続})
と呼ばれます。この節では高階手続がどのように強力な抽象化メカニズムを果たし、言語の表現力を
幅広く増大するかを示します。



\subsection{引数としての手続}
\label{Sec. 1.3.1}
\label{Section 1.3.1}


次の3つの手続について考えてみて下さい。1つ目は\code{a}から\code{b}の整数の合計を
計算します。

\begin{scheme}
(define (sum-integers a b)
  (if (> a b) 
      0
      (+ a (sum-integers (+ a 1) b))))
\end{scheme}

\noindent
2つ目は与えられた範囲の整数の立方の合計を計算します。

\begin{scheme}
(define (sum-cubes a b)
  (if (> a b)
      0
      (+ (cube a)
         (sum-cubes (+ a 1) b))))
\end{scheme}

\noindent
3つ目は以下の級数の一連の項の合計を計算します。
\begin{comment}

\begin{example}
  1       1       1
----- + ----- + ------ + ...
1 * 3   5 * 7   9 * 11
\end{example}

\end{comment}
\begin{displaymath}
 {1\over1\cdot 3} +  {1\over5\cdot 7} + {1\over9\cdot 11} + \dots, 
\end{displaymath}
\noindent
これは\( \pi / 8 \)に(とてもゆっくりと)収束します。\footnote{この級数は
一般に等価である形式\( {\pi\over4} = 1 - {1\over3} + {1\over5} - {1\over7} + \dots \)
にて記述されるLeibnizによる物です。私達はこれがある高級な数学上のトリックに使われるのを
\link{Section 3.5.3}で見ることになります。}

\begin{scheme}
(define (pi-sum a b)
  (if (> a b)
      0
      (+ (/ 1.0 (* a (+ a 2)))
         (pi-sum (+ a 4) b))))
\end{scheme}

\noindent
これらの3つの手続は明確に共通な基礎をなすパターンを共有しています。それらは
ほとんどの部分が同一で、手続の名前、和を求める項を\code{a}を用いて演算する関数、\code{a}の
次の値を与える関数のみが異なります。各手続を同じテンプレートを用いて枠を埋めることで
生成することができそうです。

\begin{scheme}
(define (~\( \dark \langle \)~~\var{\dark name}~~\( \dark \rangle \)~ a b)
  (if (> a b)
      0
      (+ (~\( \dark \langle \)~~\var{\dark term}~~\( \dark \rangle \)~ a)
         (~\( \dark \langle \)~~\var{\dark name}~~\( \dark \rangle \)~ (~\( \dark \langle \)~~\var{\dark next}~~\( \dark \rangle \)~ a) b))))
\end{scheme}

\noindent
このような共通パターンの存在は便利な抽象化が表に浮かび上がるのを待っていることを
示す強力な証拠です。実際に数学者は大昔に\newterm{summation of a series}(\jnewterm{級数の和})の
抽象化を特定し``シグマ記法''を開発しました。つまり、
\begin{comment}

\begin{example}
  b
 ---
 >    f(n) = f(a) + ... + f(b)
 ---
 n=a
\end{example}

\end{comment}
\begin{displaymath}
 \sum_{n=a}^b f(n) = f(a) + \ldots + f(b), 
\end{displaymath}
\noindent
このように表現します。シグマ記法の力は数学者に特定の合計のみについてではなく、
総和のコンセプト自身について取り扱うことを可能にしました。例えば特定の級数の和を求めることから
独立して一般的な総和についての結果を形式化することを可能としたのです。





同様に、プログラムの設計者である私達は言語に、特定の総和を求める手続のみでなく、
総和自身のコンセプトを表現する手続を書くことができるのに十分に強力になって欲しいと
願うでしょう。そうすることが直ぐに私達の手続言語にて上記にて示された共通テンプレートを
用いて、``枠''を形式パラメータに変換することで可能です。

\begin{scheme}
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))
\end{scheme}

\noindent
\code{sum}が引数として下限と上限の\code{a}と\code{b}を手続\code{term}と\code{next}と一緒に
取ることに注意して下さい。\code{sum}はこれから行うように好きな手続を使用することが
できます。例えばそれを(引数に1を足す手続\code{inc}と共に)\code{sum\-/cubes}の定義に利用
可能です。

\begin{scheme}
(define (inc n) (+ n 1))
(define (sum-cubes a b)
  (sum cube a inc b))
\end{scheme}

\noindent
これを用いて整数1から10の立方の和を求めることができます。

\begin{scheme}
(sum-cubes 1 10)
~\textit{3025}~
\end{scheme}

\noindent
termを求めるidentityプロシジャの助けを借りて、\code{sum}を用いて\code{sum\-/integers}
の定義ができます。

\begin{scheme}
(define (identity x) x)
(define (sum-integers a b)
  (sum identity a inc b))
\end{scheme}

\noindent
これで1から10までの整数の和を求められます。

\begin{scheme}
(sum-integers 1 10)
~\textit{55}~
\end{scheme}

\noindent
\code{pi\-/sum}も同様に定義可能です。\footnote{ブロック構造(\link{Section 1.1.8})を\code{pi\-/sum}の中に
\code{pi\-/next}と\code{pi\-/term}の定義を埋め込むために使用していることに注意して下さい。
これらの手続は任意の他の手続に対し有用ではなかろうためです。
それらを一緒にどのように取り除くかについては\link{Section 1.3.2}で説明します。}

\begin{scheme}
(define (pi-sum a b)
  (define (pi-term x)
    (/ 1.0 (* x (+ x 2))))
  (define (pi-next x)
    (+ x 4))
  (sum pi-term a pi-next b))
\end{scheme}

\noindent
これらの手続を用いて\( \pi \)の近似値を求められます。

\begin{scheme}
(* 8 (pi-sum 1 1000))
~\textit{3.139592655589783}~
\end{scheme}

\noindent
\code{sum}を手に入れたことで、それを構築用ブロックとしてより多くのコンセプトの形式化にて
利用可能です。例えば関数\( f \)の\( a \)と\( b \)の限度値の間の定積分は以下の式を
用いて小さな値\( dx \)に対し数値的に近似可能です。
\begin{comment}

\begin{example}
/b     /  /     dx \    /          dx \    /           dx \      \
|  f = | f| a + -- | + f| a + dx + -- | + f| a + 2dx + -- | + ...| dx
/a     \  \     2  /    \          2  /    \           2  /      /
\end{example}

\end{comment}
\begin{displaymath}
{\int_a^b \!\!\! f} \, = {\left[\;f\!\left(a + {dx\over 2}\right) 
		+ f\!\left(a + dx + {dx\over 2}\right) 
		+ f\!\left(a + 2dx + {dx\over 2}\right) + \,\dots \;\right] \! dx} 
\end{displaymath}
\noindent
これを直接、手続として表現します。

\begin{scheme}
(define (integral f a b dx)
  (define (add-dx x) 
    (+ x dx))
  (* (sum f (+ a (/ dx 2.0)) add-dx b) 
     dx))

(integral cube 0 1 0.01)
~\textit{.24998750000000042}~

(integral cube 0 1 0.001)
~\textit{.249999875000001}~
\end{scheme}

\noindent
(\code{cube}の0から1の実際の定積分の値は1/4です。)

\begin{quote}
\heading{\phantomsection\label{Exercise 1.29}Exercise 1.29:} シンプソンの公式は
上記にて示された方法よりもより正確な数値積分の方法である。
シンプソンの公式を用いて\( a \)と\( b \)の間の\( f \)の定積分は次のように
近似される。
\begin{comment}

\begin{example}
h
- (y_0 + 4y_1 + 2y_2 + 4y_3 + 2y_4 + ... + 2y_(n-2) + 4y_(n-1) + y_n)
3
\end{example}

\end{comment}
\begin{displaymath}
 {h\over 3}(y_0 + 4y_1 + 2y_2 + 4y_3 + 2y_4 + \ldots + 2y_{n-2} + 4y_{n-1} + y_n), 
\end{displaymath}
\noindent
ここで\( h = (b - a) / n \)、\( n \)は偶数、\( y_k = f(a + kh) \)である。
(\( n \)を増やすことで近似の精度を高めることができる)。
\( f \), \( a \), \( b \), \( n \)を引数に取りシンプソンの公式を用いて求めた定積分の
値を返す手続を定義せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.30}Exercise 1.30:} 上の\code{sum}手続は
線形再帰を生成する。手続は和の計算が線形で行われるよう書き直すことが可能だ。
次の定義にて消された表記を埋め、どのように行うのか示せ。

\begin{scheme}
(define (sum term a next b)
  (define (iter a result)
    (if ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~
        ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~
        (iter ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~)))
  (iter ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.31}Exercise 1.31:} \begin{enumerate}[a]

\item
\code{sum}手続は高階手続として捉えられる非常に多くの数の同様な抽象化の最も簡単な物に
すぎない。\footnote{\link{Exercise 1.31}から\link{Exercise 1.33}の目的は、
多くの一見では異なる操作を統一するために、適切な抽象化を利用することで達成される表現力を実演することです。
しかし、集積やフィルタリングは洗練された考えではありますが、この時点ではそれらを使用するのに我々の両手が縛られて
いるようなものです。私達はまだこれらの抽象化のための適切な組み合わせの手段を与えるためのデータ構造
を持っていないためです。私達は\link{Section 2.2.3}にてこれらの考えに立ち戻り、集積とフィルタを
組み合わせるためのインターフェイスとして\newterm{sequences} (\jnewterm{列})をどのように使うのかを示し
さらに一層強力な抽象化を構築します。そこではこれらの手法が実際にどのようにしてプログラムを設計するのに
強力で洗練されたアプローチとして役に立つのかを学びます。}
\code{product}と呼ぶ与えられた範囲の点の関数値の積を返す類似の手続を書け。
どのようにして\code{product}を用いて\code{factorial}を定義するのか示せ。また\code{product}を用いて
次の式を使用して\( \pi \)の近似値を計算せよ。\footnote{この式は17世紀に英国人数学者John Wallisにより
発見されました。}

\begin{comment}

\begin{example}
pi   2 * 4 * 4 * 6 * 6 * 8 ...
-- = -------------------------
 4   3 * 3 * 5 * 5 * 7 * 7 ...
\end{example}

\end{comment}
\begin{displaymath}
 {\pi\over 4} = {2\cdot 4\cdot 4\cdot 6\cdot 6\cdot 8\dots\over 
		   3\cdot 3\cdot 5\cdot 5\cdot 7\cdot 7\dots}\,. 
\end{displaymath}
\item
もしあなたの\code{product}手続が再帰プロセスを生成するのであれば線形プロセスを生成するものを書け。
もし線形プロセスを生成するのであれば再帰プロセスを生成するものを書け。

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.32}Exercise 1.32:} \begin{enumerate}[a.]

\item
\code{sum}と\code{product} (\link{Exercise 1.31})は両方とも、汎用の集積関数を用いて
項の集合を結合する\code{accumulate}(集積)と呼ばれるより一般的な目的の特別なケースに過ぎない。

\begin{scheme}
(accumulate combiner null-value term a next b)
\end{scheme}



\code{accumulate}は引数として\code{sum}と\code{product}と同じく項と範囲の指定を
(2つの引数の)\code{combiner}手続と \code{null-value}を共に得る。\code{combiner}は
どのように現在の項が以前の項の集積と結合されるかを指定し、 \code{null-value}は
項が尽きた時に使用する基となる値を指定する。\code{accumulate}を書き\code{sum}と\code{product}
の両者がどのように簡単な\code{accumulate}の呼び出しで定義できるかを示せ。

\item
あなたの\code{accumulate}が再帰プロセスを生成するのなら線形プロセスを生成する物を書け。
もし線形プロセスを生成するのならば再帰プロセスを生成する物を書け。

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.33}Exercise 1.33:} より汎用的なバージョンの
\code{accumulate} (\link{Exercise 1.32})を結合される項の
\newterm{filter}(\jnewterm{フィルタ})の概念を紹介することで得ることが可能だ。指定された条件を
満たす範囲の値から導かれる項のみを連結する。結果としての\code{filtered\-/accumulate}抽象は
\code{accumulate}と同じ引数を追加の1引数の述語と共に取り、述語はフィルタを指定する。
手続としての\code{filtered\-/accumulate}を書け。以下を\code{filtered\-/accumulate}を用いて
どのように表現するかを示せ。

\begin{enumerate}[a]

\item
\( a \)と\( b \)の区間の素数の二乗の和(あなたは既に\code{prime?}述語を書いていると前提する)

\item
全ての\( n \)未満の正の整数でかつ\( n \)に対して互いに素(つまり
\( {\rm GCD}(i, n) = 1 \)となる全ての整数\( i < n \))の積

\end{enumerate}
\end{quote}


\subsection{\code{lambda}を用いた手続の構築}
\label{Section 1.3.2}



\link{Section 1.3.1}に示すよう\code{sum}を使用する時、\code{pi\-/term}や\code{pi\-/next}のような自明な
手続を高階手続にて引数として使うためだけに定義せねばならないのはひどく不恰好に見えます。
\code{pi\-/next}や\code{pi\-/term}を定義する代わりに、``入力値に4を足す手続''や``入力値と入力値に
2を足した数の積の逆数を返す手続''を直接指定する方法を持つほうがより便利になるでしょう。
これは手続を作成する特殊形式\code{lambda}を紹介することで可能です。
\code{lambda}を用いることで先程行いたかったことを以下のように記述できます。

\begin{scheme}
(lambda (x) (+ x 4))
\end{scheme}

\noindent
そして

\begin{scheme}
(lambda (x) (/ 1.0 (* x (+ x 2))))
\end{scheme}

\noindent
次に\code{pi\-/sum}手続は補助的な手続を定義すること無しに表現が可能となります。

\begin{scheme}
(define (pi-sum a b)
  (sum (lambda (x) (/ 1.0 (* x (+ x 2))))
       a
       (lambda (x) (+ x 4))
       b))
\end{scheme}

\noindent
同様に\code{lambda}を使用して、\code{integral}手続を補助的な手続\code{add\-/dx}を定義することなく
書くことが可能です。

\begin{scheme}
(define (integral f a b dx)
  (* (sum f
          (+ a (/ dx 2.0))
          (lambda (x) (+ x dx))
          b)
     dx))
\end{scheme}

\noindent
一般的に、\code{lambda}は\code{define}と同様に手続を作成しますが、手続に対して
名前が指定されないことが異なります。

\begin{scheme}
(lambda (~\( \dark \langle \)~~\var{\dark formal-parameters}~~\( \dark \rangle \)~) ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
結果としての手続は\code{define}を用いて作成した手続と同じです。ただ1つの違いは
それが環境においてどのような名前にも結び付けられていないことです。

\begin{scheme}
(define (plus4 x) (+ x 4))
\end{scheme}

\noindent
上記は以下と等価です。

\begin{scheme}
(define plus4 (lambda (x) (+ x 4)))
\end{scheme}

\noindent
\code{lambda}式は以下のように読むことができます。

\begin{scheme}
(lambda                     (x)     (+   x     4))
    |                        |       |   |     |
手続は                    引数xを持ち 足す x と  4
\end{scheme}

\noindent
任意の値として手続を持つ式と同様に、\code{lambda}式は複合式において
オペレータとして使用することが可能です。例えば、

\begin{scheme}
((lambda (x y z) (+ x y (square z)))
 1 2 3)
~\textit{12}~
\end{scheme}

\noindent
またはより一般的に、私達が通常手続の名前を使用する任意の文脈において使用可能です。
\footnote{Lispを学ぶ人にとっては\code{lambda}という名前よりは\code{make\-/procedure}の様な
名前を使用したほうがより判りやすいか、または恐しく思わせたりはしないでしょう。
しかしこの慣習はしっかりと根付いた物です。この表記は\( \lambda \)-calculus(ラムダ計算)
という数理論理学者Alonzo \link{Church (1941)}により発表された数学上の形式主義の
名から受け入れられています。Churchは\( \lambda \)計算を関数と関数適用の概念を学ぶための
厳格な基礎として与えるために開発しました。 \( \lambda \)計算はプログラミング言語の
意味の数学上の研究のための基礎的なツールとなりました。}

\subsubsection*{ローカル変数使用のため\code{let}を用いる}



別の\code{lambda}使用法にはローカル変数の作成があります。形式的パラメータに
束縛されていないローカル変数を手続で必要とする場合は良くあります。
例えば以下の関数を演算したいとします。
\begin{comment}

\begin{example}
f(x,y) = x(1 + xy)^2 + y(1 - y) + (1 + xy)(1 - y)
\end{example}

\end{comment}
\begin{displaymath}
 f(x,y) = x(1 + xy)^2 + y(1 - y) + (1 + xy)(1 - y), 
\end{displaymath}
\noindent
これは以下のようにも表現できます。
\begin{comment}

\begin{example}
     a = 1 + xy
     b = 1 - y
f(x,y) = xa^2 + yb + ab
\end{example}

\end{comment}
\begin{displaymath}
% \eqalign{	a 	&= 1 + xy, \cr
% 		b 	&= 1 - y,  \cr
% 		f(x,y) 	&= xa^2 + yb + ab. \cr}
\begin{array}{r@{{}={}}l}
  a 	  &  1 + xy, \\
  b 	  &  1 - y,  \\
  f(x,y)  &  xa^2 + yb + ab.
\end{array}
\end{displaymath}


\( f \)を求める手続を書く場合、\( x \)と\( y \)のみでなく中間値の名前として
\( a \)や\( b \)をローカル変数として含みたくなるでしょう。これを実現する1つの
方法として補助的な手続をローカル変数を束縛するため使用することがあります。

\begin{scheme}
(define (f x y)
  (define (f-helper a b)
    (+ (* x (square a))
       (* y b)
       (* a b)))
  (f-helper (+ 1 (* x y))
            (- 1 y)))
\end{scheme}

\noindent
もちろん、\code{lambda}式を用いて無名手続をローカル変数の束縛のため指定することも
可能です。\code{f}のボディはすると手続への単一の呼び出しになります。

\begin{scheme}
(define (f x y)
  ((lambda (a b)
     (+ (* x (square a))
        (* y b)
        (* a b)))
   (+ 1 (* x y))
   (- 1 y)))
\end{scheme}

\noindent
この構成はとても便利で\code{let}と呼ばれる特殊形式がその使用をより便利にするために
用意されています。\code{let}を用いることで手続\code{f}は以下のようになります。

\begin{scheme}
(define (f x y)
  (let ((a (+ 1 (* x y)))
        (b (- 1 y)))
    (+ (* x (square a))
       (* y b)
       (* a b))))
\end{scheme}

\noindent
\code{let}式の一般的な形式は次のとおりです。

\begin{scheme}
(let ((~\( \dark \langle \)~~\( \dark var_1 \)~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark exp_1 \)~~\( \dark \rangle \)~)
      (~\( \dark \langle \)~~\( \dark var_2 \)~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark exp_2 \)~~\( \dark \rangle \)~)
      ~\( \dots \)~
      (~\( \dark \langle \)~~\( \dark var_n \)~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark exp_n \)~~\( \dark \rangle \)~))
   ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
これは以下のように考えることが可能です。

\begin{scheme}
let ~\( \dark \langle \)~~\( \dark var_1 \)~~\( \dark \rangle \)~ have the value ~\( \dark \langle \)~~\( \dark exp_1 \)~~\( \dark \rangle \)~ and
    ~\( \dark \langle \)~~\( \dark var_2 \)~~\( \dark \rangle \)~ have the value ~\( \dark \langle \)~~\( \dark exp_2 \)~~\( \dark \rangle \)~ and
    ~\( \dots \)~
    ~\( \dark \langle \)~~\( \dark var_n \)~~\( \dark \rangle \)~ have the value ~\( \dark \langle \)~~\( \dark exp_n \)~~\( \dark \rangle \)~
in  ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~
\end{scheme}

(letは使役の意ですので、\( \langle \)\var{body}\( \rangle \)の中では\( \langle \)\( var_1 \)\( \rangle \)は
\( \langle \)\( exp_1 \)\( \rangle \)の値を持たせる、以下繰り返しと読めます。)

\noindent
\code{let}式の最初の部分は名前と式のペアのリストです。\code{let}が評価される時、
各名前は関連する式の値と関連付けされます。\code{let}のボディはこれらのローカルな値に束縛された
名前と共に評価されます。\code{let}式は以下の代替文法として評価されるためこれが起こります。

\begin{scheme}
((lambda (~\( \dark \langle \)~~\( \dark var_1 \)~~\( \dark \rangle \)~ ~\( \dots \)~ ~\( \dark \langle \)~~\( \dark var_n \)~~\( \dark \rangle \)~)
    ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~)
 ~\( \dark \langle \)~~\( \dark exp_1 \)~~\( \dark \rangle \)~
 ~\( \dots \)~
 ~\( \dark \langle \)~~\( \dark exp_n \)~~\( \dark \rangle \)~)
\end{scheme}

\noindent
インタプリタ内にはローカル変数を提供するために新しいメカニズムが必要とされません。
\code{let}式は中で行われる\code{lambda}適用に対する糖衣構文でしかありません。



この等価式から\code{let}式にて指定された変数のスコープが\code{let}のボディであることが
わかります。これが以下のことを暗示します。

\begin{itemize}

\item
\code{let}は変数を可能な限り使用される場所に局地的に束縛します。例えばもし\code{x}の値が
5である時、次の式の値は

\begin{scheme}
(+ (let ((x 3))
     (+ x (* x 10)))
   x)
\end{scheme}

\noindent
38です。ここで\code{let}のボディの中の\code{x}は3ですので\code{let}式の値は33です。
一方で最も外側の\code{+}の第二引数である\code{x}は依然5です。

\item
変数の値は\code{let}の外側にて計算されます。これはローカル変数の値を提供する式が
ローカル変数自身と同じ名前を持っている変数に依存する場合に問題となります。
例えば、もし\code{x}の値が2の時、次の式では

\begin{scheme}
(let ((x 3)
      (y (+ x 2)))
  (* x y))
\end{scheme}

\noindent
式の値は12になります。\code{let}のボディ内部では\code{x}は3、\code{y}は4(外側の\code{x}足す2)に
なるためです。

\end{itemize}

\noindent
時には\code{let}と同様の効果を得るために内部定義を利用することもあります。
例として、上記の手続\code{f}を次のように定義することも可能でした。

\begin{scheme}
(define (f x y)
  (define a (+ 1 (* x y)))
  (define b (- 1 y))
  (+ (* x (square a))
     (* y b)
     (* a b)))
\end{scheme}

\noindent
しかしこのような状況では\code{let}を使用し、内部定義は内部手続のみのために利用することを
好みます。\footnote{内部定義を十分に良く理解し、プログラムが私達がそれに意図した
意味を意味することを確実にするには私達がこの章で紹介したよりもより複雑な評価過程のモデル
を必要とします。しかし手続の内部定義と共にはその機微は浮かび上がりません。
この問題については\link{Section 4.1.6}にて評価についてより学んだ後に立ち戻ります。}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.34}Exercise 1.34:} 以下の手続を定義したとする。

\begin{scheme}
(define (f g) (g 2))
\end{scheme}

すると以下の結果を得る。

\begin{scheme}
(f square)
~\textit{4}~
(f (lambda (z) (* z (+ z 1))))
~\textit{6}~
\end{scheme}


もし(天邪鬼にも)インタプリタに\code{(f f)}の組み合わせを評価させたらどのような結果が起こるか?
説明せよ。
\end{quote}


\subsection{汎用手法としての手続}
\label{Section 1.3.3}


\link{Section 1.1.4}にて複合手続を数値演算の抽象化パターンのメカニズムとして紹介し、
関係する特定の数値から独立させました。\link{Section 1.3.1}の\code{integral}手続のような
高階手続ではより強力な種類の抽象化について学び始めました。
関係する特定の関数から独立した汎用的演算手法を表現するのに利用される手続でした。
この節では2つのより複雑な例---零と関数の不動点を見付けるための汎用手法---について議論します。
そしてこれらの手法がどのように手続として直接的に表現されるのかを示します。

\subsubsection*{半区間手法により方程式の根を求める}



\newterm{half-interval method}(\jnewterm{半区間手法})は方程式\( f(x) = 0 \)の根を求めるのに
単純ながら強力なテクニックです。ここで\( f \)は連続関数とします。
この考えは\( f(a) < 0 < f(b) \)となる点\( a \)と\( b \)を与えた時、\( f \)は最低でも1つの0を
\( a \)と\( b \)の間に持つことになります。ゼロを特定するために\( a \)と\( b \)の平均\( x \)を
求め\( f(x) \)を計算します。もし\( f(x) > 0 \)なら\( f \)は0を\( a \)と\( x \)の間に持ちます。
もし\( f(x) < 0 \)なら\( f \)は0を\( x \)と\( b \)の間に持ちます。このように繰り返すことで
\( f \)が0を持つより小さな区間を特定できます。区間が十分に小さな時点に辿りついたら処理は停止します。
不確かな区間が処理の各ステップにて半分になるため、必要とされるステップ数は\( \Theta(\log(L / T)) \)
に従い増加します。このとき\( L \)は元の区間の長さで\( T \)は許容誤差(私達が``十分に小さい''と
考える区間のサイズ)になります。この戦略を実装した手続が以下になります。

\begin{scheme}
(define (search f neg-point pos-point)
  (let ((midpoint (average neg-point pos-point)))
    (if (close-enough? neg-point pos-point)
        midpoint
        (let ((test-value (f midpoint)))
          (cond ((positive? test-value)
                 (search f neg-point midpoint))
                ((negative? test-value)
                 (search f midpoint pos-point))
                (else midpoint))))))
\end{scheme}

\noindent
最初に関数\( f \)を値が負と正になる2つの点と共に与えられると想定します。
最初に2つの与えられた点の中間点を求めます。次に与えられた区間が十分に小さいかチェックし、
もしそうであれば単純に中間点を答とします。そうでなければ中間点における\( f \)の
値をtest-value(試験値)として計算します。もし試験値が正ならば、元の負の地点から中間点までの
新しい区間にて処理を続けます。もし試験値が負ならば中間値から正の地点までの区間にて
処理を続けます。最終的に試験値が0になる可能性がありますが、その場合、中間地点そのものが
我々が探している根となります。


終了地点が``十分に近い''か試験するためには\link{Section 1.1.7}にて平方根を求めるために
利用した物と同様の手続が利用可能です。\footnote{私達は``小さな''値の表現として
0.001を用い、計算にて受け入れられる誤差の許容範囲を示しました。実際の演算に
おける適切な許容範囲は解決すべき問題、計算機とアルゴリズムの制約に依存します。
これはしばしばとても微妙な考慮事項であり、数値解析者や他の魔法使いのような人達の
助けを必要とします。}

\begin{scheme}
(define (close-enough? x y) (< (abs (- x y)) 0.001))
\end{scheme}

\noindent
\code{search}は直接利用するのは扱いにくいです。\( f \)の値が必要な符号を持たない点を
意図せず与えてしまうことが可能なためです。そのような場合では間違った答を得てしまいます。
代わりに\code{search}を次の手続を経由して使用することにしましょう。これは終端のどちらが負の
関数値を持ち、どちらが正の関数値を持つか検査します。そして\code{search}手続を適切に
呼び出します。もし関数が2つの与えられた点にて同じ符号を持つ場合、半区間手法は使用
できません。この場合この手続はエラーを伝えます。\footnote{これは\code{error}を用いて達成でき
ます。\code{error}は引数としていくつかの項目を受け取りそれらをエラーメッセージとして出力します。}

\begin{scheme}
(define (half-interval-method f a b)
  (let ((a-value (f a))
        (b-value (f b)))
    (cond ((and (negative? a-value) (positive? b-value))
           (search f a b))
          ((and (negative? b-value) (positive? a-value))
           (search f b a))
          (else (error "Values are not of 
                        opposite sign" a b)))))
\end{scheme}

\noindent
次の例は半区間手法を使用して\( \pi \)の近似を\( \sin x = 0 \)の2と4の間の根として
求めています。

\begin{scheme}
(half-interval-method sin 2.0 4.0)
~\textit{3.14111328125}~
\end{scheme}

\noindent
また次の別の例では半区間手法を用いて方程式\( x^3 - 2x - 3 = 0 \)において1と2の間で
根を探しています。

\begin{scheme}
(half-interval-method (lambda (x) (- (* x x x) (* 2 x) 3))
                      1.0
                      2.0)
~\textit{1.89306640625}~
\end{scheme}

\subsubsection*{関数の不動点を求める}


数値\( x \)は\( x \)が等式\( f(x) = x \)を満たす時、関数\( f \)の\newterm{fixed point}(\jnewterm{不動点})と呼ばれます。
いくつかの関数\( f \)に対し不動点を初期推測値から始めて\( f \)を値があまり変わらなくなるまで
繰り返し適用することで求めることができます。
\begin{comment}

\begin{example}
f(x), f(f(x)), f(f(f(x))), ...
\end{example}

\end{comment}
\begin{displaymath}
 f(x),\quad f(f(x)),\quad f(f(f(x))), \quad\dots, 
\end{displaymath}
\noindent
この考えを用いて関数と初期推定値を入力とし、関数の不動点への近似を生成する手続、
\code{fixed\-/point}を開発できます。指示した許容範囲未満の差に二点が収まるまで関数を
繰り返し適用します。

\begin{scheme}
(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) 
       tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))
\end{scheme}

\noindent
例えばこの手法をコサイン関数の不動点を近似するのに利用できます。初期推測値は1
とします。\footnote{以下を暇な授業の間に実行してみて下さい：電卓をラジアンモードに設定し
不動点に到達するまで\code{cos}を連打してみましょう。}

\begin{scheme}
(fixed-point cos 1.0)
~\textit{.7390822985224023}~
\end{scheme}

\noindent
同様にして、次の方程式の答を見つけられます。
\( y = \sin y + \cos y \):

\begin{scheme}
(fixed-point (lambda (y) (+ (sin y) (cos y))) 1.0)
~\textit{1.2587315962971173}~
\end{scheme}

\noindent
不動点処理は\link{Section 1.1.7}にて平方根を求めるのに使用した処理を思い出させます。
両者は共に結果がある判定基準を満たすまで推測値を繰り返し改善する考えを基にしています。
実際に直ぐに平方根の計算を不動点検索として形式化が可能です。
ある数値\( x \)の平方根を求めるには\( y^2 = x \)を満たす\( y \)を探す必要があります。
この等式を等価な形の\( y = x / y \)
\footnote{\( \mapsto \) (``maps to''(写す)と読みます。)は数学者による\code{lambda}の記述法です。
\( y \mapsto x / y \)は\code{(lambda (y) (/ x y))}を意味し、\( y \)における関数の値は
\( x / y \)ということです。}
にするとその関数\( y \mapsto x / y \)の不動点を探してることに気付きます。従って平方根を以下のように
求めることを試すことができます。

\begin{scheme}
(define (sqrt x)
  (fixed-point (lambda (y) (/ x y)) 1.0))
\end{scheme}

\noindent
残念ながらこの不動点検索は収束しません。初期推測値を\( y_1 \)とします。次の推測値は
\( y_2 = x / y_1 \)でさらに次は\( y_3 = x / y_2 = x / (x / y_1) = y_1 \)
です。この結果は2つの推測値\( y_1 \)と\( y_2 \)がずっと繰り返し、答が振動する無限ループです。



そのような振動をコントロールする1つの方法は推測値が大きく変化することを防ぐことです。
回答は常に推測値\( y \)と\( x / y \)の間にあるはずですから\( y \)と
\( x / y \)の両方から同じ位遠くはない地点にできるはずです。
従って\( y \)と\( x / y \)の平均を取って\( y \)の次の推測値は
\( {1\over2}(y + x / y) \)となります。

\begin{scheme}
(define (sqrt x)
  (fixed-point (lambda (y) (average y (/ x y))) 1.0))
\end{scheme}

\noindent
(\( y = {1\over2}(y + x / y) \)は等式\( y = x / y \)を単純に変形したものである
ことに注意して下さい。得るためには等式の両辺に\( y \)を足し、2で割ります。)


この変更により平方根手続がうまく行きます。実際に、もし定義をひも解いた場合、ここで
生成された平方根の近似の連続は元々の\link{Section 1.1.7}の平方根手続が生成するものと正確に
同じです。この一連の近似値の平均から回答へのアプローチは、\newterm{average damping}(\jnewterm{平均減衰})
と呼ぶテクニックであり、良く不動点検索の収束に対し手助けとなります。

\begin{quote}
\heading{\phantomsection\label{Exercise 1.35}Exercise 1.35:} 黄金比率
\( \varphi \)(\link{Section 1.2.2})は変形\( x \mapsto 1 + 1 / x \)の不動点である
ことを示せ。この比率を用いて\( \varphi \)を\code{fixed\-/point}手続を用いて求めよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.36}Exercise 1.36:} \code{fixed\-/point}を変更し、
\link{Exercise 1.22}にて示された\code{newline}
と\code{display}プリミティブを用いて生成する一連の近似値を表示するようにせよ。
次に\( x^x = 1000 \)の答を\( x \mapsto \log(1000) / \log(x) \)の不動点を
求める方法で求めよ。
(Schemeのプリミティブである\code{log}手続を利用せよ。これは自然対数を計算する)。
平均減衰を用いる場合と用いない場合にてステップ数を比較せよ。(\code{fixed\-/point}を
推定値1では開始できないことに注意せよ。これは\( \log(1) = 0 \)での割り算を
引き起すためである。)
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.37}Exercise 1.37:} \begin{enumerate}[a]

\item
無限\newterm{continued fraction}(\jnewterm{連分数})とは以下の形式の式である。
\begin{comment}

\begin{example}
           N_1
f = ---------------------
               N_2
    D_1 + ---------------
                   N_3
          D_2 + ---------
                D_3 + ...
\end{example}

\end{comment}
\begin{displaymath}
 {f} = {N_1 \over {D_1 + {N_2 \over {D_2 + {N_3 \over D_3 + \dots}}}}}\,. 
\end{displaymath}


例として、無限連分数の展開として\( N_i \)と\( D_i \)の全てが1の場合、\( 1 / \varphi \)
を生成し、この時\( \varphi \)は(\link{Section 1.2.2}で説明した)黄金比率である。
無限連分数の近似を求める1つの方法として与えられた項の数を越えた後、展開を切り捨てる方法がある。
そのような切り捨て---所謂\newterm{\textit{k}-term finite continued fraction}(\jnewterm{k項有限連分数})---は以下
の形式になる。
\begin{comment}

\begin{example}
       N_1
-----------------
          N_2
D_1 + -----------
      ...    N_K
          + -----
             D_K
\end{example}

\end{comment}
\begin{displaymath}
 {N_1 \over {D_1 + {N_2 \over {\ddots + {N_k \over D_k}}}}}\,. 
\end{displaymath}


\code{n}と\code{d}は連分数の\( N_i \)\( D_i \)の項を返す1引数(項の索引\( i \))の手続であると考える。
\code{(cont\-/frac n d k)}を評価すると\( k \)項有限連分数の値を求める手続、\code{cont\-/frac}を定義せよ。
あなたの手続を以下を用いて\( 1 / \varphi \)の近似を求めることで、一連の\code{k}の値についてチェックせよ。

\begin{scheme}
(cont-frac (lambda (i) 1.0)
           (lambda (i) 1.0)
           k)
\end{scheme}

\noindent
小数点以下4桁の精度の近似を得るには\code{k}はどれだけの大きさでなければならないか?

\item
もしあなたの\code{cont\-/frac}手続が再帰プロセスを生成するのならば線形プロセスを生成するものを書け。
もし線形プロセスを生成するのであれば、再帰プロセスを生成するものを書け。

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.38}Exercise 1.38:} 1737年にスイスの数学者、
Leonhard Euler(レオンハルト・オイラー)は学術論文\textit{De Fractionibus Continuis}を出版した。
それには\( e \)が自然対数の底である時の、\( e - 2 \)に対する連分数展開が含まれている。
この分数では\( N_i \)は全て1であり、\( D_i \)は数列1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, \( \dots \)である。
\link{Exercise 1.37}のあなたの\code{cont\-/frac}手続を用いてオイラー展開を基にし\( e \)の近似を求める
プログラムを書け。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.39}Exercise 1.39:} タンジェント(正接)
関数の連分数表現は1770年にドイツの数学者J.H. Lambert
(ヨハン・ハインリッヒ・ランベルト)により発表された。
\begin{comment}

\begin{example}
              x
tan x = ---------------
                x^2
        1 - -----------
                  x^2
            3 - -------
                5 - ...
\end{example}

\end{comment}
\begin{displaymath}
 {\tan x} = {x \over {1 - {x^2 \over {3 - {x^2 \over 5 - \dots}}}}}\,, 
\end{displaymath}
\noindent
ここで\( x \)はラジアンである。ランベルトの式を基にして正接関数の近似値を求める
手続\code{(tan\-/cf x k)}を定義せよ。\code{k}は\link{Exercise 1.37}と同様に
求める項の数を指定する。
\end{quote}

\label{Section 1.3.4}
\subsection{返り値としての手続}



ここまでの一連の例は手続を引数として渡す能力が著しく私達のプログラミング言語の表現力を
拡張することを実演しました。返り値自体が手続である手続を作成することでさらに表現力を
獲得することができます。


この考えを\link{Section 1.3.3}の終わりにて説明された不動点の例を振り返ることで説明できます。
\code{square\-/root}手続の新しいバージョンを、\( \sqrt{x} \)は\( y \mapsto x / y \)関数の
不動点であるという観察結果から始めて、不動点検索の形で形式化しました。
次に平均減衰を用いて近似値を収束させました。平均減衰はそれ自体が便利な汎用技法です。
即ち関数\( f \)を与えられた時、\( x \)における関数の値が\( x \)と\( f(x) \)の平均だと
考えます。


平均減衰の考えを次の手続を用いて説明できます。

\begin{scheme}
(define (average-damp f) (lambda (x) (average x (f x))))
\end{scheme}

\noindent
\code{average\-/damp}は引数として手続\code{f}を取りその値として(\code{lambda}で生成された)手続を返します。
その手続は数値\code{x}に適用された時、\code{x}と\code{(f x)}の平均を返します。例えば\code{average\-/damp}を
\code{square}手続に適用した時、生成された手続の値は、ある値\( x \)において\( x \)と\( x^2 \)の
平均となります。この結果の手続に10を適用すれば10と100の平均として55を返します。\footnote{これは
組み合わせであり、かつそのオペレータもまた合成式であることに注意して下さい。\link{Exercise 1.4}にて
既にそのような合成式を形式化する能力については実演しました。しかしあれは単に簡単な例にすぎません。
ここではそのような合成式に対する真の要求---高階手続により値として返されることで得られた手続を
いつ適用するのかについて学び始めます。}

\begin{scheme}
((average-damp square) 10)
~\textit{55}~
\end{scheme}

\noindent
\code{average\-/damp}を用いて\code{square\-/root}手続を次のように再公式化できます。

\begin{scheme}
(define (sqrt x)
  (fixed-point (average-damp (lambda (y) (/ x y))) 1.0))
\end{scheme}

\noindent
この形式化が手法内においてどれだけ3つの考え、不動点検索、平均減衰、
関数\( y \mapsto x / y \)について明快にしているかに注目して下さい。
このsquare-rootの手法の形式化と\link{Section 1.1.7}で与えた元のバージョンの比較は
示唆的です。これらの手続が同じ処理について表現していることを心に留めて下さい。
そして同じ処理をこれらの抽象化を用いて表現した時にどれだけ明白になるのか
に注目して下さい。一般的に処理を手続に形式化する手法はとても多くの数有ります。
経験の豊富なプログラマはどのように手続形式化を選ぶのか、特に明快な方法を知っています。
そしてどこで処理の便利な要素が他のアプリケーションにて再使用可能な独立した要素として
浮かび上がるかについて知っているのです。再使用の簡単な例として\( x \)の立方根は
関数\( y \mapsto x / y^2 \)の不動点であることに注意して下さい。従って
直ぐにsquare-root手続を立方根を求める手続に汎化することが可能です。\footnote{さらなる
一般化については\link{Exercise 1.45}を参照して下さい。}


\begin{scheme}
(define (cube-root x)
  (fixed-point (average-damp (lambda (y) (/ x (square y))))
               1.0))
\end{scheme}

\subsubsection*{ニュートン法}



\link{Section 1.1.7}にて初めてsquare-root手続を紹介した時に、これは\newterm{Newton's method}(\jnewterm{ニュートン法})
の特別な場合であると伝えました。もし\( x \mapsto g(x) \)が微分可能な関数である時、方程式
\( g(x) = 0 \)の答は以下の条件で関数\( x \mapsto f(x) \)の不動点となります。
\begin{comment}

\begin{example}
           g(x)
f(x) = x - -----
           Dg(x)
\end{example}

\end{comment}
\begin{displaymath}
 {f(x) = x} - {g(x)\over Dg(x)} 
\end{displaymath}
\noindent
そして\( Dg(x) \)は\( x \)により微分した導関数です。ニュートン法は上で学んだ
不動点を用いる手法で、関数\( f \)の不動点を探すことで方程式の解の近似を求めます。
\footnote{初歩的な微積分学の教科書は通常ニュートン法を近似の数列\( x_{n+1} = x_n -
g(x_n) / Dg(x_n) \)を用いて説明しています。処理に関する言語を持ち不動点の
考えを用いることで手法の説明を平易にできます。}



多くの関数\( g \)において、また十分に良い初期推測値\( x \)においてニュートン法は
\( g(x) = 0 \)の解に急速に収束します。\footnote{ニュートン法は常に解へと収束は
しません。しかし好ましい場合においては各繰り返しにおいて解の近似値の精度の桁数は
二倍になることが示されます。そのような場合ではニュートン法は半区間手法よりも大変
速く収束します。}



ニュートン法を手続として実装するために、最初に微分の考えを表現せねばなりません。
``微分''は平均減衰と同様にある関数を別の関数へと変形することに注目して下さい。
例えば関数\( x \mapsto x^3 \)の微分は\( x \mapsto 3x^2 \)です。
一般的に\( g \)が関数であり\( dx \)が小さな値である時、\( g \)の導関数
\( Dg \)はその値が任意の数\( x \)が与えられた時に(小さな値\( dx \)の極限において)
\begin{comment}

\begin{example}
        g(x + dx) - g(x)
Dg(x) = ----------------
               dx
\end{example}

\end{comment}
\begin{displaymath}
 {Dg(x)} = {g(x + {\it dx}) - g(x) \over {\it dx}}\,. 
\end{displaymath}
\noindent
従って微分の考えを(\( dx \)を例えば0.00001として)手続として次のように
表現できます。

\begin{scheme}
(define (deriv g)
  (lambda (x) (/ (- (g (+ x dx)) (g x)) dx)))
\end{scheme}

\noindent
次の定義と一緒に用います。

\begin{scheme}
(define dx 0.00001)
\end{scheme}

\noindent
\code{average\-/damp}と同様に、\code{deriv}は引数として手続を取り、値として手続を返す手続です。
例えば導関数\( x \mapsto x^3 \)の5における値(正確な値は75です)の近似を求めるために
以下のように評価できます。

\begin{scheme}
(define (cube x) (* x x x))
((deriv cube) 5)
~\textit{75.00014999664018}~
\end{scheme}

\noindent
\code{deriv}の助けを借りて、ニュートン法を不動点処理として次のように表現できます。

\begin{scheme}
(define (newton-transform g)
  (lambda (x) (- x (/ (g x) ((deriv g) x)))))
(define (newtons-method g guess)
  (fixed-point (newton-transform g) guess))
\end{scheme}

\noindent
\code{newton\-/transform}手続はこの節の最初の式を表現しています。そして\code{newtons\-/method}
が直ぐにそれを用いて定義されています。これは初期推測値と一緒に手続を引数として取り
その手続はゼロを見つけたい関数を計算します。例えば、\( x \)の平方根を見つけたい時、
ニュートン法を用いて関数\( y \mapsto y^2 - x \)のゼロを初期推測値1から始めて探す
ことが可能です。\footnote{平方根を探す場合、ニュートン法は任意の開始値から急速に
正しい解に収束します。}


これが平方根手続の別の形を与えます。

\begin{scheme}
(define (sqrt x)
  (newtons-method
   (lambda (y) (- (square y) x)) 1.0))
\end{scheme}

\subsubsection*{抽象化と一級手続}



より一般的な手法の事例として、平方根の演算の表現方法を2つ見てきました。1つは
不動点検索で、もう1つはニュートン法です。ニュートン法はそれ自体が不動点処理として
表現されているため、実際には平方根を不動点として計算する2つの方法を見た訳になります。
各手法は関数と共に開始し、その関数のある変形の不動点を探します。この一般的な考えそれ
自身を手続として表現できます。

\begin{scheme}
(define (fixed-point-of-transform g transform guess)
  (fixed-point (transform g) guess))
\end{scheme}

\noindent
このとても汎用的な手続は引数としてある関数を計算する手続\code{g}、\code{g}を変形する
手続、初期推測値を取ります。結果としての返り値は変形された関数の不動点です。



この抽象化を用いて、この節最初の(平均減衰バージョンの\( y \mapsto x / y \)の
不動点を探した)平方根演算をこの汎用手法の例として変更できます。

\begin{scheme}
(define (sqrt x)
  (fixed-point-of-transform
   (lambda (y) (/ x y)) average-damp 1.0))
\end{scheme}

\noindent
同様にこの節の2つ目の平方根演算(\( y \mapsto y^2 - x \)のニュートン変形の不動点を
探すニュートン法の例)を以下の様に表現できます。

\begin{scheme}
(define (sqrt x)
  (fixed-point-of-transform
   (lambda (y) (- (square y) x)) newton-transform 1.0))
\end{scheme}

\noindent
\link{Section 1.3}では複合手続は重大な抽象化メカニズムであるという考えから始めました。
私達のプログラミング言語において演算の一般的な手法を明示的な要素として表現することを
可能にするためです。ここでは高階手続がどのようにこれらの一般的手法を操作してさらなる
抽象化を作成することを可能にするのかについて学びます。


プログラマとして、私達のプログラムに内在する抽象化を判別する機会を迅速に学ばねば
なりません。そしてその上に構築し、それらを汎化してより強力な抽象化を作成する術を
学ばねばなりません。これは常にプログラムを可能な限り抽象化して書かねばならないと
言う訳ではありません。エキスパートプログラマは彼等のタスクにとって適切な抽象化
レベルの選択方法を知っています。しかし、これらの抽象化を用いて考えられるように
なることが重要です。そうすればそれらを新しいコンテキストでも適用することに準備する
ことができます。高階手続の有用性は、それらがここまでの抽象化を私達の
プログラミング言語の要素として明示的に表現することを可能にしてくれることです。
そうすることで抽象化は他の計算上の要素と同様に扱われることが可能となります。



通常、プログラミング言語は計算要素が取扱可能になるような方法に制約を課します。
制約が最も少ない要素は\newterm{first-class}(\jnewterm{第一級})の地位にあると言われます。
第一級要素の``権利と特権''のいくつかを次に示します。
\footnote{プログラミング言語の要素の第一級の地位の概念はイギリスの計算機科学者
Christopher Strachey (1916-1975)によるものです。}

\begin{itemize}

\item
変数により名付けることが可能

\item
手続に対し引数として渡すことが可能

\item
手続の結果として返すことが可能

\item
データ構造に含まれることが可能\footnote{
これの例は\link{Chapter 2}にてデータ構造を紹介した後に学びます。}

\end{itemize}

\noindent
Lispは他の言語と異なり、手続に完全な第一級の地位を与えます。このことが効率の良い
実装に対して課題を課しますが、結果的に表現力に得る物は莫大な物となります。\footnote{
第一級手続の主な実装コストは、手続が値として返ることを可能とするために、手続の
自由変数に対して予備の領域を、例え手続が実行中でなくとも必要とします。私達が
\link{Section 4.1}にて学ぶSchemeの実装では、これらの変数は手続の環境に保存されます。}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.40}Exercise 1.40:} \code{newtons\-/method}手続と
共に以下の形式の式にて使用が可能な手続\code{cubic}を
定義せよ。

\begin{scheme}
(newtons-method (cubic a b c) 1)
\end{scheme}

\noindent
次に三次方程式\( x^3 + ax^2 + bx + c = 0 \)の近似解を求めよ。

\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.41}Exercise 1.41:} 引数が1つの手続を
引数として取り、その手続を二回適用する手続を返す手続\code{double}を定義せよ。
例えば\code{inc}が引数に1を足す手続であれば、\code{(double inc)}は2を足す手続になる。
次の式はどんな値を返すか?

\begin{scheme}
(((double (double double)) inc) 5)
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.42}Exercise 1.42:} \( f \)と\( g \)が
2つの1引数関数だとする。\( g \)に\( f \)を\newterm{composition}(\jnewterm{合成})するとは
関数\( x \mapsto f(g(x)) \)と定義される。合成を実装する手続\code{compose}を定義せよ。
例えば\code{inc}が引数に1を足す手続である場合、

\begin{scheme}
((compose square inc) 6)
~\textit{49}~
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.43}Exercise 1.43:} \( f \)が
数値演算関数であり\( n \)が正の整数である時、\( f \)を\( n \)回適用する、
\( x \)における値が\( f(f(\dots (f(x))\dots )) \)である関数を定義できる。
例えば\( f \)が関数\( x \mapsto x + 1 \)である時、\( f \)を\( n \)回適用した関数は
\( x \mapsto x + n \)となる。もし\( f \)が数値を二乗する操作ならば、\( f \)を
\( n \)回適用した関数は引数を\( 2^n \)乗する。入力として\( f \)を計算する手続と正の整数
\( n \)を取り、\( f \)の\( n \)回適用を計算する手続を返す手続を書け。
その手続は以下のように使用可能でなければならない。

\begin{scheme}
((repeated square 2) 5)
~\textit{625}~
\end{scheme}

ヒント：\link{Exercise 1.42}の\code{compose}を使うと便利でしょう。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.44}Exercise 1.44:} 関数の
\newterm{smoothing}(\jnewterm{補間})という考えは信号処理において重要な概念である。
\( f \)が関数であり\( dx \)がある小さな値である時、\( f \)の補間とは
\( x \)における値が\( f(x - dx) \), \( f(x) \), and \( f(x + dx) \)
の平均である関数である。入力として\( f \)を計算する手続を取り、補間された
\( f \)を計算する手続を返す手続\code{smooth}を書け。
時には関数の補正を繰り返し(つまり補間された関数をさらに補間
することを繰り返す)、\newterm{\textit{n}-fold smoothed function}(\jnewterm{\textit{n}次畳み込み補間関数})
を得ることには価値がある。任意の与えられた関数の\textit{n}次畳み込み補間関数を\link{Exercise 1.43}の
\code{smooth}と\code{repeated}を用いてどのように生成するかを示せ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.45}Exercise 1.45:} \link{Section 1.3.3}にて
平方根を求める試みにおいて単純に\( y \mapsto x / y \)の不動点を探すのでは
収束しないのを見た。この問題は平均減衰にて解決できた。同じ手法が
平均減衰を行った\( y \mapsto x / y^2 \)の不動点として立方根を求める場合においても
うまく行く。残念ながらこの処理は4乗根ではうまくいかない---単一の平均減衰は\( y \mapsto x / y^3 \)
の不動点検索を収束させるのに十分ではない。一方でもし平均減衰を二回行えば(すなわち
\( y \mapsto x / y^3 \))の平均減衰の平均減衰)不動点検索は収束する。\( n \)乗根を
\( y \mapsto x / y^{n-1} \)の平均減衰の繰り返しを基として不動点探索して求める場合に
何回の平均減衰が必要であるかを試行せよ。
この結果を用いて\link{Exercise 1.43}の\code{fixed\-/point}, \code{average\-/damp}, \code{repeated}手続を用いて\( n \)乗根を
求める単一の手続を実装せよ。
必要な数値演算はプリミティブとして存在すると仮定する。

\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 1.46}Exercise 1.46:} この章にて
説明されたいくつかの数値解析手法は非常に汎用的な計算戦略であり
\newterm{iterative improvement}(\jnewterm{反復改善法})として知られている。
反復改善法は何かを求めるために解の初期推測値から始め、推測値が十分に良いかをテストし、
そうでなければ推測値を改善し、改善された推測値を新しい推測値として用いて
処理を継続する。2つの手続を引数として取る手続\code{iterative\-/improve}を書け。1つは
推測値が十分に良いか判断する手続であり、もう1つは推測値を改善する手続である。
\code{iterative\-/improve}は推測値を引数として取り、推測値を十分に良くなる
まで繰り返す手続をその値として返さなければならない。
\link{Section 1.1.7}の\code{sqrt}手続と\link{Section 1.3.3}の\code{fixed\-/point}手続を\code{iterative\-/improve}を
用いて書き直せ。
\end{quote}
