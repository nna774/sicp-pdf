\chapter{メタ言語抽象化}
\label{Chapter 4}

\begin{quote}


\( \dots \) 魔法とは言葉の中にある---アブラカダブラ、開けゴマ、その他もろもろ---しかしあるお話の
魔法の言葉は次のお話では魔法ではない。真の魔法とはどの言葉が、いつ、何に対して働くか
を知ることだ。トリックを学ぶことがトリックなんだ。



\( \dots \) そしてそれらの言葉は私達のアルファベットの文字から出来ている。
ペンで書ける2、3ダースの走り書きだ。これが鍵なんだ！
そして宝でもある、もしそれに手をつけることさえできれば！
それはまるで---まるで宝の鍵こそが宝のようだ！

---John Barth, \textit{Chimera}
\end{quote}

\vspace{0.8em}

\noindent
プログラム設計の学習において、エキスパートなプログラマが設計の複雑さを
全ての複雑なシステムの設計者が用いるのと同じ一般的な技術を用いてコントロール
することを学んできました。彼等はプリミティブな要素を接続して複合オブジェクトを
形成し、複合オブジェクトを抽象化することでより高いレベルの建築ブロックを形成し
そして適切な大規模のシステム構造の見方を受け入れることでモジュール化方式は維持しました。
これらのテクニックの説明において、私達はLispをプロセスを記述するための言語として
用い、また計算データオブジェクトと実世界の複雑な現象をモデル化する処理を構築する
ためにも用いてきました。しかし、複雑さを増す問題に取り組むにつれ、Lisp、または
どのような固定されたプログラミング言語も、我々の必要には十分でないことを知る
ことでしょう。私達は、私達の考えをより効果的に表現するために、耐えず新しい言語に
向かわねばなりません。新しい言語を定めることは工学上の設計の複雑さをコントロール
するための強力な戦略です。私達は良く、問題を異なった方法
で記述できる(そしてそれ故に考えることができる)新しい言語を受け入れることで、
複雑な問題への対処能力を拡張することができます。プリミティブな、組み合わせの
手段や抽象化の手段を、目前の問題に特によく合ったものを用います。\footnote{同じ考えが
工学全てに渡り普及しています。例えば電子工学は多くの異なる言語を回路の記述に
用います。これらの内2つは電子ネットワークの言語と電子システムの言語です。
ネットワーク言語は別個の電子素子に関する装置の物理モデリングを重視します。
ネットワーク言語のプリミティブなオブジェクトはプリミティブな抵抗や、キャパシタ(コンデンサ)、
コイルやトランジスタ等の電子コンポーネントであり電圧と電流と呼ばれる物理的変数を
用いて特徴付けられます。回路をネットワーク言語で記述する時、技術者は設計の物理
特性に関心を持ちます。逆に、システム言語のプリミティブなオブジェクトはフィルタや
アンプのような信号処理モジュールです。モジュールの機能上の振舞のみが関係し、信号は
それらの電圧や電流のような物理的な認識に関心を持ちません。
信号処理システムの要素が電子ネットワークから構築
される意味の上ではシステム言語はネットワーク言語の上に組み立てられます。
しかしここでは関心事は与えられた応用問題を解くための大規模な電子装置の編成にあります。
パーツの物理的実現可能性は当然と考えられています。この階層化された言語の集合は
\link{Section 2.2.4}のピクチャー言語にて説明された階層化された設計テクニックのまた別の
例になります。}



プログラミングは数多くの言語により生じます。特定のコンピュータのための
機械語のような物理言語も存在します。これらの言語は個別のストレージの断片と
プリミティブな機械命令を用いてデータとコントロールの表現に関係します。
機械語プログラマは与えられたハードウェアの使用に関心を持つことでリソースに
限りある演算の効率的な実装のためのシステムとユーティリティを組み立てます。
高級言語は機械語の素地の上にありますが、データをビットの集合として表したり、
プログラムをプリミティブな命令の列で表すという懸念を隠します。これらの言語は
手続定義のような組み合わせと抽象化の手段を持ち大規模なシステム構成に適しています。



\newterm{Metalinguistic abstraction}(\jnewterm{メタ言語抽象化})---新しい言語を構築すること---が
工学設計の全ての部門にて重要な役割を果たします。これは計算機プログラミングでとても
重要です。プログラミングでは新しい言語を形成するだけでなく、これらの言語を評価機を
構築することで実装することもできるからです。プログラミング言語の\newterm{evaluator}(\jnewterm{評価機})(または
\newterm{interpreter}(\jnewterm{インタプリタ}))は手続であり、言語の式に対して適用された時、
その式を評価するために要求される行動を実行します。



プログラミングにおける考えで最も根本的な物と見做すことに何の誇張もありません。

\begin{quote}
評価機はプログラミング言語の評価手段を決定するが、それ自体は別のプログラムである。
\end{quote}

\noindent
この点を理解することはプログラマとしての私達自身のイメージを変更することです。
私達は私達自身を、他人が設計した言語のユーザとしてのみではなく、
言語の設計者として見る時点に辿りつきました。


実際に、私達はほとんど全てのプログラムをある言語の評価機だと見做すことができます。
例えば、\link{Section 2.5.3}の多項式操作システムは多項式の数値演算のルールを具象化し、
リスト構造データ上の命令を用いて実装しました。もし私達がこのシステムを多項式を
読み込み、表示する手続と共に拡張したなら、記号数学の問題を扱う特定目的言語の
コア(核)を持つことになります。\link{Section 3.3.4}のデジタル論理シミュレータと\link{Section 3.3.5}の
制約伝播はそれら自身の正しさにおける論理的言語であり、それぞれがそれ自身の
プリミティブと組み合わせの手段、抽象化の手段を持ちます。この視点から見れば
大規模計算機システムをこなす技術は新しい計算機言語を構築する技術と結合し、
計算機科学それ自身が適切な記述言語を構築する分野それ以上でも以下でもなくなります。



私達は今から他言語を用いて言語が構築される技術を巡り始めます。この章では
Lispを基盤として用い、評価機をLispの手続として実装します。Lispはこの任務に
とても良く合います。記号式を表現し、操作する能力がその理由です。
私達はLisp自身の評価機を構築することで言語がどのように実装されているかを
理解することから最初の一歩を踏み出します。私達の評価機により実装される
言語はこの本で用いるLipsのScheme方言の部分集合となります。この章で説明される
評価機がLispの特定の方言に向けて書かれていても、逐次式計算機のプログラムを
書くために設計された任意の式指向言語のための評価機の本質的な構造を含みます。
(実際に、多くの言語処理機がそれらの奥深くに小さな``Lisp''評価機を含んでいるのです。)
評価機は説明と議論のために簡略化されており、製品品質のLispシステム
に含まれるべき重要な機能が省略されています。
それにもかかわらず、この単純な評価機はこの本に現われる多くのプログラムを実行するのに
適しています。\footnote{私達の評価機が取り除いた最も重要な機能はエラーを扱う仕組みと
デバッグのサポートです。評価機のより広範囲の議論については\link{Friedman et al. 1992}を
参照して下さい。これはSchemeで書かれた一連の評価機を通して進められたプログラミング言語
の解説を与えます。}


評価機をLispプログラムとして利用可能にする重要な利点は代替となる評価ルールを
評価機プログラムへの変更として記述することで実装できることです。
この力を良い効果として用いることが可能な箇所として、\link{Chapter 3}の議論の
まさに中心であった、計算モデルが時間の概念を統合する方法に対し特別な
コントロールを得ることです。そこではストリームを用いて世界の時間表現を計算機の
時間から分離することで、状態と代入の複雑さのいくらかを緩和しました。
しかし、私達のストリームプログラムは時々扱いにくい物でした。Schemeの評価の
適用順により制約されていたためです。
\link{Section 4.2}ではより洗練された取り組み方を準備するために、
\newterm{normal-order evaluation}(\jnewterm{正規順評価})に対応する様に評価機を変更することで
基盤となる言語を変更します。


\link{Section 4.3}では式が単一の値のみでなく多くの値を持つ場合において、より野心的な言語の変更を実装します。
この\newterm{nondeterministic computing}(\jnewterm{非決定的演算})の言語においては、式の
全ての可能な値を生成する過程を生成し、次にそれらの値からいくつかの
制約を充足する値を探索することが自然に表現できます。。計算と時間のモデルにを用いれば、これは``可能な未来''の集合
を成す時間の分岐を持ち、次に適切な時系列を探すような物です。私達の
非決定的評価機を用いる複数の値の追跡と探索の実行は、根底に存在する言語の
仕組みにより自動的に取り扱われます。



\link{Section 4.4}では\newterm{logic\-/programming}(\jnewterm{論理プログラミング})言語を実装します。
それにより知識が入出力を伴なう計算を用いてではなく、関係性を用いて表現されます。
これは言語をLispから、または本当に全ての従来の言語から大幅に異なる物にしますが、
論理プログラミング評価機がLisp評価機の本質的な構造を共有することを学びます。



\section{メタ循環評価機}
\label{Section 4.1}



私達のLisp評価機はLispプログラムとして実装されます。LispプログラムをLispで実装
された評価機を用いて評価することについて考えることは循環論に見えるかもしれません。
しかし評価はプロセス(処理、過程)であり、従って評価過程をLispを用いて説明することは適切
です。Lispは結局の所、プロセスを記述するためのツールなのです。\footnote{例え
そうだとしても、私達の評価機により説明されない評価プロセスの重要な側面が残り
ます。これらの最も重要なことは手続が他の手続を呼び出し、そしてそれらを呼び出した
物に値を返す原因となる詳細な仕組みです。これらの問題は\link{Chapter 5}で解明
します。そこで私達は評価機を簡単なレジスタマシンとして実装することで評価プロセスに
より詳細に調べます。}評価する対象と同じ言語で書かれた評価機は
\newterm{metacircular}(\jnewterm{メタ循環})と呼ばれます。


メタ循環評価機は本質的には\link{Section 3.2}で説明された評価の環境モデルのScheme形式化です。
モデルには以下の2つの基本的パーツがあることを思い出して下さい

\begin{enumerate}

\item
組み合わせ(特殊な形式を除く複合式)を評価するためには、部分式を評価し、次に
オペレータ部分式をオペランド部分式の値に適用する。

\item
複合手続を引数の集合に適用するためには、手続のボディを新しい環境で評価する。
この環境を構築するためには、手続オブジェクトの環境部分をフレームにより拡張する。
フレームの中ではその手続の形式パラメタが、その手続が適用される引数に対して
束縛される
\end{enumerate}

\noindent
これら2つのルールが評価プロセスの本質を説明します。環境の中で式が評価される
基本的なサイクルは引数に適用される手続に簡約され、引数は順に新しい環境で評価される
新しい式へと簡約され、以下、値がその環境の中で見つかるシンボルか直接適用される
プリミティブな手続(\link{Figure 4.1}参照)に辿り着くまで繰り返されます。\footnote{
もし私達自身にプリミティブを適用する能力を与えるのであれば、評価機の実装には何が残って
いるのでしょうか? 評価機の仕事は言語のプリミティブを指定することではなく、
結合組織---組み合わせと抽象化の手段---を提供することであり、それがプリミティブの
集合を言語を形成するために束縛します。具体的には、



\( \bullet \) 評価機は入れ子の式の取扱を許可します。例えば単純にプリミティブを適用することは
式\code{(+ 1 6)}を評価するのには十分ですが、\code{(+ 1 (* 2 3))}を取り扱うには十分ではありません。
プリミティブな手続\code{+}が対象である限り、その引数は数値でなければならなず、もし
式\code{(* 2 3)}を引数として渡せば失敗します。評価機の重要な役割の1つは手続合成を演出することで、
\code{(* 2 3)}を\code{+}に引数として渡す前に6に簡約します。



\( \bullet \) 評価機は変数の使用を許可します。例えば加算のためのプリミティブな手続は
\code{(+ x 1)}のような式に対応する手段を持ちません。私達は評価機に変数を追跡しその値を
プリミティブな手続を実行する前に得るようにする必要があります。



\( \bullet \) 評価機は複合手続の定義を許可します。これは手続定義の追跡を含み、
これらの手続を式評価においてどのように使用するかを知っています。そして手続に
引数を受け入れることを許可する仕組みを提供します。


\( \bullet \) 評価機は特殊形式を提供します。これは手続呼出と異なった形で評価されねば
なりません。} 


この評価サイクルは評価機内の2つの重大な手続、\code{eval}と\code{apply}の間の相互作用により
具体化されます。これらの手続は\link{Section 4.1.1}にて説明されます。(\link{Figure 4.1}参照)



評価機の実装は評価される式の\newterm{syntax}(\jnewterm{構文})を定義する手続に依存します。
私達はデータ抽象化を用いて評価機を言語の表現に非依存にします。
例えば代入はシンボル\code{set!}で始まるリストにより表現されるべきという選択に
委ねるのではなく、代入のためのテストに抽象述語\code{assignment?}を用い、そして
代入の部品にアクセスするために抽象セレクタ\code{assignment\-/variable}と\code{assignment\-/value}を
用います。式の実装については\link{Section 4.1.2}で詳細に説明されます。また\link{Section 4.1.3}で
説明される``命令''もあり、これは手続と環境の表現を指定します。例えば\code{make\-/procedure}は
複合手続を構築し、\code{lookup\-/variable\-/value}は変数の値にアクセスし、
\code{apply\-/primitive\-/procedure}はプリミティブな手続を与えられた引数のリストに対し
適用します。

\begin{figure}[tb]
\phantomsection\label{Figure 4.1}
\centering
\begin{comment}
\heading{Figure 4.1:} The \code{eval}-\code{apply} cycle exposes the essence of a computer language.

\begin{example}
                           .,ad88888888baa,
                  _    ,d8P"""        ""9888ba.      _
                 /  .a8"          ,ad88888888888a   |\
               /   aP'          ,88888888888888888a   \
              /  ,8"           ,88888888888888888888,  \
             |  ,8'            (888888888888888888888, |
            /  ,8'             `8888888888888888888888  \
            |  8)               `888888888888888888888, |
Procedure,  |  8                  "88888 Apply 8888888) | Expression
Arguments   |  8     Eval          `888888888888888888) | Environment
            |  8)                    "8888888888888888  |
            \  (b                     "88888888888888'  /
             | `8,                     8888888888888)  |
             \  "8a                   ,888888888888)  /
              \   V8,                 d88888888888"  /
              _\| `8b,             ,d8888888888P' _/
                     `V8a,       ,ad8888888888P'
                        ""88888888888888888P"
                             """"""""""""

                               [graphic by Normand Veillux, modified]
\end{example}
\end{comment}
\includegraphics[width=100mm]{fig/chap4/Fig4.1.pdf}
\begin{quote}
\heading{Figure 4.1:} \code{eval}-\code{apply}サイクルがコンピュータ言語の本質を顕在化させる
\end{quote}
\end{figure}



\subsection{評価機の核}
\label{Sec. 4.1.1}
\label{Section 4.1.1}



評価プロセスは2つの手続\code{eval}と\code{apply}の相互作用であると説明可能です。

\subsubsection*{Eval}



\code{eval}は引数として式と環境を取ります。これは式と分類しその評価を監督します。
\code{eval}は評価される式の構文上の方の事例分析として構造化されます。
手続の一般性を保つため、式の型の決定を抽象的に表現し、多種の式に対するどんな
特定の表現にも委託しません。式の各型はそれをテストする述語と、その部分を選択する
抽象手段を持ちます。この\newterm{abstract syntax}(\jnewterm{抽象構文})は同じ評価機を用いつつ、
異なる構文手続の集合と合わせることで、言語の文法をどのようにして変更できるかについて
知ることを簡単にします。

\noindent
\textbf{プリミティブな式}

\begin{itemize}

\item
数値のような自己評価式に対しては\code{eval}は式それ自身を返す。

\item
\code{eval}は環境の中で変数をその値を見つけるために探さなければならない。

\end{itemize}

\noindent
\textbf{特殊形式}

\begin{itemize}

\item
クォートされた式に対しては\code{eval}はクォートされた式を返す。

\item
変数への代入(または定義)は再帰的に\code{eval}を呼び出し変数に関連付けられる新しい値を
計算しなければならない。環境は変数の束縛を変更(または作成)しなければならない。

\item
\code{if}式はその部品に対し特別な処理を要求する。もし述語が真であれば
consequent(結果)を評価し、そうでなければalternative(代替)を評価するためである。

\item
\code{lambda}(ラムダ)式は適用可能な手続に変形しなければならない。変形はラムダ式により
指定されたパラメタとボディを評価の環境と共にパッケージ化することにより行う。

\item
\code{begin}式はその一連の式をそれらが現れる順で評価する必要がある。

\item
事例分析(\code{cond})は入れ子の\code{if}式に変形し、それから評価する。

\end{itemize}

\noindent
\textbf{組み合わせ}

\begin{itemize}

\item
手続の適用に対して、\code{eval}は再帰的に組み合わせの演算子とオペランドの部分を評価
しなければならない。結果となる手続と引数は\code{apply}に渡す。これは実際の
手続適用を取り扱う。

\end{itemize}

\noindent
以下に\code{eval}の定義を示します。

\begin{scheme}
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp)
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type: EVAL" exp))))
\end{scheme}

\noindent
明快さのために、\code{eval}は\code{cond}を用いた条件分岐として実装されています。
これの欠点は手続がいくつかの判別可能な式の型のみを取り扱い、\code{eval}の
定義を編集すること無しに新しい式が定義できないことです。多くのLisp実装では
式の型に従う呼出はデータ適従スタイルにより行われています。これはユーザに
\code{eval}が判別可能な新しい式の型の追加を許可します。\code{eval}自身の定義の
変更は必要有りません。(\link{Exercise 4.3}参照)

\subsubsection*{Apply}


\code{apply}は2つの引数、手続と手続が適用されるべき引数のリストを取ります。
\code{apply}は手続を2つ種類に分類します。プリミティブの適用には
\code{apply\-/primitive\-/procedure}を呼びます。複合手続の適用には手続のボディを
作る式を連続して評価することにより行います。複合手続のボディの評価のための
環境は手続により運ばれた基礎環境を拡張することで構築し、手続のパラメタを手続が
適用される引数に束縛するフレームを含めます。以下が\code{apply}の定義です。

\begin{scheme}
(define (apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
           (procedure-body procedure)
           (extend-environment
             (procedure-parameters procedure)
             arguments
             (procedure-environment procedure))))
        (else
         (error
          "Unknown procedure type: APPLY" procedure))))
\end{scheme}

\subsubsection*{手続の引数}



\code{eval}が手続適用を処理する時、\code{list\-/of\-/values}を用いて手続が適用される引数の
リストを生成します。\code{list\-/of\-/values}は引数として組み合わせのオペランドを取ります。
各オペランドを評価し対応する値のリストを返します。\footnote{\code{eval}の
\code{application?}節は明示的に\code{list\-/of\-/values}手続を書くのではなく、\code{map}を
用いることで(そして\code{operands}がリストを返すよう規定することで)より単純にすることが
できました。ここでは\code{map}を用いないことを選択することで高階手続を用いなくとも、
例え評価機がサポートする言語が高階手続をサポートすることになっても、評価機が
実装できることを強調しました。(従って高階手続を持たない言語で評価機を書くことも可能です)。}

\begin{scheme}
(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))
\end{scheme}

\subsubsection*{条件文}


\code{eval\-/if}は与えられた環境において\code{if}式の述語部分を評価します。
もし結果が真なら\code{eval\-/if}はconsequent(結果)を評価し、そうでなければ
alternative(代替)を評価します。

\begin{scheme}
(define (eval-if exp env)
  (if (true? (eval (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))
\end{scheme}

\noindent
\code{eval\-/if}内での\code{true?}の使用は実装言語と被実装言語の間の接続の問題を強調します。
\code{if\-/predicate}は被実装言語にて評価されるのでその言語の値を生じます。
インタプリタの述語\code{true?}はその値を実装言語の\code{if}でテストできる値に翻訳します。
真実性のメタ循環表現は根底をなすSchemeのそれとは同じではないかもしれません。\footnote{今回は
実装言語と被実装言語は同じです。ここでの\code{true?}の意味に対する熟考は本質を誤解
することなく理解の発展を促します。}

\subsubsection*{列}



\code{eval\-/sequence}は\code{apply}により用いられ手続のボディの中にある連続した式を
評価します。また\code{eval}でも使用され\code{begin}式の中の一連の式を評価します。
引数として一連の式と環境を取り、式が現われる順で評価します。返り値は最後の
式の値です。

\begin{scheme}
(define (eval-sequence exps env)
  (cond ((last-exp? exps)
         (eval (first-exp exps) env))
        (else
         (eval (first-exp exps) env)
         (eval-sequence (rest-exps exps) env))))
\end{scheme}

\subsubsection*{代入と定義}


以下の手続は変数への代入を扱います。\code{eval}を呼び代入される値を見つけ
値と結果となる変数を\code{set\-/variable\-/value!}へ転送することで指定された
環境へ設定されるようにします。

\begin{scheme}
(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                       (eval (assignment-value exp) env)
                       env)
  'ok)
\end{scheme}

\noindent
変数の定義は同様の方法で扱われます。\footnote{この\code{define}の実装は内部定義の
扱いの微妙な問題を無視します。しかし多くの場合では正しく動きます。問題が何か、
どのようにして解決するかについては\link{Section 4.1.6}で学びます。}

\begin{scheme}
(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (eval (definition-value exp) env)
                    env)
  'ok)
\end{scheme}

\noindent
ここで代入、または定義の値としてシンボル\code{ok}を返すことを選択しました。\footnote{\code{define}と
\code{set!}を導入した時に述べたように、これらの値はSchemeの実装依存です---つまり、
実装者がどんな値を返すのか選択できます。}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.1}Exercise 4.1:} 
メタ循環評価機がオペランドを左から右へ評価するのか、右から左へなのか
判断が付かないことに注意せよ。評価順は下位に横たわるLispから継承する。もし
\code{list\-/of\-/values}内の\code{cons}の引数が左から右へ評価されるのなら、
\code{list\-/of\-/values}はオペランドを左から右へと評価する。もし\code{cons}の引数が
右から左へ評価されるなら、\code{list\-/of\-/values}は右から左へ評価する。



オペランドを左から右へと下位に横たわるLispの評価順に係らず評価する\code{list\-/of\-/values}の
版を書け。またオペランドを右から左へ評価する\code{list\-/of\-/values}の版も書け。
\end{quote}

\subsection{式の表現}
\label{Sec. 4.1.2}
\label{Section 4.1.2}



評価機は\link{Section 2.3.2}で議論された記号微分プログラムを思い出させます。
双方のプログラムが記号式を操作します。両方のプログラムにおいて、複合式上の操作の
結果は式の断片を再帰的に操作し、式の型に依存した方法で結合することにより決定します。
両方のプログラムにおいて、私達はデータ抽象化を用いて式がどのように表現されるかの
詳細から命令の一般的なルールを分離します。微分プログラムではこのことが、同じ微分手続が
接頭辞形式、接中辞形式、またはいくつかの他の形式の代数式を扱えることを意味しました。
評価機にとっては、これは評価される言語の文法がもっぱら式を分類し、断片を抽出する
手続により決定されることを意味します。


以下に私達の言語の構文の仕様を示します。

\begin{itemize}

\item
自己評価アイテムは数値と文字列のみです。

\begin{scheme}
(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        (else false)))
\end{scheme}

\item
変数はシンボルにより表現されます。

\begin{scheme}
(define (variable? exp) (symbol? exp))
\end{scheme}

\item
引用は\code{(quote <\var{text\-/of\-/quotation}>)}の形式を持ちます。\footnote{\link{Section 2.3.1}で
述べたとおり、評価機は引用(quote)された式を\code{quote}で始まるリストだと見ます。
例え式がクォーテーションマークで入力されていてもです。例えば式\code{'a}は
この評価機では\code{(quote a)}と見られます。\link{Exercise 2.55}を参照して下さい。}

\begin{scheme}
(define (quoted? exp) (tagged-list? exp 'quote))
(define (text-of-quotation exp) (cadr exp))
\end{scheme}


\code{quoted?}は手続\code{tagged\-/list?}を用いて定義されます。これはリストが指定された
シンボルで開始するかを判断します。

\begin{scheme}
(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      false))
\end{scheme}

\item
代入は\code{(set! <\var{var}> <\var{value}>)}の形式を取ります。

\begin{scheme}
(define (assignment? exp) (tagged-list? exp 'set!))
(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))
\end{scheme}

\item
定義は以下の形式を取ります。

\begin{scheme}
(define ~\( \dark \langle \)~~\var{\dark var}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark value}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
または以下の形式になります。

\begin{scheme}
(define (~\( \dark \langle \)~~\var{\dark var}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark parameter_1 \)~~\( \dark \rangle \)~ ~\( \dots \)~ ~\( \dark \langle \)~~\( \dark parameter_n \)~~\( \dark \rangle \)~)
  ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~)
\end{scheme}


後者の形式(標準手続定義)は以下に対する糖衣構文です。

\begin{scheme}
(define ~\( \dark \langle \)~~\var{\dark var}~~\( \dark \rangle \)~
  (lambda (~\( \dark \langle \)~~\( \dark parameter_1 \)~~\( \dark \rangle \)~ ~\( \dots \)~ ~\( \dark \langle \)~~\( \dark parameter_n \)~~\( \dark \rangle \)~)
    ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~))
\end{scheme}



対応する構文手続は以下となります。

\begin{scheme}
(define (definition? exp) (tagged-list? exp 'define))
(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))
(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)     ~\textrm{; formal parameters}~
                   (cddr exp))))   ~\textrm{; body}~
\end{scheme}

\item
\code{lambda}式はシンボル\code{lambda}で始まるリストです。

\begin{scheme}
(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))
\end{scheme}


また\code{lambda}式に対するコンストラクタも提供します。これは
上記の\code{definition\-/value}で使用されます。

\begin{scheme}
(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))
\end{scheme}

\item
条件式は\code{if}で始まり述語、結果式、持ち、(任意で)代替式を持ちます。もし式が代替式
の部分を持たないのであれば代替式として\code{false}を与えます。\footnote{述語がfalseになり
代替式が存在しない場合の\code{if}式の値はSchemeでは未定義です。ここでは私達はfalseにする
ことを選択しました。私達は変数\code{true}と\code{false}の式内での利用をサポートし、グローバル
環境でのそれらの束縛により評価されるようにします。\link{Section 4.1.4}参照。}

\begin{scheme}
(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))
\end{scheme}



また\code{if}式に対するコンストラクタも提供します。これは\code{cond\-/>if}により
\code{cond}式を\code{if}式に変換するのに用いられます。

\begin{scheme}
(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))
\end{scheme}

\item
\code{begin}は一連の式を1つの式へとまとめます。\code{begin}式から実際の列を取り出す命令と同時に、
列の最初の式とその残りの式を返すセレクタも含まれます。\footnote{式のリストに対する
これらのセレクタ---それに対応するオペランドのリスト向けのものも含めて---はデータ抽象化を
意図するものではありません。それらは基本的なリスト命令のためのmnemonic(ニーモニック)名として
\link{Section 5.4}にて明示的コントロール評価機を理解することを易しくするために導入されます。}

\begin{scheme}
(define (begin? exp) (tagged-list? exp 'begin))
(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))
\end{scheme}


また\code{cond\-/>if}で用いるコンストラクタ\code{sequence\-/>exp}も含めます。これは
列を単一の式に、必要ならば\code{begin}を用いて、変換します。

\begin{scheme}
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq))
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))
\end{scheme}

\item
手続の適用は上記の式の型ではない任意の複合式です。その式の\code{car}はオペレータであり、
\code{cdr}はオペランドのリストです。

\begin{scheme}
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))
\end{scheme}

\end{itemize}

\subsubsection*{派生式}


いくつかの私達の言語内での特殊形式は直接実装されるのでなく、他の特殊形式を含む式を用いて定義できます。
例の1つは\code{cond}です。これは入れ子の\code{if}式として実装できます。例えば以下の式の評価上の
問題を、

\begin{scheme}
(cond ((> x 0) x)
      ((= x 0) (display 'zero) 0)
      (else (- x)))
\end{scheme}

\noindent
次の\code{if}と\code{begin}の式を含む式の評価問題へと簡約することができます。

\begin{scheme}
(if (> x 0)
    x
    (if (= x 0)
        (begin (display 'zero) 0)
        (- x)))
\end{scheme}

\noindent
\code{cond}の評価をこのように実装することは評価機を簡略化します。評価過程が明示的に
指定されねばならない特殊形式の数を減らすことができるからです。



\code{cond}式の部分を抽出する構文手続と\code{cond}式を\code{if}式に変形する式\code{cond->if}を
含めます。事例分析は\code{cond}で始まり述語-行動節のリストを持ちます。節はもし
その述語がシンボル\code{else}ならば\code{else}節です。\footnote{全ての述語がfalseで
\code{else}節が存在しない場合の\code{cond}式の値はSchemeでは未定義です。ここでは
それをfalseにしました。}


\begin{scheme}
(define (cond? exp) (tagged-list? exp 'cond))
(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond->if exp) (expand-clauses (cond-clauses exp)))
(define (expand-clauses clauses)
  (if (null? clauses)
      'false                        ~\textrm{; no \code{else} clause}~
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence->exp (cond-actions first))
                (error "ELSE clause isn't last: COND->IF"
                       clauses))
            (make-if (cond-predicate first)
                     (sequence->exp (cond-actions first))
                     (expand-clauses rest))))))
\end{scheme}

\noindent
文法上の変形を実装することを選択した\code{cond}のような式は
\newterm{derived expressions}(\jnewterm{派生式})と呼ばれます。\code{let}式もまた派生式です。
(\link{Exercise 4.6}参照)\footnote{実用的なLispシステムはユーザに対し新しい派生式を
追加し、評価機の変更無しに文法上の変形としての実装を指定できる仕組みを提供します。
そのようなユーザ定義変形は\newterm{macro}(\jnewterm{マクロ})と呼ばれます。マクロ定義の初歩的な仕組みを
追加することは簡単なのですが、結果的にその言語は微妙な名前衝突の問題を持ちます。
これらの困難をもたらさないマクロ定義の仕組みに関する多くの研究が存在します。
例えば\link{Kohlbecker 1986}, \link{Clinger and Rees 1991}, \link{Hanson 1991}を
参照して下さい。}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.2}Exercise 4.2:} 
Louis Reasonerは\code{eval}の\code{cond}の順を変えて手続適用の節が代入のための節の前に
なるようにする計画を立てた。彼はこうすることでインタプリタをより効率良くできると
主張した。プログラムは通常代入、定義等より適用を含んでいるためだ、と。
彼の変更した\code{eval}は元の\code{eval}よりも通常より少ない節を式の型が判明する前に
チェックするだろうという主張だ

\begin{enumerate}[a]

\item
Louisの計画の何が間違っているか? (ヒント：Louisの評価機は式\code{(define x 3)}に
対し何を行うか?)

\item
Louisは彼の計画がうまく行かないことに激昂した。彼は他の多くの型の式をチェックする
前に彼の評価機をいくらでも長くして手続適用を認識させようとしている。評価される
言語を変更し手続適用が\code{call}で始まるようにすることで彼の手助けをせよ。
例えば\code{(factorial 3)}の代わりに変更後は\code{(call factorial 3)}と書かねばならず、
\code{(+ 1 2)}は\code{(call + 1 2)}と書かねばならない。

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.3}Exercise 4.3:} 
\code{eval}を書き直し呼出がデータ適従スタイルにて行われるようにせよ。これを
\link{Exercise 2.73}のデータ適従型微分手続と比較せよ。この節で実装された文法
に適切であるとおり、(複合式の\code{car}を式の型として用いてよい。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.4}Exercise 4.4:} 
\link{Chapter 1}の特殊形式\code{and}と\code{or}の定義を思い出せ。

\begin{itemize}

\item
\code{and}: 式は左から右へと評価される。もし任意の式がfalseと評価されるならfalseが返される。
残りの式全ては評価されない。もし全ての式がtrueの値に評価されるなら最後の式の評価値が
返される。もし式が全く存在しないならtrueが返される。

\item
\code{or}: 式は左から右へと評価される。もし任意の式がtrueと評価されるのならその値が
返される。残りの式全ては評価されない。もし全ての式がfalseと評価されるのなら、または
もし式が全く存在しないなら、falseが返される。

\end{itemize}
\code{and}と\code{or}を評価機に対する新しい特殊形式として適切な構文手続と
評価手続\code{eval\-/and}と\code{eval\-/or}を定義することで導入せよ。
代替法として、\code{and}と\code{or}を派生式として実装する方法を示せ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.5}Exercise 4.5:} 
Schemeは\code{cond}の節に追加の文法、\code{(<\var{test}> => <\var{recipient}>)}を認めている。
もし\( \langle \)\var{test}\( \kern0.08em\rangle \)がtrueとして評価されるなら、
\( \langle \)\var{recipient}\( \kern0.08em\rangle \)が評価される。その値は1引数の手続でなければならない。
そしてこの手続が\( \langle \)\var{test}\( \kern0.08em\rangle \)の値で起動され、その結果が\code{cond}式の値と
して返される。例えば、

\begin{scheme}
(cond ((assoc 'b '((a 1) (b 2))) => cadr)
      (else false))
\end{scheme}

\noindent
は2を返す。\code{cond}を変更してこの拡張文法をサポートするようにせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.6}Exercise 4.6:} 
\code{let}式は派生式である。なぜなら、

\begin{scheme}
(let ((~\( \dark \langle \)~~\( \dark var_1 \)~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark exp_1 \)~~\( \dark \rangle \)~) ~\( \dots \)~ (~\( \dark \langle \)~~\( \dark var_n \)~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark exp_n \)~~\( \dark \rangle \)~))
  ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
は以下と等価である。

\begin{scheme}
((lambda (~\( \dark \langle \)~~\( \dark var_1 \)~~\( \dark \rangle \)~ ~\( \dots \)~ ~\( \dark \langle \)~~\( \dark var_n \)~~\( \dark \rangle \)~)
   ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~)
 ~\( \dark \langle \)~~\( \dark exp_1 \)~~\( \dark \rangle \)~
 ~\( \dots \)~
 ~\( \dark \langle \)~~\( \dark exp_n \)~~\( \dark \rangle \)~)
\end{scheme}

文法上の変形\code{let\-/>combination}を実装せよ。これは\code{let}式の評価を上記で示された
型の組み合わせの評価へと簡約する。そして\code{let}式を扱うために\code{eval}に適切な節を
追加する。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.7}Exercise 4.7:}
\code{let*}は\code{let}に似ているが、\code{let*}の変数の束縛が左から右へと続けて実行され、
全ての先行する束縛が可視となるよう各束縛が環境へ追加されていく。例えば、

\begin{scheme}
(let* ((x 3)  (y (+ x 2))  (z (+ x y 5)))
  (* x z))
\end{scheme}

\noindent
は39を返す。\code{let*}式が入れ子の\code{let}式の集合としてどのように書き直すことができるか
説明せよ。そしてこの変形を実行する手続\code{let*\-/>nested\-/lets}を書け。
もし私達が既に\code{let}を実装していて(\link{Exercise 4.6})、評価機を拡張し\code{let*}を
扱いたいとしたら、以下の処理を行う節を\code{eval}に追加することは十分であろうか?

\begin{scheme}
(eval (let*->nested-lets exp) env)
\end{scheme}

\noindent
または私達は明示的に\code{let*}を非派生式を用いて拡張するべきであろうか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.8}Exercise 4.8:} 
``名前付き\code{let}''は\code{let}の変種であり以下の形式を持つ。

\begin{scheme}
(let ~\( \dark \langle \)~~\var{\dark var}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark bindings}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~)
\end{scheme}


\( \langle \)\var{bindings}\( \kern0.08em\rangle \)と\( \langle \)\var{body}\( \kern0.08em\rangle \)は
通常の\code{let}と同様である。しかし\( \langle \)\var{var}\( \kern0.08em\rangle \)が
\( \langle \)\var{body}\( \kern0.08em\rangle \)内部で束縛される手続であり、
ボディが\( \langle \)\var{body}\( \kern0.08em\rangle \)であり、
かつパラメタが\( \langle \)\var{bindings}\( \kern0.08em\rangle \)の変数である点が異なる。
従って\( \langle \)\var{var}\( \kern0.08em\rangle \)で名付けられた手続を呼び出すことで
繰り返し\( \langle \)\var{body}\( \kern0.08em\rangle \)を実行することができる。例えば、
反復フィボナッチ手続(\link{Section 1.2.2})は名前付き\code{let}を用いて以下のように書き直すことができる。
\begin{scheme}
(define (fib n)
  (let fib-iter ((a 1)
                 (b 0)
                 (count n))
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1)))))
\end{scheme}


\link{Exercise 4.6}の\code{let\-/>combination}を変更して名前付き\code{let}もサポートするようにせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.9}Exercise 4.9:} 
多くの言語が\code{do}, \code{for}, \code{while}, \code{until}のような多様な反復構造をサポートする。
Schemeでは反復処理が通常の手続呼出を用いて表現できるため特別な反復構造が演算能力に対し
本質的な利益を与えることはない。一方でそのような構造は時折便利でもある。いくつかの
反復構造を設計せよ。それらの使用の例を与えどのように派生式として実装するかについて示せ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.10}Exercise 4.10:}
データ抽象化を用いることで、評価されるべき言語の特定の文法から独立した\code{eval}手続を
書くことができる。これを説明するために\code{eval}と\code{apply}を変更すること
なくこの節の手続を変更することでSchemeの新しい文法を設計し、実装せよ。
\end{quote}

\subsection{評価機のデータ構造}
\label{Sec. 4.1.3}
\label{Section 4.1.3}

式の外側の文法を定義するのに加えて、評価機の実装は評価機が内部的に操作するデータ構造も
プログラムの実行の一部として、手続と環境の表現やtrueとfalseの表現を定義しなければなりません。

\subsubsection*{述語のテスト}


条件節に対しては真になるものは全て受け入れます。真とは明示的な\code{false}オブジェクトでは無いものです。

\begin{scheme}
(define (true? x)  (not (eq? x false)))
(define (false? x) (eq? x false))
\end{scheme}

\subsubsection*{手続の表現}


プリミティブを扱うために、以下の手続が利用可能であると仮定します。

\begin{itemize}

\item
\code{(apply\-/primitive\-/procedure <\var{proc}> <\var{args}>)}

\noindent
与えられたプリミティブな手続をリスト\( \langle \)\var{args}\( \kern0.08em\rangle \)中の
引数の値に適用し、適用の結果を返します。

\item
\code{(primitive\-/procedure? <\var{proc}>)}

\noindent
\( \langle \)\var{proc}\( \kern0.08em\rangle \)がプリミティブな手続であるか確認します。

\end{itemize}

\noindent
プリミティブを扱うこれらの仕組みは\link{Section 4.1.4}でさらに説明されます。


複合手続はパラメタ、手続のボディ、環境からコンストラクタ\code{make\-/procedure}を用いて
構築されます。

\begin{scheme}
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))
(define (compound-procedure? p)
  (tagged-list? p 'procedure))
(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))
\end{scheme}

\subsubsection*{環境上の命令}


評価機は環境を操作する命令を必要とします。\link{Section 3.2}で説明された通り、環境は
連続するフレームであり、各フレームは変数をその対応する値に関連付ける束縛のテーブルです。
以下の命令を用いて環境を操作します。

\begin{itemize}

\item
\code{(lookup\-/variable\-/value <\var{var}> <\var{env}>)}


環境\( \langle \)\var{env}\( \kern0.08em\rangle \)内でシンボル\( \langle \)\var{var}\( \kern0.08em\rangle \)に
束縛された値を返します。または変数が束縛されていない場合エラーを発します。

\item
\code{(extend\-/environment <\var{variables}> <\var{values}> <\var{base\-/env}>)}

新しいフレームから成る環境を返します。フレームの中ではリスト\( \langle \)\var{variables}\( \kern0.08em\rangle \)中の
シンボルがリスト中\( \langle \)\var{values}\( \kern0.08em\rangle \)の対応する要素に束縛されます。
取り囲む環境は環境\( \langle \)\var{base\-/env}\( \kern0.08em\rangle \)です。
\item
\code{(define\-/variable! <\var{var}> <\var{value}> <\var{env}>)}


環境\( \langle \)\var{env}\( \kern0.08em\rangle \)の最初のフレームに
変数\( \langle \)\var{var}\( \kern0.08em\rangle \)を
値\( \langle \)\var{value}\( \kern0.08em\rangle \)に関連付ける新しい束縛を追加します。
\item
\code{(set\-/variable\-/value! <\var{var}> <\var{value}> <\var{env}>)}


環境\( \langle \)\var{env}\( \kern0.08em\rangle \)中の変数\( \langle \)\var{var}\( \kern0.08em\rangle \)の束縛を変更し、
その変数が新しく値\( \langle \)\var{value}\( \kern0.08em\rangle \)に束縛されるようにします。
またはもし変数が束縛されていない場合にはエラーを発します。
\end{itemize}

\noindent
これらの命令を実装するためには環境をフレームのリストとして表現します。
環境を内包する環境はリストの\code{cdr}です。空の環境は単純に空リストです。

\begin{scheme}
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())
\end{scheme}

\noindent
環境の各フレームはリストのペアとして表現されます。フレームに束縛される変数のリストと
対応する値のリストです。\footnote{フレームは実際には以下のコードにおいてデータ抽象化されていません。
\code{Set\-/variable\-/value!}と\code{define\-/variable!}は\code{set\-/car!}を用いて直接フレームの値を変更しています。
フレーム手続の目的は環境操作手続を読み易くすることです。}

\begin{scheme}
(define (make-frame variables values)
  (cons variables values))
(define (frame-variables frame) (car frame))
(define (frame-values frame) (cdr frame))
(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))
\end{scheme}

\noindent
環境を変数を値に関連付ける新しいフレームにより拡張するために、変数のリストと値のリストから
成るフレームを作成します。そしてその環境に隣接させます。もし変数の数が値の数に合わない場合には
エラーを発します。

\begin{scheme}
(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))
\end{scheme}

\noindent
環境内の変数を探すためには、最初のフレームの変数のリストを走査します。
希望の変数を見つければ対応する値リスト内の要素を返します。
もし現在のフレーム内にその変数が見つからなければ内包する環境を探します。以下、繰り返しです。
もし空環境まで辿り着いたならば``束縛されていない変数''のエラーを発します。

\begin{scheme}
(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars)) (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
\end{scheme}

\noindent
変数に新しい値を指定された環境にて設定するには、\code{lookup\-/variable\-/value}と同様に変数を走査し、
対応する見つかった場合には対応する値を変更します。

\begin{scheme}
(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars)) (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable: SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
\end{scheme}

\noindent
変数を定義するには、最初にその変数の束縛を最初のフレームにて探します。
束縛が存在すれば変更を行います。(\code{set\-/variable\-/value!}と同様です)。
そのような束縛がなければ最初のフレームに追加します。

\begin{scheme}
(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars)) (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame) (frame-values frame))))
\end{scheme}

\noindent
ここで記述された手法は環境を表現する多くのもっともな方法の1つでしかありません。
データ抽象化を用いて評価機の他の部分を表現の詳細な選択から分離したので、もし
望めば環境の表現を変更することが可能です。(\link{Exercise 4.11}参照)。
実運用品質のLispシステムでは評価機の環境向け命令のスピードが---特に変数探索の物が---システムの
パフォーマンスに主に影響を与えます。ここで説明された表現は概念上シンプルではありますが、
効率的ではなく通常は実運用システムでは用いられません。\footnote{この
表現の欠点は(\link{Exercise 4.11}の亜種も同様に)評価機が与えられた変数を見つけるために
数多くのフレームを探索しなければならないかもしれない点です。(このような取り組み方は
\newterm{deep binding}(\jnewterm{深い束縛})と参照されます)。この非効率性を防ぐ1つの方法は
\newterm{lexical addressing}(\jnewterm{レキシカルアドレッシング})と呼ばれ\link{Section 5.5.6}にて
議論されます。}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.11}Exercise 4.11:} 
フレームをリストのペアと表現する代わりに、フレームを束縛のリストとして表現可能である。
この場合、各束縛は名前と値のペアだ。環境の命令を書き換えこの代替表現を用いるようにせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.12}Exercise 4.12:}
手続\code{set\-/variable\-/value!}, \code{define\-/variable!}, \code{lookup\-/variable\-/value}は
環境の構造を縦断するためのより抽象的な手続を用いて表現することができる。
共通なパターンを捕える抽象化を定義し、3つの手続をこられの抽象化を用いて再定義せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.13}Exercise 4.13:} 
Schemeは\code{define}を用いて新しい束縛を作成することができる。しかし束縛を
取り除く手段は提供しない。評価機に特殊形式\code{make\-/unbound!}を実装せよ。
これは\code{make\-/unbound!}が評価された環境から与えられたシンボルの束縛を
削除する。この問題は完全には指示されていない。例えば環境の最初のフレームの
束縛のみを削除するべきだろうか? 仕様を完成させあなたが行った選択について
理由を述べよ。
\end{quote}

\subsection{評価機をプログラムとして実行する}
\label{Section 4.1.4}


評価機を与えられたことで、Lisp式が評価されるプロセスの(Lispで表現された)記述を
手中にしました。評価機をプログラムとして表現することの利点の1つはプログラムを
実行できることです。これによりLispの中で実行することでLisp自身がどのように式を
評価するのかについての実行モデルを得ることができました。これは評価ルールを検証する
フレームワークの役割を果たします。実際にこの章の後の方で行います。


評価機プログラムは式を究極的にはプリミティブな手続の適用まで簡約します。
従って評価機を実行するのに必要なもの全ては基盤を無すLispシステムを呼び出す
仕組みを作成することでプリミティブ手続の適用をモデル化することです。


各プリミティブな手続の名前の束縛が存在しなければなりません。そのため\code{eval}が
プリミティブの適用の命令を評価する時、\code{apply}に渡すオブジェクトを見つけます。
従って私達は評価しようとする式の中に現れることが可能なプリミティブな手続の名前と
独自のオブジェクトを関連付けするグローバル環境を設定します。グローバル環境は
またシンボル\code{true}と\code{false}のための束縛も含めます。そうすることで
それらが評価される式の中で変数として利用することができます。

\begin{scheme}
(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true true initial-env)
    (define-variable! 'false false initial-env)
    initial-env))
(define the-global-environment (setup-environment))
\end{scheme}

\noindent
どのようにプリミティブ手続オブジェクトを評価するかは、\code{apply}がそれらを手続
\code{primitive\-/procedure?}と\code{apply\-/primitive\-/procedure}を用いて判別できる限り問題ではありません。
私達はプリミティブな手続をシンボル\code{primitive}で始まり、そのプリミティブを実装する低層のLispの手続を
含むリストとして表現することを選択しました。

\begin{scheme}
(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))
(define (primitive-implementation proc) (cadr proc))
\end{scheme}

\noindent
\code{setup\-/environment}はプリミティブの名前と実装手続をリストから得ます。\footnote{低層のLispで
定義される任意の手続はメタ循環評価機のプリミティブとして使用できます。評価機にインストールされる
プリミティブの名前は低層のLispにおける実装の名前と同じである必要はありません。
ここで名前が同じなのはメタ循環評価機がSchemeそれ自身を実装するためです。従って例えば
\code{(list 'first car)}や\code{(list 'square (lambda (x) (* x x)))}を
\code{primitive\-/procedures}に入れることもできたでしょう。}

\begin{scheme}
(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        ~\( \dark \langle \)~~\var{\dark more primitives}~~\( \dark \rangle \)~ ))
(define (primitive-procedure-names)
  (map car primitive-procedures))
(define (primitive-procedure-objects)
  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))
\end{scheme}

\noindent
プリミティブ手続を適用するためには単純に実装手続を引数に対して低層のLispシステムを
用いて適用します。\footnote{
\code{apply\-/in\-/underlying\-/scheme}は前の章で使用した
\code{apply}手続です。メタ循環評価機の\code{apply}手続(\link{Section 4.1.1})はこのプリミティブの
動き方をモデルにしています。2つの異なる\code{apply}と呼ばれる物を持つことはメタ循環
評価機を実行するにおいて問題へと導きます。メタ循環評価機の\code{apply}を定義することが
プリミティブの定義を隠してしまうためです。これを回避する1つの方法はメタ循環の
\code{apply}をリネームすることでプリミティブ手続の名前との衝突を避けることです。
私達はその代わりに下層の\code{apply}への参照をメタ循環の\code{apply}を定義する前に
以下のようにすることで保存しました。

\begin{smallscheme}
(define apply-in-underlying-scheme apply)
\end{smallscheme}

\noindent
これで元の版の\code{apply}に異なる名前でアクセスできるようになりました。}

\begin{scheme}
(define (apply-primitive-procedure proc args)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))
\end{scheme}

\noindent
メタ循環評価機実行時の利便性のために、低層のLispシステムのread-eval-print loop (REPL:レプル)を
モデルにした\newterm{driver loop}(\jnewterm{ドライバループ})を提供します。これは\newterm{prompt}(\jnewterm{プロンプト})を表示し、
入力式を読み込み、この式をグローバル環境の中で評価し、結果を表示します。
私達は各表示された結果の前に\newterm{output prompt}(\jnewterm{出力プロンプト})を置きます。そうすることで
式の値を他の表示されるかもしれない出力から判別するためです。\footnote{プリミティブな手続
\code{read}はユーザからの入力を待ち、次の入力された完全な式を返します。例えばもしユーザが
\code{(+ 23 x)}と入力した場合、\code{read}は3つの要素、シンボル\code{+}、数値23、シンボル\code{x}を
含むリストを返します。もしユーザが\code{'x}と入力したなら\code{read}は2つの要素、
シンボル\code{quote}とシンボル\code{x}を含むリストを返します。}

\begin{scheme}
(define input-prompt  ";;; M-Eval input:")
(define output-prompt ";;; M-Eval value:")
(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (eval input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))
(define (announce-output string)
  (newline) (display string) (newline))
\end{scheme}

\noindent
私達は特別なプリント手続、\code{user\-/print}を使用します。これは複合手続の環境部分を
表示するのを防ぐためです。これはとても長いリストに成り得ます。(またはさらにループを
含んでいるかもしれません。)

\begin{scheme}
(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))
\end{scheme}

\noindent
これで評価機を実行するのに必要なことはグローバル環境の初期化と
ドライバーループの開始のみです。以下がサンプルの応答です。

\begin{scheme}
(define the-global-environment (setup-environment))
(driver-loop)
~\textit{;;; M-Eval input:}~
(define (append x y)
  (if (null? x)
      y
      (cons (car x) (append (cdr x) y))))
~\textit{;;; M-Eval value:}~
~\textit{ok}~
~\textit{;;; M-Eval input:}~
(append '(a b c) '(d e f))
~\textit{;;; M-Eval value:}~
~\textit{(a b c d e f)}~
\end{scheme}

% \vspace{1em}
\begin{quote}
\heading{\phantomsection\label{Exercise 4.14}Exercise 4.14:}
Eva Lu AtorとLouis Reasonerはそれぞれ評価機を検証している。Evaは\code{map}の定義を
入力しいくつかそれを用いるテストプログラム実行している。それらはうまく動いた。
Louisは逆に\code{map}のシステム版をメタ循環評価機のプリミティブとして導入した。
彼がそれを確かめた時、全くうまく動かなかった。なぜEvaはうまく行ったのに
Louisの\code{map}は失敗するのか。説明せよ。
\end{quote}

\subsection{プログラムとしてのデータ}


Lisp式を評価するLispプログラムについて考えることにおいて、例えはとても良い
手助けになるでしょう。プログラムの意味についての命令上の視点の1つに、プログラムは
(恐らく無限に大きな)抽象機械の記述であるという物があります。
例えば階乗を計算する親しみのあるプログラムについて考えてみましょう。

\begin{scheme}
(define (factorial n)
  (if (= n 1) 1 (* (factorial (- n 1)) n)))
\end{scheme}

\noindent
私達はこのプログラムを減算、乗算、等価試験の部品と一緒に2つの位置を持つスイッチと
他の階乗機械を含める機械の説明であると見做すことができるでしょう。(階乗機械は
無限です。他の階乗機械をその中に含んでいるためです)。\link{Figure 4.2}は
階乗機械の流れ図でありその部品がどのようにお互いに接続されているかを示しています。


同様な方法で、評価機を入力として機械の説明書を取るとても特殊な機械だと見做すことができます。
この入力を与えられると、評価機はそれ自身を記述された機械を真似るように設定します。
例えばもし評価機に\link{Figure 4.3}で示される\code{factorial}の記述を与えれば、
評価機は階乗の計算ができるようになります。

\begin{figure}[tb]
\phantomsection\label{Figure 4.2}
\centering
\begin{comment}
\heading{Figure 4.2:} The factorial program, viewed as an abstract machine.

\begin{example}
    +-----------------------------------+
    | factorial                   |1    |
    |              |1             V     |
    |              |           +-----+  |
    |              V           | #   |  |
    |           +-----+        |     |  |
6 --------*-----|  =  |------->|   #-+-----> 720
    |     |     +-----+        |  /  |  |
    |     |                    | #   |  |
    |     |                    +-----+  |
    |     |                       ^     |
    |     |                       |     |
    |     |                    +--+--+  |
    |     *------------------->|  *  |  |
    |     |                    +-----+  |
    |     V                       ^     |
    |  +-----+    +-----------+   |     |
    |  |  -  +--->| factorial +---+     |
    |  +-----+    +-----------+         |
    |     ^                             |
    |     |1                            |
    +-----------------------------------+
\end{example}
\end{comment}
\includegraphics[width=84mm]{fig/chap4/Fig4.2.pdf}
\begin{quote}
\heading{Figure 4.2:} 抽象機械として見た階乗プログラム
\end{quote}
\end{figure}

\noindent
この視点からは、私達の評価機は\newterm{universal machine}(\jnewterm{万能機械})であると見えます。
他の機械がLispにて説明される時、それを真似します。\footnote{機械がLispで記述されるという
ことは本質ではありません。もし私達の評価機にC言語の様な他の言語のための評価機として
振る舞うLispプログラムを与えた場合、Lisp評価機はC評価機の真似をします。
それは順に、C言語で記述された任意の機械の真似が可能です。同様にCで書かれたLisp評価機は
任意のLispプログラムを実行できるCのプログラムを生成します。ここでの深い意図は評価機は
任意の他の物を真似できることです。従って``原理上、何が計算できるのか''という概念(必要な
時間とメモリの実現性は無視)は言語や計算機に非依存です。その代わりに根底を成す概念である
\newterm{computability}(\jnewterm{計算可能性})を反映します。これは最初にAlan M. Turing (1912-1954)に
より明確に証明されました。彼の1936年の論文は計算機科学理論の基礎を導きました。この論文で
チューリングは簡素な計算モデル---今日、\newterm{Turing machine}(\jnewterm{チューリングマシン})として
知られる---を公開し、任意の``実効的な処理''はそのような機械のプログラムとして定式化できると
主張しました。(この論拠は\newterm{Church-Turing thesis}(\jnewterm{チャーチ・チューリングのテーゼ}、
または提唱)として知られます)。チューリングは次に万能機械、即ちチューリングマシン向けプログラムの
評価機として振る舞うチューリングマシンを実装しました。彼はこのフレームワークを用いて
チューリングマシンでは計算できない上手く設定された問題が存在することを証明しました。
(\link{Exercise 4.15}参照)。そのため暗に``実効的な処理''として定式化
できない問題の存在も示したのです。チューリングは実用的な計算機科学への基礎的な貢献の
行いも続けました。例えば彼は汎用目的サブルーチンを用いて構造化プログラミングの考えを
発明しました。チューリングの経歴については\link{Hodges 1983}を参照して下さい。}これは
特筆すべきことです。電子回路向けの同等な評価機について想像することを試してみて下さい。
入力としてフィルタのようなある他の回路の計画を符号化した信号を取る回路になるでしょう。
この入力を与えられて、回路評価機はそこで記述と同じフィルタのように振る舞うでしょう。
そのような万能電子回路はほとんど想像不可能なほど複雑です。プログラム評価機がとても
簡単なプログラムであることは特筆に値します。\footnote{ある人々は比較的単純な手続により
実装された評価機が評価機それ自身より複雑なプログラムの真似ができることが直感的でないと
感じました。万能評価機械の存在は深く、そして素晴しい演算処理の特性です。\newterm{Recursion
theory}(\jnewterm{再帰理論})は数理論理学の1部門であり、演算処理の論理上の制約に関係します。
Douglas Hofstadter(ダグラス ホフスタッター)の美しい本
\textit{G\"odel, Escher, Bach}(邦題:ゲーデル エッシャー バッハ)は
これらの考えのいくつかについて探求します。(\link{Hofstadter 1979})}

\begin{figure}[tb]
\phantomsection\label{Figure 4.3}
\centering
\begin{comment}
\heading{Figure 4.3:} The evaluator emulating a factorial machine.

\begin{example}
                   +--------+
            6 ---->|  eval  |----> 720
                   +--------+
                       /
             . . .    /  . . .
       . . .       ../. .      .
     .                           ..
    .   (define (factorial n)      . . .
   .      (if (= n 1)                   . .
    .         1                            .
    .         (* (factorial (- n 1)) n)))   .
      . .                       . .        .
          . .  . .      . . . .     . . . .
                   . ..
\end{example}
\end{comment}
\includegraphics[width=69mm]{fig/chap4/Fig4.3.pdf}
\par\bigskip
\noindent
\heading{Figure 4.3:} 階乗マシンを真似する評価機
\end{figure}

\noindent
もう1つの特筆すべき評価機の側面はそれがプログラミング言語により操作されるデータオブジェクトと
プログラミング言語それ自身との間のブリッジ(橋)として働くことです。(Lispで実装された)
評価機プログラムが実行中であり、ユーザが式をその評価機に入力し結果を観察していると
想像してみて下さい。ユーザの視点からは\code{(* x x)}の様な入力式はプログラミング言語に
よる式であり、評価機が実行すべき物です。しかし、評価機の視点からは式は単純なリスト
(この場合ではシンボル\code{*}, \code{x}, \code{x}のリスト)であり、これは明確なルール集合に
従って操作されねばならぬ物です。

ユーザのプログラムが評価機のデータだということは混乱の元となる必要はありません。
実際に、時々はこの区別は無視したほうが便利です。そしてユーザに対し明示的にデータ
オブジェクトをLispの式として評価する能力を\code{eval}手続をプログラム中で使用できる
ようにすることで与えることもまた便利なことです。多くのLisp方言は引数として
式と環境を取り、その環境に関連してその式を評価するプリミティブな\code{eval}手続を
与えます。\footnote{警告：この\code{eval}プリミティブは私達が\link{Section 4.1.1}で
実装した\code{eval}手続とは異なります。それは私達が\link{Section 4.1.3}で構築した
サンプルの環境構造ではなく、実際のScheme環境を用いるためです。これらの実際の環境は
ユーザにより通常のリストとして操作することはできません。それらは\code{eval}により
アクセスされるか、他の特別な命令を用います。同様に以前に見た\code{apply}プリミティブ
もメタ循環\code{apply}とは異なります。それが私達が\link{Section 4.1.3}と\link{Section 4.1.4}で
構築した手続オブジェクトではなく、実際のScheme手続を用いるからです。}従って、

\begin{scheme}
(eval '(* 5 5) user-initial-environment)
\end{scheme}

\noindent
と

\begin{scheme}
(eval (cons '* (list 5 5)) user-initial-environment)
\end{scheme}

\noindent
の両方は25を返します。\footnote{Schemeの\acronym{MIT}実装は\code{eval}と同様に
ユーザの入力式が評価される初期環境に束縛されるシンボル\code{user\-/initial\-/environment}も
含みます。}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.15}Exercise 4.15:}
1引数手続\code{p}とオブジェクト\code{a}を与えられた時、式\code{(p a)}が(エラーメッセージや
無限に停止しない場合とは対照的に)値を返す場合に、\code{p}は\code{a}に対して``halt''(停止)
すると呼ばれる。\code{p}が\code{a}に対し停止するかどうかを任意の手続\code{p}と任意のオブジェクト\code{a}に
対して正確に決定する手続\code{halts?}を書くことは不可能であることを示せ。以下の推測を
用いろ：もしそのような手続\code{halts?}が存在するなら以下のプログラムを実装できるだろう。

\begin{scheme}
(define (run-forever) (run-forever))
(define (try p)
  (if (halts? p p) (run-forever) 'halted))
\end{scheme}


ここで式\code{(try try)}の評価について考え、どんな可能な結末(停止するか、無限に実行するか)も
\code{halts?}の意図した振舞に違反することを示せ。\footnote{\code{halts?}が手続オブジェクトを
与えらえたと規定したが、この推測が例え\code{halts?}が手続のテキストとその環境への
アクセスを得ることが出来るとしても依然として適用できることに注意せよ。
これはチューリングの著名な\newterm{Halting Theorem}(\jnewterm{停止性問題})であり、
\newterm{non\-/computable}(\jnewterm{計算不可能})な問題の最初の明確な例を与える。
言い換えれば、計算手続として実行不可能なうまく設定された課題である。}
\end{quote}

\subsection{内部定義}
\label{Section 4.1.6}


私達の評価の環境モデルとメタ循環評価機は定義を順に実行し、環境のフレームを1度に
1定義づつ拡張します。これはインタラクティブなプログラム開発に対しては特に便利です。
その場合にはプログラマは自由に手続の適用を新しい手続の定義に混ぜる必要があります。
しかし、(\link{Section 1.1.8}で紹介された)ブロック構造を実装するために用いられた内部定義に
ついて注意深く考えてみれば、環境の名前毎の拡張はローカル変数の定義に最良の方法
ではないのではと気付くのではないでしょうか。


内部定義を伴なう以下のような手続について考えてみます。

\begin{scheme}
(define (f x)
  (define (even? n) (if (= n 0) true  (odd?  (- n 1))))
  (define (odd? n)  (if (= n 0) false (even? (- n 1))))
  ~\( \dark \langle \)~~\var{\dark rest of body of \code{f}}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
ここでの意図は手続\code{even?}のボディ内の名前\code{odd?}は\code{even?}の後に定義された
手続\code{odd?}を参照しなければなりません。名前\code{odd?}のスコープは\code{f}の
ボディ全体であり、\code{odd?}の定義が起こった箇所から始まる\code{f}のボディの
一部分ではありません。実際に\code{odd?}がそれ自身\code{even?}を用いて定義されて
いることについて考えると---\code{even?}と\code{odd?}は相互再帰手続であり---2つの
\code{define}を満足させる解釈はそれらを名前\code{even?}と\code{odd?}が環境に同時に
追加されたと見做すことのみだとわかります。より一般的には、ブロック構造において、
ローカルな名前のスコープは\code{define}が評価された手続のボディ全体だという
ことです。

偶然にも私達のインタプリタは\code{f}の呼出を正確に評価します。しかし``予想外''の
理由のためです。内部手続の定義が最初に来るため、これらの手続への呼出はそれらの
全てが定義されるまで起こりません。従って\code{odd?}は\code{even?}が実行された時に
定義されるのです。
内部定義がボディの最初に来て定義された変数の値の式の評価が実際にはどの定義された
変数も用いない任意の手続に対し直接、同時定義を実装する仕組みと、私達の逐次的な
評価システムの仕組みは実際に同じ結果を与えます。
(これらの制限に従わず、その結果逐次定義が同時定義と等価でない手続の例に対しては
\link{Exercise 4.19}を参照して下さい)。\footnote{プログラムにこの評価の仕組みに依存
して欲しくないというのが\link{Chapter 1}の\link{Footnote 28}での見解、``管理は責任を
取れない''に対する理由です。これを主張することで内部定義は最初に来て、定義中で
お互いを定義が評価されている間に使用はしません。Schemeの\acronym{IEEE}標準は
実装者にこれらの定義の評価に用いられる仕組みについて幾つかの選択を残します。
別のルールではなくある評価ルールを選択することはここでは``悪い形式''のプログラムの
解釈のみに影響する小さな問題に見えるかもしれません。しかし\link{Section 5.5.6}では同時に
内部定義を行うモデルへの移行が、そうしなければコンパイラの実装にて起こり得る意地の悪い
問題を防ぐことを学びます。}


しかし内部定義の名前が真に同時にスコープを持つようになる簡単な定義の扱い方が存在します。
単に現在の環境に入ることになる全てのローカル変数をどの値の式が評価されるよりも早く
作成することです。これを行う1つの方法は\code{lambda}式上の構文変形によります。
\code{lambda}式のボディを評価する前に、ボディの中の全ての内部定義を走査し、削除します。
内部で定義された変数は\code{let}を用いて作成され、次に代入を用いてそれらの値に設定されます。
例えば、以下の手続は、

\begin{scheme}
(lambda ~\( \dark \langle \)~~\var{\dark vars}~~\( \dark \rangle \)~
  (define u ~\( \dark \langle \)~~\var{\dark e1}~~\( \dark \rangle \)~)
  (define v ~\( \dark \langle \)~~\var{\dark e2}~~\( \dark \rangle \)~)
  ~\( \dark \langle \)~~\var{\dark e3}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
以下の形式に変形されます。

\begin{scheme}
(lambda ~\( \dark \langle \)~~\var{\dark vars}~~\( \dark \rangle \)~
  (let ((u '*unassigned*)
        (v '*unassigned*))
    (set! u ~\( \dark \langle \)~~\var{\dark e1}~~\( \dark \rangle \)~)
    (set! v ~\( \dark \langle \)~~\var{\dark e2}~~\( \dark \rangle \)~)
    ~\( \dark \langle \)~~\var{\dark e3}~~\( \dark \rangle \)~))
\end{scheme}

\noindent
ここで\code{*unassigned*}は特別なシンボルであり、変数が調べられた時にもしまだ値が
割り当てられていない変数を使用しようとしたならばエラーを発せさせます。

内部定義を全て走査する方法の代替となる戦略は\link{Exercise 4.18}にて示されます。
上で示された変形とは異なり、これは定義された変数の値がその変数のどんな値も
用いずに評価できるという制約を強制します。\footnote{Schemeの\acronym{IEEE}標準は
この制約を強制する実装にまかせるのではなく、プログラマに対してこの制約に従うかを
まかせると指定することで、異なる実装戦略を許しています。\acronym{MIT} Schemeを含む
いくつかのScheme実装は上で示された変形を用いています。従ってこの制約に従わない
プログラムは実際にはそのような実装の下では動作します。}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.16}Exercise 4.16:}
この課題では内部定義を逐次実行するためについ先程説明された手法を実装する。
評価機は\code{let}をサポートすると仮定する。(\link{Exercise 4.6}参照)

\begin{enumerate}[a]

\item
\code{lookup\-/variable\-/value} (\link{Section 4.1.3})を変更してもし見つけた値が
シンボル\code{*unassigned*}ならエラーを発するようにする。

\item
手続のボディを取り内部手続を持たない同等な手続を返す手続\code{scan\-/out\-/defines}を
上で説明された変形を作成することにより、書け。

\item
\code{scan\-/out\-/defines}をインタプリタの\code{make\-/procedure}または
\code{procedure\-/body} (see \link{Section 4.1.3})の中に導入せよ。
どちらの場所が良いか? それは何故か?

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.17}Exercise 4.17:}
この本の手続の式\( \langle \)\var{e3}\( \kern0.1em\rangle \)の評価を実施している時の
環境図を書くことで、定義が逐次的に翻訳された時にどのように構築されるかと、定義が
説明されたように走査された場合にどのように構築されるかとの違いを比較せよ。
変形されたプログラムにはなぜ余分なフレームが存在するのか? 環境構造内のこの違いが
正しいプログラムの振舞に違いを起こさないのか説明せよ。インタプリタに内部定義の
``同時''スコープのルールを余分なフレームの構築成しに実装させる方法を設計せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.18}Exercise 4.18:}
テキストの例を以下の様に変形する定義の走査に対する代替となる戦略を考えよ。

\begin{scheme}
(lambda ~\( \dark \langle \)~~\var{\dark vars}~~\( \dark \rangle \)~
  (let ((u '*unassigned*)
        (v '*unassigned*))
    (let ((a ~\( \dark \langle \)~~\var{\dark e1}~~\( \dark \rangle \)~) (b ~\( \dark \langle \)~~\var{\dark e2}~~\( \dark \rangle \)~))
      (set! u a)
      (set! v b))
    ~\( \dark \langle \)~~\var{\dark e3}~~\( \dark \rangle \)~))
\end{scheme}

ここで\code{a}と\code{b}は新しい変数の名前を表現することを意味し、インタプリタにより作成され、ユーザの
プログラムには現れない。\link{Section 3.5.4}の\code{solve}手続について考える。

\begin{scheme}
(define (solve f y0 dt)
  (define  y (integral (delay dy) y0 dt))
  (define dy (stream-map f y))
  y)
\end{scheme}

この手続はこの課題に示されたように内部定義が走査された場合にうまく動くだろうか?
テキストに示されたように走査された場合には動くだろうか? 説明せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.19}Exercise 4.19:}
Ben Bitdiddle, Alyssa P. Hacker, Eva Lu Atorの3人は以下の式を評価した場合の
望まれた結果について議論している。

\begin{scheme}
(let ((a 1))
  (define (f x)
    (define b (+ a x))
    (define a 5)
    (+ a b))
  (f 10))
\end{scheme}

Benは結果は\code{define}に対する逐次的実行のルールを用いて得られるべきだと主張した。
\code{b}は11に定義され、\code{a}は5に定義される。従って結果は16である。Alyssaは相互再帰は
同時スコープのルールが内部手続定義に要求されるとして異議を唱えた。手続の名前を
他の名前から異なって扱うのは不合理だ。従って彼女は\link{Exercise 4.16}で実装された
仕組みに賛成した。これは\code{a}が\code{b}の値が計算される時点では割り当てられていない
という結論に導くだろう。従ってAlyssaの視点では手続はエラーを生じなければならない。
Evaは3つ目の立ち位置を取る。彼女はもし\code{a}と\code{b}の定義が真に同時であることを意味
するのであれば、\code{a}に対する値5は\code{b}の評価にて用いられるべきであると述べた。
従ってEvaの視点では\code{a}は5でなければならず、\code{b}は15でなければならない。そして
結果は20にならなければならない。(もし同意するなら)3人の視点であなたはどれを支持するのか?
あなたはEvaが好んだように振る舞う内部定義を実装する方法を考案できるか?\footnote{\acronym{MIT} Schemeの
実装者達は次の根拠に従ってAlyssaを支持する。Evaは原理上は正しい。定義は同時だと見做される
べきだ。しかしEvaが要求することを行う一般的でかつ効率的な仕組みを実装することは難しく
見える。そのような仕組みが不足している状況では、同時定義の難しい場合についてはエラーを
生成するほうが(Alyssaの意見)、正しくない答を生成するよりも(Benの様に)、より良いだろう。}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.20}Exercise 4.20:}
内部定義は逐次的に見えるが実際には同時であるため、いくらかの人々はこれを完全に
回避するほうを好むだろう。そして特殊形式\code{letrec}を代わりに用いる。
\code{letrec}は\code{let}に似ているため、それが束縛する変数が同時に束縛されお互いに
同じスコープを持つことは不思議ではないだろう。上記のサンプル手続\code{f}は内部手続を
用いずに、しかし全く同じ意味を持つように書くことができる。

\begin{scheme}
(define (f x)
  (letrec
    ((even? (lambda (n)
              (if (= n 0) true  (odd?  (- n 1)))))
     (odd?  (lambda (n)
              (if (= n 0) false (even? (- n 1))))))
    ~\( \dark \langle \)~~\var{\dark rest of body of \code{f}}~~\( \dark \rangle \)~))
\end{scheme}

\code{letrec}式は以下の形式を持つ。

\begin{scheme}
(letrec ((~\( \dark \langle \)~~\( \dark var_1 \)~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark exp_1 \)~~\( \dark \rangle \)~) ~\( \dots \)~ (~\( \dark \langle \)~~\( \dark var_n \)~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark exp_n \)~~\( \dark \rangle \)~))
  ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
\code{letrec}式は\code{let}の亜種であり、変数\( \langle \)\( var_k \)\( \kern0.08em\rangle \)に
初期値を与える式\( \langle \)\( exp_k \)\( \kern0.08em\rangle \)は、全ての\code{letrec}の束縛を
含む環境にて評価される。これは上の例においての\code{even?}と\code{odd?}の相互再帰のような束縛の中での再帰を許す。
または以下の様な10の階乗の評価も可能である。

\begin{scheme}
(letrec
  ((fact (lambda (n)
           (if (= n 1) 1 (* n (fact (- n 1)))))))
  (fact 10))
\end{scheme}

\begin{enumerate}[a]

\item
\code{letrec}を派生式として実装せよ。\code{letrec}式を\code{let}を上で示したように、
または\link{Exercise 4.18}の様に変形することで行え。
即ち、\code{letrec}の変数は\code{let}を用いて作成しなければならず、そして次に
それらの値を\code{set!}で代入すること。

\item
Louis Reasonerは内部定義に関するこの全ての空騒ぎにより混乱してしまった。
彼の見解は、もし手続の中での\code{define}の使用を好まないのであれば、単に
\code{let}を使えるのではないかである。彼のreasoning(推測)の何が緩いのかを、この課題と同様に
定義された\code{f}を用いて、式\code{(f 5)}の評価の間に
\( \langle \)\var{rest of body of \code{f}}\( \kern0.08em\rangle \)が評価された
環境を示す環境図を書くことによって説明せよ。
同じ環境の、ただし\code{f}の定義中の\code{letrec}の場所に\code{let}を用いた場合の環境図を書け。

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.21}Exercise 4.21:}
驚くべきことに、\link{Exercise 4.20}におけるLouisの直感は正しい。\code{letrec}を(または
\code{define}すらも)用いずに再帰手続を指定することは本当に可能である。しかしこれを
達成する手法はLouisが存在したよりもずっと繊細である。以下の式は10の階乗を再帰
階乗手続を適用することで求めている。\footnote{この例は再帰手続を\code{define}を用いずに
定式化するためのプログラミング上の技を説明しています。最も一般的なこの種の技は
\( Y \) \newterm{operator}(\jnewterm{Yコンビネータ}、不動点演算子)です。これは
``pure \( \lambda \)-calculus''(純粋ラムダ計算)による再帰の実装を与えます。(\( \lambda \)計算の
詳細については\link{Stoy 1977}を参照して下さい。またSchemeによる\( Y \)コンビネータの
解説については\link{Gabriel 1988}を参照して下さい。}

\begin{scheme}
((lambda (n)
   ((lambda (fact) (fact fact n))
    (lambda (ft k)
      (if (= k 1) 1 (* k (ft ft (- k 1)))))))
 10)
\end{scheme}

\begin{enumerate}[a]

\item
(式を評価することで)これが実際に階乗を計算することを確認せよ。
フィボナッチ数を計算する同様な式を工夫せよ。

\item
以下の手続について考える。これは相互再帰内部定義を含む。

\begin{scheme}
(define (f x)
  (define (even? n)
    (if (= n 0) true  (odd?  (- n 1))))
  (define (odd? n)
    (if (= n 0) false (even? (- n 1))))
  (even? x))
\end{scheme}

\code{f}の代替的な定義を完成するために欠けている式を埋めよ。これは内部定義も
\code{letrec}も使用してはいない。

\begin{scheme}
(define (f x)
  ((lambda (even? odd?) (even? even? odd? x))
   (lambda (ev? od? n)
     (if (= n 0) true (od? ~\( \dark \langle \)~??~\( \dark \rangle \)~ ~\( \dark \langle \)~??~\( \dark \rangle \)~ ~\( \dark \langle \)~??~\( \dark \rangle \)~)))
   (lambda (ev? od? n)
     (if (= n 0) false (ev? ~\( \dark \langle \)~??~\( \dark \rangle \)~ ~\( \dark \langle \)~??~\( \dark \rangle \)~ ~\( \dark \langle \)~??~\( \dark \rangle \)~)))))
\end{scheme}
\end{enumerate}
\end{quote}

\subsection{構文分析を実行から分離する}
\label{Section 4.1.7}

上で実装された評価機は簡単ですが、非効率です。式の構文上の分析がその実行と相互
配置されているためです。従ってもしプログラムが何度も実行された場合、その構文は
何度も分析されます。例えば次の\code{factorial}を用いて\code{(factorial 4)}を評価する
ことを考えてみて下さい。

\begin{scheme}
(define (factorial n)
  (if (= n 1) 1 (* (factorial (- n 1)) n)))
\end{scheme}

\noindent
\code{factorial}が呼ばれる度に、評価機はボディが\code{if}式であることを判断せねばならず、
それから述語を取り出します。その後にのみ述語を評価しその値により振り分けが行えます。
式\code{(* (factorial (- n 1)) n)}、または部分式
\code{(factorial (- n 1))}と\code{(- n 1)}を評価する度に、評価機は\code{eval}にて状況分析を
行い式が適用であるかを判断せねばならず、また演算子とオペランドの抽出をせねばなりません。
この分析はコストが高いのです。これを繰り返し実行することは無駄が多いでしょう。

評価機を変形し構文上の分析をたった1度のみ実行されるように準備することで
著しく効率良くすることができます。\footnote{この技はコンパイル過程に
不可欠な要素であり、\link{Chapter 5}で議論します。Jonathan Reesは1982年頃に
このようなSchemeインタプリタをTプロジェクトのために書きました(\link{Rees and Adams 1982})。
Marc \link{Feeley (1986)} (\link{Feeley and Lapalme 1987}も参照)は彼の修士論文にて
独力でこの技を発明しました。}私達は式と環境を取る\code{eval}を2つに分けます。
手続\code{analyze}は式のみを取ります。構文上の分析を行い新しい手続
\newterm{execution procedure}(\jnewterm{実行手続})を返します。この手続は分析された式を
実行するにおいて行われた結果をカプセル化します。実行手続は環境を引数として
取り評価を完了します。これは実行手続が何度も呼ばれるのに対し、\code{analyze}が式に
対して1度しか呼ばれないため作業量を減らせます。


分析と実行への分離に伴ない、\code{eval}は以下の様になります。

\begin{scheme}
(define (eval exp env) ((analyze exp) env))
\end{scheme}

\noindent
\code{analyze}の呼出の結果は環境に適用される実行手続です。\code{analyze}手続は\link{Section 4.1.1}の
元の\code{eval}により実行されたのと同じ状況分析です。ただし私達が呼び出す手続は完全な
評価ではなく分析のみを実行します。

\begin{scheme}
(define (analyze exp)
  (cond ((self-evaluating? exp)
         (analyze-self-evaluating exp))
        ((quoted? exp) (analyze-quoted exp))
        ((variable? exp) (analyze-variable exp))
        ((assignment? exp) (analyze-assignment exp))
        ((definition? exp) (analyze-definition exp))
        ((if? exp) (analyze-if exp))
        ((lambda? exp) (analyze-lambda exp))
        ((begin? exp)
         (analyze-sequence (begin-actions exp)))
        ((cond? exp) (analyze (cond->if exp)))
        ((application? exp) (analyze-application exp))
        (else
         (error "Unknown expression type: ANALYZE" exp))))
\end{scheme}

\noindent
以下に最も簡単な構文分析手続があります。これは自己評価式です。環境引数を無視し、
ただ式を返す実行手続を返します。

\begin{scheme}
(define (analyze-self-evaluating exp)
  (lambda (env) exp))
\end{scheme}

\noindent
クォートされた式に対してはそのテキストの取り出しを実行フェーズでなく、分析フェーズで
1度だけ行うことでほんの少し効率良くすることができます。

\begin{scheme}
(define (analyze-quoted exp)
  (let ((qval (text-of-quotation exp)))
    (lambda (env) qval)))
\end{scheme}

\noindent
変数の値の探索は依然として実行フェーズで行わねばなりません。これは環境を知ることに
依存するためです。\footnote{しかし、構文上の分析の部分にて終わらせられる変数探索の
重要な部分があります。\link{Section 5.5.6}にて示されるように、環境構造の中でどこで変数の値が
見つかるか、その位置を決定することが可能です。従って変数にマッチするエントリのために
環境を走査する必要を防ぐことができます。}

\begin{scheme}
(define (analyze-variable exp)
  (lambda (env) (lookup-variable-value exp env)))
\end{scheme}

\noindent
\code{analyze\-/assignment}もまた実際の変数の設定を環境の供給が完了する実行時まで
遅らせなければなりません。しかし\code{assignment\-/value}式が分析の間に
(再帰的に)分析されることができることは効率を大きく向上します。\code{assignment\-/value}式は
今はただ1度しか分析されないためです。同じことが定義に対しても言えます。

\begin{scheme}
(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))
    (lambda (env)
      (set-variable-value! var (vproc env) env)
      'ok)))
(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze (definition-value exp))))
    (lambda (env)
      (define-variable! var (vproc env) env)
      'ok)))
\end{scheme}

\noindent
\code{if}式に対しては分析時に述語、結果、代替を取り出し分析します。

\begin{scheme}
(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
        (cproc (analyze (if-consequent exp)))
        (aproc (analyze (if-alternative exp))))
    (lambda (env) (if (true? (pproc env))
                      (cproc env)
                      (aproc env)))))
\end{scheme}

\noindent
\code{lambda}式の分析もまた効率が大きく向上します。\code{lambda}のボディは1度しか
分析しません。例え\code{lambda}の評価の結果としての手続が何度適用されてもです。

\begin{scheme}
(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env) (make-procedure vars bproc env))))
\end{scheme}

\noindent
(\code{begin}や\code{lambda}式のボディの中としての)式の列の評価の分析は
より必要とされます。\footnote{列の処理に関する実態については\link{Exercise 4.23}を
参照して下さい。}列の各式は分析され実行手続を生じます。これらの実行手続は
環境を引数として取り順番に各個別の実行手続を引数としての環境と共に呼び出す
実行手続を生成するために組み合わせれます。

\begin{scheme}
(define (analyze-sequence exps)
  (define (sequentially proc1 proc2)
    (lambda (env) (proc1 env) (proc2 env)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc (car rest-procs))
              (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs) (error "Empty sequence: ANALYZE"))
    (loop (car procs) (cdr procs))))
\end{scheme}

\noindent
適用を分析するためには、演算子とオペランドを分析し、演算子の実行手続を(実際に適用される
手続を得るために)呼び出し、オペランドの実行手続を(実際の引数を得るために)呼び出す
実行手続を構築します。次にこれらを\code{execute\-/application}に渡します。これは
\link{Section 4.1.1}の\code{apply}の類似品です。\code{execute\-/application}は\code{apply}とは
複合手続のための手続のボディが既に分析されている点が異なります。そのためさらなる
分析の必要性がありません。その代わりに、ただ拡張された環境上のボディに対して
手続実行を呼び出します。

\begin{scheme}
(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env)
      (execute-application
       (fproc env) 
       (map (lambda (aproc) (aproc env))
            aprocs)))))
(define (execute-application proc args)
  (cond ((primitive-procedure? proc)
         (apply-primitive-procedure proc args))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment
           (procedure-parameters proc)
           args
           (procedure-environment proc))))
        (else
         (error "Unknown procedure type:
                 EXECUTE-APPLICATION"
                proc))))
\end{scheme}

\noindent
私達の新しい評価機は節\link{Section 4.1.2}, \link{Section 4.1.3}, \link{Section 4.1.4}に
あるように、同じデータ構造、構文手続、実行時サポート手続を用います。

\begin{quote}
\heading{\phantomsection\label{Exercise 4.22}Exercise 4.22:}
この節の評価機を特殊形式\code{let}をサポートするように拡張せよ。(\link{Exercise 4.6}参照)
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.23}Exercise 4.23:}
Alyssa P. Hackerはなぜ\code{analyze\-/sequence}がそんなに複雑になるのか理解できなかった。
他の分析手続全ては\link{Section 4.1.1}の対応する評価手続(または\code{eval}節)の簡単な変形である。
彼女は\code{analyze\-/sequence}は以下のようになるのではと予想した。

\begin{scheme}
(define (analyze-sequence exps)
  (define (execute-sequence procs env)
    (cond ((null? (cdr procs))
           ((car procs) env))
          (else
           ((car procs) env)
           (execute-sequence (cdr procs) env))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error "Empty sequence: ANALYZE"))
    (lambda (env) (execute-sequence procs env))))
\end{scheme}


Eva Lu AtorはAlyssaに対し、テキストの版は分析時に列を評価する仕事よりもより多くの
ことを行っていると説明した。Alyssaの逐次実行手続は個別の組み込みの実行手続に
対する呼出を行うのではなく、複数の手続を通してそれらを呼び出すためにループする。
実際に列内の個別の式は分析されるが、列それ自身は分析されない。


2つの版の\code{analyze\-/sequence}を比較せよ。例として、列がただ1つの式を持つ場合に
おいて(手続のボディ特有の)共通な場合について考えよ。Alyssaのプログラムにより生成された
実行手続はどのような行いをするか? 上のテキスト内のプログラムで生成された実行手続に
ついてはどうか? 2つの版は2つの式を持つ列に対してはどのように比較されるか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.24}Exercise 4.24:}
元のメタ循環評価機とこの節の版のスピードを比較するためのいくつかの実験を設計し
実行せよ。あなたの結果を用いて種々の手続に対して分析と実行で消費された時間を
概算せよ。
\end{quote}

\section{Scheme上でのバリエーション --- 遅延評価}
\label{Sec. 4.2}
\label{Section 4.2}

今や私達はLispプログラムとして表現された評価機を得ました。これで言語設計上の代替となる
選択を単純に評価機を変更することで試験することができます。実際に新しい言語は良く、
最初に既存の高級言語の中に新しい言語を埋め込む評価機を書くことで開発されます。
例えばもしわたしたちがLispに対する変更の提案のある側面についてLispコミュニティの他の
メンバと議論したい時に、変更を組み込んだ評価機を与えることができます。受け手はすると
新しい評価機を持ちいて実験を行いさらなる変更としてのコメントを返すことができます。
高レベルな実装ベースが評価機のテストとデバッグをより簡単にするだけではありません。
加えて組込むことは設計者に対し下層の言語から機能をsnarfする\footnote{Snarf: ``つかみ
取ること、特に巨大な文書やファイルを持ち主の許可を得ても得なくても使う目的のため''
Snarf Down: ``snarfすること、稀に吸収する、処理する、または理解するの含意を持つ''
(これらの定義は\link{Steele et al. 1983}からsnarfした。\link{Raymond 1993}も参照すること)}
ことを可能にします。これは
私達の組込Lisp評価機が下層のLispからプリミティブやコントロール構造を使用するのと同じです。
設計者は(もし必要があれば)後で低レベル言語やハードウェアにて完全な実装を構築するだけです。
この節と次ではSchemeの、優位な追加の表現力を提供するいくつかのバリエーションについて探求します。



\subsection{正規順と適用順}
\label{Section 4.2.1}

\link{Section 1.1}では評価のモデルについての議論を始めましたが、Schemeは\newterm{applicative-order}(\jnewterm{適用順序})
言語であると記しました。即ち、Schemeの手続への全ての引数は手続が適用される時に評価される、と。
逆に、\newterm{normal-order}(\jnewterm{正規順序})言語は手続引数の評価を実際に引数の値が必要とされるまで
遅らせます。手続引数の評価を可能な限り最後の瞬間まで(例えばプリミティブ命令により必要とされるまで)
遅らせることは\newterm{lazy evaluation}(\jnewterm{遅延評価})と呼ばれます。\footnote{専門用語
``lazy''と``normal-order''の間の違いはいささか曖昧(fuzzy)です。一般的に``lazy''は特定の
評価機の仕組みを参照しますが、一方で``normal-order''は言語の意味を参照し、どんな特定の評価戦術からも
独立しています。しかしこれは確かな区別ではありません。そして2つの専門用語は良く同義的に
用いられています。} 以下の手続について考えてみましょう。

\begin{scheme}
(define (try a b) (if (= a 0) 1 b))
\end{scheme}

\noindent
\code{(try 0 (/ 1 0))}の評価はSchemeではエラーを生成します。遅延評価ではエラーは現れません。
その式の評価は1になります。なぜなら絶対に引数は評価されないためです。


遅延評価を利用した例で、手続\code{unless}の定義です。

\begin{scheme}
(define (unless condition usual-value exceptional-value)
  (if condition exceptional-value usual-value))
\end{scheme}

\noindent
これは以下のような式で使用できます。

\begin{scheme}
(unless (= b 0)
        (/ a b)
        (begin (display "exception: returning 0") 0))
\end{scheme}

\noindent
これは適用順序の言語では動きません。通常値と例外値の両方が\code{unless}が呼ばれる前に
評価されるためです。(\link{Exercise 1.6}と比較してみて下さい)。遅延評価の利点は
\code{unless}のような手続は例えそれらの引数の幾つかの評価がエラーを発したり、
停止しなかったとしても役立つ計算ができます。

引数の評価が完了する前に手続のボディに入ることを、手続がその引数において
\newterm{non\-/strict}(\jnewterm{非厳密})であると呼びます。もし引数が手続のボディに入る前に
評価されたなら手続はその引数に対し\newterm{strict}(\jnewterm{厳密})であると言います。\footnote{``厳密''対
``非厳密''の技術用語は本質的には``適用順序''対``正規順序''と同じことを言っています。
しかし個別の手続と引数を言及しており、言語全体を言及してはいません。
プログラミング言語のカンファレンスでは誰かがこのようなことを言うのを聞くかもしれません。
``正規順序言語のHassleはいくつか厳密なプリミティブを持っている。他の手続はそれらの引数を
遅延評価で取る。''}純粋適用順序言語では全ての手続が全ての引数に対し厳密です。そして
プリミティブな手続は厳密にも非厳密にも成り得ます。またプログラマに彼等が定義する手続の
厳密さに細かなコントロールを提供する言語もあります。(\link{Exercise 4.31}参照)

実用性のため非厳密にすることができる手続の印象的な例には\code{cons}(または一般的に、
ほとんど全てのデータ構造のコンストラクタが)あります。
例えもし要素の値がわからなくても、データ構造を形成するよう要素を組み立て、
結果のデータ構造上で操作する実用的な計算を行えます。例えばリストの長さを
リスト内の個々の要素の値を知ること無しに計算することは完璧に意味があります。
私達はこの考えを\link{Section 4.2.3}で非厳密な\code{cons}ペアにより形成されたリストとして
\link{Chapter 3}のストリームを実装するために利用します。

\begin{quote}
\heading{\phantomsection\label{Exercise 4.25}Exercise 4.25:}
(通常の適用順Schemeにおいて)\code{unless}を上で示されたように定義し、
次に\code{unless}を用いて以下のように\code{factorial}を定義する。

\begin{scheme}
(define (factorial n)
  (unless (= n 1)
          (* n (factorial (- n 1)))
          1))
\end{scheme}


もし\code{(factorial 5)}を評価したら何が起こるか? この定義は正規順序言語では
動くか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.26}Exercise 4.26:}
Ben BitdiddleとAlyssa P. Hackerは\code{unless}のような物を実装するための
遅延評価の重要性について意見が分かれた。Benは\code{unless}を適用順序でも特殊形式として
実装可能である点を指摘した。Alyssaはもしそれを行えば\code{unless}はただ単に構文であり
高階手続と連動して使用できる手続ではないと反論した。議論の両サイド上の詳細を埋めよ。
\code{unless}をどのようにして派生手続として(\code{cond}や\code{let}のように)実装するかを示せ。
そして特殊形式ではなく手続として存在する\code{unless}を持つことが有効である状況の
例を与えよ。
\end{quote}

\subsection{遅延評価を持つインタプリタ}
\label{Section 4.2.2}


この節ではSchemeと同じですが、複合手続が全ての引数に対して非厳密であることが異なる
正規順言語を実装します。プリミティブな手続は依然として厳密です。\link{Section 4.1.1}の
評価機を、それが解釈する言語がこのように振る舞うように変更するのは難しくありません。
ほとんど全ての必要な変更は手続適用が中心となります。


基本的な考えは、手続を適用する時、インタプリタはどの引数が評価されるべきかと、
どの引数が遅延されるべきかを決定しなければなりません。遅延化された引数は評価されません。
その代わりにそれらは\newterm{thunks}(\jnewterm{サンク})と呼ばれるオブジェクトに変形されます。\footnote{\newterm{thunk}という
単語は非公式な作業部会により考案されました。彼等はAlgol 60にてcall\-/by\-/nameの
実装について議論していたのです。彼等は式のほとんどの分析は(``式についての考えは'')
コンパイル時に行えることに気付きました。従って実行時には式は既に(\link{Ingerman et al. 1960})に
係わる``サンク''を持っていました。}サンクは引数の値を生成するために必要な情報を必要な時に
含んでなければなりません。それはまるで適用時に評価されたかのようにです。従って、
サンクは引数の式と手続適用がその中で評価される環境を持たなければなりません。


サンク中の式の評価プロセスは\newterm{forcing}(\jnewterm{強制})と呼ばれます。\footnote{これは
\link{Chapter 3}でストリームを表現するのに導入された遅延化オブジェクト上で\code{force}を
用いることに類似しています。ここで行っていることと、\link{Chapter 3}で行ったことの
重大な違いは、ここでは遅延化と強制を評価機の中に構築していることです。従って
これを言語を通して同一化し、自動化しています。}
一般的にはサンクはその値が必要になった時のみ強制されます。サンクの値を使用する
プリミティブな手続に渡された時です。またオペレータの値であり手続として適用される時です。
設計上の1つの選択として可能なこととして、\link{Section 3.5.1}にて遅延化オブジェクトに我々がしたように、
サンクを\newterm{memoize}(\jnewterm{メモ化})するか否かがあります。メモ化を用いれば、サンクが初めて
強制された時、計算された値が格納されます。続く強制は単純に演算を繰り返すことなく単純に
格納された値を返します。私達はインタプリタをメモ化します。これはとても多くのアプリケーションに
対して効率的だからです。しかし、これには用心しなければならない考慮点が存在します。\footnote{メモ化と
組み合わされた遅延評価は時々、\newterm{call-by-need}(\jnewterm{必要時呼出})引数渡しと呼ばれます。
\newterm{call-by-name}(\jnewterm{名前呼出})引数渡しと対照的です。(call-by-nameはAlgol 60で導入されましたが、
メモ化を行わない遅延評価と同類です)。言語設計者として、私達は評価機をメモ化することも、しないことも、
プログラマに任せることも可能です(\link{Exercise 4.31})。\link{Chapter 3}からおわかりかと思いますが、
これらの選択は微妙で、かつ混乱を招く問題を代入の存在において提起します。(\link{Exercise 4.27}と
\link{Exercise 4.29}を参照)。\link{Clinger (1982)}による素晴しい論文がここで提起される混乱の
複数の特徴を明らかにしようと試みています。}

\subsubsection*{評価機を変更する}

遅延評価と\link{Section 4.1}の評価との主な違いは\code{eval}と\code{apply}における手続適用の取扱に存在します。


\code{eval}の\code{application?}節は以下になります。

\begin{scheme}
((application? exp)
 (apply (actual-value (operator exp) env)
        (operands exp)
        env))
\end{scheme}

\noindent
これは\link{Section 4.1.1}の\code{eval}の\code{application?}節とほとんど同じです。
遅延評価のためにはしかし、\code{apply}をオペランド式と共に呼びます。それらを評価することで
生成された引数と共にではありません。もし引数が遅延化されるのであれば環境にサンクを
構築させる必要が出るので、これも渡さなければいけません。依然として演算子は評価します。
\code{apply}は実際の手続が必要です。その型(プリミティブであるか複合であるか)に従って
呼出と適用を行うためです。


式の実際の値が必要になる度に、\code{eval}するだけの代わりに以下を用います。

\begin{scheme}
(define (actual-value exp env)
  (force-it (eval exp env)))
\end{scheme}

\noindent
これでもし式の値がサンクであれば強制されます。


また新しい版の\code{apply}もほとんど\link{Section 4.1.1}の版と同じです。
違いは\code{eval}が未評価のオペランド式を通り直ぎたことです。(厳密である)プリミティブな手続に対しては
プリミティブを適用する前に全ての引数を評価します。(非厳密である)複合手続に対しては
全ての引数を手続に適用する前に遅延化します。

\begin{scheme}
(define (apply procedure arguments env)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure
          procedure
          (list-of-arg-values arguments env)))   ;~\textrm{changed}~
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           (list-of-delayed-args arguments env)  ;~\textrm{changed}~
           (procedure-environment procedure))))
        (else (error "Unknown procedure type: APPLY"
                     procedure))))
\end{scheme}

\noindent
引数を処理する手続は\link{Section 4.1.1}の\code{list\-/of\-/values}そっくりです。しかし
\code{list\-/of\-/delayed\-/args}が引数を評価するのではなく遅延化することと、
\code{list\-/of\-/arg\-/values}が\code{eval}の代わりに\code{actual\-/value}を用いることが違います。

\begin{scheme}
(define (list-of-arg-values exps env)
  (if (no-operands? exps)
      '()
      (cons (actual-value (first-operand exps)
                          env)
            (list-of-arg-values (rest-operands exps)
                                env))))
(define (list-of-delayed-args exps env)
  (if (no-operands? exps)
      '()
      (cons (delay-it (first-operand exps)
                      env)
            (list-of-delayed-args (rest-operands exps)
                                  env))))
\end{scheme}

\noindent
評価機で変更しなければいけない他の場所は\code{if}の取扱の中にあります。
そこでは\code{eval}の代わりに\code{actual\-/value}を使用して述語が真であるか偽で
あるかテストする前に、述語式の値を取らねばなりません。

\begin{scheme}
(define (eval-if exp env)
  (if (true? (actual-value (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))
\end{scheme}

\noindent
最後に、\link{Section 4.1.4}の\code{driver\-/loop}手続を変更して、\code{eval}の代わりに
\code{actual\-/value}を使用せねばなりあせん。そうすることでもし遅延化された値が
REPLに伝播して返った場合に、表示される前に強制されます。またプロンプトも
変更してこれが遅延評価であることを示します。

\begin{scheme}
(define input-prompt  ";;; L-Eval input:")
(define output-prompt ";;; L-Eval value:")
(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output
           (actual-value
            input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
\end{scheme}

\noindent
これらの変更を行うことで、評価機を開始しテストすることができます。
\link{Section 4.2.1}で議論された\code{try}式の評価の成功はインタプリタが遅延評価を
実行していることを示しています。

\begin{scheme}
(define the-global-environment (setup-environment))
(driver-loop)
~\textit{;;; L-Eval input:}~
(define (try a b) (if (= a 0) 1 b))
~\textit{;;; L-Eval value:}~
~\textit{ok}~
~\textit{;;; L-Eval input:}~
(try 0 (/ 1 0))
~\textit{;;; L-Eval value:}~
~\textit{1}~
\end{scheme}

\subsubsection*{サンクの表現}


私達の評価機は手続が引数に適用される時にサンクを作成することと、これらのサンクを
後で強制することの準備をせねばなりません。サンクは式を環境と一緒にまとめなければ
なりません。そうすることで引数が後から生成されることができます。
サンクを強制するためには単純に式と環境をサンクから取り出しその環境の中で式を評価します。
\code{eval}ではなく\code{actual\-/value}を用いることで式の値それ自身がサンクである場合にその
強制をサンクでない物に辿り着くまで繰り返します。

\begin{scheme}
(define (force-it obj)
  (if (thunk? obj)
      (actual-value (thunk-exp obj) (thunk-env obj))
      obj))
\end{scheme}

\noindent
式と環境をまとめる1つの簡単な方法はその式と環境を含むリストを作成することです。
従ってサンクを以下のように作成します。

\begin{scheme}
(define (delay-it exp env)
  (list 'thunk exp env))
(define (thunk? obj)
  (tagged-list? obj 'thunk))
(define (thunk-exp thunk) (cadr  thunk))
(define (thunk-env thunk) (caddr thunk))
\end{scheme}

\noindent
実際に私達のインタプリタに欲っしたものはこれではなく、メモ化されたサンクです。
サンクが強制された時に格納された式とその値に置き換え、
\code{thunk}タグを変更することでサンクをサンクが評価された物に変更することで、
既に評価されたと認識させることができます。\footnote{
一度式の値が計算されれば
サンクから\code{env}もまた消去します。これによりインタプリタにより返される値に違いは
生じません。しかしこれはスペースを本当に節約します。サンクから\code{env}への参照を
必要が無くなったら直ぐに削除することで、この構造が
\newterm{garbage-collected}(\jnewterm{ガベージコレクション}、GC、ゴミ集め)され、そのスペースは
\link{Section 5.3}で議論されるようにリサイクルされます。


同様に、\link{Section 3.5.1}のメモ化、遅延化されたオブジェクトの中の不必要な環境をGCされるように
許可することも、\code{memo\-/proc}に\code{(set! proc '())}の様な何かを行わせて
(\code{delay}が中で評価される環境を含む)手続\code{proc}をその値を格納した後に捨てることでできました。}

\begin{scheme}
(define (evaluated-thunk? obj)
  (tagged-list? obj 'evaluated-thunk))
(define (thunk-value evaluated-thunk) 
  (cadr evaluated-thunk))
(define (force-it obj)
  (cond ((thunk? obj)
         (let ((result (actual-value (thunk-exp obj)
                                     (thunk-env obj))))
           (set-car! obj 'evaluated-thunk)
           (set-car! (cdr obj) 
                     result)     ;~\textrm{\code{exp}をその値で置き換える}~
           (set-cdr! (cdr obj) 
                     '())        ;~\textrm{不必要な\code{env}を忘れる}~
           result))
        ((evaluated-thunk? obj) (thunk-value obj))
        (else obj)))
\end{scheme}

\noindent
同じ\code{delay\-/it}手続がメモ化有りでも無しでも動作することに注意して下さい。

\begin{quote}
\heading{\phantomsection\label{Exercise 4.27}Exercise 4.27:}
以下の定義を遅延評価機に入力したとする。

\begin{scheme}
(define count 0)
(define (id x) (set! count (+ count 1)) x)
\end{scheme}


以下の一連の応答の欠けた値を与えよ。そして貴方の回答について説明せよ。\footnote{この
課題は遅延評価と副作用の間の応答が大きな混乱の原因となりえることを実演している。
これこそが\link{Chapter 3}の議論からあなたが予期するかもしれないことである。}

\begin{scheme}
(define w (id (id 10)))
~\textit{;;; L-Eval input:}~
count
~\textit{;;; L-Eval value:}~
~\( \dark \langle \)~~\var{\dark response}~~\( \dark \rangle \)~
~\textit{;;; L-Eval input:}~
w
~\textit{;;; L-Eval value:}~
~\( \dark \langle \)~~\var{\dark response}~~\( \dark \rangle \)~
~\textit{;;; L-Eval input:}~
count
~\textit{;;; L-Eval value:}~
~\( \dark \langle \)~~\var{\dark response}~~\( \dark \rangle \)~
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.28}Exercise 4.28:}
\code{eval}は\code{eval}でなく\code{actual\-/value}を用いて\code{apply}に渡す前に
演算子を評価する。演算子の値を強制するためである。この強制の必要性を実演する
例を与えよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.29}Exercise 4.29:}
メモ化しない場合に、メモ化した場合よりも非常に遅く実行されると予測するプログラムを
示せ。また以下の応答について考えよ。\code{id}手続は\link{Exercise 4.27}と同じに定義され
\code{count}は0から始める。

\begin{scheme}
(define (square x) (* x x))
~\textit{;;; L-Eval input:}~
(square (id 10))
~\textit{;;; L-Eval value:}~
~\( \dark \langle \)~~\var{\dark response}~~\( \dark \rangle \)~
~\textit{;;; L-Eval input:}~
count
~\textit{;;; L-Eval value:}~
~\( \dark \langle \)~~\var{\dark response}~~\( \dark \rangle \)~
\end{scheme}


評価機がメモ化された場合とメモ化されない場合の両方について応答を与えよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.30}Exercise 4.30:}
Cy D. Fectは元C言語プログラマである。彼はいくつかのside effects(副作用)が起こらない
のではないかと心配している。遅延評価が列内の式に強制を行わないためである。
最後の1つ以外の列内の式の値は使用されないため(式は変数への代入や表示等の作用のため
だけに存在している)、この値の強制を引き起こす後の使用は存在しない(例えばプリミティブな手続の
引数として)。Cyは従って列を評価する時には列内の最後の1つを除いた全ての式を評価せねば
ならないと考えた。彼は\link{Section 4.1.1}の\code{eval\-/sequence}を変更し\code{eval}でなく
\code{actual\-/value}を使用することを提案した。

\begin{scheme}
(define (eval-sequence exps env)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else (actual-value (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))
\end{scheme}

\begin{enumerate}[a]

\item
Ben BitdiddleはCyが間違っていると考えた。彼はCyに\link{Exercise 2.23}で説明された
\code{for\-/each}手続を見せた。これは副作用を伴う列の重要な例を与える。 

\begin{scheme}
(define (for-each proc items)
  (if (null? items)
      'done
      (begin (proc (car items))
             (for-each proc (cdr items)))))
\end{scheme}

彼はテキストの評価機(オリジナルの\code{eval\-/sequence}を持つ物)は
これを正しく取り扱うと主張した。

\begin{scheme}
~\textit{;;; L-Eval input:}~
(for-each (lambda (x) (newline) (display x))
          (list 57 321 88))
~\textit{57}~
~\textit{321}~
~\textit{88}~
~\textit{;;; L-Eval value:}~
~\textit{done}~
\end{scheme}

なぜBenが\code{for\-/each}の振舞について正しいのか説明せよ。

\item
CyはBenが\code{for\-/each}について正しいのは同意した。しかし彼が\code{eval\-/sequence}に対する
変更を提案した時、彼が考えていたのはこの種のプログラムではないと言った。
彼は以下の2つの遅延評価の手続を定義した。

\begin{scheme}
(define (p1 x)
  (set! x (cons x '(2)))
  x)
(define (p2 x)
  (define (p e)
    e
    x)
  (p (set! x (cons x '(2)))))
\end{scheme}

オリジナルの\code{eval\-/sequence}を用いた時、\code{(p1 1)}と\code{(p2 1)}の値はいくらか?
Cyが提案した\code{eval\-/sequence}への変更を用いた時には値はどうなるか?

\item
Cyは彼が提案した通りの\code{eval\-/sequence}への変更はaの例の振舞に影響を与えないと
指摘した。なぜこれが正しいのか説明せよ。

\item
遅延評価では列はどのように扱われるべきと考えるか? あなたはCyのアプローチ、テキストの
アプローチ、または他のアプローチのどれを好むか?

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.31}Exercise 4.31:}
この節で取り上げられた取り組み方は少々、不愉快である。Schemeに対して互換性のない
変更を行うためだ。遅延評価を\newterm{upward-compatible extension}(\jnewterm{上位互換性のある拡張})として
実装するほうがより良いだろう。それは通常のSchemeプログラムが依然と同じように
働くということである。これをユーザに引数が遅延されるか、されないかを
コントロールさせるように手続定義の構文を拡張することで可能である。それを行う間、
ユーザに遅延をメモ化させるか、させないかの選択も同様に与えることができるだろう。
例えば、以下の定義は

\begin{scheme}
(define (f a (b lazy) c (d lazy-memo))
  ~\( \dots \)~)
\end{scheme}

\noindent
\code{f}は4つの引数の手続であり、最初と3番目の引数は手続が呼ばれた時に評価され、
2番目は遅延化され、4番目は遅延化とメモ化が行われる。従って通常の手続定義は
通常のSchemeと同じ振舞を行うが、\code{lazy\-/memo}宣言を各複合手続の各パラメタに
追加することでこの節で定義された遅延評価の振舞を行う。この変更の設計と実装は
Schemeに対しそのような拡張の生成を必要とする。あなたは\code{define}に対する新しい構文を
取り扱う新しい構文手続を実装しなければならない。また引数がいつ遅延化されるか、そして
いつ強制するか、またはそれに応じて引数を遅延化するか決定するために\code{eval}や
\code{apply}に対して準備もしなければならない。同時に強制に対してメモ化するか、しないかも
適切に準備すること。
\end{quote}

\subsection{遅延化リストとしてのストリーム}
\label{Section 4.2.3}


\link{Section 3.5.1}ではどのようにストリームを遅延化されたリストとして実装するかについて示しました。
特殊形式\code{delay}と\code{cons\-/stream}導入しました。このことは私達にストリームの\code{cdr}を
求める``promise''(プロミス、約束)を、実際には後になるまではプロミスを実行すること
無しに構築することを可能にしました。

遅延評価ではストリームとリストは同一にできます。そのため特殊形式やリストとストリームの
命令を分ける必要はありません。私達が行わなければならないこと全ては\code{cons}が非厳密になる
よう問題を準備することです。これを達成する1つの方法は遅延評価を拡張しプリミティブにも
非厳密を許し\code{cons}をこれらの内の1つとすることです。より簡単な方法は(\link{Section 2.1.3})の
\code{cons}をプリミティブとして実装する必要性は本質的には全く無いということを思い出すことです。
その代わりに、ペアは手続として表現可能です。\footnote{これが\link{Exercise 2.4}で説明された
手続表現です。本質的にはどんな手続表現(例えばメッセージパッシングによる実装)も同じことが行え
るでしょう。これらの定義を遅延評価に単純にドライバーループにて型を付けることのみでインストール
できることに注意して下さい。もし私達が元々\code{cons}, \code{car}, \code{cdr}をグローバル環境の
プリミティブとして含めていたのならば、それらは再定義されるでしょう。(\link{Exercise 4.33}と
\link{Exercise 4.34}も参照して下さい。}

\begin{scheme}
(define (cons x y) (lambda (m) (m x y)))
(define (car z) (z (lambda (p q) p)))
(define (cdr z) (z (lambda (p q) q)))
\end{scheme}

\noindent
これらの基本的な命令において、リスト命令の標準定義は無限リスト(ストリーム)と同様に
有限な物としても働きます。そしてストリーム命令はリスト命令として実装可能です。
以下にいくつかの例を示します。

\begin{scheme}
(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))
(define (map proc items)
  (if (null? items)
      '()
      (cons (proc (car items)) (map proc (cdr items)))))
(define (scale-list items factor)
  (map (lambda (x) (* x factor)) items))
(define (add-lists list1 list2)
  (cond ((null? list1) list2)
        ((null? list2) list1)
        (else (cons (+ (car list1) (car list2))
                    (add-lists (cdr list1) (cdr list2))))))
(define ones (cons 1 ones))
(define integers (cons 1 (add-lists ones integers)))
~\textit{;;; L-Eval input:}~
(list-ref integers 17)
~\textit{;;; L-Eval value:}~
~\textit{18}~
\end{scheme}

\noindent
これらの遅延リストは\link{Chapter 3}のストリームよりもさらに遅延化されています。
リストの\code{car}も\code{cdr}と同様に遅延化されます。\footnote{このことはより一般的な
種類の、ただの列ではない、リスト構造の遅延化版を作ることを可能にします。
\link{Hughes 1990}は``遅延化木''のいくつかのアプリケーションについて議論しています。}実際に、
遅延化ペアの\code{car}や\code{cdr}に対するアクセスさえもリスト要素の値を強制する必要がありません。
その値はそれが本当に必要になった場合---例えばプリミティブの引数としてや回答として
表示される場合に---強制されることになります。

遅延化ペアはまた\link{Section 3.5.4}でストリームに対して提起された問題に対する手助けにも
なります。その時はループを伴なうシステムのストリームモデルを定式化することは
明示的な\code{delay}命令を\code{cons\-/stream}で提供されるものを越えてプログラムの中に
撒き散らすことを必要としました。遅延評価では全ての手続の引数は遅延化に統一されています。
例えばリストと統合する手続を実装し微分方程式を\link{Section 3.5.4}で元々意図したように実装する
ことが可能です。

\begin{scheme}
(define (integral integrand initial-value dt)
  (define int
    (cons initial-value
          (add-lists (scale-list integrand dt) int)))
  int)
(define (solve f y0 dt)
  (define  y (integral dy y0 dt))
  (define dy (map f y))
  y)
~\textit{;;; L-Eval input:}~
(list-ref (solve (lambda (x) x) 1 0.001) 1000)
~\textit{;;; L-Eval value:}~
~\textit{2.716924}~
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.32}Exercise 4.32:}
\link{Chapter 3}のストリームとこの節で説明された``より遅延化された''遅延化リストの間
の違いを説明する例をいくつか上げよ。この拡張された遅延性の利点をどのように活用するか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.33}Exercise 4.33:}
Ben Bitdiddleは上で与えられた遅延リスト実装を式\code{(car '(a b c))}を評価することで
テストした。

\begin{scheme}
(car '(a b c))
\end{scheme}

驚いたことにこれはエラーを生じる。幾らか考えた後に、彼はクォートされた
式を読み込むことで得られた``リスト''が\code{cons}, \code{car}, \code{cdr}の新しい定義で
操作されたリストから異なることに気が付いた。評価機のクォートされた式の扱いを
修正しドライバループで型付けされたクォートされたリストが正しい遅延リストを
生成するようにせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.34}Exercise 4.34:}
評価機のドライバループを変更し遅延化したペアとリストが何らかの妥当な方法で
表示を行うようにせよ。(無限リストに対しては何を行うか?)。遅延化ペアの表現も
変更が必要になるだろう。評価機がそれらを表示するためにそれらを判別することが
できるようにするためである。
\end{quote}

\section{Scheme上でのバリエーション --- 非決定性演算}
\label{Section 4.3}


この節では\newterm{nondeterministic computing}(\jnewterm{非決定性演算})と呼ばれる
プログラミングパラダイムをサポートするよう、評価機の中に自動的な探索をサポートするための
機能を構築することで、Scheme評価機を拡張します。これは\link{Section 4.2}での
遅延評価の導入に比べ、とても深い言語への変更です。


非決定性演算はストリーム処理のように、``生成してテストする''アプリケーションに対して
便利です。正の整数の2つのリストを用いて開始する、整数のペアを見つけるタスクについて考えます
1つは最初のリストから、もう1つは別のリストから取得し、その和は素数となります。
私達はこの問題をどのように扱うかについて、\link{Section 2.2.3}では有限列の命令を用いて、
\link{Section 3.5.3}では無限ストリームを用いる方法について学びました。私達の取り組み方は
全ての可能なペアを生成し、これらから和が素数になるペアを選択するという方法でした。
実際にペアの列全体を最初に生成する\link{Chapter 2}や、生成とフィルタリングを相互配置する
\link{Chapter 3}に係わらず演算がどのように体系化されるかの本質的なイメージに対しては
重要ではありませんでした。


非決定性の取り組み方は異なるイメージを喚起します。単純に(何らかの方法で)最初のリストから
数値を選択し、別の数値を2つ目のリストから選択し、(何らかの仕組みで)それらの和が素数である
ことを要求とすると想像してみてください。これは以下の手続により表現されます。

\begin{scheme}
(define (prime-sum-pair list1 list2)
  (let ((a (an-element-of list1))
        (b (an-element-of list2)))
    (require (prime? (+ a b)))
    (list a b)))
\end{scheme}

\noindent
この手続はただ単に問題を言い直したに過ぎなく、解法を指定したようには見えないかも
しれません。それにもかかわらず、これは正規の非決定性プログラムです。\footnote{以前に
数値が素数であるかをテストする手続\code{prime?}を定義しました。例え\code{prime?}が
定義されていたとしても、\code{prime\-/sum\-/pair}手続は、\link{Section 1.1.7}の最初で説明した
助けにならない``擬似Lisp''による平方根関数の定義の試みのように疑わしく見えるかも
しれません。現実に、あれらの行に沿った平方根手続が実際に非決定性プログラムとして
定式化することができます。評価機に探索の仕組みを合併することで、どのようにして回答を
計算するかについての純粋な宣言型の記述と命令型の仕様の間の区別を侵食していきます。
私達は\link{Section 4.4}にてこの方向へとさらに進みます。}

ここでの鍵となる考えは、非決定性言語における式は1つ以上の可能な値を持つことが
できるということです。例えば\code{an\-/element\-/of}は与えられたリストのどの要素でも
返すことが有り得ます。私達の非決定性プログラム評価機は自動的に可能な値を選択し
その選択を追跡することで働きます。もし続く要件に合わなければ、評価機は異なる
選択を試します。そして評価が成功するまで、または選択肢が無くなるまで、新しい選択を試し続けます。
遅延評価がプログラマを値がどのように遅延化され強制されるかの詳細から解放されたのと
同様に、非決定性プログラムの評価機はプログラマを選択がどのように行われるかの詳細から
解放します。

非決定性評価とストリーム処理により起こった時間の異なるイメージの対比は
示唆的です。ストリーム処理は遅延評価を可能な答のストリームが組まれた時間を
実際のストリーム要素が生成された時間から分離します。評価機は全ての可能な
回答が私達の前に永遠の列の中に横たわっているというイリュージョンを支えます。
非決定性評価機では式は可能な世界の集合の調査を表現します。それぞれは選択の
集合により判断されます。可能なせかい のいくつかは行き止まりへと導き、一方、
他は役立つ値へと導きます。非決定性プログラム評価機は時間の分岐と私達のプログラムが
異なる可能な実行履歴を持つというイリュージョンを支えます。行き止まりに辿り着いた
時には直前の選択地点に戻り、異なる分岐に従って進むことが可能です。

以下で実装される非決定性プログラム評価機は\code{amb}評価機と呼ばれます。
それが\code{amb}と呼ばれる新しい特殊形式に基づくためです。上記の\code{prime\-/sum\-/pair}の
定義を\code{amb}評価機ドライバループにて(\code{prime?}, \code{an\-/element\-/of}, \code{require}と
一緒に)型を付け、以下のように手続を実行することができます。

\begin{scheme}
~\textit{;;; Amb-Eval input:}~
(prime-sum-pair '(1 3 5 8) '(20 35 110))
~\textit{;;; Starting a new problem}~
~\textit{;;; Amb-Eval value:}~
~\textit{(3 20)}~
\end{scheme}

\noindent
返り値は評価機が条件に合う選択が行われるまで繰り返し各リストから要素を選択した
後に取得されました。


\link{Section 4.3.1}は\code{amb}を紹介しそれがどのように非決定性を評価機の自動探索の仕組みを
通してサポートするかについて説明します。\link{Section 4.3.2}は非決定性プログラムの例を与え、
\link{Section 4.3.3}は\code{amb}の実装方法の詳細を通常のScheme評価機を変更することで与えます。



\subsection{ambと検索}
\label{Section 4.3.1}

Schemeに非決定性を対応するよう拡張するために、\code{amb}と呼ばれる新しい特殊形式を
導入します。\footnote{非決定性プログラミングのための\code{amb}の考えは1961年に
最初にJohn McCarthyにより説明されました。(\link{McCarthy 1963}参照)。}

\begin{scheme}
(amb ~\( \dark \langle \)~~\( \dark e_1 \)~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark e_2 \)~~\( \dark \rangle \)~ ~\( \dots \)~ ~\( \dark \langle \)~~\( \dark e_n \)~~\( \dark \rangle \)~)
\end{scheme}

\noindent
上の式は\( n \)個の式\( \langle \)\( e_i \)\( \kern0.08em\rangle \)の内1つの値を``ambiguously''(曖昧に)
返します。例えば以下の式は

\begin{scheme}
(list (amb 1 2 3) (amb 'a 'b))
\end{scheme}

\noindent
以下の6つの値の可能性があります。

\begin{scheme}
~\code{(1 a)}~ ~\code{(1 b)}~ ~\code{(2 a)}~ ~\code{(2 b)}~ ~\code{(3 a)}~ ~\code{(3 b)}~
\end{scheme}

\noindent
単一の選択を行う\code{amb}は通常の(単一の)値を生成します。

\noindent
選択を行わない\code{amb}---式\code{(amb)}---は受け入れられる値の無い式です。操作上、
\code{(amb)}を評価された時に演算に対し``fail''(失敗)を起こさせると考えることができます。
演算は異常終了し、何の値も生成されません。この考えを用いて、ある特定の述語式\code{p}が
真でなければならないことを以下のように表現可能です。

\begin{scheme}
(define (require p) (if (not p) (amb)))
\end{scheme}

\noindent
\code{amb}と\code{require}を用いて上で使用された\code{an\-/element\-/of}を実装可能です。

\begin{scheme}
(define (an-element-of items)
  (require (not (null? items)))
  (amb (car items) (an-element-of (cdr items))))
\end{scheme}

\noindent
\code{an\-/element\-/of}はリストが空である場合には失敗します。そうでなければリストの
最初の要素か、リストの残りの要素から選択された要素を曖昧に返します。

無限の範囲の選択も表現可能です。以下の手続は可能性としてある与えられた\( n \)に
等しいか大きな任意の整数を返します。

\begin{scheme}
(define (an-integer-starting-from n)
  (amb n (an-integer-starting-from (+ n 1))))
\end{scheme}

\noindent
これはまるで\link{Section 3.5.2}で説明されたストリーム手続\code{integers\-/starting\-/from}の様です。
しかし重要な違いがあります。ストリーム処理は\( n \)で始まる全ての整数の列を表す
オブジェクトを返します。一方、\code{amb}手続は単一の整数を返します。\footnote{本当は
非決定的に単一の選択を返すことと全ての選択を返すことの違いは私達の視点に
幾分、依存します。値を使用するコードの視点からは非決定性による選択は単一の値を返します。
コードを設計するプログラマの視点からは非決定性による選択は潜在的に全ての可能な値を
返します。そして各値が個別に調査されるように演算は分岐するのです。}

抽象的に、\code{amb}式を評価することが時間に対して分岐を起こさせ、演算は各分岐上にて
式の可能な値の1つに上で続行するのだと想像することができます。\code{amb}が
\newterm{nondeterministic choice point}(\jnewterm{非決定性選択点})を表現すると言えます。
もし私達が動的に獲得できる十分な数のプロセッサを持つ計算機を持っているならば、
探索を簡単な方法で実装できるでしょう。実行は\code{amb}式に遭遇するまでは逐次的に
行われます。遭遇した時点では多くのプロセッサが獲得され選択により暗示された
全ての並列実行を続けるために初期化されます。各プロセッサは選択がそれしか無かった
かのように逐次的に続行します。その処理は失敗に遭遇して停止するか、さらなる分岐が
起こるか、完了するまで続けられます。\footnote{これは絶望的に非効率だと異議を唱える
人がいるかもしれません。この方法では簡単に規定された問題を解くのに数百万の
プロセッサを必要とするかもしれません。そしてそれらの多くのプロセッサはほとんどの
時間をアイドル状態(遊休状態)になるでしょう。この異議は歴史の文脈で捕えられるべきです。
メモリはとても高価な消費財だと考えられてきました。1964年にはメガバイトのRAMは\$400,000
の費用が掛かりました。現在では全てのPCが多数のメガバイトのRAMを積んでいます。そして
ほとんどの時間でほとんどのメモリは利用されていません。大量生産された電子製品の
コストを過小評価することは難しいことです。}

一方で、もし私達が1つのプロセス(またはいくつかの並行プロセス)しか実行できない計算機を持っている場合には
逐次的に動作する代替法を考えねばなりません。1つの方法としては評価機を選択点に辿り着いた時に
無作為に分岐を選択するよう変更することが考えられるでしょう。しかし無作為な選択は簡単に
失敗する値へと導きます。評価機を何度も何度も実行し無作為な選択を行い失敗しない値を見つけることを
期待するかもしれません。しかし全ての可能な実行パス(実行経路)を
\newterm{systematically search}(\jnewterm{体系的探索})をしたほうがより良いです。私達がこの節で開発し
働きかける\code{amb}評価機は体系的探索を次のように実装します。評価機が\code{amb}の適用に遭遇した
場合に初期値として最初の選択肢を選択します。この選択それ自身がさらなる選択へと導きます。
評価機は常に初期値として最初の選択肢を各選択点にて選択します。もし選択の結果が失敗となれば
評価機はautomagically\footnote{automagically: ``自動的に、しかし幾つかの理由で(典型的には
複雑過ぎて、または酷すぎて、または恐らくさらにどうでも良すぎて)話者が説明する気にならない''
(\link{Steele et al. 1983}, \link{Raymond 1993})\label{Footnote 4.47}}に最も最近の選択に
\newterm{backtracks}(\jnewterm{バックトラック}、引き返す)し、次の選択肢を試行します。もしどこかの
選択点において、全ての選択肢を使用してしまえば、評価機は以前の選択点へと戻りそこから
再開します。この処理は\newterm{depth-first search}(\jnewterm{深さ優先探索})または\newterm{chronological
backtracking}(クロノロジカルバックトラック、\jnewterm{年代順バックトラック})として知られる
探索戦略へと導きます。\footnote{自動的な探索戦略の
プログラミング言語への統合は長く功罪相半ばする歴史があります。非決定性アルゴリズムが美しく
プログラミング言語へと探索と自動的バックトラックと共に組込まれただろう最初の提案は
Robert \link{Floyd (1967)}により行われました。Carl \link{Hewitt (1969)}はPlannerと呼ばれる
プログラミング言語を発明しましたが、これは明示的に自動的なクロノロジカルバックトラックを
サポートし、組込の深さ優先探索戦略を提供していました。\link{Sussman et al. (1971)}はこの言語の
部分集合であるMicroPlannerを実装しました。これは問題解決とロボット計画の仕事の支持に使用され
ました。同様なアイデアが論理と定理証明から提起され、エディンバラとマルセイユにて洗練された
言語Prologの起源へと導きました。(\link{Section 4.4}にて議論します)。自動探索に対する多くの不満の後に
\link{McDermott and Sussman (1972)}はConniverと呼ばれる言語を開発しました。これはプログラマの
コントロール下に探索戦略を置くための仕組みを含みました。しかしこれは扱い難く、
\link{Sussman and Stallman 1975}はもっと御しやすい取り組み方を電子回路向け記号分析の手法の
研究の間に発見しました。彼等は事実を繋げる論理的依存性の追跡を基にした非クロノロジカルな
バックトラック計画を開発しました。これは
\newterm{dependency-directed backtracking}(\jnewterm{依存型バックトラック})として知られるようになった
技術です。彼等の手法は複雑でしたが、合理的な効率の良いプログラムを生成しました。冗長な
探索をほとんどしなかったためです。\link{Doyle (1979)}と\link{McAllester (1978; 1980)}は
StallmanとSussmanの手法を一般化し、明確にしました。そして探索を定式化するための
新しいパラダイムを開発しました。これは今では\newterm{truth maintenance}(\jnewterm{真理維持})と呼ばれています。
現代の問題解決システムは全て真理維持システムの何らかの形式を素地として使用しています。
真理維持システムと真理維持を用いたアプリケーションを構築するための洗練された方法の
議論については\link{Forbus and deKleer 1993}を参照して下さい。
\link{Zabih et al. 1987}はSchemeに対する\code{amb}を基にした非決定性拡張を説明しています。
これはこの節で説明されるインタプリタと同様です。しかしより高度な物です。それが
クロノロジカルバックトラックではなく依存型バックトラックを使用しているためです。
\link{Winston 1992}は両方の種類のバックトラックに対する入門を提供しています。}

\subsubsection*{ドライバループ}

\code{amb}評価機のドライバループはいくつかの普通ではない性質を持っています。
これは式を読み最初の失敗ではない実行の値を上で示された\code{prime\-/sum\-/pair}の例のように
表示します。もし次の成功する実行の値を見たいのであれば、インタプリタにバックトラックして
二番目の失敗ではない実行を生成する試行を命令します。これはシンボル\code{try\-/again}を入力
することで伝えられます。もし\code{try\-/again}ではない任意の式が与えられたなら、
インタプリタは新しい問題を開始し、直前の問題の調査されていない選択肢を捨てます。
以下にサンプルの応答を示します。

\begin{scheme}
~\textit{;;; Amb-Eval input:}~
(prime-sum-pair '(1 3 5 8) '(20 35 110))
~\textit{;;; Starting a new problem}~
~\textit{;;; Amb-Eval value:}~
~\textit{(3 20)}~

~\textit{;;; Amb-Eval input:}~
try-again
~\textit{;;; Amb-Eval value:}~
~\textit{(3 110)}~

~\textit{;;; Amb-Eval input:}~
try-again
~\textit{;;; Amb-Eval value:}~
~\textit{(8 35)}~

~\textit{;;; Amb-Eval input:}~
try-again
~\textit{;;; There are no more values of}~
~\textit{(prime-sum-pair (quote (1 3 5 8)) (quote (20 35 110)))}~

~\textit{;;; Amb-Eval input:}~
(prime-sum-pair '(19 27 30) '(11 36 58))
~\textit{;;; Starting a new problem}~
~\textit{;;; Amb-Eval value:}~
~\textit{(30 11)}~
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.35}Exercise 4.35:}
2つの与えられた境界値の間の整数を返す手続\code{an\-/integer\-/between}を書け。
これはピタゴラスの3つ組を求める手続を実装するのに使用できる。例えば与えられた範囲の間の
整数の三つ組\( (i, j, k) \)で\( i \le j \) and \( i^2 + j^2 = k^2 \)の場合は以下の様になる。

\begin{scheme}
(define (a-pythagorean-triple-between low high)
  (let ((i (an-integer-between low high)))
    (let ((j (an-integer-between i high)))
      (let ((k (an-integer-between j high)))
        (require (= (+ (* i i) (* j j)) (* k k)))
        (list i j k)))))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.36}Exercise 4.36:}
\link{Exercise 3.69}ではどのように``全ての''ピタゴラスの三つ組のストリームを探索対象の整数の
サイズに上限無しで生成するかについて議論した。なぜ単純に\code{an\-/inte\-/ger\-/between}を
\link{Exercise 4.35}の手続内の\code{an\-/integer\-/starting\-/from}で置き換えることは、
自由裁量なピタゴラスの三つ組を生成するのに適切でないのか、説明せよ。
これを実際に達成する手続を書け。
(すなわち、原理上は\code{try\-/again}を繰り返し入力することで全てピタゴラスの三つ組を生成する手続を書け)。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.37}Exercise 4.37:}
Ben Bitdiddleは以下のピタゴラスの3つ組を生成する手法は\link{Exercise 4.35}の手法に比べ
より効率的であると主張した。彼は正しいだろうか? (ヒント：探索しなければならない可能性の
数を考えよ)

\begin{scheme}
(define (a-pythagorean-triple-between low high)
  (let ((i (an-integer-between low high))
        (hsq (* high high)))
    (let ((j (an-integer-between i high)))
      (let ((ksq (+ (* i i) (* j j))))
        (require (>= hsq ksq))
        (let ((k (sqrt ksq)))
          (require (integer? k))
          (list i j k))))))
\end{scheme}
\end{quote}

\subsection{非決定性プログラムの例}
\label{Section 4.3.2}
\link{Section 4.3.3}は\code{amb}評価機の実装を説明します。しかし最初にそれがどのように使用できるかに
ついて、いくつかの例を与えます。非決定性プログラミングの利点は探索がどのように実行されるのか
についての詳細を隠すことができることです。従って抽象の高いレベルにてプログラムを表現できます。

\subsubsection*{論理パズル}


以下のパズル(\link{Dinesman 1968}から拝借しました)は典型的な大きなクラスの簡単な
論理パズルです。

\begin{quote}
Baker, Cooper, Fletcher, Miller, それにSmithは同じ5階しかないアパートの異なる階に
住んでいます。Bakerは最上階には住んでいません。Cooperは最下階には住んでいません。
Fletcherは最上階にも最下階にも住んでいません。MillerはCooperよりも高い階に住んでいます。
SmithはFletcherのすぐ隣の階には住んでいません。FletcherはCooperのすぐ隣の階には住んでいません。
皆はどの階に住んでいるでしょうか?
\end{quote}

\noindent
誰がどの階に住んでいるかを、全ての可能性を列挙し与えられた制約を与える簡単な方法で
決定することができます。\footnote{
私達のプログラムは以下の手続をリストの要素が識別可能
であるか判断するために使用しています。

\begin{smallscheme}
(define (distinct? items)
  (cond ((null? items) true)
        ((null? (cdr items)) true)
        ((member (car items) (cdr items)) false)
        (else (distinct? (cdr items)))))
\end{smallscheme}

\noindent
\code{member}は\code{memq}と同様ですがこれは\code{eq?}の代わりに\code{equal?}を
等価性のテストに用いています。}

\begin{scheme}
(define (multiple-dwelling)
  (let ((baker    (amb 1 2 3 4 5)) (cooper (amb 1 2 3 4 5))
        (fletcher (amb 1 2 3 4 5)) (miller (amb 1 2 3 4 5))
        (smith    (amb 1 2 3 4 5)))
    (require
     (distinct? (list baker cooper fletcher miller smith)))
    (require (not (= baker 5)))
    (require (not (= cooper 1)))
    (require (not (= fletcher 5)))
    (require (not (= fletcher 1)))
    (require (> miller cooper))
    (require (not (= (abs (- smith fletcher)) 1)))
    (require (not (= (abs (- fletcher cooper)) 1)))
    (list (list 'baker baker)       (list 'cooper cooper)
          (list 'fletcher fletcher) (list 'miller miller)
          (list 'smith smith))))
\end{scheme}

\noindent
式\code{(multiple\-/dwelling)}を評価すると結果を生成します。

\begin{scheme}
((baker 3) (cooper 2) (fletcher 4) (miller 5) (smith 1))
\end{scheme}

\noindent
この簡単な手続はうまく行きますが、とても遅いです。\link{Exercise 4.39}と
\link{Exercise 4.40}はいくらかの可能な改善法について議論します。

\begin{quote}
\heading{\phantomsection\label{Exercise 4.38}Exercise 4.38:}
multiple-dwelling手続を変更し、SmithとFletcherが隣接する階に住んでいないという
要件を取り除く。この変更したパズルにはいくつの解が存在するか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.39}Exercise 4.39:}
multiple-dwelling手続内の制約の順は解に影響するだろうか? 回答を見つけるのにかかる
時間には影響を与えるだろうか? もしそれが重要であると考えるのなら、制約の順を変える
ことで与えられる物から得られるより速いプログラムを実演せよ。
もしそれが問題ではないと考えるのなら、あなたの考えを論ぜよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.40}Exercise 4.40:}
複数の住居の問題において、人を階へと割り当てる方法は、requirementの前と後で階の割り当てが
区別可能な方法でいくつあるか? 全ての人から階への可能な割り当てを生成してからその次に
それらを排除するためにbacktrackにまかせることは非常に非効率である。
例えば制約のほとんどは一つか二つの人と階の変数を持ち、従って全ての人に対して階が
選択される前に制約を与えることができる。この問題を先の制約により既に排除されたもの
以外の可能性のみを生成することに基づいて解くずっと効率の良い非決定性手続を書き、実演せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.41}Exercise 4.41:}
複数住居パズルを解く通常のSchemeプログラムを書け。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.42}Exercise 4.42:}
次の``嘘つき''パズル(\link{Phillips 1934}から)を解け

5人の女生徒が試験のために座っている。彼女達は、彼女等の両親が
結果に過大な興味を見せていると考えている。従って彼女達は次のことを合意した。
それぞれの少女が1つの正しい文と嘘の文を作り、各家庭に試験についての手紙を書く。
以下は彼女らの手紙の該当する一節である。

\begin{itemize}

\item
Betty: ``Kittyが試験では二位だった。私だけが3位だった。''

\item
Ethel: ``喜んで、私がトップ。Joanが2位だった。''

\item
Joan: ``私が3番。可哀想なEthelは最下位だった。''

\item
Kitty: ``私が2番。Maryが単独で4位。''

\item
Mary: ``私が4位。トップはBettyが取ったわ。''

\end{itemize}

実際にはどの順に5人の女の子は並べられるか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.43}Exercise 4.43:}
\code{amb}評価機を用いて以下のパズルを解け\footnote{これは1960年代にLitton Industriesにより出版された
``問題の多いレクリエーション''と呼ばれる小冊子から引用しました。
\textit{Kansas State Engineer}著。}

Mary Ann Mooreの父はヨットを持っており、彼の4人の友達、
Downing大佐, Hallさん, Barnacle Hood卿, Dr. Parkerもそれぞれが持っていました。
5人のそれぞれに一人の娘がおり、それぞれが各自のヨットに他人の娘の名を取って付けていました。
Barnacle卿のヨットはGabrielleで、MooreさんのはLornaです。HallさんのはRosalindです。
Downing大佐のMelissaはBarnacle卿の娘の名を取って付けました。
Gabrielleの父のヨットはDr. Parkerの娘からです。Lornaの父は誰でしょう?

効率良く実行されるプログラムを書くように努めること(\link{Exercise 4.40}参照)。
また、もしMary Annの家族名がMooreであることを伝えなければ、いくつの解が存在するだろうか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.44}Exercise 4.44:}
\link{Exercise 2.42}はチェス盤に8つのクイーンをどの2つもお互いに攻撃することが無いように
置く``8クイーンパズル''について説明した。このパズルを解く非決定性プログラムを書け。
\end{quote}

\subsubsection*{自然言語の構文解析}

自然言語を入力として受け入れるよう設計されたプログラムは通常、その入力を
\newterm{parse}(\jnewterm{パース}、\jnewterm{構文解析})することから始めます。つまり入力を
ある文法構造に対して合わせることです。例えば冠詞と続く名詞、続く動詞から成る
簡単な文、''The cat eats.``(猫は食べる)のような物を認識しようとしていると
します。そのような分析を達成するためには個別の単語の品詞を判別できなければ
なりません。多種の単語を判別できるいくつかのリストから始めることが
できるでしょう。\footnote{ここでは各リストの最初の要素はリストの残りの単語の
品詞を示すという仕様を用いています。}

\begin{scheme}
(define nouns '(noun student professor cat class))
(define verbs '(verb studies lectures eats sleeps))
(define articles '(article the a))
\end{scheme}

\noindent
また\newterm{grammar}(\jnewterm{文法})も必要です。つまり、文法上の要素がどのようにより簡単な要素から
組み立てられるのかを説明するルールの集合です。とても簡単な文法は文は常に2つの要素---名詞句と
それに続く動詞---により成ると規定することができるかもしれません。そして名詞句は定冠詞と
それに続く名詞から成り立ちます。この文法を用いて、文``The cat eats.''は以下のように
パースされます。

\begin{scheme}
(sentence (noun-phrase (article the) (noun cat))
          (verb eats))
\end{scheme}

\noindent
そのようなパースを、手続を各文法上のルールに分割する簡単なプログラムを用いて生成することができます。
文をパースするためには、それを構成する2つの要素を判別し、これらの2つの要素のリストを
シンボル\code{sentence}のタグを付けて返します。


\begin{scheme}
(define (parse-sentence)
  (list 'sentence
         (parse-noun-phrase)
         (parse-word verbs)))
\end{scheme}

\noindent
名詞句も同様に定冠詞とそれに続く名詞を見つけることでパースされます。

\begin{scheme}
(define (parse-noun-phrase)
  (list 'noun-phrase
        (parse-word articles)
        (parse-word nouns)))
\end{scheme}

\noindent
最も低いレベルでは、パースとは繰り返し次のパースされていない単語が必要とされる品詞の
ための単語のリストのメンバであるかをチェックすることだとまとめられます。
これを実装するために、私達はグローバル変数\code{*unparsed*}を持ちます。これは
まだパースされていない入力です。単語をチェックする各時点で\code{*unparsed*}が空では
ないことを要求し、また指定されたリストの単語で始まることを要求します。もしそうで
あるならその単語を\code{*unparsed*}から削除し、その単語をその品詞(これはリストの先頭に
見つかります)と共に返します。\footnote{\code{parse\-/word}がparseされていない入力リストの
変更するのに\code{set!}を用いているおおに注意して下さい。これをうまく行うためには、
\code{amb}評価機は\code{set!}命令の効果をバックトラックする時に取り消しできなければいけません。}

\begin{scheme}
(define (parse-word word-list)
  (require (not (null? *unparsed*)))
  (require (memq (car *unparsed*) (cdr word-list)))
  (let ((found-word (car *unparsed*)))
    (set! *unparsed* (cdr *unparsed*))
    (list (car word-list) found-word)))
\end{scheme}

\noindent
パースを始めるために行わなければいけないこと全ては\code{*unparsed*}に入力全体を設定し、
文のパースを試み、何も残っていないことをチェックすることです。

\begin{scheme}
(define *unparsed* '())
(define (parse input)
  (set! *unparsed* input)
  (let ((sent (parse-sentence)))
    (require (null? *unparsed*)) sent))
\end{scheme}

\noindent
これでパーザ(parser、パースを行うプログラム)を試し、簡単なテスト文に対してうまく働くこと
を確認することができます。

\begin{scheme}
~\textit{;;; Amb-Eval input:}~
(parse '(the cat eats))
~\textit{;;; Starting a new problem}~
~\textit{;;; Amb-Eval value:}~
\end{scheme}
\begin{smallscheme}
~\textit{(sentence (noun-phrase (article the) (noun cat)) (verb eats))}~
\end{smallscheme}

\noindent
\code{amb}評価機はここでとても役立ちます。\code{require}の助けを用いてパースする上での
制約を表現するのにとても便利なためです。しかし、自動的な探索とバックトラックが
本当に効果を生むのはより複雑な文法について考えた時に、1つの単位の分解方法に
多数の選択肢が存在する場合です。


私達の文法に前置詞を追加してみましょう。

\begin{scheme}
(define prepositions '(prep for to in by with))
\end{scheme}

\noindent
そして前置詞句(例えば``for the cat''(猫のために))を名詞句の前の前置詞として定義します。

\begin{scheme}
(define (parse-prepositional-phrase)
  (list 'prep-phrase
        (parse-word prepositions)
        (parse-noun-phrase)))
\end{scheme}

\noindent
これで文は名詞句に動詞句が続くと定義でき、動詞句は動詞か、または前置詞句で拡張された動詞句
となります。\footnote{この定義が再帰的であることに注意して下さい。動詞には任意の数の
前置詞句が続けられます。}

\begin{scheme}
(define (parse-sentence)
  (list 'sentence (parse-noun-phrase) (parse-verb-phrase)))
(define (parse-verb-phrase)
  (define (maybe-extend verb-phrase)
    (amb verb-phrase
         (maybe-extend
          (list 'verb-phrase
                verb-phrase
                (parse-prepositional-phrase)))))
  (maybe-extend (parse-word verbs)))
\end{scheme}

\noindent
ここまでを行っている間に、名詞句の定義に``a cat in the class''(クラスの猫)のような
物を認めるよう詳細を詰めることができます。今まで名詞句と呼んできた物はこれからは
シンプルな名詞句と呼びます。そして名詞句はこれからシンプルな名詞句か前置詞句で
拡張した名詞句となります。

\begin{scheme}
(define (parse-simple-noun-phrase)
  (list 'simple-noun-phrase
        (parse-word articles)
        (parse-word nouns)))
(define (parse-noun-phrase)
  (define (maybe-extend noun-phrase)
    (amb noun-phrase
         (maybe-extend
          (list 'noun-phrase
                noun-phrase
                (parse-prepositional-phrase)))))
  (maybe-extend (parse-simple-noun-phrase)))
\end{scheme}

\noindent
私達の新しい文法はより複雑な文をパースできます。例えば、

\begin{scheme}
(parse '(the student with the cat sleeps in the class))
\end{scheme}

\noindent
(猫と一緒にその生徒はクラスで寝ている)は以下を生成します。

\begin{scheme}
(sentence
 (noun-phrase
  (simple-noun-phrase (article the) (noun student))
  (prep-phrase
   (prep with)
   (simple-noun-phrase (article the) (noun cat))))
 (verb-phrase
  (verb sleeps)
  (prep-phrase
   (prep in)
   (simple-noun-phrase (article the) (noun class)))))
\end{scheme}

\noindent
与えられた入力が二つ以上の有効な分析結果を持つかもしれないことを確認して下さい。
文``The professor lectures to the student with the cat''はprofessor(教授)が猫と一緒に
講義をしている場合と、学生が猫を持っている場合が有り得ます。
私達の非決定性プログラムは両方の可能性を見つけます。

\begin{scheme}
(parse '(the professor lectures to the student with the cat))
\end{scheme}

\noindent
は以下を生成します。

\begin{scheme}
(sentence
 (simple-noun-phrase (article the) (noun professor))
 (verb-phrase
  (verb-phrase
   (verb lectures)
   (prep-phrase
    (prep to)
    (simple-noun-phrase (article the) (noun student))))
  (prep-phrase
   (prep with)
   (simple-noun-phrase (article the) (noun cat)))))
\end{scheme}

\noindent
評価機にもう一度試行を命ずると以下を生じます。

\begin{scheme}
(sentence
 (simple-noun-phrase (article the) (noun professor))
 (verb-phrase
  (verb lectures)
  (prep-phrase
   (prep to)
   (noun-phrase
    (simple-noun-phrase (article the) (noun student))
    (prep-phrase
     (prep with)
     (simple-noun-phrase (article the) (noun cat)))))))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.45}Exercise 4.45:}
上で与えられた文法を用いて次の文は5通りにパースできる。 ``The professor
lectures to the student in the class with the cat''。5通りの結果を与えて
それらの間の様々な意味の違いを説明せよ。

\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.46}Exercise 4.46:} 
\link{Section 4.1}と\link{Section 4.2}は評価機はどの順でオペランドが評価されるかを決定しない。
我々は\code{amb}評価機がそれらを左から右へと評価するのを見るだろう。
なぜ我々のパーザはオペランドが何らかの他の順で評価されたならうまく働かないのか
説明せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.47}Exercise 4.47:}
Louis Reasonerは動詞句は動詞か前置詞句が続く動詞句であるのだから、
手続\code{parse\-/verb\-/phrase}を以下のように(そして同様に名詞句に対しても)
定義すればずっと簡単になるのではないかと提案した。

\begin{scheme}
(define (parse-verb-phrase)
  (amb (parse-word verbs)
       (list 'verb-phrase
             (parse-verb-phrase)
             (parse-prepositional-phrase))))
\end{scheme}

これはうまく行くだろうか? このプログラムの振舞はもし\code{amb}内の式の順を置き換えたら
変わるだろうか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.48}Exercise 4.48:}
上で与えられた文法をより複雑な文を取り扱うように拡張せよ。例えば、名詞句と動詞句を
拡張し形容詞と福祉を含める、または複合文を取り扱えるようできるだろう。\footnote{この種の
文法は任意の複雑さに成り得ます。しかし現実の言語の理解を考える限りはただの玩具に
過ぎません。現実の自然言語のコンピュータによる理解は構文解析と意味解釈の念入りな
混合が要求されます。一方で、例えおもちゃのパーザでもプログラムのための柔軟な命令言語、
例えば情報取得システム等をサポートするには実用的です。\link{Winston 1992}は
計算機による自然言語理解への取り組みと共に簡単な文法の命令言語のアプリケーションについても
議論しています。}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.49}Exercise 4.49:}
Alyssa P. Hackerはパースするよりも面白い文を生成することにより興味を持っている。
彼女は手続\code{parse\-/word}を簡単に変更してそれが``入力文''を無視し、その代わりに
常に成功して適切な単語を生成するようにすれば、このパースのために構築したプログラムを
用いて代わりに生成を行えるのではないかと推測した。Alyssaの考えを実装せよ。そして
生成された文の最初の半ダースかそこらを示せ。\footnote{Alyssaのアイデアはちゃんと
うまく働きますが(そして驚くほど簡単ですが)、それが生成する文は少しつまらないです。
それらはこの言語の可能な文からとても面白い様には抽出はしません。実際に文法は
多くの場所で高度に再帰し、Alyssaの技術はこれらの再帰の1つに``falls into''(陥り)、
抜け出せなくなります。これに対処する方法は\link{Exercise 4.50}を参照して下さい。}
\end{quote}

\subsection{\code{Amb}評価機の実装}
\label{Section 4.3.3}


通常のScheme式の評価機は値を返すか、永遠に停止しないか、またはエラーを発します。
非決定性Schemeでは式の評価はそれに加えて探索が行き止まりに帰結します。
その場合には評価機は依然の選択点へバックトラックしなければなりません。
非決定性Schemeの解釈はこの特別な場合により複雑になります。


私達は非決定性Schemeのための\code{amb}評価機を、\link{Section 4.1.7}の分析評価機を変更することで
構築します。\footnote{私達は\link{Section 4.2}の遅延評価機を\link{Section 4.1.1}の通常のメタ循環評価機に
対する変更として実装することを選択しました。対照的に、\link{Section 4.1.7}の分析評価機を
\code{amb}評価機の基にします。その評価機内の実行手続がバックトラックを実装するのに
便利なフレームワークを提供するためです。}分析評価機のように、式の評価は式の分析により
生成される実行手続を呼ぶことにより達成されます。通常のSchemeの解釈と非決定性Schemeの
解釈との違いは完全に実行手続の中に存在します。

\subsubsection*{手続と継続の実行}

通常の評価機の実行手続が1つの引数、実行の環境を取ることを思い出して下さい。
対照的に、\code{amb}評価機の実行手続は3つの引数を取ります。環境と
\newterm{continuation procedures}(\jnewterm{継続手続})と呼ばれる2つの手続です。
式の評価はこれらの2つの継続の1つを呼ぶことで完了します。もし評価の結果が
値に帰結するならば、\newterm{success continuation}(\jnewterm{成功継続})がその値と共に
呼ばれます。もし評価が行き止まりの発見に帰結したのであれば、
\newterm{failure continuation}(\jnewterm{失敗継続})が呼ばれます。適切な継続の構築と呼出が
非決定性評価機のバックトラックが実装される仕組みです。

値を受け取り計算を続行することが成功継続の仕事です。その値と共に、成功継続は別の
失敗継続も渡されます。これはその後にもしその値の使用が行き止まりに導いたなら
呼び出されます。


非決定性処理の他の分岐を試すのは失敗継続の仕事です。非決定性言語の本質は
式が選択肢の間の選択を表現するだろうという事実の中に存在します。
そのような式の評価は例え前もってどの選択肢受け入れ可能な結果に導くか知らなくても
指示された代替となる選択の一つを用いて続行しなければなりません。これを処理するため
には、評価機は選択肢から1つを取り出しこの値を成功継続に渡します。この値と共に、
評価機は後で異なる選択肢を選択するために呼び出し可能な失敗継続を構築し、一緒に渡します。


失敗は評価の間に引き起こされます。(言い換えれば失敗継続が呼ばれます)。それはユーザプログラムが
明示的に現在の一連の取り組みを拒絶した場合に起こります。(例えば、\code{require}の呼出は結果として
\code{(amb)}が実行される場合があります。これは常に失敗する式です。---\link{Section 4.3.1}参照)。
その時点で手中にある失敗継続が最も最近の選択点に他の選択肢を選択させます。
もしもうその選択点にて考えられる他の選択肢が無い場合には、直前の選択点の失敗が引き起こされます。
以下その繰り返しです。失敗継続はまた式の別の値を見つけるためのドライバループによる\code{try\-/again}要求への
応答としても起動されます。


加えて、もし副作用命令(変数への代入等)がある選択の結果としての分岐処理上で起こったならば、
処理が行き止まりを見つけた時に、新しい選択を行う前にその副作用を取り消しする必要が
あるかもしれません。これは副作用命令に副作用を取り消し失敗を伝播させる失敗継続を
生成させることで達成されます。


まとめとして、失敗継続は以下により構築されます。

\begin{itemize}

\item
\code{amb}式---\code{amb}式により行われた現在の選択が行き止まりに導いた場合に別の選択を行う
仕組みを提供します

\item
トップレベルドライバ---選択肢が枯渇した時に失敗を報告する仕組みを提供します

\item
代入---失敗に割り込み、バックトラックの間に代入を取り消します

\end{itemize}

\noindent
失敗は行き止まりに遭遇したその時のみ起動されます。これは以下の場合に起こります。

\begin{itemize}

\item
ユーザプログラムが\code{(amb)}を実行した

\item
ユーザがトップレベルドライバにて\code{try\-/again}を入力した

\end{itemize}

\noindent
失敗継続はまた失敗処理の間にも呼ばれます。

\begin{itemize}

\item
代入が副作用の取消を完了させることで失敗継続が作成された時に、それは割り込んだ
失敗継続を、失敗を伝播させこの代入に導いた選択点に戻すために、またはトップレベルに戻すために
呼びます。

\item
\code{amb}に対する失敗継続が選択肢を使い切った時、、
失敗を直前の選択点かトップレベルに伝播させるために、\code{amb}に対して元々与えられた失敗継続を呼び出します。

\end{itemize}

\subsubsection*{評価機の構造}


\code{amb}評価機に対する文法とデータの表現手続、また基本的な\code{analyze}手続は、
\link{Section 4.1.7}の評価機のそれらに等しい物です。しかし私達が追加の構文手続を\code{amb}の
特殊形式を認識するために必要とすることが異なります。\footnote{評価機は\code{let}を
サポートすると想定しています。(\link{Exercise 4.22}参照)。私達はこれを非決定性
プログラム内にて利用してきました。}

\begin{scheme}
(define (amb? exp)
  (tagged-list? exp 'amb))
(define (amb-choices exp) (cdr exp))
\end{scheme}

\noindent
\code{analyze}内にこの特殊形式を認識し、適切な実行手続を生成する呼出を追加しなければなりません。

\begin{scheme}
((amb? exp) (analyze-amb exp))
\end{scheme}

\noindent
トップレベル手続\code{ambeval}(\link{Section 4.1.7}で与えられた\code{eval}の版に似た物)は
与えられた式を分析し、実行手続を与えられた環境に対し、2つの与えられた継続と一緒に
適用しなければなりません。

\begin{scheme}
(define (ambeval exp env succeed fail)
  ((analyze exp) env succeed fail))
\end{scheme}

\noindent
成功継続は2引数の手続です。2引数は得られたばかりの値とその値がその後に失敗へと導いたなら
使用される別の失敗継続です。失敗継続は引数無しの手続です。そのため実行手続の
一般的な形は以下のようになります。

\begin{scheme}
(lambda (env succeed fail)
  ~\textrm{;; \code{succeed} is \code{(lambda (value fail) \( \dots \))}}~
  ~\textrm{;; \code{fail} is \code{(lambda () \( \dots \))}}~
  ~\( \dots \)~)
\end{scheme}

\noindent
例えば、以下を実行すると、

\begin{scheme}
(ambeval ~\( \dark \langle \)~~\var{\dark exp}~~\( \dark \rangle \)~
         the-global-environment
         (lambda (value fail) value)
         (lambda () 'failed))
\end{scheme}

\noindent
与えられた式を評価し、式の値(評価が成功した場合)かシンボル\code{failed}(評価が失敗
した場合)を返します。以下で示されるドライバループ内での\code{ambeval}の呼出はより
多くの複雑な継続手続を使用します。これらはループを継続し\code{try\-/again}要求を
サポートします。

\code{amb}の複雑さの多くは実行手続がお互いを呼ぶに従い、継続をたらい回しにすることから来ています。
以下のコードを通して読むに当って、それぞれの実行手続を\link{Section 4.1.7}で与えられた通常の評価機のための
対応する手続と比べて下さい。

\subsubsection*{単純な式}

最も単純な種類の式に対する実行手続は本質的に通常の評価機に対するものと同じです。
ただし、継続を管理する必要があることが異なります。これらの実行手続は式の値と共に単純に
成功し、渡された失敗継続をそのまま手渡します。

\begin{scheme}
(define (analyze-self-evaluating exp)
  (lambda (env succeed fail)
    (succeed exp fail)))
(define (analyze-quoted exp)
  (let ((qval (text-of-quotation exp)))
    (lambda (env succeed fail)
      (succeed qval fail))))
(define (analyze-variable exp)
  (lambda (env succeed fail)
    (succeed (lookup-variable-value exp env)
             fail)))
(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env succeed fail)
      (succeed (make-procedure vars bproc env)
               fail))))
\end{scheme}

\noindent
変数の検索が常に`成功'することに注意して下さい。もし\code{lookup\-/variable\-/value}が
変数を見つけるのに失敗した場合、それはいつも通りにエラーを発します。
そのような``失敗''はプログラムのバグ---未束縛な変数への参照---を示します。
これは現在試行中の物の代わりに別の非決定性選択を試すことを示してはいません。

\subsubsection*{条件文と列}


条件文もまた通常の評価機と同様に取り扱われます。\code{analyze\-/if}により生成される
実行手続は述語実行手続\code{pproc}を成功継続と共に起動します。成功継続は
述語の値が真であるかチェックし、結果部(consequent)か代替部(alternative)を実行します。
もし\code{pproc}の実行が失敗したなら\code{if}式に対する元の失敗継続が呼ばれます。

\begin{scheme}
(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
        (cproc (analyze (if-consequent exp)))
        (aproc (analyze (if-alternative exp))))
    (lambda (env succeed fail)
      (pproc env
             ~\textrm{;; 述語を評価するための成功継続を置く}~
             ~\textrm{;; \code{pred\-/value}を得るため}~
             (lambda (pred-value fail2)
               (if (true? pred-value)
                   (cproc env succeed fail2)
                   (aproc env succeed fail2)))
             ~\textrm{;; 述語を評価するための失敗継続}~
             fail))))
\end{scheme}

\noindent
列もまた以前の評価機と同様に取り扱われます。ただし継続を渡すために必要とされる
内部手続\code{sequentially}内の企みが異なります。具体的には\code{a}を実行し、次に\code{b}と順に
行うために、\code{a}を成功継続と共に呼び、成功継続が\code{b}を呼びます。

\begin{scheme}
(define (analyze-sequence exps)
  (define (sequentially a b)
    (lambda (env succeed fail)
      (a env
         ~\textrm{;; \code{a}を呼ぶための成功継続}~
         (lambda (a-value fail2)
           (b env succeed fail2))
         ~\textrm{;; \code{a}を呼ぶための失敗継続}~
         fail)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc
                            (car rest-procs))
              (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error "Empty sequence: ANALYZE"))
    (loop (car procs) (cdr procs))))
\end{scheme}

\subsubsection*{定義と代入}

定義は継続を管理するために手間をかけなければいけない一例です。定義の値(definition-value)の式を
実際に新しい値を定義する前に評価する必要があるためです。これを達成するためには
定義値実行手続\code{vproc}が環境、成功継続、失敗継続と共に呼ばれます。
もし\code{vproc}の実行が成功したなら定義値のための値\code{val}を取得し、変数が定義され
成功が伝播されます。

\begin{scheme}
(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze (definition-value exp))))
    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)
               (define-variable! var val env)
               (succeed 'ok fail2))
             fail))))
\end{scheme}

\noindent
代入はもっと面白いです。これは継続をたらい回しにするのではなく、本当に継続を使用する最初の場所です。
代入のための実行手続は定義のためのものと同様に開始します。最初に変数に代入される新しい値を取得しようと
試みます。もしこの\code{vproc}の評価が失敗したら代入は失敗します。


しかし\code{vproc}が成功し代入を行なおうとした場合には、この計算の分岐が後に失敗する
可能性について考えねばなりません。この場合には代入から外れてバックトラックする必要があります。
従ってこの代入をバックトラック処理の一部分として取消する準備をしなければなりません。\footnote{定義の
取消については心配しません。内部定義は走査されたことが想定可能なためです。(\link{Section 4.1.6})}


これは\code{vproc}に(下でコメント``*1*''が記された)成功継続を与えることで達成されます。
この成功継続は新しい値を代入し、結果として存在する前に、変数の古い値を保存します。
代入値と共に渡された(下でコメント``*2*''が記された)失敗継続は失敗を続ける前に変数の古い値を再格納します。
つまり、代入の成功は後の失敗に割り込む失敗継続を提供します。そうでなければ\code{fail2}を呼んでいたはずのどんな失敗も
この手続を代わりに呼ぶことで、実際に\code{fail2}を呼ぶ前に代入を取り消します。

\begin{scheme}
(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))

    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)        ~\textrm{; *1*}~
               (let ((old-value
                      (lookup-variable-value var env)))
                 (set-variable-value! var val env)
                 (succeed 'ok
                          (lambda ()    ~\textrm{; *2*}~
                            (set-variable-value!
                             var old-value env)
                            (fail2)))))
             fail))))
\end{scheme}

\subsubsection*{手続の適用}


適用のための実行手続は新しいアイデアを含んではいません。ただし継続を管理する
技術的な複雑さが異なります。この複雑さは\code{analyze\-/application}の中で
オペランドを評価するに従い成功と失敗の継続を追跡する必要があるために、浮上します。
私達は通常の評価機の中の様に単純に\code{map}を使うのでなく、手続\code{get\-/args}を用いてオペランドの
リストを評価しています。

\begin{scheme}
(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env succeed fail)
      (fproc env
             (lambda (proc fail2)
               (get-args aprocs
                         env
                         (lambda (args fail3)
                           (execute-application
                            proc args succeed fail3))
                         fail2))
             fail))))
\end{scheme}

\noindent
\code{get\-/args}の中では、どのようにして\code{aproc}実行手続のリストを\code{cdr}で下り、そして
結果の\code{args}のリストを全て\code{cons}するかについて注意して下さい。
これはリスト中の全ての\code{aproc}を、
再帰的に\code{get\-/args}を呼ぶ成功継続と共に呼ぶことにより達成されます。
これらの\code{get\-/args}に対する全ての再帰的呼出は、蓄積された引数のリストの上に
新しく取得された引数を\code{cons}した値を返す成功継続を持っています。

\begin{scheme}
(define (get-args aprocs env succeed fail)
  (if (null? aprocs)
      (succeed '() fail)
      ((car aprocs)
       env
       ;;~\textrm{この\code{aproc}のための成功継続}~
       (lambda (arg fail2)
         (get-args
          (cdr aprocs)
          env
          ;;~\textrm{\code{get\-/args}の再帰呼出のための}~
          ;;~\textrm{成功継続}~
          (lambda (args fail3)
            (succeed (cons arg args) fail3))
          fail2))
       fail)))
\end{scheme}

\noindent
\code{exe@\-/cute\-/application}により実行される実際の手続適用は通常の評価機に対する物と
同じ方法にて達成されます。ただし継続の管理の必要が異なります。

\begin{scheme}
(define (execute-application proc args succeed fail)
  (cond ((primitive-procedure? proc)
         (succeed (apply-primitive-procedure proc args)
                  fail))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment
           (procedure-parameters proc)
           args
           (procedure-environment proc))
          succeed
          fail))
        (else (error "Unknown procedure type:
                      EXECUTE-APPLICATION"
                     proc))))
\end{scheme}

\subsubsection*{\code{amb}式の評価}

\code{amb}の特殊形式は非決定性言語の鍵となる要素です。ここでは逐次翻訳処理の本質と
継続を追跡する理由について学びます。\code{amb}に対する実行手続はループ\code{try\-/next}を
定義します。これは全ての\code{amb}式の可能な値のために、全実行手続を通して実行します。
各実行手続は次の実行手続を試す失敗継続と共に呼ばれます。試行する選択肢が無くなった
時には、\code{amb}式全体が失敗します。

\begin{scheme}
(define (analyze-amb exp)
  (let ((cprocs (map analyze (amb-choices exp))))
    (lambda (env succeed fail)
      (define (try-next choices)
        (if (null? choices)
            (fail)
            ((car choices)
             env
             succeed
             (lambda () (try-next (cdr choices))))))
      (try-next cprocs))))
\end{scheme}

\subsubsection*{ドライバループ}

\code{amb}評価機のドライバループは複雑です。ユーザに式の評価を再試行(try-again)
することを可能にする仕組みのためです。ドライバは\code{internal\-/loop}と呼ばれる
手続を使用します。これは引数として手続\code{try\-/again}を取ります。これの意図は
\code{try\-/again}の呼出は次のまだ試行されていない非決定性評価における選択肢へ
続けなければならないことです。\code{internal\-/loop}はユーザのドライバループでの
\code{try\-/again}の入力への応答として\code{try\-/again}を呼ぶか、またはそうでなければ
\code{ambeval}を呼ぶことにより新しい評価を開始します。

\code{ambeval}へのこの呼出のための失敗継続はユーザにもう値は残っていないと伝え、
ドライバループを再起動する。

\code{ambeval}への呼出のための成功継続はより微妙です。獲得した値を表示し、次に内部ループを
再び起動します。起動には次の選択肢を試行可能な\code{try\-/again}手続を伴ないます。
この\code{next\-/alternative}手続は成功継続に二番目の引数として渡されます。通常はこの二番目の
引数はもし現在の評価分岐が後に失敗場合に利用される失敗継続として考えます。
今回の場合はしかし、評価を成功裏に完了しました。そのため``失敗''の代替分岐を追加の成功する
評価を探すために起動することができます。

\begin{scheme}
(define input-prompt  ";;; Amb-Eval input:")
(define output-prompt ";;; Amb-Eval value:")
(define (driver-loop)
  (define (internal-loop try-again)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (if (eq? input 'try-again)
          (try-again)
          (begin
            (newline)
            (display ";;; Starting a new problem ")
            (ambeval
             input
             the-global-environment
             ;; ~\textrm{\code{ambeval} success}~
             (lambda (val next-alternative)
               (announce-output output-prompt)
               (user-print val)
               (internal-loop next-alternative))
             ;; ~\textrm{\code{ambeval} failure}~
             (lambda ()
               (announce-output
                ";;; There are no more values of")
               (user-print input)
               (driver-loop)))))))
  (internal-loop
   (lambda ()
     (newline)
     (display ";;; There is no current problem")
     (driver-loop))))
\end{scheme}

\noindent
\code{internal\-/loop}の最初の呼出では現在、問題が無いと不服を述べ、ドライバループを再開します。
これはユーザが\code{try\-/again}を入力し評価に進展が無い場合に起こる振舞です。

\begin{quote}
\heading{\phantomsection\label{Exercise 4.50}Exercise 4.50:}
\code{amb}と似ているが、次の選択肢を左から右へでなくランダムな順で探索する新しい特殊形式\code{ramb}を実装せよ。
\link{Exercise 4.49}におけるAlyssaの問題をどのように助けるか示せ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.51}Exercise 4.51:}
失敗時に取り消されない\code{permanent\-/set!}と呼ばれる新しい種類の代入を実装せよ。
例えば、以下の様に2つの区別可能な要素をリストから選択し、成功した選択に必要とした試行の数を
カウントする。

\begin{scheme}
(define count 0)
(let ((x (an-element-of '(a b c)))
      (y (an-element-of '(a b c))))
  (permanent-set! count (+ count 1))
  (require (not (eq? x y)))
  (list x y count))
~\textit{;;; Starting a new problem}~
~\textit{;;; Amb-Eval value:}~
~\textit{(a b 2)}~
~\textit{;;; Amb-Eval input:}~
try-again
~\textit{;;; Amb-Eval value:}~
~\textit{(a c 3)}~
\end{scheme}


ここで\code{permanent\-/set!}の代わりに\code{set!}を使ったらどんな値が表示されるだろうか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.52}Exercise 4.52:}
ユーザに式の失敗を捕獲させることを可能にする新しいコンストラクタ\code{if\-/fail}を実装せよ。
\code{if\-/fail}は2つの式を取る。最初の式を通常通りに評価し評価が成功したら普通に戻る。
しかし、もし評価が失敗したら2つ目の式の値が以下の例の様に返される。

\begin{scheme}
~\textit{;;; Amb-Eval input:}~
(if-fail (let ((x (an-element-of '(1 3 5))))
           (require (even? x))
           x)
         'all-odd)
~\textit{;;; Starting a new problem}~
~\textit{;;; Amb-Eval value:}~
~\textit{all-odd}~

~\textit{;;; Amb-Eval input:}~
(if-fail (let ((x (an-element-of '(1 3 5 8))))
           (require (even? x))
           x)
         'all-odd)
~\textit{;;; Starting a new problem}~
~\textit{;;; Amb-Eval value:}~
~\textit{8}~
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.53}Exercise 4.53:}
\link{Exercise 4.51}で説明した\code{permanent\-/set!}と\link{Exercise 4.52}の
\code{if\-/fail}を用いて以下を評価した時どのような結果になるか。

\begin{scheme}
(let ((pairs '()))
  (if-fail 
   (let ((p (prime-sum-pair '(1 3 5 8)
                            '(20 35 110))))
     (permanent-set! pairs (cons p pairs))
     (amb))
   pairs))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.54}Exercise 4.54:}
もし\code{require}が\code{amb}を用いた通常の手続として実装できることに気付かなかった場合、
ユーザにより非決定性プログラムの一部として定義されるために、それを特殊形式として
実装する必要があったはずである。これは以下の構文手続を必要としたであろう。

\begin{scheme}
(define (require? exp)
  (tagged-list? exp 'require))
(define (require-predicate exp) 
  (cadr exp))
\end{scheme}

\noindent
そして\code{analyze}内の呼出に新しい節が必要となった。

\begin{scheme}
((require? exp) (analyze-require exp))
\end{scheme}

\noindent
また\code{require}式を取り扱う手続\code{analyze\-/require}も必要となった。
以下の\code{analyze\-/require}の定義を完成させよ。

\begin{scheme}
(define (analyze-require exp)
  (let ((pproc (analyze (require-predicate exp))))
    (lambda (env succeed fail)
      (pproc env
             (lambda (pred-value fail2)
               (if ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~
                   ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~
                   (succeed 'ok fail2)))
             fail))))

\end{scheme}
\end{quote}


\section{論理プログラミング}
\label{Section 4.4}

\link{Chapter 1}では計算機科学は命令型(どうするか)の知識を扱い、一方、数学は宣言型(何であるか)の
知識を扱うと強調しました。実際に、プログラミング言語はプログラマが特定の問題を解くために、
段階的な手法を示す形式により、知識を表現することを要求します。
一方、高級言語は言語の実装の一部としてユーザを、指定された演算がどのように進められるかについての詳細から
解放する、十分な量の方法論的知識を提供します。

Lispを含む多くのプログラミング言語は数学上の関数の値の演算の周りに体系化されています。
式指向の言語(例えばLisp、Fortran、Algol)は関数の値を記述する式がその値を求める
手段としても解釈されるという``多義性''を十分に活用しています。このため、多くの
プログラミング言語は単向性演算(明確な入力と出力を持つ演算)に向けて強く偏っています。
しかし、この偏りを緩和する完全に異なるプログラミング言語も存在します。そのような言語の
例を\link{Section 3.3.5}で見ました。そこでは計算オブジェクトは数値的な制約でした。制約システムでは
演算の向きと順はあまり明らかには指定されません。従って、演算の実行においてシステムはより
詳細な``行い方''の知識を、通常の数値演算による場合よりも多く提供しなければなりません。
しかし、これはユーザが命令型の知識を提供する責任から完全に解放されることは意味しません。
同じ制約の集合を実装する制約ネットワークは数多く存在し、ユーザは数学的に等価なネットワークの中から
特定の演算を指定するのに適切なネットワークを選択せねばなりません。

\link{Section 4.3}の非決定性プログラム評価機もまたプログラミングとは一方向性関数のための
アルゴリズムを構築することであるという視点から離れています。非決定性言語においては、
式は2つ以上の値を持つことができ、結果として演算とは単一の値の関数ではなく関係性を
取り扱う物になります。論理プログラミングはプログラミングの関係性の視点と
\newterm{unification}(\jnewterm{ユニフィケーション}、単一化)と呼ばれる強力な種類の記号パターン
マッチングとを組み合わせることでこの考えを拡張します。\footnote{論理プログラミングは
自動定理証明の研究の長い歴史から成長しました。早期の定理証明プログラムはあまり目的を
達成することができませんでした。可能な証明空間を網羅的に探索するためです。受け入れ可能な
探索を行える打開策の主な物は1960年代早期の\newterm{unification algorithm}(\jnewterm{ユニフィケーションアルゴリズム})と
\newterm{resolution principle}(\jnewterm{導出原理})(\link{Robinson 1965})の発見でした。
例えば導出は\link{Green and Raphael (1968)}により(\link{Green 1969}も参照)
演繹的質問応答システムの基盤として使用されました。この時期の多くの間、研究者達は
証明が存在するのであれば見つけられることが保証されたアルゴリズムについて集中していました。
そのようなアルゴリズムはコントロールして証明に向かわせることが難しいものでした。
\link{Hewitt (1969)}はプログラミング言語のコントロール構造と論理操作システムとの
結合の可能性を認識し、\link{Section 4.3.1}(\link{Footnote 4.47})で述べられた自動探索の成果へと
導きました。同時期に、マルセイユのColmerauerは自然言語を扱うルールベースシステム
(\link{Colmerauer et al. 1973})により同じ事を達成しました。彼はPrologと呼ばれる
プログラミング言語を開発しそれらのルールを表現しました。\link{Kowalski (1973; 1979)}は
エディンバラにて、Prologプログラムの実行は(線形ホーン節導出と呼ばれる
証明のテクニックを用いて)定理証明として解釈できることを認めました。
最後の2つの糸を縒り合わせることが論理プログラミング運動へと導きました。従って
論理プログラミングの開発に対して功績を与えることにおいて、フランス人はマルセイユ大学
でのPrologの起源を指摘することができ、一方、イギリス人はエディンバラ大学の成果を
強調することができます。\acronym{MIT}の人々に言わせれば、論理プログラミングはこれらの
グループにより、Hewittがその才能ある、しかし頑迷な博士論文にて何を伝えていたかを
解き明かす試みにより開発されました。論理プログラミングの歴史については
\link{Robinson 1983}を参照して下さい。}

この取り組み方は、うまく行く場合には、プログラムを書くのにとても強力な方法となります。
その力の一部は単一の``何であるか''という事実が、異なる``行い方''の要素を持つかもしれない
いくつかの異なる問題を解決するのに使用できるという事実から来ています。
例として、\code{append}命令について考えましょう。これは2つのリストを引数として取り、それらの
要素を結合して単一のリストを形成します。Lispのような手続型言語では\code{append}を
基本的なリストコンストラクタ\code{cons}を用いて、\link{Section 2.2.1}で行ったように定義することができました。

\begin{scheme}

(define (append x y)
  (if (null? x) y (cons (car x) (append (cdr x) y))))
\end{scheme}

\noindent
この手続は以下の2つのルールによりLispへと翻訳したと捕えることができます。
最初のルールは1つ目のリストが空である場合を扱い、2つ目のルールは空でないリスト、
つまり2つの部分による\code{cons}の場合を扱います。

\begin{itemize}

\item
任意のリスト\code{y}に対し、空リストと\code{y}の\code{append}は\code{y}を形成する。

\item
任意の\code{u}, \code{v}, \code{y}, \code{z}に対し、\code{(cons u v)}と\code{y}の\code{append}は
もし\code{v}と\code{y}の\code{append}が\code{z}を形成するならば\code{(cons u z)}を形成する。\footnote{ルールと
手続の間の対応を見るためには、手続における\code{x}(\code{x}が空でない場合)を
ルールの\code{(cons u v)}に対応させます。次にルールの\code{z}は\code{(cdr x)}と\code{y}の
\code{append}に対応します。}

\end{itemize}

\noindent
\code{append}手続を用いることで、私達は次のような質問に答えることができます。

\begin{quote}
\code{(a b)}と\code{(c d)}の\code{append}を求めよ。
\end{quote}

\noindent
しかし同じ2つのルールがまた以下のような種類の質問に答えるためにも十分です。
これらは手続では答えられません。

\begin{quote}
\code{(a b)}と\code{append}すると\code{(a b c d)}を生成するリスト\code{y}を求めよ。


\code{append}すると\code{(a b c d)}を生成する全ての\code{x}と\code{y}を求めよ。
\end{quote}

\noindent
論理プログラミング言語ではプログラマは\code{append}``手続''を上で与えられた\code{append}に関する
2つのルールを提示することにより記述します。``行い方''の知識は自動的にインタプリタにより
提供されこの単一ペアのルールが3つ全てのタイプの\code{append}に関する質問に対して答えることを
可能にします。\footnote{これは確かにユーザをどのように回答を求めるかという問題全体からは
解放しません。\code{append}の関係を形式化するための数学的に等価なルールは数多く存在します。
それらのいくつかのみが任意の方向の演算に対する効果的な手段と成り得ます。
付け加えて、時々、``何であるか''という情報は``どのように''回答を求めるかについて
何の手掛かりも与えない場合があります。例えば\( y^2 = x \)となる\( y \)を求める
問題について考えてみて下さい。}


現代の論理プログラミング言語(ここで私達が実装しているものを含めて)にはかなりの量の
不足がそれらの一般的な``行い方''の手法について存在します。このことが偽の無限ループを
引き起したり、他の望ましくない振舞へと導いてしまします。論理プログラミングは計算機
科学において活発な研究領域です。\footnote{論理プログラミングへの興味は80年代早期に
日本政府が論理プログラミング言語を実行するのに最適化されたとても速い計算機を構築する
ことを狙った大望あるプロジェクトを開始した時にピークを迎えました。そのような計算機の
スピードは通常のFLOPS(FLoating-point Operations Per Second)でなく
LIPS(Logical Inferences Per Second)で計られます。プロジェクトはハードウェアとソフトウェアの
開発において元々の計画通りに成功しましたが、国際的なコンピュータ業界は異なる方向へと
向かいました。日本のプロジェクトの評価の概観については\link{Feigenbaum and Shrobe 1993}を
参照して下さい。論理プログラミングコミュニティもまた、\link{Section 3.3.5}の制約伝播システムで
説明されたような数値値上の制約を取り扱う能力の様な単純なパターンマッチングではない
技術を基盤にしたリレーショナルプログラミングへと移行しました。}


この章の最初では私達はインタプリタの実装技術を探求しLispの様な言語のための
インタプリタに対して(実際に、任意の従来の言語に対して)本質である要素を説明しました。
今から私達はこれらの考えを応用し論理プログラミング言語のためのインタプリタについて議論します。
この言語を\newterm{query language}(\jnewterm{クエリ言語})と呼ぶことにします。言語で内で表現される、
\newterm{queries}(\jnewterm{クエリ})、つまり質問を定式化することによりデータベースから情報を
取得することに対してとても便利なためです。
クエリ言語はLispと全く違うであるにも係らず、私達がここまで利用してきた同じ一般的なフレームワークを
用いてこの言語を説明することがとても都合が良いことを理解するでしょう。
このフレームワークはプリミティブな要素の集合として、簡単な要素を組み合わせることでより複雑な要素を作ることを
可能にする組み合わせの手段と、複雑な要素を単純な概念の単位として見做すことを可能にする
抽象化の手段とを一緒に用いました。
論理プログラミング言語向けインタプリタはLispのような言語のインタプリタよりも大幅に複雑です。
それでも、私達のクエリ言語インタプリタが\link{Section 4.1}のインタプリタ内にて見つけた多くの同じ
要素を含むことを学ぶでしょう。
具体的には式を方に従って分類する``eval''のパートが存在し、そして言語の抽象化の仕組み(Lispの
場合では手続であり、論理プログラミングの場合ではルール)を実装する``apply''のパートが存在します。
また、中心的な役割はフレームデータ構造により実装の中で演じられます。このフレームデータ構造は
シンボルとそれらに関連する値の間の対応を決定します。クエリ言語の実装の追加の面白い側面の1つは、
\link{Chapter 3}で紹介したストリームを大量に使用することです。



\subsection{演繹的情報検索}
\label{Section 4.4.1}

論理プログラミングは情報取得のためのデータベースに対するインターフェイスの提供に
おいて秀でています。私達がこの章で実装するクエリ言語はこのように使用されるよう
設計されています。


クエリシステムが何を行うかを説明するために、ボストン区域に存在する成長中の
ハイテク企業、Microshaftの社員情報のデータベースを管理するために、クエリシステムが
どのように利用できるかについて示します。この言語はパターンにより示される社員情報への
アクセスを提供し、また論理的演繹法を行うための一般的なルールの利点をも得ることができます。

\subsubsection*{サンプルデータベース}

Microshaftの社員情報データベースは会社の全社員に関する\newterm{assertions}(\jnewterm{アサーション}、表明)を
保持します。以下に常駐のコンピュータウィザード、Ben Bitdiddleに関する情報を挙げます。

\begin{scheme}
(address (Bitdiddle Ben) (Slumerville (Ridge Road) 10))
(job (Bitdiddle Ben) (computer wizard))
(salary (Bitdiddle Ben) 60000)
\end{scheme}

\noindent
各アサーションはリスト(この場合3つ組)で、その要素はそれ自体がリストに成り得ます。


常駐のウィザードとして、Benは会社のコンピュータ部門を管理し、二人のプログラマと一人の
技術者を監督します。以下に部下に関する情報を挙げます。

\begin{scheme}
(address (Hacker Alyssa P) (Cambridge (Mass Ave) 78))
(job (Hacker Alyssa P) (computer programmer))
(salary (Hacker Alyssa P) 40000)
(supervisor (Hacker Alyssa P) (Bitdiddle Ben))

(address (Fect Cy D) (Cambridge (Ames Street) 3))
(job (Fect Cy D) (computer programmer))
(salary (Fect Cy D) 35000)
(supervisor (Fect Cy D) (Bitdiddle Ben))

(address (Tweakit Lem E) (Boston (Bay State Road) 22))
(job (Tweakit Lem E) (computer technician))
(salary (Tweakit Lem E) 25000)
(supervisor (Tweakit Lem E) (Bitdiddle Ben))
\end{scheme}

\noindent
Alyssaに監督されているプログラマ見習いもいます。

\begin{scheme}
(address (Reasoner Louis) (Slumerville (Pine Tree Road) 80))
(job (Reasoner Louis) (computer programmer trainee))
(salary (Reasoner Louis) 30000)
(supervisor (Reasoner Louis) (Hacker Alyssa P))
\end{scheme}

\noindent
これらの人々全てはコンピュータ部門に属し、彼等の職位(job)記述の最初の項目である
単語\code{computer}により示されています。


Benは高位の従業員です。彼の監督者は会社の有力者である彼自身です。

\begin{scheme}
(supervisor (Bitdiddle Ben) (Warbucks Oliver))
(address (Warbucks Oliver) (Swellesley (Top Heap Road)))
(job (Warbucks Oliver) (administration big wheel))
(salary (Warbucks Oliver) 150000)
\end{scheme}

\noindent
コンピュータ部門がBenに監督されているのに加えて、会社には会計士長とそのアシスタントから
成る経理部門があります。

\begin{scheme}
(address (Scrooge Eben) (Weston (Shady Lane) 10))
(job (Scrooge Eben) (accounting chief accountant))
(salary (Scrooge Eben) 75000)
(supervisor (Scrooge Eben) (Warbucks Oliver))

(address (Cratchet Robert) (Allston (N Harvard Street) 16))
(job (Cratchet Robert) (accounting scrivener))
(salary (Cratchet Robert) 18000)
(supervisor (Cratchet Robert) (Scrooge Eben))
\end{scheme}

\noindent
また重役のための秘書もいます。

\begin{scheme}
(address (Aull DeWitt) (Slumerville (Onion Square) 5))
(job (Aull DeWitt) (administration secretary))
(salary (Aull DeWitt) 25000)
(supervisor (Aull DeWitt) (Warbucks Oliver))
\end{scheme}

\noindent
データベースはまたどの職種が他の職種を持つ人々により行われることができるかに関する
アサーションも含みます。例えばコンピュータウィザードはコンピュータプログラマと
コンピュータ技術者の両方の職を行うことができます。

\begin{scheme}
(can-do-job (computer wizard) (computer programmer))
(can-do-job (computer wizard) (computer technician))
\end{scheme}

\noindent
コンピュータプログラマは見習いを埋めることができるでしょう。

\begin{scheme}
(can-do-job (computer programmer)
            (computer programmer trainee))
\end{scheme}

\noindent
また良く知られているように以下も言えます。

\begin{scheme}
(can-do-job (administration secretary)
            (administration big wheel))
\end{scheme}

\subsubsection*{単純なクエリ}


クエリ言語はユーザにシステムプロンプトに対する応答として
クエリを提示させることで、データベースから情報を取得することを許します。

\begin{scheme}
~\textit{;;; Query input:}~
(job ?x (computer programmer))
\end{scheme}

\noindent
システムは以下の項目を返します。

\begin{scheme}
~\textit{;;; Query results:}~
(job (Hacker Alyssa P) (computer programmer))
(job (Fect Cy D) (computer programmer))
\end{scheme}

\noindent
入力クエリはある種のパターンにマッチするデータベース内のエントリを探すことを指示します。
この例では、パターンは3つの項目から成るエントリを指定しています。最初が文字シンボルの
\code{job}、2つ目は任意の値に成り得て、3番目は文字のリスト\code{(computer programmer)}です。
マッチングリスト内の2つ目の項目に成り得る``任意項''は\newterm{pattern variable}(\jnewterm{パターン変数})\code{?x}で
指定されます。パターン変数の一般的な形式はクエスチョンマークを前に置いた、変数の名前と
して取られるシンボルです。以下では、なぜこのことが単に\code{?}を``任意''を表すパターンに
置くのではなく、パターン変数のために名前を指定することが便利であるかを学びます。
システムは簡単なクエリに指定されたパターンにマッチするデータベース内の全てのエントリを
表示することで応答します。

パターンは複数の変数を持つことができます。例えば、以下のクエリ

\begin{scheme}
(address ?x ?y)
\end{scheme}

\noindent
は全ての従業員の住所を並べます。

パターンはクエリが単純にパターンがデータベース内のエントリであるかどうかを決定する
場合には変数を持つことができません。もしそうであれば1つの一致が存在します。
そうでなければ1つも一致は存在しません。

同じパターン変数が1つのクエリ内に複数存在することができ、同じ``任意項''が各位置に
現われなければいけないこと指定します。これがなぜ変数が名前を持つのかの理由です。
例えば、

\begin{scheme}
(supervisor ?x ?x)
\end{scheme}

\noindent
上のクエリは自分自身を監督する全ての人々を見つけます。(しかし私達のサンプル
データベース内のアサーションにはそのようなエントリがありません。)

以下のクエリは、

\begin{scheme}
(job ?x (computer ?type))
\end{scheme}

\noindent
3つ目の項目が二要素リストでありその1つ目の要素が\code{computer}である全ての職種エントリに
適合します。

\begin{scheme}
(job (Bitdiddle Ben) (computer wizard))
(job (Hacker Alyssa P) (computer programmer))
(job (Fect Cy D) (computer programmer))
(job (Tweakit Lem E) (computer technician))
\end{scheme}

\noindent
この同じパターンが以下にはマッチ``しません''。

\begin{scheme}
(job (Reasoner Louis) (computer programmer trainee))
\end{scheme}

\noindent
なぜならエントリの3つ目の項目が3要素のリストであり、パターンの3つ目の項目がそこは
2要素でなければならないと指定しているためです。もし私達がパターンを変更し3つ目の
項目が\code{computer}で始まる任意のリストでも良いようにしたければ、以下のように
指定可能です。\footnote{これは\link{Exercise 2.20}で紹介されたドット付き末尾記述を
用いています。}

\begin{scheme}
(job ?x (computer . ?type))
\end{scheme}

\noindent
例えば、以下のクエリは、

\begin{scheme}
(computer . ?type)
\end{scheme}

\noindent
次のデータに適合します。

\begin{scheme}
(computer programmer trainee)
\end{scheme}

\noindent
この時\code{?type}はリスト\code{(programmer trainee)}になります。これはまた
次のデータにも適合します。

\begin{scheme}
(computer programmer)
\end{scheme}

\noindent
この時\code{?type}はリスト\code{(programmer)}になります。さらに以下のデータにも
適合します。

\begin{scheme}
(computer)
\end{scheme}

\noindent
この時\code{?type}は空リスト\code{()}です。


クエリ言語の簡単なクエリの処理は以下のように説明できます。

\begin{itemize}

\item
システムはクエリパターン内の変数に対する、パターンを満たす全ての割り当てを見つけます---つまり、
パターン変数が値によりインスタンス化されるような(例示されるような)、つまり値により置き換えられるような
変数に対する値の全ての集合です。結果はデータベース内に存在します。

\item
システムはクエリに対し、パターンを満たす変数割り当てと共に、クエリパターンの
全てのインスタンス(事例)を列挙することで応答します。

\end{itemize}

\noindent
もしパターンに変数が無い場合、クエリはそのパターンがデータベース内に存在するかどうか
の決定に簡約されることに注意して下さい。もしそうならば、変数に何の値も割り当てない
空割り当てがデータベースに対するそのパターンを満たします。

\begin{quote}
\heading{\phantomsection\label{Exercise 4.55}Exercise 4.55:}
以下の情報をデータベースから取り出す簡単なクエリを与えよ。

\begin{enumerate}

\item
Ben Bitdiddleにより監督される(supervisor)全ての人

\item
経理部門に属す全ての人の名前(name)と職種(job)

\item
Slumervilleに済む全ての人の名前と住所(address)

\end{enumerate}
\end{quote}

\subsubsection*{複合クエリ}


単純なクエリはクエリ言語のプリミティブな命令を形成します。複雑な命令を形成する
ためには、クエリ言語は組み合わせの手段を提供します。クエリ言語を論理プログラミング言語と
成す物の1つに組み合わせの手段が論理式を形成するのに用いられる組み合わせの手段に酷似することが
あげられます。\code{and}, \code{or}, \code{not}です。(ここでは\code{and}, \code{or}, \code{not}は
Lispのプリミティブではありません。クエリ言語の組込命令です。)

\noindent
\code{and}を以下の様に用いて全てのコンピュータプログラマの住所を見つけることができます。

\begin{scheme}
(and (job ?person (computer programmer))
     (address ?person ?where))
\end{scheme}

\noindent
結果の出力は以下の通りです。

\begin{scheme}
(and (job (Hacker Alyssa P) (computer programmer))
     (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))
(and (job (Fect Cy D) (computer programmer))
     (address (Fect Cy D) (Cambridge (Ames Street) 3)))
\end{scheme}

\noindent
一般的に、

\begin{scheme}
(and ~\( \dark \langle \)~~\( \dark query_1 \)~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark query_2 \)~~\( \dark \rangle \)~ ~\( \dots \)~ ~\( \dark \langle \)~~\( \dark query_n \)~~\( \dark \rangle \)~)
\end{scheme}

\noindent
上の式はパターン変数に対する全ての値の集合が同時に
\( \langle \)\( query_1 \)\( \rangle \) \( \dots \) \( \langle \)\( query_n \)\( \rangle \)を満す時に
満たされます。

\noindent
簡単にクエリに関しては、システムはクエリを満たすパターン変数への全ての割り当てを見つける
ことにより複合クエリを処理します。そしてそれらの値によるクエリのインスタンスを
表示します。

\noindent
複合クエリを構築する別の手段として\code{or}を通す方法があります。例えば、

\begin{scheme}
(or (supervisor ?x (Bitdiddle Ben))
    (supervisor ?x (Hacker Alyssa P)))
\end{scheme}

\noindent
上の式はBen Bitdiddle、またはAlyssa P.  Hackerに監督される従業員全てを見つけます。

\begin{scheme}
(or (supervisor (Hacker Alyssa P) (Bitdiddle Ben))
    (supervisor (Hacker Alyssa P) (Hacker Alyssa P)))
(or (supervisor (Fect Cy D) (Bitdiddle Ben))
    (supervisor (Fect Cy D) (Hacker Alyssa P)))
(or (supervisor (Tweakit Lem E) (Bitdiddle Ben))
    (supervisor (Tweakit Lem E) (Hacker Alyssa P)))
(or (supervisor (Reasoner Louis) (Bitdiddle Ben))
    (supervisor (Reasoner Louis) (Hacker Alyssa P)))
\end{scheme}

\noindent
一般的に、

\begin{scheme}
(or ~\( \dark \langle \)~~\( \dark query_1 \)~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark query_2 \)~~\( \dark \rangle \)~ ~\( \dots \)~ ~\( \dark \langle \)~~\( \dark query_n \)~~\( \dark \rangle \)~)
\end{scheme}

\noindent
上の式はパターン変数に対する全ての値の集合が、
\( \langle \)\( query_1 \)\( \rangle \) \( \dots \) \( \langle \)\( query_n \)\( \rangle \)の内、少くとも1つを
満たす場合に満たされます。

\noindent
複合クエリはまた\code{not}を用いても形成できます。例えば、

\begin{scheme}
(and (supervisor ?x (Bitdiddle Ben))
     (not (job ?x (computer programmer))))
\end{scheme}

\noindent
上の式はBen Bitdiddleに監督されるが、コンピュータプログラマではない全ての人を見つけます。
一般的に、

\begin{scheme}
(not ~\( \dark \langle \)~~\( \dark query_1 \)~~\( \dark \rangle \)~)
\end{scheme}

\noindent
上の式はパターン変数に対する全ての割り当てが\( \langle \)\( query_1 \)\( \rangle \)を
満たさない場合に満たされます。\footnote{実際にはこの\code{not}の説明は簡単な場合に対してのみ有効です。
本当の\code{not}の振舞はより複雑です。\code{not}の奇妙な点については節\link{Section 4.4.2}と
\link{Section 4.4.3}にて調査します。}

最後の組み合わせ形式は\code{lisp\-/value}と呼ばれます。lisp-value
がパターンの最初の要素の時、
次の要素は(インスタンス化された)残りの要素を引数として適用されるLispの述語であることを意味します。
一般的に、

\begin{scheme}
(lisp-value ~\( \dark \langle \)~~\var{\dark predicate}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\( \dark arg_1 \)~~\( \dark \rangle \)~ ~\( \dots \)~ ~\( \dark \langle \)~~\( \dark arg_n \)~~\( \dark \rangle \)~)
\end{scheme}

\noindent
上の式は\( \langle \)\var{predicate}\( \rangle \)がパターン変数に対してインスタンス化された
\( \langle \)\( arg_1 \)\( \rangle \) \( \dots \) \( \langle \)\( arg_n \)\( \rangle \)に適用された
時の値がtrueになる場合の割り当てにより満たされます。

\begin{scheme}
(and (salary ?person ?amount) (lisp-value > ?amount 30000))
\end{scheme}


\begin{quote}
\heading{\phantomsection\label{Exercise 4.56}Exercise 4.56:}
以下の情報を取得する複合クエリを定式化せよ。

\begin{enumerate}[a]

\item
Ben Bitdiddleに監督される全ての人の名前と住所を共に

\item
Ben Bitdiddleよりも給料(salary)が安い全ての人をその給料とBen Bitdiddleの給料と共に

\item
コンピュータ部門ではない人に監督されている全ての人をその上司の名前と職種と共に

\end{enumerate}
\end{quote}

\subsubsection*{ルール}


プリミティブなクエリと複合クエリに加えて、クエリ言語はクエリを抽象化する手段を
提供します。これらは\newterm{rules}(\jnewterm{ルール})により提供されます。
以下のルールは、

\begin{scheme}
(rule (lives-near ?person-1 ?person-2)
      (and (address ?person-1 (?town . ?rest-1))
           (address ?person-2 (?town . ?rest-2))
           (not (same ?person-1 ?person-2))))
\end{scheme}

\noindent
二人の人が同じ街に住んでいるのなら、お互いに近くに住んでいると指定しています。
最後の\code{not}節はこのルールが全ての人がその人自身の近くに住んでいると言うことを
防ぎます。\code{same}リレーションはとても簡単なルールにより定義されます。\footnote{2つの
物が同じであるようにするためには\code{same}は必要ではないことに注意して下さい。
単に同じパターン変数をそれぞれに使用するだけです。実際に、最初から2つの物でなく
1つの物しか持ちません。例として\code{lives\-/near}ルールの\code{?town}や下記の\code{wheel}ルールの
\code{?middle\-/manager}を参照して下さい。\code{same}は2つの物が異なることを強制する場合に
便利です。例えば\code{lives\-/near}ルールの\code{?person\-/1}と\code{?person\-/2}です。
同じパターン変数をクエリの2つの部分に使うことは両方の場所に同じ値が現れることを
強制しますが、異なるパターン変数を用いることは異なる値が現れることを強制しません。
(異なるパターン変数に割り当てられた値は同じにも違う値にも成り得ます。)}

\begin{scheme}
(rule (same ?x ?x))
\end{scheme}

\noindent
以下のルールはある人が監督する人が同様に監督者である場合に組織内での``wheel''(重要人物)であると
宣言します。

\begin{scheme}
(rule (wheel ?person)
      (and (supervisor ?middle-manager ?person)
           (supervisor ?x ?middle-manager)))
\end{scheme}

\noindent
ルールの一般的な形式は以下となります。

\begin{scheme}
(rule ~\( \dark \langle \)~~\var{\dark conclusion}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark body}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
\( \langle \)\var{conclusion}\( \rangle \)がパターンであり\( \langle \)\var{body}\( \rangle \)が
任意のクエリです。\footnote{私達はsameの様にボディの無いルールも認めます。また
そのようなルールは、ルールの結論(conclusion)が任意の変数の値により満たされたことを意味する
と解釈します。}ルールは大きな(例え無限でも)アサーションの集合を表現するものとして考えることができます。
即ち、ルールのボディを満たす変数の割り当てを用いたルールの結果の全てのインスタンスです。
簡単なクエリ(パターン)を説明した時、変数への割り当ては、インスタンス化されたパターンがデータベース内に
存在する場合にパターンが満たされると説明しました。しかし、パターンは明示的にアサーションとして
データベース内に存在する必要はありません。ルールにより暗示される暗黙的なアサーションに成り得ます。
例えば、以下のクエリは、

\begin{scheme}
(lives-near ?x (Bitdiddle Ben))
\end{scheme}

\noindent
次の結果を生みます。

\begin{scheme}
(lives-near (Reasoner Louis) (Bitdiddle Ben))
(lives-near (Aull DeWitt) (Bitdiddle Ben))
\end{scheme}

\noindent
Ben Bitdiddleの近くに住む全てのコンピュータプログラマを見つけるためには、
以下のように質問することができます。

\begin{scheme}
(and (job ?x (computer programmer))
     (lives-near ?x (Bitdiddle Ben)))
\end{scheme}

\noindent
複合手続の場合と同様に、ルールは他のルールの一部分として(上記の\code{lives\-/near}ルールで
見たように)使用可能です。または再帰的に定義することさえもできます。例として、
以下のルールは、

\begin{scheme}
(rule (outranked-by ?staff-person ?boss)
      (or (supervisor ?staff-person ?boss)
          (and (supervisor ?staff-person ?middle-manager)
               (outranked-by ?middle-manager ?boss))))
\end{scheme}

\noindent
もしボスがスタッフの上司であるか、(再帰的に)スタッフの上司よりボスが上役(outranked)であるならば
ボスはスタッフより地位が上であると言えます。

\begin{quote}
\heading{\phantomsection\label{Exercise 4.57}Exercise 4.57:}
人(person)その1が人その2を置き換えられるとは人その1が人その2と同じ仕事をしているか、
または第三者(someone)が人その1と同じ仕事をしつつ、かつ人その2の仕事も行え、そして
人その1と人その2が異なる人である場合であると述べるルールを定義せよ。
そのルールを用いて以下の条件を見つけるクエリを与えよ。

\begin{enumerate}[a]

\item
Cy D. Fectを置き換えられる全ての人

\item
自分より給料の高い誰かを置き換えられる全ての人を二人の給料と一緒に。

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.58}Exercise 4.58:}
ある人が自分が働いている同じ部署に上司(監督者)がいない場合にその人を``big shot''(有力者)である
と述べるルールを定義せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.59}Exercise 4.59:}
Ben Bitdiddleはある会議を何度も欠席してしまった。彼の会議を忘れる癖は仕事を失う
恐れがある。Benは何かしなければならないと決心した。彼は会社の週次ミーティング全てを
Microshaftデータベースに以下のアサーションとして加えた。

\begin{scheme}
(meeting accounting (Monday 9am))
(meeting administration (Monday 10am))
(meeting computer (Wednesday 3pm))
(meeting administration (Friday 1pm))
\end{scheme}

各アサーションは部門の全体ミーティングのためのものだ。Benはまた全ての部門に渡る
全社会議のエントリを追加した。会社の全従業員がこの会議に参加する。

\begin{scheme}
(meeting whole-company (Wednesday 4pm))
\end{scheme}

\begin{enumerate}[a]

\item
金曜の朝に、Benはその日の全ての会議をデータベースからクエリしたいと思った。
彼のクエリはどのような物になるか?

\item
Alyssa P. Hackerは感心しなかった。彼女は自分の名前を指定することで彼女の会議を
尋ねることができればより便利になるだろうと考えた。そのため彼女はある人の会議は
全ての\code{whole\-/company}(全社)会議に加えてその人の部門会議を全て含むと言うルールを
設計した。Alyssaのルールのボディを埋めよ。

\begin{scheme}
(rule (meeting-time ?person ?day-and-time)
      ~\( \dark \langle \)~~\var{\dark rule-body}~~\( \dark \rangle \)~)
\end{scheme}

\item
Alyssaは水曜の朝に仕事場に到着し、その日に何の会議があるかについて考えた。
上記のルールを定義した上で、彼女のがこのことを見つけるためにはどのようなクエリを
行うべきか?

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.60}Exercise 4.60:}
以下のクエリを与えることにより、

\begin{scheme}
(lives-near ?person (Hacker Alyssa P))
\end{scheme}

Alyssa P. Hackerは仕事場に相乗りできる、彼女の近所に住む人を見つけることができる。
一方で、お互いが近所に住んでいる全ての人々のペアを見つけたい場合には以下のクエリを
用いる。

\begin{scheme}
(lives-near ?person-1 ?person-2)
\end{scheme}

\noindent
彼女はお互いに近所に住んでいる人々の各ペアが二度づつ挙げられていることに気付いた。
例えば、

\begin{scheme}
(lives-near (Hacker Alyssa P) (Fect Cy D))
(lives-near (Fect Cy D) (Hacker Alyssa P))
\end{scheme}

なぜこれが起こるのか?  お互いに近くに住んでいる人々のリストを各ペアが一度しか現れないように
見つける方法は存在するか? 説明せよ。
\end{quote}

\subsubsection*{プログラムとしての論理}


ルールを論理的意味合いの一種であると見做すことができます。\emph{もし}パターン変数に
対する値の割り当てがボディを満たす場合、\emph{それならば}結論を満たします。必然的に、
クエリ言語はルールを基にした\newterm{logical deductions}(\jnewterm{論理的推理})を実行する能力を
有すると見做すことができます。例として、\link{Section 4.4}の始めに説明した\code{append}命令について
考えてみましょう。既に述べたように、\code{append}は以下の2つのルールにて特徴づけられます。

\begin{itemize}

\item
任意のリスト\code{y}に対し、空リストと\code{y}の\code{append}は\code{y}を形成する。

\item
任意の\code{u}, \code{v}, \code{y}, \code{z}に対し、\code{(cons u v)}と\code{y}の\code{append}は
もし\code{v}と\code{y}\code{append}が\code{z}を形成する場合、\code{(cons u z)}を形成する。

\end{itemize}

\noindent
これを私達のクエリ言語で表現するために、以下の関係に対する2つのルールを定義します。

\begin{scheme}
(append-to-form x y z)
\end{scheme}

\noindent
上の関係は``\code{x}と\code{y}の\code{append}は\code{z}を形成する''ことを意味すると解釈できます。

\begin{scheme}
(rule (append-to-form () ?y ?y))
(rule (append-to-form (?u . ?v) ?y (?u . ?z))
      (append-to-form ?v ?y ?z))
\end{scheme}

\noindent
最初のルールにはボディがありません。これは結果部分が\code{?y}の任意の値を保持することを
意味します。2つ目のルールがどのようにドット付き末尾記述をリストの\code{car}と\code{cdr}に
名前を付けるために使用しているかについて注意して下さい。


これら2つのルールを与えられることで、2つのリストに対する\code{append}を求めるクエリを
定式化することができます。

\begin{scheme}
~\textit{;;; Query input:}~
(append-to-form (a b) (c d) ?z)
~\textit{;;; Query results:}~
(append-to-form (a b) (c d) (a b c d))
\end{scheme}

\noindent
より印象的なのは、同じルールを``\code{(a b)}に対し\code{append}したら\code{(a b c d)}になるリストは何''
という質問に使用できることです。これは以下のように行われます。

\begin{scheme}
~\textit{;;; Query input:}~
(append-to-form (a b) ?y (a b c d))
~\textit{;;; Query results:}~
(append-to-form (a b) (c d) (a b c d))
\end{scheme}

\noindent
\code{append}すると\code{(a b c d)}を形成する全てのリストのペアを尋ねることも可能です。

\begin{scheme}
~\textit{;;; Query input:}~
(append-to-form ?x ?y (a b c d))
~\textit{;;; Query results:}~
(append-to-form () (a b c d) (a b c d))
(append-to-form (a) (b c d) (a b c d))
(append-to-form (a b) (c d) (a b c d))
(append-to-form (a b c) (d) (a b c d))
(append-to-form (a b c d) () (a b c d))
\end{scheme}

\noindent
上記のクエリに対する答を推論するルールを用いることにておいて、クエリシステムは
かなりの知性を示すように見えるかもしれません。実際には次の節で学ぶように、
システムはルールをときほぐす明確なアルゴリズムに従っているに過ぎません。
残念ながら、システムが\code{append}の場合では見事な程うまく行きますが、
一般的な手法はより複雑な場合に分解されるかもしれません。このことは\link{Section 4.4.3}で学びます。

\begin{quote}
\heading{\phantomsection\label{Exercise 4.61}Exercise 4.61:}
以下のルールはリストの直前の要素を見つける関係\code{next\-/to}を実装する。

\begin{scheme}
(rule (?x next-to ?y in (?x ?y . ?u)))
(rule (?x next-to ?y in (?v . ?z))
      (?x next-to ?y in ?z))
\end{scheme}


以下のクエリの結果を答えよ。

\begin{scheme}
(?x next-to ?y in (1 (2 3) 4))
(?x next-to  1 in (2 1 3 1))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.62}Exercise 4.62:}
\link{Exercise 2.17}の\code{last\-/pair}命令を実装するルールを定義せよ。
これは空ではないリストの最後の要素を含むリストを返す。あなたのルールを
\code{(last\-/pair (3) ?x)}, \code{(last\-/pair (1 2 3) ?x)}, \code{(last\-/pair (2 ?x) (3))}のような
クエリにて確認せよ。あなたのルールは\code{(last\-/pair ?x (3))}の様なクエリに対し
正しく動作するだろうか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.63}Exercise 4.63:}
以下のデータベース(創世記第4章を参照せよ)はAdaの子孫の家系をCainを経由してAdamまで
戻りながら辿っている。

\begin{scheme}
(son Adam Cain)
(son Cain Enoch)
(son Enoch Irad)
(son Irad Mehujael)
(son Mehujael Methushael)
(son Methushael Lamech)
(wife Lamech Ada)
(son Ada Jabal)
(son Ada Jubal)
\end{scheme}

``もし\( S \)が\( f \)の息子であり、かつ、\( f \)が\( G \)の息子ならば、\( S \)は\( G \)
の孫である''と``もし\( W \)が\( M \)の妻であり、かつ、\( S \)が\( W \)の息子ならば、\( S \)は
\( M \)の息子である''(これは恐らく今日より聖書の時代にはより正確であっただろう)のルールを
定式化せよ。これらはクエリシステムに対しCainの孫、Lamechの息子、Methushaelの孫を見つけることを可能にする。
(より複雑な関係を推論するいくつかのルールについては\link{Exercise 4.69}を参照せよ。)

\end{quote}

\subsection{クエリシステムの働き方}
\label{Sec. 4.4.2}
\label{Section 4.4.2}

\link{Section 4.4.4}ではクエリインタプリタを手続の集合として紹介します。この節では低レベルの
実装上の詳細からは独立したシステムの一般的な構造について説明する概観を与えます。
インタプリタの実装を説明した後に、私達はインタプリタのいくつかの限界と記号論理学の演算とは異なる
クエリ言語の論理演算のいくつかの微妙な行い方を理解できる位置に辿り着きます。

クエリ評価機がクエリをデータベース内の事実とルールに対してマッチさせるために
ある種の探索を実行せねばならないことは明らかでしょう。これを行う1つの方法はクエリシステムを
\link{Section 4.3}の\code{amb}評価機を用いて非決定性プログラムとして実装することになります(\link{Exercise 4.78}参照)。
別の可能性にはストリームの助けを用いて探索を管理する方法があります。私達の実装は
この2つ目のアプローチに従います。

クエリシステムは2つの中心となる演算、\newterm{pattern matching}(\jnewterm{パターンマッチング})と
\newterm{unification}(\jnewterm{ユニフィケーション}、単一化)の周りに体系化されます。
最初にパターンマッチングについて記述し、この演算がフレームのストリームを用いた情報体系と
共にどのように単純クエリと複合クエリの両方を実装可能にするのか説明します。
次に私達はユニフィケーション、つまりルールを実装ために必要なパターンマッチングの
一般化について議論します。最後に、
\link{Section 4.1}で説明されたインタプリタのために\code{eval}が式を分類する方法と同様の方法で、
式を分類する手続を通してクエリインタプリタ全体がどのように組み合わされるかについて示します。

\subsubsection*{パターンマッチング}

\newterm{pattern matcher}(\jnewterm{パターンマッチャ})はあるデータが指定されたパターンに適合するかどうかを
試すプログラムです。例えばデータリスト\code{((a b) c (a b))}はパターン\code{(?x c ?x)}に対し
パターン変数\code{?x}が\code{(a b)}に束縛されることで適合します。
同じデータリストがパターン\code{(?x ?y ?z)}に対し\code{?x}と\code{?z}の両者が\code{(a b)}に束縛され、
\code{?y}が\code{c}に束縛されることで適合します。これはまたパターン\code{((?x ?y) c (?x ?y))}に
対しても\code{?x}が\code{a}に、\code{?y}が\code{b}に束縛されることで適合します。
しかし、これはパターン\code{(?x a ?y)}には適合しません。このパターンが2つ目の要素がシンボル\code{a}で
あるリストを指定しているためです。

パターンマッチャはクエリシステムにより使用されます。クエリシステムは入力として
パターン、データ、\newterm{frame}(\jnewterm{フレーム})を取ります。フレームはさまざまな
パターン変数に対する束縛を指定します。パターンマッチャはデータがフレームに既に
存在する束縛と一致する状態でパターンに適合するかどうかをチェックします。
もしそうであれば、その適合により決定された任意の束縛を増やしたフレームを返します。
そうでなければ、適合が失敗したことを示します。

例えば、パターン\code{(?x ?y ?x)}を用いて\code{(a b a)}に空のフレームを与えられた
場合に適合を行うと\code{?x}が\code{a}に、\code{?y}が\code{b}に束縛されることを指定する
フレームを返します。同じパターン、同じデータで\code{?y}が\code{a}に束縛されている
と指定するフレームを用いて適合を行うと失敗します。同じパターン、同じデータで
\code{?y}が\code{b}に束縛され\code{?x}が未束縛であるフレームを用いて適合を行えば
与えられたフレームに\code{?x}の\code{a}への束縛を増やした物が返されます。

パターンマッチャはルールを含まない単純なクエリを処理するのに必要な仕組みの全てです。
例えば、以下のクエリを処理する場合、

\begin{scheme}
(job ?x (computer programmer))
\end{scheme}

\noindent
データベース内の全てのアサーションを探索し、最初は空のフレームを考慮してパターンに
適合する物を選択します。探索を行った各適合に対して、適合により返されたフレームを
用いてパターンを\code{?x}の値と共にインスタンス化します。

\subsubsection*{フレームのストリーム}

フレームに対してパターンのテストを行うことはストリームの使用を通して体系化されています。
単一のフレームを与えられて、マッチング処理はデータベースのエントリを1つづつ通して実行します。
各データベースエントリに対して、マッチャは適合が失敗したことを示す特別なシンボルか、
フレームに対する拡張を生成します。全てのデータベースエントリに対する結果はストリーム内に
集められ、フィルタを通すことで失敗が取り除かれます。結果は与えられた
フレームを適合を通すことでデータベース内のあるアサーションに拡張した全てのフレームの
ストリームです。\footnote{マッチングは一般的にとても重いので、完全なマッチャをデータベース
の全ての要素に対して適用することは防ぎたいと考えます。これは通常は高速で粗い適合と
最終適合の部品に分解することで準備します。粗い適合はデータベースをフィルタし、最終適合の
ための候補の小さな集合を生成します。手間をかけて、粗い適合のいくつかの成果がデータベースが
候補を選択したい時ではなく、構築された時に行えるようにデータベースを事前に
準備することができます。データベースの索引の仕組みの周りには莫大な技術が構築されています。
私達の実装は\link{Section 4.4.4}で説明されているように、そのような最適化のあまり賢くはない形態を
含んでいます。}

私達のシステムでは\link{Figure 4.4}で示されるように、クエリはフレームの入力ストリームを取り、
ストリーム内の各フレームに対して上記のマッチング処理を実行します。
言い替えれば、入力ストリーム内の各フレームに対して、クエリはデータベース内のアサーションに対する
適合による、全てのフレームの拡張から成る新しいストリームを生成します。
これらのストリームの全ては次に組み合わされて1つの大きなストリームを形成します。
これは入力ストリーム内の各フレームの全ての可能な拡張を含んでいます。
このストリームがクエリの出力です。

単純なクエリに答えるためにはクエリを単一の空フレームから成る入力ストリームと共に
用います。結果としての出力ストリームは空にフレームに対する全ての拡張を含んでいます(言い換えれば、
クエリに対する全ての答を含みます)。このフレームのストリームは次に、元々のクエリのパターンと
各フレーム内の値でインスタンス化された変数のコピーのストリームを生成するのに利用されます。
そしてこれが最終的に表示されるストリームです。

\begin{figure}[tb]
\phantomsection\label{Figure 4.4}
\centering
\begin{comment}
\heading{Figure 4.4:} A query processes a stream of frames.

\begin{example}
                                  output stream
  input stream   +-------------+  of frames,
  of frames      |    query    |  filtered and extended
---------------->|             +------------------------->
                 | (job ?x ?y) |
                 +-------------+
                        ^
                        |
               stream of assertions
                  from data base
\end{example}
\end{comment}
\includegraphics[width=102mm]{fig/chap4/Fig4.4.pdf}
\par\bigskip
\noindent
\heading{Figure 4.4:} フレームのストリームを処理するクエリ
\end{figure}

\subsubsection*{複合クエリ}


フレームのストリーム実装の真に優雅な点は複合クエリを扱う時に明白になります。
複合クエリの処理は適合の結果が指定されたフレームに一致するという私達の
マッチャが要求する能力を利用します。例えば、2つのクエリの\code{and}を取り扱う
以下のようなクエリでは

\begin{scheme}
(and (can-do-job ?x (computer programmer trainee))
     (job ?person ?x))
\end{scheme}

\noindent
(簡単に言えば、``コンピュータプログラマ見習いの職を行える全ての人を見つけろ'')
まず以下のパターンに適合する全てのエントリを見つけます。

\begin{scheme}
(can-do-job ?x (computer programmer trainee))
\end{scheme}

\noindent
これはフレームのストリームを生成します。各フレームは\code{?x}に対する束縛を含んでいます。
次にストリーム内の各フレームに対し、与えられた\code{?x}に対する束縛に一致する様に、
以下のパターンに適合する全てのエントリを探します。

\begin{scheme}
(job ?person ?x)
\end{scheme}

\noindent
そのような適合のそれぞれは\code{?x}と\code{?person}に対する束縛を含むフレームを生成します。
2つのクエリの\code{and}は\link{Figure 4.5}に示されるように、一連の2つのクエリのコンポーネントの
組み合わせであると見做すことができます。最初のクエリフィルタを通過するフレームは
フィルタをかけられ、2つ目のクエリにてさらに拡張されます。

\begin{figure}[tb]
\phantomsection\label{Figure 4.5}
\centering
\begin{comment}
\heading{Figure 4.5:} The \code{and} combination of two queries is produced 
by operating on the stream of frames in series.

\begin{example}
                +----------------------+
                |       (and A B)      |
  input stream  |                      |  output stream
  of frames     |   +---+       +---+  |  of frames
------------------->| A +------>| B +-------------------->
                |   +---+       +---+  |
                |     ^           ^    |
                |     |           |    |
                |     +-----*-----+    |
                +-----------|----------+
                            |
                        data base
\end{example}
\end{comment}
\includegraphics[width=93mm]{fig/chap4/Fig4.5.pdf}
\begin{quote}
\heading{Figure 4.5:} 2つのクエリの\code{and}の組合せはフレームのストリーム上での連続した操作により生成される
\end{quote}
\end{figure}

\begin{figure}[tb]
\phantomsection\label{Figure 4.6}
\centering
\begin{comment}
\heading{Figure 4.6:} The \code{or} combination of two queries is produced 
by operating on the stream of frames in parallel and merging the results.

\begin{example}
           +---------------------------+
           |          (or A B)         |
           |    +---+                  |
input      | +->| A |------------+     |  output
stream of  | |  +---+            V     |  stream of
frames     | |    ^          +-------+ |  frames
-------------*    |          | merge +--------------->
           | |    |          +-------+ |
           | |    |              ^     |
           | |    |   +---+      |     |
           | +------->| B +------+     |
           |      |   +---+            |
           |      |     ^              |
           |      |     |              |
           |      +--*--+              |
           +---------|-----------------+
                     |
                 data base
\end{example}
\end{comment}
\includegraphics[width=107mm]{fig/chap4/Fig4.6.pdf}
\begin{quote}
\heading{Figure 4.6:} 2つのクエリのcode{or}の組合せはフレームのストリームを並列に操作しその結果をマージする
ことで生成される
\end{quote}
\end{figure}

\noindent
\link{Figure 4.6}は2つのクエリの\code{or}を2つのクエリコンポーネント
の並列な組み合わせとして求めるための類似の手法を示しています。
フレームの入力ストリームは各クエリにより別々に拡張されます。2つの結果ストリームは
次にマージされ最終の出力ストリームを生成します。

この高いレベルの記述からでも複合クエリの処理が遅くなることがはっきりとわかります。
例えば、クエリは各入力フレームに対して複数の出力ストリームを生成するかもしれません。
そして各クエリも同様です。最悪の場合にはクエリ数の指数関数となる多数のマッチングを
実行しなければなりません(\link{Exercise 4.76}参照)。\footnote{しかし、この種の
指数関数爆発は\code{and}クエリでは一般的ではありません。追加された条件が生成されるフレームの
数を増やすのでなく、減らす傾向があるためです。}単純なクエリのみを扱うシステムのほうが
とても実用的ではありますが、複合クエリを扱うことは極めて難しいのです。\footnote{複合
クエリをどのように効果的に扱うかに関連するデータベース管理システムの多数の文献が
存在します。}

フレームのストリームの視点から、あるクエリの\code{not}はクエリが満たされる
全てのフレームを取り除くフィルタとして働きます。例えば、以下のパターンを与えらえると、

\begin{scheme}
(not (job ?x (computer programmer)))
\end{scheme}

\noindent
入力ストリームの各フレームに対して\code{(job ?x (computer programmer))}を満たす
拡張フレームの生成を試みます。入力ストリームからそのような拡張が存在する
全てのフレームを削除します。結果はフレーム中の\code{?x}の束縛が
\code{(job ?x (computer programmer))}を満たさないフレームのみから成るストリームと
なります。例えば以下のクエリの処理においては、

\begin{scheme}
(and (supervisor ?x ?y)
     (not (job ?x (computer programmer))))
\end{scheme}

\noindent
最初の節は\code{?x}と\code{?y}に対する束縛を持つフレームを生成します。次に
\code{not}節はこれらから\code{?x}に対する束縛が\code{?x}がコンピュータプログラマである
という制約を満たす全てのフレームを削除することでフィルタリングします。\footnote{この
\code{not}のフィルタ実装と、記号論理学における通常の意味での\code{not}の間には
微妙な違いが存在します。\link{Section 4.4.3}を参照して下さい。}


\code{lisp\-/value}特殊形式はフレームのストリーム上の同様なフィルタとして実装されます。
ストリーム内の各フレームをパターン内の任意の変数をインスタンス化するために用い、
そしてLisp手続を適用します。入力ストリームから述語が失敗する全てのフレームを削除します。

\subsubsection*{ユニフィケーション}


クエリ言語内のルールを扱うために、ルールの結果が与えられたクエリパターンに適合する
ルールを見付けられねばなりません。ルールの結果はアサーションに似ていますが、変数を
含められる所が異なります。そのためパターンマッチングの
一般化---\newterm{unification}(\jnewterm{ユニフィケーション})と呼ばれます---を必要とし、
その中で``パターン''と``データ''の両方が変数を持ち得ます。

ユニファイアは2つの定数と変数を含むパターンを取り、2つのパターンを等しくする
変数への値の割り当てが可能であるかどうかを決定します。もしそうであれば、
これらの束縛を含むフレームを返します。例えば\code{(?x a ?y)}と\code{(?y ?z a)}の
ユニフィケーションは\code{?x}, \code{?y}, \code{?z}が全て\code{a}に束縛されなければならない
フレームを指示します。一方で、\code{(?x ?y a)}と\code{(?x b ?y)}のユニフィケーションは
失敗します。2つのパターンを等しくできる\code{?y}の値が存在しないためです。(両方のパターンの
2つ目の要素が等しくなるためには\code{?y}は\code{b}にならなければなりません。
しかし、3番目の要素が等しくなるためには\code{?y}が\code{a}になるしかありません)。
クエリシステムで用いられるユニファイアはパターンマッチャの様に、フレームを入力として取り
このフレームと一致するユニフィケーションを実行します。

ユニフィケーションアルゴリズムはクエリシステムで最も技術的に難しい部分です。
複雑なパターンを共なうため、ユニフィケーションの実行は演繹を必要とするように見えるかもしれません。
例えば、\code{(?x ?x)}と\code{((a ?y c) (a b ?z))}をユニフィケーションするためには
アルゴリズムは\code{?x}は\code{(a b c)}に、\code{?y}は\code{b}に、\code{?z}は\code{c}にならなければ
いけないことを推論しなければなりません。この処理はパターンコンポーネント間の
等式の集合を解くこととして考えることができます。一般的には、これらは連立方程式であり、
これを解くためには大量の操作が必要となるでしょう。\footnote{一方向のパターンマッチングでは、
全てのパターン変数を含む等式は明白で未知数(パターン変数)について既に解かれています。}
例えば、\code{(?x ?x)}と\code{((a ?y c) (a b ?z))}のユニフィケーションは以下の連立方程式を
指定することだと考えられるでしょう。

\begin{scheme}
?x  =  (a ?y c)
?x  =  (a b ?z)
\end{scheme}

\noindent
これらの方程式は以下を暗示します。

\begin{scheme}
(a ?y c)  =  (a b ?z)
\end{scheme}

\noindent
これは順に次を暗示します。

\begin{scheme}
 a  =  a, 
?y  =  b, 
 c  =  ?z,
\end{scheme}

\noindent
従って以下の通りです。

\begin{scheme}
?x  =  (a b c)
\end{scheme}

\noindent
パターンマッチが成功する場合、全てのパターン変数は束縛され、それらに束縛される
値は定数のみを持ちます。これはまたここまで見てきた全てのユニフィケーションの例に
対しても真です。しかし一般的に、ユニフィケーションが成功する場合には変数の値が
完全には決定されるとは限りません。いくつかの変数は未束縛のままで、他は変数を
含む値に束縛されます。

\code{(?x a)}と\code{((b ?y) ?z)}のユニフィケーションについて考えます。
\code{?x = (b ?y)}であり\code{a = ?z}であると推論できます。しかしそれ以上\code{?x}と\code{?y}に
ついて解くことはできません。このユニフィケーションは失敗はしません。確かに
2つのパターンを\code{?x}と\code{?y}に値を割り当てることで等しくすることは可能なためです。
この適合が\code{?y}の取り得る値を全く限定しないため、結果フレームに\code{?y}の束縛は
全く入りません。しかしこの適合は\code{?x}の値は限定します。\code{?y}がどのような値を
取っても、\code{?x}は必ず\code{(b ?y)}になります。従って\code{?x}の\code{(b ?y)}への束縛は
フレームへ入れられます。もし\code{?y}の値が(パターンマッチ、またはこのフレームに
一致する必要のあるユニフィケーションにより)後に決定されフレームに追加されたなら、
その前に束縛された\code{?x}はこの値を参照することになります。\footnote{ユニフィケーションについて
考えるもう1つの方法は、二つの入力パターンの特殊化である最も一般的なパターンを生成するということです。
言い換えれば、\code{(?x a)}と\code{((b ?y) ?z)}のユニフィケーションは\code{((b ?y) a)}であり、
上で議論した \code{(?x a ?y)}と\code{(?y ?z a)}のユニフィケーションは\code{(a a a)}です。
私達の実装に対しては、ユニフィケーションの結果をパターンではなく、フレームとして
考えたほうがより便利です。}

\subsubsection*{ルールの適用}


ユニフィケーションはルールから推論を行わせるクエリシステムのコンポーネントに対する
鍵です。これがどのように達成されるかについて学ぶためには、ルールの適用を含むクエリの
処理について考えてみましょう。例えば、以下について考えます。

\begin{scheme}
(lives-near ?x (Hacker Alyssa P))
\end{scheme}

\noindent
このクエリを処理するためには、最初に通常の上で説明されたパターンマッチ手続を用いて
このパターンに適合するアサーションがデータベース内に存在するかどうかを見ます。(この場合には
存在しません。私達のデータベースには誰が誰の近くに住んでいるかについての直接の
アサーションが全く含まれていないためです)。次のステップはクエリパターンと各ルールの結果との
ユニフィケーションを試みることです。このパターンは以下のルールの結果とユニフィケーションする
と、

\begin{scheme}
(rule (lives-near ?person-1 ?person-2)
      (and (address ?person-1 (?town . ?rest-1))
           (address ?person-2 (?town . ?rest-2))
           (not (same ?person-1 ?person-2))))
\end{scheme}

\noindent
結果としてフレームに\code{?person\-/2}が\code{(Hacker Alyssa P)}に束縛され、
\code{?x}が(同じ値として)\code{?person\-/1}に束縛されなければならないことの指定が
入ることを発見します。これで、このフレームに関連して、このルールのボディにより
与えられた複合クエリを評価します。適合が成功すればこのフレームは\code{?person\-/1}に
対する束縛を与えることで拡張され、その結果として\code{?x}の値も決定し、元々のクエリ
パターンをインスタンス化するのに利用することができます。


一般的に、クエリ評価機は以下の手法を用いて、パターン変数に対する束縛を指定する
フレーム内のクエリパターンを定めようとする時に、ルールを適用します。

\begin{itemize}

\item
クエリをルールの結論とユニフィケーションすることで(成功すれば)元のフレームの
拡張を形成する

\item
拡張されたフレームを参照しながら、ルールのボディにより形成されたクエリを評価する

\end{itemize}

\noindent
これがどれほどLispの\code{eval}/\code{apply}評価機内での手続適用のための手法に似ているか
について注意して下さい。

\begin{itemize}

\item
手続のパラメタをその引数に束縛することで元々の手続環境を拡張するフレームを形成する

\item
拡張された環境を参照しながら、手続のボディにより形成された式を評価する

\end{itemize}

\noindent
2つの評価機の間の類似度は驚くべきことではありません手続定義がLispにおける抽象化の
手段であるように、ルール定義はクエリ言語の抽象化の手段です。それぞれの場合において、
適切な束縛を作成し、ルール、または手続のボディをこれらの束縛を参照することで
抽象化を巻き戻します。

\subsubsection*{単純なクエリ}


私達はこの節の始めにルールを欠いた単純なクエリをどのように評価するかについて学びました。
今ではルールの適用の仕方も学んだため、単純なクエリをルールとアサーションの両方を用いて
どのように評価するかについても説明することができます。


クエリパターンとフレームのストリームを与えられた時、入力ストリーム内の各フレームに対して
2つのストリームを生成します。

\begin{itemize}

\item
(パターンマッチャを用いて)データベース内の全てのアサーションに対してパターンの適合を行うことにより
得られた拡張フレームのストリーム

\item
(ユニファイアを用いて)全ての可能なルールを適用することにより得られた
拡張フレームのストリーム\footnote{ユニフィケーションはマッチングの一般化であるため、
ユニファイアを用いて両方のストリームを生成することによりシステムを簡略化することが
できました。しかし、簡単な場合を単純なマッチャで取り扱うことはマッチング(適合)が
どのように(本格的なユニフィケーションとは逆に)それ自身の正しさにおいて便利であることを
説明します。}

\end{itemize}

\noindent
これらの2つのストリームをアペンドすることにより、与えられたパターンを元のフレームに
一致して満たすことができる全ての方法により成り立つストリームを生成します。
これらのストリーム(入力ストリームの各フレームに対して1つ)はこれで全てが1つの
巨大なストリームに接続されます。従ってこの巨大ストリームは元の入力ストリーム内の
任意のフレームを与えられたパターンへの適合を生成するために拡張した全ての方法から
成り立っています。

\subsubsection*{クエリ評価機とドライバループ}

潜在的なマッチング操作の複雑さに係らず、システムは任意の言語のための評価機と
そっくりに体系化されます。マッチング操作を統合する手続は\code{qeval}と呼ばれ、
Lispの\code{eval}手続の役割と同様な役割を演じます。\code{qeval}は入力としてクエリと
フレームのストリームを取ります。その出力はフレームのストリームであり、クエリパターンへの
成功したマッチングに相応します。これは\link{Figure 4.4}で示されるよう入力ストリームの
いくつかを拡張しています。\code{eval}と同様に、\code{qeval}は異なる型の式(クエリ)を分類し、
それぞれに対する適切な手続を呼び出します。各特殊形式(\code{and}, \code{or}, \code{not}, \code{lisp\-/value})に
手続が存在し、また単純なクエリにも手続が存在します。

この章の他の評価機のための\code{driver\-/loop}手続と同様のドライバループが端末から
クエリを読み出します。各クエリに対して、ドライバループは\code{qeval}をそのクエリと
1つの空フレームと共に呼び出します。これにより全ての可能な適合(全ての可能な空フレームに
対する拡張)のストリームが生成されます。結果としてのストリームの各フレームに対して、
ドライバループは元のクエリをフレーム内で見つかった変数の値を用いてインスタンス化します。
次にこのインスタンス化されたクエリのストリームは表示されます。\footnote{私達が
フレームの(リストではなく)ストリームを使う理由は、ルールの再帰的適用は
クエリを満たす無限の数の値を生成することができるからです。ストリームに組込まれた
遅延化された評価がここでは重要です。システムは応答を1つづつそれらが生成された順に、
有限か無限の数の応答があるかに係らずに表示します。}

ドライバはまた特別なコマンド\code{assert!}をチェックします。これは入力がクエリではなく
データベースに追加するアサーション、またはルールでることを示します。例えば、

\begin{scheme}
(assert! (job (Bitdiddle Ben)
              (computer wizard)))
(assert! (rule (wheel ?person)
               (and (supervisor ?middle-manager ?person)
                    (supervisor ?x ?middle-manager))))
\end{scheme}


\subsection{論理プログラミングは記号論理学なのか?}
\label{Sec. 4.4.3}
\label{Section 4.4.3}

クエリ言語内で使用される組み合わせの手段は最初は記号論理学の\code{and}, \code{or}, \code{not}命令と
同じに見えるかもしれません。実際にクエリ言語のルールの適用は、推論という、まともな手段を通して
達成されます。\footnote{推論の特定の手段がまともであるということは自明な主張ではありません。
もし真となる前提で開始したのであれば、真となる結論のみが導き出されることを証明しな
ければなりません。ルール適用で表現された推論の手法は\newterm{modus ponens}(\jnewterm{肯定式})という
親しみある推論の手法であり、もし\( A \)が真でありかつ\emph{A implies B}(AならばB)が真である
ならば、\( B \)は真であると結論づけることができます。}
しかし、このクエリ言語の記号論理学を用いた同定は実際には有効ではありません。クエリ言語が
論理的な命題を手続的に解釈する\newterm{control structure}(\jnewterm{制御構造})を提供するためです。
私達は頻繁にこの制御構造を活用することができます。例えばプログラマの監督者全てを見るけるためには
以下の2つの論理的に等価な形式のどちらかをクエリとして策定することができます。

\begin{scheme}
(and (job ?x (computer programmer)) (supervisor ?x ?y))
\end{scheme}

\noindent
または

\begin{scheme}
(and (supervisor ?x ?y) (job ?x (computer programmer)))
\end{scheme}

\noindent
もし会社に(通常の場合として)プログラマより多くの監督者が存在するのであれば、
2つ目よりも最初の形式を用いたほうが良いです。なぜならデータベースは\code{and}の
最初の節により生成された中間結果(フレーム)全てに対して探索されねばならないためです。

論理プログラミングの目的はプログラマに演算問題を2つの分離された問題、``何''が求めらるべきかと
``どのように''これが求められるべきかに分解する技術を与えることです。
これは記号論理学の命題の部分集合を選択することで達成されます。これは人が演算したい
対象全てを記述するのに十分に強く、けれども制御可能な手続的解釈を行うに十分に弱い
物です。一方で、ここでの意図は論理プログラミング言語で指示されたプログラムは
計算機により実行され得る実効的なプログラムでなければなりません。
制御(``どのように''演算するか)は言語の評価順の使用に影響を受けます。
私達は節の順と各節の中の下位目標の順とを操作し、演算が実効的、かつ効率的であると
考えれられる順で行われるようにせねばなりません。

私達のクエリ言語は単なるそのような手続的に解釈可能な記号論理学の部分集合であると
見做すことができます。アサーションは単純な事実(アトミックな命題)を表現します。
ルールはルールのボディが持つ複数の場合に対する、ルールの結論が持つ推測の結果を表現します。
ルールは自然な手続的解釈を持ちます。ルールの結論を成立させるためには、ルールのボディを
定めます。従って、ルールは演算を提示しています。しかし、ルールはまた記号論理学の命題であるとも
見做すことができるため、同じ結果が全体的に記号論理学の中で働くことにより得られることを
主張することで、論理プログラムにより遂行された任意の``推論''を正当化することができます。\footnote{私達は
この命題を以下に同意することで制限しなければなりません。``推論''が論理プログラムにより
正当化されるに言及するにおいて、私達は演算が停止することを前提としています。
残念なことに、例えこの制限された命題もクエリ言語の私達の実装においては正しくありません。
(そして同時にPrologのプログラムにとっても、そして他のほとんどの現在の論理プログラミング
言語においてもこれは正しくありません)。原因は私達の\code{not}と\code{lisp\-/value}の使用のためです。
この先で議論するように、クエリ言語で実装された\code{not}は常に記号論理学の\code{not}と一致
しません。そして\code{lisp\-/value}は複雑さを増します。私達は
単純に\code{not}と\code{lisp\-/value}を言語から削除し、プログラムを単純なクエリ, \code{and}, \code{or}のみを用いて
書くことに同意することで、記号論理学と一致する言語を実装することができます。
しかし、これは言語の表現力を大きく制限してしまいます。論理プログラミングにおける主要な
研究課題の1つは過度に表現力を犠牲にすることなく、記号論理学とより一致する方法を
見つけることです。}

\subsubsection*{無限ループ}


論理プログラムの手続的な解釈の結果は絶望的に非効率なプログラムを一部の問題に
対して構築することが有り得ることです。極端に非効率な場合にはシステムは演繹を
行う無限ループに落ち込んでしまいます。簡単な例として、縁組のデータベースを
構築したと考えてみましょう。以下を含みます。

\begin{scheme}
(assert! (married Minnie Mickey))
\end{scheme}

\noindent
ここで以下を尋ねた場合、

\begin{scheme}
(married Mickey ?who)
\end{scheme}

\noindent
応答は有りません。なぜならシステムはもし\( A \)が\( B \)に結婚した場合、\( B \)が
\( A \)に結婚することになることを知らないためです。そのため以下のルールを
宣言します。

\begin{scheme}
(assert! (rule (married ?x ?y) (married ?y ?x)))
\end{scheme}

\noindent
そして再び質問します。

\begin{scheme}
(married Mickey ?who)
\end{scheme}

\noindent
残念ながら、これはシステムを無限ループに追いやります。以下のとおりです。

\begin{itemize}

\item
システムは\code{married}ルールが適用可能であることを見つけます。言い換えれば、
ルールの結論\code{(married ?x ?y)}は成功裏にクエリパターン\code{(married Mickey ?who)}と
単一化し、\code{?x}が\code{Mickey}に、\code{?y}が\code{?who}に束縛されるフレームを生成します。

\item
1つの答は直接データベース内のアサーションとして現れます: \code{(married
Minnie Mickey)}

\item
\code{married}ルールもまた適用可能です。そのためインタプリタは再度ルールのボディを
評価し、今回は\code{(married Mickey ?who)}に等しくなります。

\end{itemize}

\noindent
これでシステムは無限ループの中です。実際に、システムが簡単な答、\code{(married Minnie Mickey)}を
ループに入る前に見つけるかどうかは、システムがデータベース内のアイテムをチェックする順に
関連する実装上の詳細に依存します。これは起こり得るループのとても単純な種類の例です。
相互に関連するルールの蓄積は予想することがより難しいループへと導きます。そしてループの
出現は\code{and}内の節の順(\link{Exercise 4.64}参照)か、またはシステムがクエリを処理する順に
関連する低レベルの詳細に依存します。\footnote{これは論理の問題ではなく、私達のインタプリタにより
提供される手続的な解釈の問題です。ここでループに陥らないインタプリタを書くこともできました。
例えばアサーションとルールから導きだせる全ての証明を深さ優先探索でなく、幅優先探索で
列挙することもできました。しかし、そのようなシステムは私達のプログラムの中における推論の
順序を活用することがより難しくなります。そのようなプログラムの中に洗練された制御を構築する
試みが\link{deKleer et al. 1977}に説明されています。そのような
深刻な制御上の問題に導かない別のテクニックとして、特定の種類のループの検知器のような
特別な知識を組込むことがあります(\link{Exercise 4.67})。しかし、推論の実行において
無限の小道を下ることから確実にシステムを防ぐ一般的な理論体系は有りません。
``\( P(x) \)が真であることを示すためには、\( P(f(x)) \)が真であることを示せ''という様式の
悪魔のルールをいくつかの適切に選択された関数\( f \)に対して想像してみて下さい。}

\subsubsection*{\code{not}の問題}


もう1つのクエリシステムの予測できない出来事は\code{not}に関連します。\link{Section 4.4.1}の
データベースを受け取った時、以下の2つのクエリについて考えてみます。

\begin{scheme}
(and (supervisor ?x ?y)
     (not (job ?x (computer programmer))))
(and (not (job ?x (computer programmer)))
     (supervisor ?x ?y))
\end{scheme}

\noindent
これらの2つのクエリは同じ結果を生成しません。最初のクエリはデータベース中の
\code{(supervisor ?x ?y)}に適合する全てのエントリを見つけ、次に結果のフレームから
\code{?x}の値が\code{(job ?x (computer programmer))}を満たす物を削除します。
2つ目のクエリは入力フレームから\code{(job ?x (computer programmer))}を満たす物を
消すフィルタから開始します。入力フレームだけでは空であるため、データベースから
\code{(job ?x (computer programmer))}を満たするパターンが存在するか確認します。
通常はこの形式のエントリが存在するので、\code{not}節は空のフレームを取り除き、
空のフレームのストリームを返します。結果として、複合クエリ全体が空ストリームを
返します。

問題は\code{not}の私達の実装は本当に変数の値上のフィルタとしての役目を果たす
ことを意図しています。もし\code{not}節がいくつかの束縛されていない変数を持つ
フレームと処理された場合(上記の例における\code{?x}が行うように)、システムは
予想外の結果を生成します。同様の問題が\code{lisp\-/value}の使用でも起こります。
Lispの述語はその引数のいくつかが未束縛な場合働くことができません。
\link{Exercise 4.77}を参照して下さい。

クエリ言語の\code{not}が記号論理学の\code{not}と異なるずっと深刻な部分があります。
論理学では命題``not \( P \)''を\( P \)は真ではないことを意味すると解釈します。
しかし、クエリシステムでは``not \( P \)''は\( P \)がデータベース内の知識から
推論不可能であることを意味しています。例えば、\link{Section 4.4.1}の社員情報データベース
を与えられた場合、システムは幸いにも全ての種類の\code{not}命令を推論することができるでしょう。
例えばBen Bitdiddleは野球のファンではない、外で雨は振っていない、2 + 2 は4ではないなどです。\footnote{クエリ
\code{(not (baseball\-/fan (Bitdiddle Ben)))}について考えてみましょう。システムは
データベースに\code{(baseball\-/fan (Bitdiddle Ben))}が無いことを知り、そのため空フレームは
パターンを満たさず初期値のフレームのストリームから取り除かれません。クエリの結果は
従って空フレームであり、これが入力クエリのインスタンス化に用いられ、
\code{(not (baseball\-/fan (Bitdiddle Ben)))}が生成されます。}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.64}Exercise 4.64:}
Louis Reasonerは誤って\code{outranked\-/by}ルール(\link{Section 4.4.1})をデータベースから削除して
しまった。彼はこのことに気付いた時、直ぐに再インストールした。残念なことに、
彼はルールにわずかな変更を行い、以下のように入力した。

\begin{scheme}
(rule (outranked-by ?staff-person ?boss)
      (or (supervisor ?staff-person ?boss)
          (and (outranked-by ?middle-manager ?boss)
               (supervisor ?staff-person 
                           ?middle-manager))))
\end{scheme}


Louisがこの情報をシステムに入力して直ぐに、DeWitt AullがやってきてBen Bitdiddleの
上司は誰かを調べようとした。彼は以下のクエリを入力した。

\begin{scheme}
(outranked-by (Bitdiddle Ben) ?who)
\end{scheme}


回答を行った後、システムは無限ループへと陥った。何故であるか、説明せよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.65}Exercise 4.65:}
組織内での昇進の日を待ち望んでいるCy D. Fectは全ての重役を探すクエリを入力
してみた(\link{Section 4.4.1}のルール\code{wheel}を用いた)。

\begin{scheme}
(wheel ?who)
\end{scheme}


驚いたことにシステムは以下の内容を応答した。

\begin{scheme}
~\textit{;;; Query results:}~
(wheel (Warbucks Oliver))
(wheel (Bitdiddle Ben))
(wheel (Warbucks Oliver))
(wheel (Warbucks Oliver))
(wheel (Warbucks Oliver))
\end{scheme}

何故、Oliver Warbucksは4度表示されたのか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.66}Exercise 4.66:}
Benはクエリシステムを一般化し会社に関する統計を提供する。例えば、全ての
コンピュータプログラマの給料の合計を求めるためには、以下のように入力することが
できるだろう。

\begin{scheme}
(sum ?amount (and (job ?x (computer programmer))
                  (salary ?x ?amount)))
\end{scheme}


全般に、Benの新しいシステムは以下の形式の式を可能にする。

\begin{scheme}
(accumulation-function ~\( \dark \langle \)~~\var{\dark variable}~~\( \dark \rangle \)~ ~\( \dark \langle \)~~\var{\dark query pattern}~~\( \dark \rangle \)~)
\end{scheme}

\noindent
ここで\code{accumulation\-/function}は\code{sum}, \code{average}, または\code{maximum}のような物である。
Benはこれを実装するのは簡単なはずだと考えた。単純にクエリパターンを\code{qeval}に追加するだろう。
これはフレームのストリームを生成するだろう。すると彼はこのストリームをmap関数を通すことで
ストリーム内の各フレームから指定した変数の値を抽出し、結果の値のストリームをaccumulation(集積)
関数へと与えるだろう。Benが実装を完成し、丁度試験を行おうとした時にCyが依然として\link{Exercise 4.65}の
\code{wheel}クエリの結果に悩みながら歩いてきた。CyがBenにシステムの応答を見せた時、Benはうなってから
``なんてこった。私の簡単な集積の仕組みは動かない!''と述べた。


Benは何に気付いたのか? この状況を救い出すため用いられる手段の要点を述べよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.67}Exercise 4.67:}
クエリシステムにループ検知器をインストールし、テキストと\link{Exercise 4.64}で
説明されたような単純なループを防ぐための手段を工夫せよ。
一般的なアイデアは、システムに現在の推論の連鎖のある種の履歴を管理させ、既に取り組んでいる
クエリの処理を始めないようにすることである。どのような種類の情報(パターンとフレーム)が
この履歴に含まれるか、そしてどのように検査が行われるべきかについて説明せよ。(\link{Section 4.4.4}に
おけるクエリシステムの実装の詳細を学んだ後に、あなたはシステムを変更してループ検知器を
入れたいと思うだろう)。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.68}Exercise 4.68:}
\link{Exercise 2.18}の\code{reverse}命令を実装するルールを定義せよ。これは与えられたリストの
逆順で同じ要素を含むリストを返す。(ヒント：\code{append\-/to\-/form}を使用せよ)。あなたの
ルールは\code{(reverse (1 2 3) ?x)}と\code{(reverse ?x (1 2 3))}の両方に回答することができるだろうか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.69}Exercise 4.69:}
\link{Exercise 4.63}で策定したデータベースとルールから始めて、孫の関係に``great''を
追加するためのルールを工夫せよ。これはシステムに対しIradがAdamのgreat-grandson(ひ孫)である
こと、またJabalとJubalがgreat-great-great-great-great-grandsons(ひひひひひ孫)であることを
推論することを可能にしなければならない。(ヒント：例えばIradに関する事実を
\code{((great grandson) Adam Irad)}として表現する。リストの終端が単語\code{grandson}であるかを
決定するルールを書け。これを用いて\code{?rel}が\code{grandson}で終わるリストである場合に、
関係\code{((great .  ?rel) ?x ?y)}を導き出すことが可能なルールを表現せよ)。
あなたのルールを\code{((great grandson) ?g ?ggs)}と\code{(?relationship Adam Irad)}のような
クエリを用いて確認せよ。
\end{quote}

\subsection{クエリシステムの実装}
\label{Sec. 4.4.4}
\label{Section 4.4.4}


\link{Section 4.4.2}はどのようにクエリシステムが働くかについて説明した。ここでは完全なシステムの実装
を公開することにより詳細を知らせる。



\subsubsection{ドライバループとインスタンス化}
\label{Section 4.4.4.1}


クエリシステムのためのドライバループは繰り返し入力式を読み込みます。もし式が追加されるべき
ルールかアサーションであるのならばその情報が追加されます。そうでなければ式はクエリであると
見做されます。ドライバはこのクエリを評価機\code{qeval}に単一の空のフレームから成る初期フレーム
ストリームと共に渡されます。評価の結果はクエリをデータベース内で見つかった変数の値で
満たすことにより生成されたフレームのストリームです。これらのフレームは、フレームのストリームに
より提供された値を用いて変数がインスタンス化された元のクエリのコピーから
成る新しいストリームを形成するのに用いられます。そしてこの最終的なストリームが
端末に表示されます。

\begin{scheme}
(define input-prompt  ";;; Query input:")
(define output-prompt ";;; Query results:")

(define (query-driver-loop)
  (prompt-for-input input-prompt)
  (let ((q (query-syntax-process (read))))
    (cond ((assertion-to-be-added? q)
           (add-rule-or-assertion! (add-assertion-body q))
           (newline)
           (display "Assertion added to data base.")
           (query-driver-loop))
          (else
           (newline)
           (display output-prompt)
           (display-stream
            (stream-map
             (lambda (frame)
               (instantiate
                q
                frame
                (lambda (v f)
                  (contract-question-mark v))))
             (qeval q (singleton-stream '()))))
           (query-driver-loop)))))
\end{scheme}

\noindent
ここで、この章の他の評価機と同様に、クエリ言語の式に対して抽象構文を用います。
式の構文の実装は述語\code{assertion\-/to\-/be\-/added?}とセレクタ\code{add\-/assertion\-/body}を
含めて、\link{Section 4.4.4.7}にて与えられます。\code{add\-/rule\-/or\-/assertion!}は\link{Section 4.4.4.5}で
定義されます。


入力式のどんな処理を行う前にも、ドライバループは処理をより効率的にする形式へと
構文的に変換します。これはパターン変数の表現の変更を含みます。クエリが初期化される
時、未束縛である任意の変数は表示される前に入力時の表現に戻されます。これらの
変換は2つの手続、\code{query\-/syntax\-/process}と\code{contract\-/question\-/mark}により実行されます(\link{Section 4.4.4.7})。


式をインスタンス化するためにはまずコピーを行い、式中の全ての変数を与えられたフレーム内の
それらの値にて置き換えます。値はそれら自身がインスタンス化されます。それらが変数を含む
可能性があるためです(例えば、式の中の\code{?x}がユニフィケーションの結果として\code{?y}に
束縛され、\code{?y}が同様に5に束縛されている場合)。変数がインスタンス化できない場合に取るべき
行動は手続\code{instantiate}の引数に渡されます。

\begin{scheme}
(define (instantiate exp frame unbound-var-handler)
  (define (copy exp)
    (cond ((var? exp)
           (let ((binding (binding-in-frame exp frame)))
             (if binding
                 (copy (binding-value binding))
                 (unbound-var-handler exp frame))))
          ((pair? exp)
           (cons (copy (car exp)) (copy (cdr exp))))
          (else exp)))
  (copy exp))
\end{scheme}

\noindent
束縛を操作する手続は\link{Section 4.4.4.8}で定義されます。

\subsubsection{評価機}
\label{Section 4.4.4.2}


\code{query\-/driver\-/loop}により呼ばれる\code{qeval}手続はクエリシステムの基本的な評価機です。
入力としてクエリとフレームのストリームを取り、拡張されたフレームのストリームを返します。
\link{Chapter 2}で総称的な命令を実装したのと同様に、
\code{get}と\code{put}を用いたデータ適従による呼出により特殊形式を判別します。
特殊形式とは判別されない任意のクエリは単純なクエリと見做され\code{simple\-/query}により処理されます。

\begin{scheme}
(define (qeval query frame-stream)
  (let ((qproc (get (type query) 'qeval)))
    (if qproc
        (qproc (contents query) frame-stream)
        (simple-query query frame-stream))))
\end{scheme}

\noindent
\code{type}と\code{contents}は\link{Section 4.4.4.7}で定義され、特殊形式の抽象構文を実装します。

\subsubsection*{単純なクエリ}


\code{simple\-/query}手続は単純なクエリを扱います。引数として単純なクエリ(パターン)をフレームの
ストリームと共に取り、クエリのデータベースへの適合全てにより各フレームを拡張することにより
形成されたストリームを返します。

\begin{scheme}
(define (simple-query query-pattern frame-stream)
  (stream-flatmap
   (lambda (frame)
     (stream-append-delayed
      (find-assertions query-pattern frame)
      (delay (apply-rules query-pattern frame))))
   frame-stream))
\end{scheme}

\noindent
入力ストリーム中の各フレームに対し、\code{find\-/assertions}(\link{Section 4.4.4.3})を用いて
データベース内の全てのアサーションに対してパターンを適合し、拡張フレームの
ストリームを生成します。そして\code{apply\-/rules}(\link{Section 4.4.4.4})を用いて全ての
可能なルールを適用し、拡張フレームのもう1つのストリームを生成します。
これらの2つのストリームは(\code{stream\-/append\-/delayed}(\link{Section 4.4.4.6})を用いて)
接続され、与えられたパターンが元のフレームに一致して満たされることが可能な
全ての手段でストリームを作ります(\link{Exercise 4.71}参照)。個別の入力フレームに
対するストリームは\code{stream\-/flatmap} (\link{Section 4.4.4.6})を用いて接続され、
元の入力ストリーム内の任意のフレームが与えられたパターンを用いて
適合を生成するために拡張されることができる全ての手段により、1つの
巨大なストリームが形成されます。

\subsubsection*{複合クエリ}

\code{and}クエリは\link{Figure 4.5}にて説明されているように\code{conjoin}手続により
扱われます。\code{conjoin}は入力として結合(conjuncts)とフレームのストリームを
取り、拡張されたフレームのストリームを返します。最初に\code{conjoin}はフレームの
ストリームを処理し、結合内の最初のクエリを満たす全ての可能なフレームの拡張の
ストリームを探します。次に、これを新しいフレームのストリームとして用いて、
再帰的にクエリの残りに対して\code{conjoin}を適用します。

\begin{scheme}
(define (conjoin conjuncts frame-stream)
  (if (empty-conjunction? conjuncts)
      frame-stream
      (conjoin (rest-conjuncts conjuncts)
               (qeval (first-conjunct conjuncts)
                      frame-stream))))
\end{scheme}

\noindent
以下の式は

\begin{scheme}
(put 'and 'qeval conjoin)
\end{scheme}

\noindent
\code{qeval}に対し、\code{and}の型に遭遇した場合に\code{conjoin}を呼び出すように設定します。

\code{or}クエリも同様に、\link{Figure 4.6}に示されるように扱われます。
\code{or}の多様な選言肢に対する出力ストリームは別々に求められ、\link{Section 4.4.4.6}の
\code{interleave\-/delayed}手続を用いて結合されます。(\link{Exercise 4.71}と\link{Exercise 4.72}を参照)

\begin{scheme}
(define (disjoin disjuncts frame-stream)
  (if (empty-disjunction? disjuncts)
      the-empty-stream
      (interleave-delayed
       (qeval (first-disjunct disjuncts)
              frame-stream)
       (delay (disjoin (rest-disjuncts disjuncts)
                       frame-stream)))))
(put 'or 'qeval disjoin)
\end{scheme}

\noindent
論理積(conjuncts)と論理和(disjuncts)の構文のための述語とセレクタは\link{Section 4.4.4.7}で
提供されます。

\subsubsection*{フィルタ}


\code{not}は\link{Section 4.4.2}にて概説された手法により扱われます。入力ストリーム内の各フレームを
否定されたクエリを満たすように拡張することを試みます。そして拡張できない場合にのみ
出力ストリームに与えられたフレームを含めます。

\begin{scheme}
(define (negate operands frame-stream)
  (stream-flatmap
   (lambda (frame)
     (if (stream-null?
          (qeval (negated-query operands)
                 (singleton-stream frame)))
         (singleton-stream frame)
         the-empty-stream))
   frame-stream))
(put 'not 'qeval negate)
\end{scheme}

\noindent
\code{lisp\-/value}は\code{not}に似たフィルタです。ストリーム内の各フレームはパターン内の
変数をインスタンス化するために用いられ、指定された述語が適用され、述語が偽を返した
フレームは入力ストリームから取り除かれます。未束縛なパターン変数が存在する場合には
結果はエラーとなります。

\begin{scheme}
(define (lisp-value call frame-stream)
  (stream-flatmap
   (lambda (frame)
     (if (execute
          (instantiate
           call
           frame
           (lambda (v f)
             (error "Unknown pat var: LISP-VALUE"
                    v))))
         (singleton-stream frame)
         the-empty-stream))
   frame-stream))
(put 'lisp-value 'qeval lisp-value)
\end{scheme}

\noindent
\code{execute}は述語を引数に適用しますが、述語式を評価し適用する手続を得なければなりません。
しかし引数は評価してはいけません。なぜならそれらは既に実際の引数であり、その(Lispにおける)
評価が引数を生成する式ではないためです。\code{execute}が基礎を成すLispシステムの
\code{eval}と\code{apply}を使用して実装されていることに注意して下さい。

\begin{scheme}
(define (execute exp)
  (apply (eval (predicate exp)
               user-initial-environment)
         (args exp)))
\end{scheme}

\noindent
特殊形式\code{always\-/true}はクエリに対し常に満たされた状態を与えます。これはその
中身(通常は空)を無視し、単純に入力ストリームの全てのフレームを通します。
\code{always\-/true}は\code{rule\-/body}セレクタ(\link{Section 4.4.4.7})により利用され、ボディ成しで
定義されたルールに対しボディを提供します。(言い換えれば、その結果部分が常に
満たされます。)

\begin{scheme}
(define (always-true ignore frame-stream) frame-stream)
(put 'always-true 'qeval always-true)
\end{scheme}

\noindent
\code{not}と\code{lisp\-/value}の構文を定義するセレクタは\link{Section 4.4.4.7}で提供されます。

\subsubsection{パターンマッチングによりアサーションを見つける}
\label{Sec. 4.4.4.3}
\label{Section 4.4.4.3}

\code{find\-/assertions}は\code{simple\-/query} (\link{Section 4.4.4.2})により呼ばれ、
入力としてパターンとフレームを取ります。フレームのストリームを返し、各フレームは
与えられた物を与えらえたパターンへのデータベースの適合により拡張されています。
\code{fetch\-/assertions} (\link{Section 4.4.4.5})を用いてデータベース内の全てのアサーションの
ストリームを得ます。これはパターンとフレームに対して適合するか確認されなければなりません。
ここで\code{fetch\-/assertions}する理由は、私達は良く簡単なテストをここで適用するためです。
このテストは適合を成功する候補のプールからデータベース内のエントリを数多く削減することが
できます。システムは例え\code{fetch\-/assertions}を削除して単純にデータベース内の全ての
アサーションのストリームを確認するだけでも動くでしょう。しかし演算は効率的ではなくなります。
より多くのマッチャに対する呼出を行わねばならなくなるためです。

\begin{scheme}
(define (find-assertions pattern frame)
  (stream-flatmap 
    (lambda (datum) 
      (check-an-assertion datum pattern frame))
    (fetch-assertions pattern frame)))
\end{scheme}

\noindent
\code{check\-/an\-/assertion}は引数としてパターン、データオブジェクト(アサーション)、フレームを取り、
拡張されたフレームを含む1要素のストリームか、適合を失敗した場合に\code{the\-/empty\-/stream}を返します。

\begin{scheme}
(define (check-an-assertion
         assertion query-pat query-frame)
  (let ((match-result
         (pattern-match query-pat assertion query-frame)))
    (if (eq? match-result 'failed)
        the-empty-stream
        (singleton-stream match-result))))
\end{scheme}

\noindent
基本的なパターンマッチャはシンボル\code{failed}か、与えられたフレームの拡張を返します。
マッチャの基本的な考えはパターンをデータに対して要素毎に確認し、パターン変数に対する
束縛を集積します。もしパターンとデータオブジェクトが同じであるなら、適合は成功しそこまで
集積された束縛のフレームを返します。そうでなければ、もしパターンが変数ならば、変数を
データに対して束縛することで現在のフレームを拡張することをフレーム内に既に存在する
束縛に一致するまで行います。もしパターンとデータの両方がペアであるなら、(再帰的に)パターンの
\code{car}をデータの\code{car}に対して適合を行いフレームを生成します。次にこのフレームの中で
パターンの\code{cdr}をデータのに対して適合を行います。もしこれらの場合全てが当て嵌らない
場合、適合は失敗し、シンボル\code{failed}を返します。

\begin{scheme}
(define (pattern-match pat dat frame)
  (cond ((eq? frame 'failed) 'failed)
        ((equal? pat dat) frame)
        ((var? pat) (extend-if-consistent pat dat frame))
        ((and (pair? pat) (pair? dat))
         (pattern-match 
          (cdr pat)
          (cdr dat)
          (pattern-match (car pat) (car dat) frame)))
        (else 'failed)))
\end{scheme}

\noindent
次が、フレーム内に既に存在している束縛に一致するなら、新しい束縛を追加することによりフレームを拡張する手続です。

\begin{scheme}
(define (extend-if-consistent var dat frame)
  (let ((binding (binding-in-frame var frame)))
    (if binding
        (pattern-match
         (binding-value binding) dat frame)
        (extend var dat frame))))
\end{scheme}

\noindent
もしフレーム内の変数に対する束縛が無い場合、単純に変数のデータに対する束縛を追加します。
そうでなければこのフレーム内で、データをフレーム内の変数の値に対して適合を行います。
もし格納されていた値が定数のみを持つならば、つまり\code{extend\-/if\-/consistent}により
パターンマッチングの間に格納されたのであれば、適合は単純に格納されていた値と新しい
値が同じであるかどうかを確認します。もしそうならば、フレームを変更せずに返します。
そうでないならば、失敗を示す印を返します。しかし格納されたいた値は、それがユニフィケーションの
間に格納されたのであればパターン変数を含む場合があります(\link{Section 4.4.4.4}参照)。
格納されたパターンの新しいデータに対する再帰的な適合はこのパターン内の変数に対する
束縛の追加、または確認を行います。例えば、\code{?x}が\code{(f ?y)}に束縛され\code{?y}が未束縛である
フレームを持っているとしましょう。そしてこのフレームを\code{?x}の\code{(f b)}への束縛で
拡大させたいとします。私達は\code{?x}を探し、それが\code{(f ?y)}に束縛されているのを見つけます。
このことがこの同じフレームの中で提案された新しい値\code{(f b)}に対して\code{(f ?y)}を適合させる
ことへと導きます。最終的に、この適合は\code{?y}から\code{b}への束縛を追加する
ことによりこのフレームを拡張します。\code{?x}は\code{(f ?y)}への束縛を維持します。
格納されていた束縛を変更することはありません。また与えられた変数に対して複数の
束縛を格納することもありません。


\code{extend\-/if\-/consistent}により使用される束縛を操作するための複数の手続は\link{Section 4.4.4.8}で
定義されます。

\subsubsection*{末尾ドット付きパターン}
\label{Sec. 4.4.4.4}
\label{Section 4.4.4.4}

パターンがドットとそれに続くパターン変数を含む場合、そのパターン変数はデータリストの
(次の要素ではなく)残りに適合します。誰かが予想するように\link{Exercise 2.20}にて
説明されたドット付き末尾記述と同様です。私達が実装したばかりのパターンマッチャは
ドットを探しませんが、私達が望むとおりに振舞います。これは\code{query\-/driver\-/loop}で
用いられるLispの\code{read}プリミティブがクエリを読み込みリスト構造として表現する時に
ドットを特別な方法で扱うためです。

\code{read}がドットを見た時、次の項目をリストの次の要素にするのではなく
(\code{cons}の\code{car}のこと、\code{cdr}はリストの残り)、リスト構造の\code{cdr}を
次の項目にします。例えば、パターン\code{(computer ?type)}に対する\code{read}により
生成されるリスト構造は式\code{(cons 'computer (cons '?type '()))}を評価することにより
構築されます。またパターン\code{(computer . ?type)}に対する場合は式
\code{(cons 'computer '?type)}を評価することにより構築されます。

従って\code{pattern\-/match}が再帰的にデータリストとドットを持つパターンの\code{car}と\code{cdr}を
比較するにつれ、最終的にはドットの後ろの変数(パターンの\code{cdr})がデータリストの
部分リストに対して適合され、そのリストに対してその変数が束縛されます。例えば、
パターン\code{(computer . ?type)}を\code{(programmer trainee)}に適合することは
\code{?type}をリスト\code{(programmer trainee)}に適合させます。

\subsubsection{ルールとユニフィケーション}

\code{apply\-/rules}は\code{find\-/assertions}の類似のルールです(\link{Section 4.4.4.3})。
入力としてパターンとフレームを取り、データベースからルールを適用することにより
拡張フレームのストリームを形成します。\code{stream\-/flatmap}は\code{apply\-/a\-/rule}を
(\code{fetch\-/rules}により選択された(\link{Section 4.4.4.5}))恐らく適用可能な
ルールのストリームに対しmapし、結果のフレームのストリーム群を結合します。

\begin{scheme}
(define (apply-rules pattern frame)
  (stream-flatmap (lambda (rule)
                    (apply-a-rule rule pattern frame))
                  (fetch-rules pattern frame)))
\end{scheme}

\noindent
\code{apply\-/a\-/rule}は\link{Section 4.4.2}で概説された手法を用いてルールを適用します。
最初にルールの結論を与えられたフレーム内のパターンとユニフィケーションを行うことで
引数フレームを増大させます。これが成功したならこの新しいフレーム内でルールのボディを
評価します。

しかしこの全てが起こる前に、プログラムはルール内の全ての変数を個別の新しい名前に
変更します。この理由は異なるルールの適用に対する変数が御互いに混同されることを
防ぐためです。例えば、もし2つのルールの両方が\code{?x}と名付けられた変数を用いる場合、
それぞれが適用された時に\code{?x}に対する束縛をフレームに追加するかもしれません。
これら2つの\code{?x}は御互いに関係がありません。そして私達は2つの束縛が一致するはずだと
考えるように惑わされてはいけません。変数名を変えるのでなく、より賢い環境構造を
工夫することもできるでしょう。しかし、私達がここで選択した改名による取り組み方は
最も効率的ではないとしても、最も簡単です(\link{Exercise 4.79}参照)。
以下が\code{apply\-/a\-/rule}手続です。

\begin{scheme}
(define (apply-a-rule rule query-pattern query-frame)
  (let ((clean-rule (rename-variables-in rule)))
    (let ((unify-result
           (unify-match query-pattern
                        (conclusion clean-rule)
                        query-frame)))
      (if (eq? unify-result 'failed)
          the-empty-stream
          (qeval (rule-body clean-rule)
                 (singleton-stream unify-result))))))
\end{scheme}

\noindent
セレクタ\code{rule\-/body}と\code{conclusion}はルールの部分を抜き出します。
これは\link{Section 4.4.4.7}で定義されます。

私達はユニークな(unique、独自の)識別子(例えば番号)を各ルールの適用に関連付けし、この識別子を元の
変数名に接続することで、ユニークな変数名を生成します。例えば、もしルール適用識別子が7なら、
ルール内の各\code{?x}を\code{?x\-/7}に、各\code{?y}を\code{?y\-/7}に変更するでしょう。
(\code{make\-/new\-/variable}と\code{new\-/rule\-/application\-/id}は\link{Section 4.4.4.7}の構文手続に含まれます。)

\begin{scheme}
(define (rename-variables-in rule)
  (let ((rule-application-id (new-rule-application-id)))
    (define (tree-walk exp)
      (cond ((var? exp)
             (make-new-variable
              exp rule-application-id))
            ((pair? exp)
             (cons (tree-walk (car exp))
                   (tree-walk (cdr exp))))
            (else exp)))
    (tree-walk rule)))
\end{scheme}

\noindent
ユニフィケーションアルゴリズムは手続として実装され、入力として2つのパターンとフレームを取り、
拡張されたフレームかシンボル\code{failed}を返します。ユニファイアはパターンマッチャに似ていますが、
対照的であることが異なります---つまり、変数が適合の両サイドに存在することが許されます。
\code{unify\-/match}は基本的には\code{pattern\-/match}と同じですが、(以下で``\code{***}''のマークを付けた)
拡張コードの存在が異なります。これは適合の右側のオブジェクトが変数である場合を扱います。

\begin{scheme}
(define (unify-match p1 p2 frame)
  (cond ((eq? frame 'failed) 'failed)
        ((equal? p1 p2) frame)
        ((var? p1) (extend-if-possible p1 p2 frame))
        ((var? p2) (extend-if-possible p2 p1 frame))  ~\textrm{; ***}~
        ((and (pair? p1) (pair? p2))
         (unify-match (cdr p1)
                      (cdr p2)
                      (unify-match (car p1)
                                   (car p2)
                                   frame)))
        (else 'failed)))
\end{scheme}

\noindent
ユニフィケーションにおいては一方向マッチングのように、既存の束縛に一致する場合のみ
提案されたフレームの拡張を受け入れたいです。手続\code{extend\-/if\-/possible}はユニフィケーションに
おいて使用され、パターンマッチにて利用される\code{extend\-/if\-/consistent}と同じですが、
下記のプログラムで``\code{***}''がマークされている、2つの特別なチェックが異なります。
最初のケースでは、もし適合を試す変数が未束縛であり、かつそれに対して適合させようと
している値それ自体が(異なる)変数である場合に、その値が束縛されているかを確認する
必要があります。そしてもしそうであれば、その値を適合する必要があります。
もし適合の両側が共に未束縛である場合、それぞれを御互いに束縛します。

2つ目のチェックは変数を、変数を含むパターンに対して束縛する試みを取り扱います。
そのような状況は変数が両方のパターン内で繰り返される場合に常に起こり得ます。
例えば2つのパターン、\code{(?x ?x)}と\code{(?y <\var{\code{?y}を含む式}>)}を、
\code{?x}と\code{?y}の両方が未束縛である場合のフレーム内にてユニフィケーションを
行う場合について考えてみて下さい。最初の\code{?x}は\code{?y}に対して適合し、\code{?x}から\code{?y}への
束縛を作成します。次に同じ\code{?x}が与えられた\code{?y}を含む式に対して適合されます。
\code{?x}は既に\code{?y}に対して束縛されているため、これは結果として\code{?y}をその式に対して
適合することになります。もし私達がユニファイアを2つのパターンを同じにするパターン変数に
対する値の集合を見つけるものとして考えているなら、これらのパターンは\code{?y}が\code{?y}を
含む式に等しいような\code{?y}を見付ける命令を暗示します。そのような方程式を解く一般的な
手法は存在しませんので、私達はそのような束縛を却下します。このような場合が述語\code{depends\-/on?}に
より認識されます。\footnote{
一般的に、\code{?y}を\code{?y}を含む式にユニフィケーションを行う場合には、
方程式\code{?y} = <\var{expression involving \code{?y}}>の不動点を見つけられなければなりません。
偶に解が存在する式を構文的に形成することが可能です。例えば、\code{?y} = \code{(f ?y)}は不動点
\code{(f (f (f \( \dots \) )))}を持つように見えます。これは式\code{(f ?y)}で始め、繰り返し\code{?y}を
\code{(f ?y)}で置き換えることで生成できます。残念ながら全てのそのような方程式が意味のある
不動点を持つわけではありません。ここで浮かび上がる問題は数学で無限級数を扱う場合の
問題と似ています。例えば、私達は2が方程式\( y = 1 + y / 2 \)の解であることを知っています。
式\( 1 + y / 2 \)で始めて、繰り返し\( y \)を\( 1 + y / 2 \)で置き換えていくと
以下の様になります。
\begin{comment}
\begin{example}
2 = y = 1 + y/2 = 1 + (1 + y/2)/2 = 1 + 1/2 + y/4 = ...
\end{example}
\end{comment}
\begin{displaymath}
 2 = y = 1 + {y \over 2} = 1 + {1\over2}\left(1 + {y \over 2}\right) = 
	1 + {1\over2} + {y \over 4} = \dots , 
\end{displaymath}
\noindent
これは以下の式へと導きます。
\begin{comment}

\begin{example}
2 = 1 + 1/2 + 1/4 + 1/8 + ...
\end{example}

\end{comment}
\begin{displaymath}
 2 = 1 + {1\over2} + {1\over4} + {1\over8} + \dots. 
\end{displaymath}
\noindent
しかし、もし同じ操作を式\( y = 1 + 2y \)の解が-1であるという結果から始めると、
\begin{comment}

\begin{example}
-1 = y = 1 + 2y = 1 + 2(1 + 2y) = 1 + 2 + 4y = ...
\end{example}

\end{comment}
\begin{displaymath}
 -1 = y = 1 + 2y = 1 + 2(1 + 2y) = 1 + 2 + 4y = \dots, 
\end{displaymath}
\noindent
これは以下の式へと導きます。
\begin{comment}

\begin{example}
-1 = 1 + 2 + 4 + 8 + ...
\end{example}

\end{comment}
\begin{displaymath}
 -1 = 1 + 2 + 4 + 8 + \dots. 
\end{displaymath}
\noindent
これらの2つの等式を導き出した形式的な操作は同一であるにも係らず、最初の結果は
無限級数に関して有効な正しい主張となりますが、2つ目はそうではありません。
同様に、私達のユニフィケーションの結果に対して無計画に構文に従い構築された
式はエラーへと繋るでしょう。
}


一方で、変数をそれ自体へ束縛する試みを拒否したくはありません。例として、
\code{(?x ?x)}と\code{(?y ?y)}のユニフィケーションについて考えてみましょう。
二度目の\code{?x}を\code{?y}へ束縛する試行は\code{?y}(\code{?x}の新しい値)に対する
\code{?y}(\code{?x}に格納された値)に適合します。これは\code{unify\-/match}の
\code{equal?}節により担当されます。

\begin{scheme}
(define (extend-if-possible var val frame)
  (let ((binding (binding-in-frame var frame)))
    (cond (binding
           (unify-match
            (binding-value binding) val frame))
          ((var? val)                      ~\textrm{; ***}~
           (let ((binding (binding-in-frame val frame)))
             (if binding
                 (unify-match
                  var (binding-value binding) frame)
                 (extend var val frame))))
          ((depends-on? val var frame)     ~\textrm{; ***}~
           'failed)
          (else (extend var val frame)))))
\end{scheme}

\noindent
\code{depends\-/on?}はパターン変数の値であると提案された式がその変数に依存するかを確認します。
これは現在のフレームと比較して行われなければなりません。式がテスト変数に依存する値を
既に持つ変数の存在を含むかもしれないためです。\code{depends\-/on?}の構造は簡単な再帰木の
探索であり、この中で必要な場合いつでも変数の値を置き換えます。

\begin{scheme}
(define (depends-on? exp var frame)
  (define (tree-walk e)
    (cond ((var? e)
           (if (equal? var e)
               true
               (let ((b (binding-in-frame e frame)))
                 (if b
                     (tree-walk (binding-value b))
                     false))))
          ((pair? e)
           (or (tree-walk (car e))
               (tree-walk (cdr e))))
          (else false)))
  (tree-walk exp))
\end{scheme}

\subsubsection{データベースの保守}
\label{Sec. 4.4.4.5}
\label{Section 4.4.4.5}

論理プログラミング言語の設計における重要な問題の1つは、与えられたパターンの確認に
おいてできる限り少ないデータベースのエントリが検査されるように物事を準備することです。
私達のシステムでは、全てのアサーションを1つの大きなストリームに格納することに加えて、
\code{car}が静的なシンボルである全てのアサーションをそのシンボルで索引付けられたテーブル内の
分離されたストリームに格納します。パターンに適合するかもしれないアサーションを取り出すためには、
最初にパターンの\code{car}が静的なシンボルであるかを確認します。
もしそうならば、(マッチャを用いて確認するため)同じ\code{car}を持つ全ての格納された
アサーションを返します。もしパターンの\code{car}が静的なシンボルでない場合には、格納された
アサーションを全て返します。より賢い方法ではフレーム内の情報も活用するか、パターンの
\code{car}が静的なシンボルでない場合にも最適化を行うことに挑むことができるでしょう。
私達は検索作成の基準(\code{car}を用いる、静的シンボルの場合のみを扱う)をこのプログラムの中に
構築することを避けました。その代わりに私達の基準を具現する述語とセレクタを呼び出します。

\begin{scheme}
(define THE-ASSERTIONS the-empty-stream)
(define (fetch-assertions pattern frame)
  (if (use-index? pattern)
      (get-indexed-assertions pattern)
      (get-all-assertions)))
(define (get-all-assertions) THE-ASSERTIONS)
(define (get-indexed-assertions pattern)
  (get-stream (index-key-of pattern) 'assertion-stream))
\end{scheme}

\noindent
\code{get\-/stream}はテーブル内のストリームを探し、そこに何にも格納されていない場合には
空ストリームを返します。

\begin{scheme}
(define (get-stream key1 key2)
  (let ((s (get key1 key2)))
    (if s s the-empty-stream)))
\end{scheme}

\noindent
ルールも同様にルールの結論の\code{car}を用いて格納されます。しかしルールの結論は任意の
パターンであるため、変数を含められることがアサーションとは異なります。\code{car}が静的なシンボルである
パターンは結論が変数で始まるルールと、結論が同じ\code{car}を持つルールにも適合できます。
従って、\code{car}が静的なシンボルであるパターンに適合するかもしれないルールを取り出す場合、
結論が変数で始まる全てのルールと、結論がそのパターンと同じ\code{car}を持つルールを取り出します。
この目的のために、結論が変数で始まる全てのルールをテーブル内の分離されたストリームに、
シンボル\code{?}で索引付けして格納します。

\begin{scheme}
(define THE-RULES the-empty-stream)
(define (fetch-rules pattern frame)
  (if (use-index? pattern)
      (get-indexed-rules pattern)
      (get-all-rules)))
(define (get-all-rules) THE-RULES)
(define (get-indexed-rules pattern)
  (stream-append
   (get-stream (index-key-of pattern) 'rule-stream)
   (get-stream '? 'rule-stream)))
\end{scheme}

\noindent
\code{add\-/rule\-/or\-/assertion!}は\code{query\-/driver\-/loop}により使用されアサーションと
ルールとデータベースに追加します。各アイテムは適切であればインデックスに格納され、
データベース内の全てのアサーション、またはルールのストリームに格納されます。

\begin{scheme}
(define (add-rule-or-assertion! assertion)
  (if (rule? assertion)
      (add-rule! assertion)
      (add-assertion! assertion)))
(define (add-assertion! assertion)
  (store-assertion-in-index assertion)
  (let ((old-assertions THE-ASSERTIONS))
    (set! THE-ASSERTIONS
          (cons-stream assertion old-assertions))
    'ok))
(define (add-rule! rule)
  (store-rule-in-index rule)
  (let ((old-rules THE-RULES))
    (set! THE-RULES (cons-stream rule old-rules))
    'ok))
\end{scheme}

\noindent
実際にアサーション、またはルールを格納するためには、索引を付けられるかを確認します。
もしそうであれば、適切なストリームに格納します。

\begin{scheme}
(define (store-assertion-in-index assertion)
  (if (indexable? assertion)
      (let ((key (index-key-of assertion)))
        (let ((current-assertion-stream
               (get-stream key 'assertion-stream)))
          (put key
               'assertion-stream
               (cons-stream
                assertion
                current-assertion-stream))))))
(define (store-rule-in-index rule)
  (let ((pattern (conclusion rule)))
    (if (indexable? pattern)
        (let ((key (index-key-of pattern)))
          (let ((current-rule-stream
                 (get-stream key 'rule-stream)))
            (put key
                 'rule-stream
                 (cons-stream rule
                              current-rule-stream)))))))
\end{scheme}

\noindent
以下の手続はデータベースのインデックス(索引)がどのように使用されかについて定義します。
パターン(アサーション、またはルールの結論)が変数、または静的なシンボルで始まる場合に
テーブルに格納されます。

\begin{scheme}
(define (indexable? pat)
  (or (constant-symbol? (car pat))
      (var? (car pat))))
\end{scheme}

\noindent
パターンがその下に格納されるテーブル内のキーは(変数で始まる場合には)\code{?}、または
パターンの始めの静的なシンボルです。

\begin{scheme}
(define (index-key-of pat)
  (let ((key (car pat)))
    (if (var? key) '? key)))
\end{scheme}

\noindent
インデックスはパターンが静的なシンボルで始まる場合、パターンにマッチするかもしれない
アイテムを取得するために利用されます。

\begin{scheme}
(define (use-index? pat) (constant-symbol? (car pat)))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.70}Exercise 4.70:}
手続\code{add\-/assertion!}と\code{add\-/rule!}内の\code{let}の束縛の目的は何か?
以下の\code{add\-/assertion!}の実装の誤りは何か? ヒント：\link{Section 3.5.2}における1の
無限ストリームの定義を思い出せ：\code{(define ones (cons\-/stream 1 ones))}

\begin{scheme}
(define (add-assertion! assertion)
  (store-assertion-in-index assertion)
  (set! THE-ASSERTIONS
        (cons-stream assertion THE-ASSERTIONS))
  'ok)
\end{scheme}
\end{quote}

\subsubsection{ストリーム命令}
\label{Section 4.4.4.6}

クエリシステムは\link{Chapter 3}には存在しなかったいくつかのストリーム命令を用います。


\code{stream\-/append\-/delayed}と\code{interleave\-/delayed}は\code{stream\-/append}と\\
\code{interleave}(\link{Section 3.5.3})と
同じですが、それらが(\link{Section 3.5.4}の\code{integral}の様に)遅延化された引数を取ることが異なります。
これはいくつかの場合においてループを先送りします。(\link{Exercise 4.71}参照)

\begin{scheme}
(define (stream-append-delayed s1 delayed-s2)
  (if (stream-null? s1)
      (force delayed-s2)
      (cons-stream
       (stream-car s1)
       (stream-append-delayed
        (stream-cdr s1)
        delayed-s2))))
(define (interleave-delayed s1 delayed-s2)
  (if (stream-null? s1)
      (force delayed-s2)
      (cons-stream
       (stream-car s1)
       (interleave-delayed
        (force delayed-s2)
        (delay (stream-cdr s1))))))
\end{scheme}

\noindent
\code{stream\-/flatmap}はクエリ評価機を通して使用され手続をフレームのストリーム上に対してmapし、
結果としての複数のフレームのストリームを接続します。
\code{stream\-/flatmap}は\link{Section 2.2.3}にて通常のリストのために導入された\code{flatmap}手続の
ストリーム向け類似品です。しかし通常の\code{flatmap}と異なり、単純にストリームをappendしていく
のではなく、相互配置処理により蓄積します。(\link{Exercise 4.72}と\link{Exercise 4.73}参照)
\begin{scheme}
(define (stream-flatmap proc s)
  (flatten-stream (stream-map proc s)))

(define (flatten-stream stream)
  (if (stream-null? stream)
      the-empty-stream
      (interleave-delayed
       (stream-car stream)
       (delay (flatten-stream (stream-cdr stream))))))
\end{scheme}

\noindent
評価機はまた以下の単純な手続を用いて単一要素から成るストリームを生成します。

\begin{scheme}
(define (singleton-stream x)
  (cons-stream x the-empty-stream))
\end{scheme}

\subsubsection{クエリ構文手続}
\label{Section 4.4.4.7}


\code{qeval}(\link{Section 4.4.4.2})により用いられる\code{type}と\code{contents}は、
特殊形式がその\code{car}に存在するシンボルにより判別されることを指示します。
これらは\link{Section 2.4.2}の\code{type\-/tag}と\code{contents}手続と同じですが、エラーメッセージが
異なります。

\begin{scheme}
(define (type exp)
  (if (pair? exp)
      (car exp)
      (error "Unknown expression TYPE" exp)))
(define (contents exp)
  (if (pair? exp)
      (cdr exp)
      (error "Unknown expression CONTENTS" exp)))
\end{scheme}

\noindent
以下の手続は\link{Section 4.4.4.1}の\code{query\-/driver\-/loop}にて使用されます。これはルールと
アサーションがデータベースに\code{(assert! <\var{rule\-/or\-/assertion}>)}の形式の式により
追加されることを指示します。

\begin{scheme}
(define (assertion-to-be-added? exp)
  (eq? (type exp) 'assert!))
(define (add-assertion-body exp) (car (contents exp)))
\end{scheme}

\noindent
以下は特殊形式\code{and}, \code{or}, \code{not}, \code{lisp\-/value}のための構文定義です。(\link{Section 4.4.4.2})

\begin{scheme}
(define (empty-conjunction? exps) (null? exps))
(define (first-conjunct exps) (car exps))
(define (rest-conjuncts exps) (cdr exps))
(define (empty-disjunction? exps) (null? exps))
(define (first-disjunct exps) (car exps))
(define (rest-disjuncts exps) (cdr exps))
(define (negated-query exps) (car exps))
(define (predicate exps) (car exps))
(define (args exps) (cdr exps))
\end{scheme}

\noindent
以下の3つの手続はルールの構文を定義します。

\begin{scheme}
(define (rule? statement)
  (tagged-list? statement 'rule))
(define (conclusion rule) (cadr rule))
(define (rule-body rule)
  (if (null? (cddr rule)) '(always-true) (caddr rule)))
\end{scheme}

\noindent
\code{query\-/driver\-/loop}(\link{Section 4.4.4.1})は\code{query\-/syntax\-/process}を呼び、
\code{?symbol}の形態を持つ式のパターン変数を内部形式\code{(? symbol)}に変形します。
これは言ってみれば、\code{(job ?x ?y)}のようなパターンが実際には内部的にシステムにより
\code{(job (? x) (? y))}と表現されているということです。これによりクエリ処理の効率が
良くなります。システムが式がパターン変数であるかを確認するのにシンボルから文字を
抽出する必要が無しに、式の\code{car}がシンボル\code{?}であるかどうかを確認することにより
確認できることを意味するためです。構文変形は以下の手続により達成されます。\footnote{
多くの
Lispシステムは通常の\code{read}手続を\newterm{reader macro characters}(\jnewterm{リーダ
マクロキャラクタ})を定義することにより変更し、そのような変形を実行させる能力を
ユーザにに与えています。クォートされた式は既にこのような取り扱われています。
リーダーは評価機が式を見る前に自動的に\code{'expression}を\code{(quote expression)}に
変形します。私達は同様に\code{?expression}が\code{(? expression)}に変形されるように
準備することも可能でした。しかし、明快さのために、私達はここに明示的に変形手続を
含めました。

\code{expand\-/question\-/mark}と\code{contract\-/question\-/mark}は名前に\code{string}を持つ
いくつかの手続を使用します。これらはSchemeのプリミティブです。}

\begin{scheme}
(define (query-syntax-process exp)
  (map-over-symbols expand-question-mark exp))
(define (map-over-symbols proc exp)
  (cond ((pair? exp)
         (cons (map-over-symbols proc (car exp))
               (map-over-symbols proc (cdr exp))))
        ((symbol? exp) (proc exp))
        (else exp)))
(define (expand-question-mark symbol)
  (let ((chars (symbol->string symbol)))
    (if (string=? (substring chars 0 1) "?")
        (list '?
              (string->symbol
               (substring chars 1 (string-length chars))))
        symbol)))
\end{scheme}

\noindent
一旦、変数がこのように変形されれば、パターン内の変数は\code{?}で始まるリストであり、
静的なシンボル(データベースの索引付けのために必要、\link{Section 4.4.4.5})はただのシンボルです。

\begin{scheme}
(define (var? exp) (tagged-list? exp '?))
(define (constant-symbol? exp) (symbol? exp))
\end{scheme}

\noindent
他とは異なる変数がルールの適用の間に以下の手続を用いて構築されます(\link{Section 4.4.4.4})。
ルール適用のための独自識別子は数値であり、ルールが適用される度にインクリメントされます。

\begin{scheme}
(define rule-counter 0)
(define (new-rule-application-id)
  (set! rule-counter (+ 1 rule-counter))
  rule-counter)
(define (make-new-variable var rule-application-id)
  (cons '? (cons rule-application-id (cdr var))))
\end{scheme}

\noindent
\code{query\-/driver\-/loop}が回答を表示するためにクエリをインスタンス化する時、
全ての未束縛のパターン変数を表示に適した形式に以下を用いて戻します。

\begin{scheme}
(define (contract-question-mark variable)
  (string->symbol
   (string-append "?"
     (if (number? (cadr variable))
         (string-append (symbol->string (caddr variable))
                        "-"
                        (number->string (cadr variable)))
         (symbol->string (cadr variable))))))
\end{scheme}

\subsubsection{フレームと束縛}
\label{Section 4.4.4.8}


フレームは変数と値のペアである束縛のリストとして表現されます。

\begin{scheme}
(define (make-binding variable value)
  (cons variable value))
(define (binding-variable binding) (car binding))
(define (binding-value binding) (cdr binding))
(define (binding-in-frame variable frame)
  (assoc variable frame))
(define (extend variable value frame)
  (cons (make-binding variable value) frame))
\end{scheme}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.71}Exercise 4.71:}

Louis Reasonerはなぜ\code{simple\-/query}と\code{disjoin}の手続(\link{Section 4.4.4.2})は
以下のような定義ではなく、明示的な\code{delay}命令を用いて実装されたのか不思議だった。

\begin{scheme}
(define (simple-query query-pattern frame-stream)
  (stream-flatmap
   (lambda (frame)
     (stream-append
      (find-assertions query-pattern frame)
      (apply-rules query-pattern frame)))
   frame-stream))
(define (disjoin disjuncts frame-stream)
  (if (empty-disjunction? disjuncts)
      the-empty-stream
      (interleave
       (qeval (first-disjunct disjuncts)
              frame-stream)
       (disjoin (rest-disjuncts disjuncts)
                frame-stream))))
\end{scheme}

あなたはこれらのより簡単な定義を望まない振舞いへと導くクエリの例を与えることができるか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.72}Exercise 4.72:}
なぜ\code{disjoin}と\code{stream\-/flatmap}は単純にそれらをappendせずに相互配置するのか?
なぜ相互配置のほうがより良く働くのかを説明する例を与えよ。(ヒント：なぜ私達は
\link{Section 3.5.3}において\code{interleave}を使用したのか?)
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.73}Exercise 4.73:}
なぜ\code{flatten\-/stream}は明示的に\code{delay}を用いるのか?
以下のように定義した場合に何が間違っているのか?

\begin{scheme}
(define (flatten-stream stream)
  (if (stream-null? stream)
      the-empty-stream
      (interleave
       (stream-car stream)
       (flatten-stream (stream-cdr stream)))))
\end{scheme}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.74}Exercise 4.74:}
Alyssa P. Hackerはより簡単な版の\code{stream\-/flatmap}を\code{negate}, \code{lisp\-/value},
\code{find\-/assertions}の中で使用することを提案した。彼女はフレームのストリーム上に
mapされる手続はこれらの場合において常に空ストリームか、単一要素のストリームを
生成する。そのためこれらのストリームを接続する場合、相互配置する必要が無いと
気付いた。

\begin{enumerate}[a]

\item
Alyssaのプログラムに欠けている式を埋めよ。

\begin{scheme}
(define (simple-stream-flatmap proc s)
  (simple-flatten (stream-map proc s)))
(define (simple-flatten stream)
  (stream-map ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~
              (stream-filter ~\( \dark \langle \)~~\var{\dark ??}~~\( \dark \rangle \)~ stream)))
\end{scheme}

\item
クエリシステムの振舞はこのように変更した場合に変化するだろうか?

\end{enumerate}
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.75}Exercise 4.75:}
クエリ言語に対して新しい特殊形式\code{unique}を実装せよ。\code{unique}は正確に
データベース内の1つの項目が指定されたクエリを満たす場合に成功しなければならない。
例えば、

\begin{scheme}
(unique (job ?x (computer wizard)))
\end{scheme}

\noindent
上の式は1つの項目のストリームを表示しなければならない。

\begin{scheme}
(unique (job (Bitdiddle Ben) (computer wizard)))
\end{scheme}

\noindent
Benはただ1人のコンピュータウィザードであるためである。
次に、

\begin{scheme}
(unique (job ?x (computer programmer)))
\end{scheme}

\noindent
上は空ストリームを表示しなければならない。複数のコンピュータプログラマが存在するためである。
さらに、

\begin{scheme}
(and (job ?x ?j) (unique (job ?anyone ?j)))
\end{scheme}

\noindent
上はただ1人により埋められた役職とその人達を全て表示しなければならない。


\code{unique}を実装するには2つの部分が存在する。1つ目はこの特殊形式を扱う手続を
書くことであり、2つ目は\code{qeval}にその手続を呼出させることである。2つ目の部分は
自明だ。\code{qeval}はその呼出をデータ適従の方法に従うためである。もしあなたの
手続が\code{uniquely\-/asserted}という名前であるなら、やらなければいけないことは以下である。

\begin{scheme}
(put 'unique 'qeval uniquely-asserted)
\end{scheme}

\noindent
これで\code{qeval}は型(\code{car})がシンボル\code{unique}である全てのクエリに対して
この手続を呼び出す。

真の問題は手続\code{uniquely\-/asserted}を書くことである。これは入力として\code{unique}クエリの
\code{contents}(\code{cdr})をフレームのストリームと共に受け取る。ストリームの各フレームに対し、
\code{qeval}を用いて与えられたクエリを満たすフレームの全ての拡張のストリームを見つけなければ
ならない。正確に1つのアイテムのみを持たないストリームは全て取り除かれなければならない。
残ったストリームは\code{unique}クエリの結果である1つの巨大なストリームに蓄積するために
戻されなければならない。これは特殊形式\code{not}の実装に似ている。

あなたの実装を正確に1人だけを監督する全ての人々を並べるクエリを形成することによりテストせよ。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.76}Exercise 4.76:}
一連のクエリの結合としての\code{and}の実装(\link{Figure 4.5})は洗練されているが非効率だ。
\code{and}の2つ目のクエリの処理において最初のクエリにより生成された各フレームに対して
データベースを走査しなければならないためである。もしデータベースが\( n \)個の要素を持ち、
典型的なクエリが\( n \)に比例した数(仮に\( n / k \)個)の出力フレームを生成する場合、
最初のクエリにより生成された各フレームに対するデータベースの走査は\( n^2\! / k \)の
パターンマッチャの呼出を必要とする。別の取り組み方としては\code{and}の2つの節を分離して処理し、
矛盾のない出力フレームの全てのペアを探すことになるだろう。もし各クエリが\( n / k \)個の
出力フレームを生成するなら、これは\( n^2\! / k^2 \)回の無矛盾テストを実行しなければ
ならないことを意味する。\( k \)の係数が現在の手法で必要な適合数よりもより少ない。


この戦略を用いる\code{and}の実装を工夫せよ。入力として2つのフレームを取り、
両フレームの中の束縛が無矛盾であることを確認しなければならない。もしそうであるなら
束縛の2つの集合をマージするフレームを生成する。この操作はユニフィケーションに似ている。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.77}Exercise 4.77:}
\link{Section 4.4.3}において\code{not}と\code{lisp\-/value}がクエリ言語に対し
もしこれらのフィルタリング命令が変数が束縛されていないフレームに適用された場合に
``間違った''回答を与えることがあることを学んだ。この欠陥を直す方法を工夫せよ。
1つの考えはフィルタリングを``遅延''の様式で実行することだ。フレームに``プロミス''を
追加することで十分な変数がその操作を可能にする場合にのみそれを果たすようにする。
フィルタリングの実行は全ての他の命令が実行を終えるまで待つことができる。しかし、
効率のために生成される中間フレームの数を削減できるようフィルタリングをできるだけ早く実行したい。
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.78}Exercise 4.78:}
クエリ言語をストリーム処理ではなく非決定性プログラムとして、\link{Section 4.3}の評価機を用いて実装されるように
再設計せよ。この取り組み方においては、各クエリは(全ての回答のストリームではなく)単一の回答を生成し、
ユーザは\code{try\-/again}を入力することでより多くの回答を見ることができる。
この節で構築した仕組みの多くは非決定性探索とバックトラックにより組込まれていることに気付かなければ
ならない。しかし、新しいクエリ言語の振舞にここで実装されたものからわずかな違うことにも気付くだろう。
この違いを説明する例を見つけることができるだろうか?
\end{quote}

\begin{quote}
\heading{\phantomsection\label{Exercise 4.79}Exercise 4.79:}
\link{Section 4.1}でLisp評価機を実装した時に、どのようにローカル環境を使用して
手続のパラメタ間の名前衝突を防ぐかについて学んだ。例えば以下を評価する場合に
おいて、

\begin{scheme}
(define (square x) (* x x))
(define (sum-of-squares x y)
  (+ (square x) (square y)))
(sum-of-squares 3 4)
\end{scheme}

\noindent
\code{square}の\code{x}と\code{sum\-/of\-/squares}の\code{x}の間に混乱は無い。なぜなら
各手続のボディをローカル変数のための束縛を含めるために特別に構築した環境の
中で評価するからである。クエリシステムではルール適用における名前衝突を
避けるために異なる戦略を用いた。ルールを適用する度に変数名を唯一であることを
保証された新しい名前に変えている。Lisp評価機に対する同様の戦略はローカルな
環境を排除し、手続を適用する度に手続のボディの中の変数を改名することになるだろう。

クエリ言語に対して改名でなく、環境を用いるルール適用手法を実装せよ。
あなたの環境構造上に巨大システムを取り扱うために、クエリ言語内にブロック構造化された
手続に同等なルールのような構成概念を作るために構築できるか確かめよ。
これの何かを文脈中での推論を行う問題に、問題解決の手段として関連付けることはできるだろうか?
(例えば``もし\( P \)が真であるとするならば、\( A \)と\( B \)を推論することができる'')。

(この問題には明確な回答やルールは存在しない。良い回答は恐らく博士号の価値があるだろう。)
\end{quote}
